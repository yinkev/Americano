
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model Lecture
 * 
 */
export type Lecture = $Result.DefaultSelection<Prisma.$LecturePayload>
/**
 * Model ContentChunk
 * 
 */
export type ContentChunk = $Result.DefaultSelection<Prisma.$ContentChunkPayload>
/**
 * Model LearningObjective
 * 
 */
export type LearningObjective = $Result.DefaultSelection<Prisma.$LearningObjectivePayload>
/**
 * Model ObjectivePrerequisite
 * 
 */
export type ObjectivePrerequisite = $Result.DefaultSelection<Prisma.$ObjectivePrerequisitePayload>
/**
 * Model Mission
 * 
 */
export type Mission = $Result.DefaultSelection<Prisma.$MissionPayload>
/**
 * Model Card
 * 
 */
export type Card = $Result.DefaultSelection<Prisma.$CardPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model StudySession
 * 
 */
export type StudySession = $Result.DefaultSelection<Prisma.$StudySessionPayload>
/**
 * Model Concept
 * 
 */
export type Concept = $Result.DefaultSelection<Prisma.$ConceptPayload>
/**
 * Model ConceptRelationship
 * 
 */
export type ConceptRelationship = $Result.DefaultSelection<Prisma.$ConceptRelationshipPayload>
/**
 * Model ValidationPrompt
 * 
 */
export type ValidationPrompt = $Result.DefaultSelection<Prisma.$ValidationPromptPayload>
/**
 * Model ValidationResponse
 * 
 */
export type ValidationResponse = $Result.DefaultSelection<Prisma.$ValidationResponsePayload>
/**
 * Model ComprehensionMetric
 * 
 */
export type ComprehensionMetric = $Result.DefaultSelection<Prisma.$ComprehensionMetricPayload>
/**
 * Model BehavioralEvent
 * 
 */
export type BehavioralEvent = $Result.DefaultSelection<Prisma.$BehavioralEventPayload>
/**
 * Model BehavioralPattern
 * 
 */
export type BehavioralPattern = $Result.DefaultSelection<Prisma.$BehavioralPatternPayload>
/**
 * Model BehavioralInsight
 * 
 */
export type BehavioralInsight = $Result.DefaultSelection<Prisma.$BehavioralInsightPayload>
/**
 * Model InsightPattern
 * 
 */
export type InsightPattern = $Result.DefaultSelection<Prisma.$InsightPatternPayload>
/**
 * Model UserLearningProfile
 * 
 */
export type UserLearningProfile = $Result.DefaultSelection<Prisma.$UserLearningProfilePayload>
/**
 * Model LearningPattern
 * 
 */
export type LearningPattern = $Result.DefaultSelection<Prisma.$LearningPatternPayload>
/**
 * Model PerformancePrediction
 * 
 */
export type PerformancePrediction = $Result.DefaultSelection<Prisma.$PerformancePredictionPayload>
/**
 * Model StrugglePrediction
 * 
 */
export type StrugglePrediction = $Result.DefaultSelection<Prisma.$StrugglePredictionPayload>
/**
 * Model StruggleIndicator
 * 
 */
export type StruggleIndicator = $Result.DefaultSelection<Prisma.$StruggleIndicatorPayload>
/**
 * Model InterventionRecommendation
 * 
 */
export type InterventionRecommendation = $Result.DefaultSelection<Prisma.$InterventionRecommendationPayload>
/**
 * Model PredictionFeedback
 * 
 */
export type PredictionFeedback = $Result.DefaultSelection<Prisma.$PredictionFeedbackPayload>
/**
 * Model PerformanceMetric
 * 
 */
export type PerformanceMetric = $Result.DefaultSelection<Prisma.$PerformanceMetricPayload>
/**
 * Model Exam
 * 
 */
export type Exam = $Result.DefaultSelection<Prisma.$ExamPayload>
/**
 * Model CoursePriority
 * 
 */
export type CoursePriority = $Result.DefaultSelection<Prisma.$CoursePriorityPayload>
/**
 * Model PriorityFeedback
 * 
 */
export type PriorityFeedback = $Result.DefaultSelection<Prisma.$PriorityFeedbackPayload>
/**
 * Model Streak
 * 
 */
export type Streak = $Result.DefaultSelection<Prisma.$StreakPayload>
/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model StudyGoal
 * 
 */
export type StudyGoal = $Result.DefaultSelection<Prisma.$StudyGoalPayload>
/**
 * Model MissionAnalytics
 * 
 */
export type MissionAnalytics = $Result.DefaultSelection<Prisma.$MissionAnalyticsPayload>
/**
 * Model MissionFeedback
 * 
 */
export type MissionFeedback = $Result.DefaultSelection<Prisma.$MissionFeedbackPayload>
/**
 * Model MissionStreak
 * 
 */
export type MissionStreak = $Result.DefaultSelection<Prisma.$MissionStreakPayload>
/**
 * Model MissionReview
 * 
 */
export type MissionReview = $Result.DefaultSelection<Prisma.$MissionReviewPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ProcessingStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type ProcessingStatus = (typeof ProcessingStatus)[keyof typeof ProcessingStatus]


export const ObjectiveComplexity: {
  BASIC: 'BASIC',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED'
};

export type ObjectiveComplexity = (typeof ObjectiveComplexity)[keyof typeof ObjectiveComplexity]


export const MasteryLevel: {
  NOT_STARTED: 'NOT_STARTED',
  BEGINNER: 'BEGINNER',
  INTERMEDIATE: 'INTERMEDIATE',
  ADVANCED: 'ADVANCED',
  MASTERED: 'MASTERED'
};

export type MasteryLevel = (typeof MasteryLevel)[keyof typeof MasteryLevel]


export const MissionStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  SKIPPED: 'SKIPPED'
};

export type MissionStatus = (typeof MissionStatus)[keyof typeof MissionStatus]


export const CardType: {
  BASIC: 'BASIC',
  CLOZE: 'CLOZE',
  CLINICAL_REASONING: 'CLINICAL_REASONING'
};

export type CardType = (typeof CardType)[keyof typeof CardType]


export const ReviewRating: {
  AGAIN: 'AGAIN',
  HARD: 'HARD',
  GOOD: 'GOOD',
  EASY: 'EASY'
};

export type ReviewRating = (typeof ReviewRating)[keyof typeof ReviewRating]


export const RelationshipType: {
  PREREQUISITE: 'PREREQUISITE',
  RELATED: 'RELATED',
  INTEGRATED: 'INTEGRATED',
  CLINICAL: 'CLINICAL'
};

export type RelationshipType = (typeof RelationshipType)[keyof typeof RelationshipType]


export const PromptType: {
  EXPLAIN_TO_PATIENT: 'EXPLAIN_TO_PATIENT',
  CLINICAL_REASONING: 'CLINICAL_REASONING',
  CONTROLLED_FAILURE: 'CONTROLLED_FAILURE'
};

export type PromptType = (typeof PromptType)[keyof typeof PromptType]


export const EventType: {
  MISSION_STARTED: 'MISSION_STARTED',
  MISSION_COMPLETED: 'MISSION_COMPLETED',
  CARD_REVIEWED: 'CARD_REVIEWED',
  VALIDATION_COMPLETED: 'VALIDATION_COMPLETED',
  SESSION_STARTED: 'SESSION_STARTED',
  SESSION_ENDED: 'SESSION_ENDED',
  LECTURE_UPLOADED: 'LECTURE_UPLOADED',
  SEARCH_PERFORMED: 'SEARCH_PERFORMED',
  GRAPH_VIEWED: 'GRAPH_VIEWED'
};

export type EventType = (typeof EventType)[keyof typeof EventType]


export const EngagementLevel: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type EngagementLevel = (typeof EngagementLevel)[keyof typeof EngagementLevel]


export const CompletionQuality: {
  RUSHED: 'RUSHED',
  NORMAL: 'NORMAL',
  THOROUGH: 'THOROUGH'
};

export type CompletionQuality = (typeof CompletionQuality)[keyof typeof CompletionQuality]


export const BehavioralPatternType: {
  OPTIMAL_STUDY_TIME: 'OPTIMAL_STUDY_TIME',
  SESSION_DURATION_PREFERENCE: 'SESSION_DURATION_PREFERENCE',
  CONTENT_TYPE_PREFERENCE: 'CONTENT_TYPE_PREFERENCE',
  PERFORMANCE_PEAK: 'PERFORMANCE_PEAK',
  ATTENTION_CYCLE: 'ATTENTION_CYCLE',
  FORGETTING_CURVE: 'FORGETTING_CURVE'
};

export type BehavioralPatternType = (typeof BehavioralPatternType)[keyof typeof BehavioralPatternType]


export const InsightType: {
  STUDY_TIME_OPTIMIZATION: 'STUDY_TIME_OPTIMIZATION',
  SESSION_LENGTH_ADJUSTMENT: 'SESSION_LENGTH_ADJUSTMENT',
  CONTENT_PREFERENCE: 'CONTENT_PREFERENCE',
  RETENTION_STRATEGY: 'RETENTION_STRATEGY'
};

export type InsightType = (typeof InsightType)[keyof typeof InsightType]


export const PatternType: {
  OPTIMAL_STUDY_TIME: 'OPTIMAL_STUDY_TIME',
  STRUGGLE_TOPIC: 'STRUGGLE_TOPIC',
  CONTENT_PREFERENCE: 'CONTENT_PREFERENCE',
  SESSION_LENGTH: 'SESSION_LENGTH',
  DAY_OF_WEEK_PATTERN: 'DAY_OF_WEEK_PATTERN'
};

export type PatternType = (typeof PatternType)[keyof typeof PatternType]


export const PredictionStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  FALSE_POSITIVE: 'FALSE_POSITIVE',
  MISSED: 'MISSED'
};

export type PredictionStatus = (typeof PredictionStatus)[keyof typeof PredictionStatus]


export const IndicatorType: {
  LOW_RETENTION: 'LOW_RETENTION',
  PREREQUISITE_GAP: 'PREREQUISITE_GAP',
  COMPLEXITY_MISMATCH: 'COMPLEXITY_MISMATCH',
  COGNITIVE_OVERLOAD: 'COGNITIVE_OVERLOAD',
  HISTORICAL_STRUGGLE_PATTERN: 'HISTORICAL_STRUGGLE_PATTERN',
  TOPIC_SIMILARITY_STRUGGLE: 'TOPIC_SIMILARITY_STRUGGLE'
};

export type IndicatorType = (typeof IndicatorType)[keyof typeof IndicatorType]


export const Severity: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type Severity = (typeof Severity)[keyof typeof Severity]


export const InterventionType: {
  PREREQUISITE_REVIEW: 'PREREQUISITE_REVIEW',
  DIFFICULTY_PROGRESSION: 'DIFFICULTY_PROGRESSION',
  CONTENT_FORMAT_ADAPT: 'CONTENT_FORMAT_ADAPT',
  COGNITIVE_LOAD_REDUCE: 'COGNITIVE_LOAD_REDUCE',
  SPACED_REPETITION_BOOST: 'SPACED_REPETITION_BOOST',
  BREAK_SCHEDULE_ADJUST: 'BREAK_SCHEDULE_ADJUST'
};

export type InterventionType = (typeof InterventionType)[keyof typeof InterventionType]


export const InterventionStatus: {
  PENDING: 'PENDING',
  APPLIED: 'APPLIED',
  COMPLETED: 'COMPLETED',
  DISMISSED: 'DISMISSED'
};

export type InterventionStatus = (typeof InterventionStatus)[keyof typeof InterventionStatus]


export const FeedbackType: {
  HELPFUL: 'HELPFUL',
  NOT_HELPFUL: 'NOT_HELPFUL',
  INACCURATE: 'INACCURATE',
  INTERVENTION_GOOD: 'INTERVENTION_GOOD',
  INTERVENTION_BAD: 'INTERVENTION_BAD'
};

export type FeedbackType = (typeof FeedbackType)[keyof typeof FeedbackType]


export const PriorityLevel: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL'
};

export type PriorityLevel = (typeof PriorityLevel)[keyof typeof PriorityLevel]


export const FeedbackRating: {
  TOO_HIGH: 'TOO_HIGH',
  JUST_RIGHT: 'JUST_RIGHT',
  TOO_LOW: 'TOO_LOW'
};

export type FeedbackRating = (typeof FeedbackRating)[keyof typeof FeedbackRating]


export const AchievementType: {
  STREAK_MILESTONE: 'STREAK_MILESTONE',
  OBJECTIVES_COMPLETED: 'OBJECTIVES_COMPLETED',
  CARDS_MASTERED: 'CARDS_MASTERED',
  PERFECT_SESSION: 'PERFECT_SESSION',
  EARLY_BIRD: 'EARLY_BIRD',
  NIGHT_OWL: 'NIGHT_OWL'
};

export type AchievementType = (typeof AchievementType)[keyof typeof AchievementType]


export const AchievementTier: {
  BRONZE: 'BRONZE',
  SILVER: 'SILVER',
  GOLD: 'GOLD',
  PLATINUM: 'PLATINUM'
};

export type AchievementTier = (typeof AchievementTier)[keyof typeof AchievementTier]


export const GoalType: {
  TIME_BASED: 'TIME_BASED',
  OBJECTIVE_BASED: 'OBJECTIVE_BASED',
  REVIEW_BASED: 'REVIEW_BASED'
};

export type GoalType = (typeof GoalType)[keyof typeof GoalType]


export const GoalPeriod: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY'
};

export type GoalPeriod = (typeof GoalPeriod)[keyof typeof GoalPeriod]


export const AnalyticsPeriod: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY'
};

export type AnalyticsPeriod = (typeof AnalyticsPeriod)[keyof typeof AnalyticsPeriod]


export const PaceRating: {
  TOO_SLOW: 'TOO_SLOW',
  JUST_RIGHT: 'JUST_RIGHT',
  TOO_FAST: 'TOO_FAST'
};

export type PaceRating = (typeof PaceRating)[keyof typeof PaceRating]


export const ReviewPeriod: {
  WEEK: 'WEEK',
  MONTH: 'MONTH'
};

export type ReviewPeriod = (typeof ReviewPeriod)[keyof typeof ReviewPeriod]

}

export type ProcessingStatus = $Enums.ProcessingStatus

export const ProcessingStatus: typeof $Enums.ProcessingStatus

export type ObjectiveComplexity = $Enums.ObjectiveComplexity

export const ObjectiveComplexity: typeof $Enums.ObjectiveComplexity

export type MasteryLevel = $Enums.MasteryLevel

export const MasteryLevel: typeof $Enums.MasteryLevel

export type MissionStatus = $Enums.MissionStatus

export const MissionStatus: typeof $Enums.MissionStatus

export type CardType = $Enums.CardType

export const CardType: typeof $Enums.CardType

export type ReviewRating = $Enums.ReviewRating

export const ReviewRating: typeof $Enums.ReviewRating

export type RelationshipType = $Enums.RelationshipType

export const RelationshipType: typeof $Enums.RelationshipType

export type PromptType = $Enums.PromptType

export const PromptType: typeof $Enums.PromptType

export type EventType = $Enums.EventType

export const EventType: typeof $Enums.EventType

export type EngagementLevel = $Enums.EngagementLevel

export const EngagementLevel: typeof $Enums.EngagementLevel

export type CompletionQuality = $Enums.CompletionQuality

export const CompletionQuality: typeof $Enums.CompletionQuality

export type BehavioralPatternType = $Enums.BehavioralPatternType

export const BehavioralPatternType: typeof $Enums.BehavioralPatternType

export type InsightType = $Enums.InsightType

export const InsightType: typeof $Enums.InsightType

export type PatternType = $Enums.PatternType

export const PatternType: typeof $Enums.PatternType

export type PredictionStatus = $Enums.PredictionStatus

export const PredictionStatus: typeof $Enums.PredictionStatus

export type IndicatorType = $Enums.IndicatorType

export const IndicatorType: typeof $Enums.IndicatorType

export type Severity = $Enums.Severity

export const Severity: typeof $Enums.Severity

export type InterventionType = $Enums.InterventionType

export const InterventionType: typeof $Enums.InterventionType

export type InterventionStatus = $Enums.InterventionStatus

export const InterventionStatus: typeof $Enums.InterventionStatus

export type FeedbackType = $Enums.FeedbackType

export const FeedbackType: typeof $Enums.FeedbackType

export type PriorityLevel = $Enums.PriorityLevel

export const PriorityLevel: typeof $Enums.PriorityLevel

export type FeedbackRating = $Enums.FeedbackRating

export const FeedbackRating: typeof $Enums.FeedbackRating

export type AchievementType = $Enums.AchievementType

export const AchievementType: typeof $Enums.AchievementType

export type AchievementTier = $Enums.AchievementTier

export const AchievementTier: typeof $Enums.AchievementTier

export type GoalType = $Enums.GoalType

export const GoalType: typeof $Enums.GoalType

export type GoalPeriod = $Enums.GoalPeriod

export const GoalPeriod: typeof $Enums.GoalPeriod

export type AnalyticsPeriod = $Enums.AnalyticsPeriod

export const AnalyticsPeriod: typeof $Enums.AnalyticsPeriod

export type PaceRating = $Enums.PaceRating

export const PaceRating: typeof $Enums.PaceRating

export type ReviewPeriod = $Enums.ReviewPeriod

export const ReviewPeriod: typeof $Enums.ReviewPeriod

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs>;

  /**
   * `prisma.lecture`: Exposes CRUD operations for the **Lecture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lectures
    * const lectures = await prisma.lecture.findMany()
    * ```
    */
  get lecture(): Prisma.LectureDelegate<ExtArgs>;

  /**
   * `prisma.contentChunk`: Exposes CRUD operations for the **ContentChunk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentChunks
    * const contentChunks = await prisma.contentChunk.findMany()
    * ```
    */
  get contentChunk(): Prisma.ContentChunkDelegate<ExtArgs>;

  /**
   * `prisma.learningObjective`: Exposes CRUD operations for the **LearningObjective** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningObjectives
    * const learningObjectives = await prisma.learningObjective.findMany()
    * ```
    */
  get learningObjective(): Prisma.LearningObjectiveDelegate<ExtArgs>;

  /**
   * `prisma.objectivePrerequisite`: Exposes CRUD operations for the **ObjectivePrerequisite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ObjectivePrerequisites
    * const objectivePrerequisites = await prisma.objectivePrerequisite.findMany()
    * ```
    */
  get objectivePrerequisite(): Prisma.ObjectivePrerequisiteDelegate<ExtArgs>;

  /**
   * `prisma.mission`: Exposes CRUD operations for the **Mission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Missions
    * const missions = await prisma.mission.findMany()
    * ```
    */
  get mission(): Prisma.MissionDelegate<ExtArgs>;

  /**
   * `prisma.card`: Exposes CRUD operations for the **Card** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cards
    * const cards = await prisma.card.findMany()
    * ```
    */
  get card(): Prisma.CardDelegate<ExtArgs>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs>;

  /**
   * `prisma.studySession`: Exposes CRUD operations for the **StudySession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudySessions
    * const studySessions = await prisma.studySession.findMany()
    * ```
    */
  get studySession(): Prisma.StudySessionDelegate<ExtArgs>;

  /**
   * `prisma.concept`: Exposes CRUD operations for the **Concept** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Concepts
    * const concepts = await prisma.concept.findMany()
    * ```
    */
  get concept(): Prisma.ConceptDelegate<ExtArgs>;

  /**
   * `prisma.conceptRelationship`: Exposes CRUD operations for the **ConceptRelationship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConceptRelationships
    * const conceptRelationships = await prisma.conceptRelationship.findMany()
    * ```
    */
  get conceptRelationship(): Prisma.ConceptRelationshipDelegate<ExtArgs>;

  /**
   * `prisma.validationPrompt`: Exposes CRUD operations for the **ValidationPrompt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ValidationPrompts
    * const validationPrompts = await prisma.validationPrompt.findMany()
    * ```
    */
  get validationPrompt(): Prisma.ValidationPromptDelegate<ExtArgs>;

  /**
   * `prisma.validationResponse`: Exposes CRUD operations for the **ValidationResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ValidationResponses
    * const validationResponses = await prisma.validationResponse.findMany()
    * ```
    */
  get validationResponse(): Prisma.ValidationResponseDelegate<ExtArgs>;

  /**
   * `prisma.comprehensionMetric`: Exposes CRUD operations for the **ComprehensionMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComprehensionMetrics
    * const comprehensionMetrics = await prisma.comprehensionMetric.findMany()
    * ```
    */
  get comprehensionMetric(): Prisma.ComprehensionMetricDelegate<ExtArgs>;

  /**
   * `prisma.behavioralEvent`: Exposes CRUD operations for the **BehavioralEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BehavioralEvents
    * const behavioralEvents = await prisma.behavioralEvent.findMany()
    * ```
    */
  get behavioralEvent(): Prisma.BehavioralEventDelegate<ExtArgs>;

  /**
   * `prisma.behavioralPattern`: Exposes CRUD operations for the **BehavioralPattern** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BehavioralPatterns
    * const behavioralPatterns = await prisma.behavioralPattern.findMany()
    * ```
    */
  get behavioralPattern(): Prisma.BehavioralPatternDelegate<ExtArgs>;

  /**
   * `prisma.behavioralInsight`: Exposes CRUD operations for the **BehavioralInsight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BehavioralInsights
    * const behavioralInsights = await prisma.behavioralInsight.findMany()
    * ```
    */
  get behavioralInsight(): Prisma.BehavioralInsightDelegate<ExtArgs>;

  /**
   * `prisma.insightPattern`: Exposes CRUD operations for the **InsightPattern** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InsightPatterns
    * const insightPatterns = await prisma.insightPattern.findMany()
    * ```
    */
  get insightPattern(): Prisma.InsightPatternDelegate<ExtArgs>;

  /**
   * `prisma.userLearningProfile`: Exposes CRUD operations for the **UserLearningProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserLearningProfiles
    * const userLearningProfiles = await prisma.userLearningProfile.findMany()
    * ```
    */
  get userLearningProfile(): Prisma.UserLearningProfileDelegate<ExtArgs>;

  /**
   * `prisma.learningPattern`: Exposes CRUD operations for the **LearningPattern** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearningPatterns
    * const learningPatterns = await prisma.learningPattern.findMany()
    * ```
    */
  get learningPattern(): Prisma.LearningPatternDelegate<ExtArgs>;

  /**
   * `prisma.performancePrediction`: Exposes CRUD operations for the **PerformancePrediction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerformancePredictions
    * const performancePredictions = await prisma.performancePrediction.findMany()
    * ```
    */
  get performancePrediction(): Prisma.PerformancePredictionDelegate<ExtArgs>;

  /**
   * `prisma.strugglePrediction`: Exposes CRUD operations for the **StrugglePrediction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StrugglePredictions
    * const strugglePredictions = await prisma.strugglePrediction.findMany()
    * ```
    */
  get strugglePrediction(): Prisma.StrugglePredictionDelegate<ExtArgs>;

  /**
   * `prisma.struggleIndicator`: Exposes CRUD operations for the **StruggleIndicator** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StruggleIndicators
    * const struggleIndicators = await prisma.struggleIndicator.findMany()
    * ```
    */
  get struggleIndicator(): Prisma.StruggleIndicatorDelegate<ExtArgs>;

  /**
   * `prisma.interventionRecommendation`: Exposes CRUD operations for the **InterventionRecommendation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InterventionRecommendations
    * const interventionRecommendations = await prisma.interventionRecommendation.findMany()
    * ```
    */
  get interventionRecommendation(): Prisma.InterventionRecommendationDelegate<ExtArgs>;

  /**
   * `prisma.predictionFeedback`: Exposes CRUD operations for the **PredictionFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PredictionFeedbacks
    * const predictionFeedbacks = await prisma.predictionFeedback.findMany()
    * ```
    */
  get predictionFeedback(): Prisma.PredictionFeedbackDelegate<ExtArgs>;

  /**
   * `prisma.performanceMetric`: Exposes CRUD operations for the **PerformanceMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerformanceMetrics
    * const performanceMetrics = await prisma.performanceMetric.findMany()
    * ```
    */
  get performanceMetric(): Prisma.PerformanceMetricDelegate<ExtArgs>;

  /**
   * `prisma.exam`: Exposes CRUD operations for the **Exam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exams
    * const exams = await prisma.exam.findMany()
    * ```
    */
  get exam(): Prisma.ExamDelegate<ExtArgs>;

  /**
   * `prisma.coursePriority`: Exposes CRUD operations for the **CoursePriority** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoursePriorities
    * const coursePriorities = await prisma.coursePriority.findMany()
    * ```
    */
  get coursePriority(): Prisma.CoursePriorityDelegate<ExtArgs>;

  /**
   * `prisma.priorityFeedback`: Exposes CRUD operations for the **PriorityFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PriorityFeedbacks
    * const priorityFeedbacks = await prisma.priorityFeedback.findMany()
    * ```
    */
  get priorityFeedback(): Prisma.PriorityFeedbackDelegate<ExtArgs>;

  /**
   * `prisma.streak`: Exposes CRUD operations for the **Streak** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Streaks
    * const streaks = await prisma.streak.findMany()
    * ```
    */
  get streak(): Prisma.StreakDelegate<ExtArgs>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs>;

  /**
   * `prisma.studyGoal`: Exposes CRUD operations for the **StudyGoal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudyGoals
    * const studyGoals = await prisma.studyGoal.findMany()
    * ```
    */
  get studyGoal(): Prisma.StudyGoalDelegate<ExtArgs>;

  /**
   * `prisma.missionAnalytics`: Exposes CRUD operations for the **MissionAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MissionAnalytics
    * const missionAnalytics = await prisma.missionAnalytics.findMany()
    * ```
    */
  get missionAnalytics(): Prisma.MissionAnalyticsDelegate<ExtArgs>;

  /**
   * `prisma.missionFeedback`: Exposes CRUD operations for the **MissionFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MissionFeedbacks
    * const missionFeedbacks = await prisma.missionFeedback.findMany()
    * ```
    */
  get missionFeedback(): Prisma.MissionFeedbackDelegate<ExtArgs>;

  /**
   * `prisma.missionStreak`: Exposes CRUD operations for the **MissionStreak** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MissionStreaks
    * const missionStreaks = await prisma.missionStreak.findMany()
    * ```
    */
  get missionStreak(): Prisma.MissionStreakDelegate<ExtArgs>;

  /**
   * `prisma.missionReview`: Exposes CRUD operations for the **MissionReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MissionReviews
    * const missionReviews = await prisma.missionReview.findMany()
    * ```
    */
  get missionReview(): Prisma.MissionReviewDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.17.0
   * Query Engine version: 393aa359c9ad4a4bb28630fb5613f9c281cde053
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Course: 'Course',
    Lecture: 'Lecture',
    ContentChunk: 'ContentChunk',
    LearningObjective: 'LearningObjective',
    ObjectivePrerequisite: 'ObjectivePrerequisite',
    Mission: 'Mission',
    Card: 'Card',
    Review: 'Review',
    StudySession: 'StudySession',
    Concept: 'Concept',
    ConceptRelationship: 'ConceptRelationship',
    ValidationPrompt: 'ValidationPrompt',
    ValidationResponse: 'ValidationResponse',
    ComprehensionMetric: 'ComprehensionMetric',
    BehavioralEvent: 'BehavioralEvent',
    BehavioralPattern: 'BehavioralPattern',
    BehavioralInsight: 'BehavioralInsight',
    InsightPattern: 'InsightPattern',
    UserLearningProfile: 'UserLearningProfile',
    LearningPattern: 'LearningPattern',
    PerformancePrediction: 'PerformancePrediction',
    StrugglePrediction: 'StrugglePrediction',
    StruggleIndicator: 'StruggleIndicator',
    InterventionRecommendation: 'InterventionRecommendation',
    PredictionFeedback: 'PredictionFeedback',
    PerformanceMetric: 'PerformanceMetric',
    Exam: 'Exam',
    CoursePriority: 'CoursePriority',
    PriorityFeedback: 'PriorityFeedback',
    Streak: 'Streak',
    Achievement: 'Achievement',
    StudyGoal: 'StudyGoal',
    MissionAnalytics: 'MissionAnalytics',
    MissionFeedback: 'MissionFeedback',
    MissionStreak: 'MissionStreak',
    MissionReview: 'MissionReview'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "course" | "lecture" | "contentChunk" | "learningObjective" | "objectivePrerequisite" | "mission" | "card" | "review" | "studySession" | "concept" | "conceptRelationship" | "validationPrompt" | "validationResponse" | "comprehensionMetric" | "behavioralEvent" | "behavioralPattern" | "behavioralInsight" | "insightPattern" | "userLearningProfile" | "learningPattern" | "performancePrediction" | "strugglePrediction" | "struggleIndicator" | "interventionRecommendation" | "predictionFeedback" | "performanceMetric" | "exam" | "coursePriority" | "priorityFeedback" | "streak" | "achievement" | "studyGoal" | "missionAnalytics" | "missionFeedback" | "missionStreak" | "missionReview"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      Lecture: {
        payload: Prisma.$LecturePayload<ExtArgs>
        fields: Prisma.LectureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LectureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LectureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>
          }
          findFirst: {
            args: Prisma.LectureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LectureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>
          }
          findMany: {
            args: Prisma.LectureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>[]
          }
          create: {
            args: Prisma.LectureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>
          }
          createMany: {
            args: Prisma.LectureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LectureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>[]
          }
          delete: {
            args: Prisma.LectureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>
          }
          update: {
            args: Prisma.LectureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>
          }
          deleteMany: {
            args: Prisma.LectureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LectureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LectureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>
          }
          aggregate: {
            args: Prisma.LectureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLecture>
          }
          groupBy: {
            args: Prisma.LectureGroupByArgs<ExtArgs>
            result: $Utils.Optional<LectureGroupByOutputType>[]
          }
          count: {
            args: Prisma.LectureCountArgs<ExtArgs>
            result: $Utils.Optional<LectureCountAggregateOutputType> | number
          }
        }
      }
      ContentChunk: {
        payload: Prisma.$ContentChunkPayload<ExtArgs>
        fields: Prisma.ContentChunkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentChunkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentChunkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentChunkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentChunkPayload>
          }
          findFirst: {
            args: Prisma.ContentChunkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentChunkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentChunkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentChunkPayload>
          }
          findMany: {
            args: Prisma.ContentChunkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentChunkPayload>[]
          }
          create: {
            args: Prisma.ContentChunkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentChunkPayload>
          }
          createMany: {
            args: Prisma.ContentChunkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentChunkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentChunkPayload>[]
          }
          delete: {
            args: Prisma.ContentChunkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentChunkPayload>
          }
          update: {
            args: Prisma.ContentChunkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentChunkPayload>
          }
          deleteMany: {
            args: Prisma.ContentChunkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentChunkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContentChunkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentChunkPayload>
          }
          aggregate: {
            args: Prisma.ContentChunkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentChunk>
          }
          groupBy: {
            args: Prisma.ContentChunkGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentChunkGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentChunkCountArgs<ExtArgs>
            result: $Utils.Optional<ContentChunkCountAggregateOutputType> | number
          }
        }
      }
      LearningObjective: {
        payload: Prisma.$LearningObjectivePayload<ExtArgs>
        fields: Prisma.LearningObjectiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningObjectiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningObjectivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningObjectiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningObjectivePayload>
          }
          findFirst: {
            args: Prisma.LearningObjectiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningObjectivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningObjectiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningObjectivePayload>
          }
          findMany: {
            args: Prisma.LearningObjectiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningObjectivePayload>[]
          }
          create: {
            args: Prisma.LearningObjectiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningObjectivePayload>
          }
          createMany: {
            args: Prisma.LearningObjectiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearningObjectiveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningObjectivePayload>[]
          }
          delete: {
            args: Prisma.LearningObjectiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningObjectivePayload>
          }
          update: {
            args: Prisma.LearningObjectiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningObjectivePayload>
          }
          deleteMany: {
            args: Prisma.LearningObjectiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearningObjectiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LearningObjectiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningObjectivePayload>
          }
          aggregate: {
            args: Prisma.LearningObjectiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearningObjective>
          }
          groupBy: {
            args: Prisma.LearningObjectiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearningObjectiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearningObjectiveCountArgs<ExtArgs>
            result: $Utils.Optional<LearningObjectiveCountAggregateOutputType> | number
          }
        }
      }
      ObjectivePrerequisite: {
        payload: Prisma.$ObjectivePrerequisitePayload<ExtArgs>
        fields: Prisma.ObjectivePrerequisiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObjectivePrerequisiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePrerequisitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObjectivePrerequisiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePrerequisitePayload>
          }
          findFirst: {
            args: Prisma.ObjectivePrerequisiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePrerequisitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObjectivePrerequisiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePrerequisitePayload>
          }
          findMany: {
            args: Prisma.ObjectivePrerequisiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePrerequisitePayload>[]
          }
          create: {
            args: Prisma.ObjectivePrerequisiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePrerequisitePayload>
          }
          createMany: {
            args: Prisma.ObjectivePrerequisiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ObjectivePrerequisiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePrerequisitePayload>[]
          }
          delete: {
            args: Prisma.ObjectivePrerequisiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePrerequisitePayload>
          }
          update: {
            args: Prisma.ObjectivePrerequisiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePrerequisitePayload>
          }
          deleteMany: {
            args: Prisma.ObjectivePrerequisiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ObjectivePrerequisiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ObjectivePrerequisiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ObjectivePrerequisitePayload>
          }
          aggregate: {
            args: Prisma.ObjectivePrerequisiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateObjectivePrerequisite>
          }
          groupBy: {
            args: Prisma.ObjectivePrerequisiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ObjectivePrerequisiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObjectivePrerequisiteCountArgs<ExtArgs>
            result: $Utils.Optional<ObjectivePrerequisiteCountAggregateOutputType> | number
          }
        }
      }
      Mission: {
        payload: Prisma.$MissionPayload<ExtArgs>
        fields: Prisma.MissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          findFirst: {
            args: Prisma.MissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          findMany: {
            args: Prisma.MissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>[]
          }
          create: {
            args: Prisma.MissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          createMany: {
            args: Prisma.MissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>[]
          }
          delete: {
            args: Prisma.MissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          update: {
            args: Prisma.MissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          deleteMany: {
            args: Prisma.MissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionPayload>
          }
          aggregate: {
            args: Prisma.MissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMission>
          }
          groupBy: {
            args: Prisma.MissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MissionCountArgs<ExtArgs>
            result: $Utils.Optional<MissionCountAggregateOutputType> | number
          }
        }
      }
      Card: {
        payload: Prisma.$CardPayload<ExtArgs>
        fields: Prisma.CardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          findFirst: {
            args: Prisma.CardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          findMany: {
            args: Prisma.CardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>[]
          }
          create: {
            args: Prisma.CardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          createMany: {
            args: Prisma.CardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>[]
          }
          delete: {
            args: Prisma.CardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          update: {
            args: Prisma.CardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          deleteMany: {
            args: Prisma.CardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardPayload>
          }
          aggregate: {
            args: Prisma.CardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCard>
          }
          groupBy: {
            args: Prisma.CardGroupByArgs<ExtArgs>
            result: $Utils.Optional<CardGroupByOutputType>[]
          }
          count: {
            args: Prisma.CardCountArgs<ExtArgs>
            result: $Utils.Optional<CardCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      StudySession: {
        payload: Prisma.$StudySessionPayload<ExtArgs>
        fields: Prisma.StudySessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudySessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudySessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudySessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudySessionPayload>
          }
          findFirst: {
            args: Prisma.StudySessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudySessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudySessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudySessionPayload>
          }
          findMany: {
            args: Prisma.StudySessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudySessionPayload>[]
          }
          create: {
            args: Prisma.StudySessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudySessionPayload>
          }
          createMany: {
            args: Prisma.StudySessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudySessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudySessionPayload>[]
          }
          delete: {
            args: Prisma.StudySessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudySessionPayload>
          }
          update: {
            args: Prisma.StudySessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudySessionPayload>
          }
          deleteMany: {
            args: Prisma.StudySessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudySessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudySessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudySessionPayload>
          }
          aggregate: {
            args: Prisma.StudySessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudySession>
          }
          groupBy: {
            args: Prisma.StudySessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudySessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudySessionCountArgs<ExtArgs>
            result: $Utils.Optional<StudySessionCountAggregateOutputType> | number
          }
        }
      }
      Concept: {
        payload: Prisma.$ConceptPayload<ExtArgs>
        fields: Prisma.ConceptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConceptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConceptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptPayload>
          }
          findFirst: {
            args: Prisma.ConceptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConceptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptPayload>
          }
          findMany: {
            args: Prisma.ConceptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptPayload>[]
          }
          create: {
            args: Prisma.ConceptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptPayload>
          }
          createMany: {
            args: Prisma.ConceptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConceptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptPayload>[]
          }
          delete: {
            args: Prisma.ConceptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptPayload>
          }
          update: {
            args: Prisma.ConceptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptPayload>
          }
          deleteMany: {
            args: Prisma.ConceptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConceptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConceptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptPayload>
          }
          aggregate: {
            args: Prisma.ConceptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConcept>
          }
          groupBy: {
            args: Prisma.ConceptGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConceptGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConceptCountArgs<ExtArgs>
            result: $Utils.Optional<ConceptCountAggregateOutputType> | number
          }
        }
      }
      ConceptRelationship: {
        payload: Prisma.$ConceptRelationshipPayload<ExtArgs>
        fields: Prisma.ConceptRelationshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConceptRelationshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptRelationshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConceptRelationshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptRelationshipPayload>
          }
          findFirst: {
            args: Prisma.ConceptRelationshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptRelationshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConceptRelationshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptRelationshipPayload>
          }
          findMany: {
            args: Prisma.ConceptRelationshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptRelationshipPayload>[]
          }
          create: {
            args: Prisma.ConceptRelationshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptRelationshipPayload>
          }
          createMany: {
            args: Prisma.ConceptRelationshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConceptRelationshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptRelationshipPayload>[]
          }
          delete: {
            args: Prisma.ConceptRelationshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptRelationshipPayload>
          }
          update: {
            args: Prisma.ConceptRelationshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptRelationshipPayload>
          }
          deleteMany: {
            args: Prisma.ConceptRelationshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConceptRelationshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConceptRelationshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConceptRelationshipPayload>
          }
          aggregate: {
            args: Prisma.ConceptRelationshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConceptRelationship>
          }
          groupBy: {
            args: Prisma.ConceptRelationshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConceptRelationshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConceptRelationshipCountArgs<ExtArgs>
            result: $Utils.Optional<ConceptRelationshipCountAggregateOutputType> | number
          }
        }
      }
      ValidationPrompt: {
        payload: Prisma.$ValidationPromptPayload<ExtArgs>
        fields: Prisma.ValidationPromptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ValidationPromptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPromptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ValidationPromptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPromptPayload>
          }
          findFirst: {
            args: Prisma.ValidationPromptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPromptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ValidationPromptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPromptPayload>
          }
          findMany: {
            args: Prisma.ValidationPromptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPromptPayload>[]
          }
          create: {
            args: Prisma.ValidationPromptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPromptPayload>
          }
          createMany: {
            args: Prisma.ValidationPromptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ValidationPromptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPromptPayload>[]
          }
          delete: {
            args: Prisma.ValidationPromptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPromptPayload>
          }
          update: {
            args: Prisma.ValidationPromptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPromptPayload>
          }
          deleteMany: {
            args: Prisma.ValidationPromptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ValidationPromptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ValidationPromptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationPromptPayload>
          }
          aggregate: {
            args: Prisma.ValidationPromptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateValidationPrompt>
          }
          groupBy: {
            args: Prisma.ValidationPromptGroupByArgs<ExtArgs>
            result: $Utils.Optional<ValidationPromptGroupByOutputType>[]
          }
          count: {
            args: Prisma.ValidationPromptCountArgs<ExtArgs>
            result: $Utils.Optional<ValidationPromptCountAggregateOutputType> | number
          }
        }
      }
      ValidationResponse: {
        payload: Prisma.$ValidationResponsePayload<ExtArgs>
        fields: Prisma.ValidationResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ValidationResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ValidationResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationResponsePayload>
          }
          findFirst: {
            args: Prisma.ValidationResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ValidationResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationResponsePayload>
          }
          findMany: {
            args: Prisma.ValidationResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationResponsePayload>[]
          }
          create: {
            args: Prisma.ValidationResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationResponsePayload>
          }
          createMany: {
            args: Prisma.ValidationResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ValidationResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationResponsePayload>[]
          }
          delete: {
            args: Prisma.ValidationResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationResponsePayload>
          }
          update: {
            args: Prisma.ValidationResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationResponsePayload>
          }
          deleteMany: {
            args: Prisma.ValidationResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ValidationResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ValidationResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ValidationResponsePayload>
          }
          aggregate: {
            args: Prisma.ValidationResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateValidationResponse>
          }
          groupBy: {
            args: Prisma.ValidationResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ValidationResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ValidationResponseCountArgs<ExtArgs>
            result: $Utils.Optional<ValidationResponseCountAggregateOutputType> | number
          }
        }
      }
      ComprehensionMetric: {
        payload: Prisma.$ComprehensionMetricPayload<ExtArgs>
        fields: Prisma.ComprehensionMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComprehensionMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprehensionMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComprehensionMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprehensionMetricPayload>
          }
          findFirst: {
            args: Prisma.ComprehensionMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprehensionMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComprehensionMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprehensionMetricPayload>
          }
          findMany: {
            args: Prisma.ComprehensionMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprehensionMetricPayload>[]
          }
          create: {
            args: Prisma.ComprehensionMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprehensionMetricPayload>
          }
          createMany: {
            args: Prisma.ComprehensionMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComprehensionMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprehensionMetricPayload>[]
          }
          delete: {
            args: Prisma.ComprehensionMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprehensionMetricPayload>
          }
          update: {
            args: Prisma.ComprehensionMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprehensionMetricPayload>
          }
          deleteMany: {
            args: Prisma.ComprehensionMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComprehensionMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComprehensionMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComprehensionMetricPayload>
          }
          aggregate: {
            args: Prisma.ComprehensionMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComprehensionMetric>
          }
          groupBy: {
            args: Prisma.ComprehensionMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComprehensionMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComprehensionMetricCountArgs<ExtArgs>
            result: $Utils.Optional<ComprehensionMetricCountAggregateOutputType> | number
          }
        }
      }
      BehavioralEvent: {
        payload: Prisma.$BehavioralEventPayload<ExtArgs>
        fields: Prisma.BehavioralEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BehavioralEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BehavioralEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralEventPayload>
          }
          findFirst: {
            args: Prisma.BehavioralEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BehavioralEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralEventPayload>
          }
          findMany: {
            args: Prisma.BehavioralEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralEventPayload>[]
          }
          create: {
            args: Prisma.BehavioralEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralEventPayload>
          }
          createMany: {
            args: Prisma.BehavioralEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BehavioralEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralEventPayload>[]
          }
          delete: {
            args: Prisma.BehavioralEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralEventPayload>
          }
          update: {
            args: Prisma.BehavioralEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralEventPayload>
          }
          deleteMany: {
            args: Prisma.BehavioralEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BehavioralEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BehavioralEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralEventPayload>
          }
          aggregate: {
            args: Prisma.BehavioralEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBehavioralEvent>
          }
          groupBy: {
            args: Prisma.BehavioralEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<BehavioralEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.BehavioralEventCountArgs<ExtArgs>
            result: $Utils.Optional<BehavioralEventCountAggregateOutputType> | number
          }
        }
      }
      BehavioralPattern: {
        payload: Prisma.$BehavioralPatternPayload<ExtArgs>
        fields: Prisma.BehavioralPatternFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BehavioralPatternFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralPatternPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BehavioralPatternFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralPatternPayload>
          }
          findFirst: {
            args: Prisma.BehavioralPatternFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralPatternPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BehavioralPatternFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralPatternPayload>
          }
          findMany: {
            args: Prisma.BehavioralPatternFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralPatternPayload>[]
          }
          create: {
            args: Prisma.BehavioralPatternCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralPatternPayload>
          }
          createMany: {
            args: Prisma.BehavioralPatternCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BehavioralPatternCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralPatternPayload>[]
          }
          delete: {
            args: Prisma.BehavioralPatternDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralPatternPayload>
          }
          update: {
            args: Prisma.BehavioralPatternUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralPatternPayload>
          }
          deleteMany: {
            args: Prisma.BehavioralPatternDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BehavioralPatternUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BehavioralPatternUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralPatternPayload>
          }
          aggregate: {
            args: Prisma.BehavioralPatternAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBehavioralPattern>
          }
          groupBy: {
            args: Prisma.BehavioralPatternGroupByArgs<ExtArgs>
            result: $Utils.Optional<BehavioralPatternGroupByOutputType>[]
          }
          count: {
            args: Prisma.BehavioralPatternCountArgs<ExtArgs>
            result: $Utils.Optional<BehavioralPatternCountAggregateOutputType> | number
          }
        }
      }
      BehavioralInsight: {
        payload: Prisma.$BehavioralInsightPayload<ExtArgs>
        fields: Prisma.BehavioralInsightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BehavioralInsightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralInsightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BehavioralInsightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralInsightPayload>
          }
          findFirst: {
            args: Prisma.BehavioralInsightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralInsightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BehavioralInsightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralInsightPayload>
          }
          findMany: {
            args: Prisma.BehavioralInsightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralInsightPayload>[]
          }
          create: {
            args: Prisma.BehavioralInsightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralInsightPayload>
          }
          createMany: {
            args: Prisma.BehavioralInsightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BehavioralInsightCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralInsightPayload>[]
          }
          delete: {
            args: Prisma.BehavioralInsightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralInsightPayload>
          }
          update: {
            args: Prisma.BehavioralInsightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralInsightPayload>
          }
          deleteMany: {
            args: Prisma.BehavioralInsightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BehavioralInsightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BehavioralInsightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehavioralInsightPayload>
          }
          aggregate: {
            args: Prisma.BehavioralInsightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBehavioralInsight>
          }
          groupBy: {
            args: Prisma.BehavioralInsightGroupByArgs<ExtArgs>
            result: $Utils.Optional<BehavioralInsightGroupByOutputType>[]
          }
          count: {
            args: Prisma.BehavioralInsightCountArgs<ExtArgs>
            result: $Utils.Optional<BehavioralInsightCountAggregateOutputType> | number
          }
        }
      }
      InsightPattern: {
        payload: Prisma.$InsightPatternPayload<ExtArgs>
        fields: Prisma.InsightPatternFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InsightPatternFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPatternPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsightPatternFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPatternPayload>
          }
          findFirst: {
            args: Prisma.InsightPatternFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPatternPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsightPatternFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPatternPayload>
          }
          findMany: {
            args: Prisma.InsightPatternFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPatternPayload>[]
          }
          create: {
            args: Prisma.InsightPatternCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPatternPayload>
          }
          createMany: {
            args: Prisma.InsightPatternCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InsightPatternCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPatternPayload>[]
          }
          delete: {
            args: Prisma.InsightPatternDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPatternPayload>
          }
          update: {
            args: Prisma.InsightPatternUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPatternPayload>
          }
          deleteMany: {
            args: Prisma.InsightPatternDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InsightPatternUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InsightPatternUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPatternPayload>
          }
          aggregate: {
            args: Prisma.InsightPatternAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInsightPattern>
          }
          groupBy: {
            args: Prisma.InsightPatternGroupByArgs<ExtArgs>
            result: $Utils.Optional<InsightPatternGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsightPatternCountArgs<ExtArgs>
            result: $Utils.Optional<InsightPatternCountAggregateOutputType> | number
          }
        }
      }
      UserLearningProfile: {
        payload: Prisma.$UserLearningProfilePayload<ExtArgs>
        fields: Prisma.UserLearningProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserLearningProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLearningProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserLearningProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLearningProfilePayload>
          }
          findFirst: {
            args: Prisma.UserLearningProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLearningProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserLearningProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLearningProfilePayload>
          }
          findMany: {
            args: Prisma.UserLearningProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLearningProfilePayload>[]
          }
          create: {
            args: Prisma.UserLearningProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLearningProfilePayload>
          }
          createMany: {
            args: Prisma.UserLearningProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserLearningProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLearningProfilePayload>[]
          }
          delete: {
            args: Prisma.UserLearningProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLearningProfilePayload>
          }
          update: {
            args: Prisma.UserLearningProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLearningProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserLearningProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserLearningProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserLearningProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserLearningProfilePayload>
          }
          aggregate: {
            args: Prisma.UserLearningProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserLearningProfile>
          }
          groupBy: {
            args: Prisma.UserLearningProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserLearningProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserLearningProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserLearningProfileCountAggregateOutputType> | number
          }
        }
      }
      LearningPattern: {
        payload: Prisma.$LearningPatternPayload<ExtArgs>
        fields: Prisma.LearningPatternFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearningPatternFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPatternPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearningPatternFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPatternPayload>
          }
          findFirst: {
            args: Prisma.LearningPatternFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPatternPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearningPatternFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPatternPayload>
          }
          findMany: {
            args: Prisma.LearningPatternFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPatternPayload>[]
          }
          create: {
            args: Prisma.LearningPatternCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPatternPayload>
          }
          createMany: {
            args: Prisma.LearningPatternCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearningPatternCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPatternPayload>[]
          }
          delete: {
            args: Prisma.LearningPatternDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPatternPayload>
          }
          update: {
            args: Prisma.LearningPatternUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPatternPayload>
          }
          deleteMany: {
            args: Prisma.LearningPatternDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearningPatternUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LearningPatternUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearningPatternPayload>
          }
          aggregate: {
            args: Prisma.LearningPatternAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearningPattern>
          }
          groupBy: {
            args: Prisma.LearningPatternGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearningPatternGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearningPatternCountArgs<ExtArgs>
            result: $Utils.Optional<LearningPatternCountAggregateOutputType> | number
          }
        }
      }
      PerformancePrediction: {
        payload: Prisma.$PerformancePredictionPayload<ExtArgs>
        fields: Prisma.PerformancePredictionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerformancePredictionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformancePredictionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerformancePredictionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformancePredictionPayload>
          }
          findFirst: {
            args: Prisma.PerformancePredictionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformancePredictionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerformancePredictionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformancePredictionPayload>
          }
          findMany: {
            args: Prisma.PerformancePredictionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformancePredictionPayload>[]
          }
          create: {
            args: Prisma.PerformancePredictionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformancePredictionPayload>
          }
          createMany: {
            args: Prisma.PerformancePredictionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PerformancePredictionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformancePredictionPayload>[]
          }
          delete: {
            args: Prisma.PerformancePredictionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformancePredictionPayload>
          }
          update: {
            args: Prisma.PerformancePredictionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformancePredictionPayload>
          }
          deleteMany: {
            args: Prisma.PerformancePredictionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerformancePredictionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PerformancePredictionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformancePredictionPayload>
          }
          aggregate: {
            args: Prisma.PerformancePredictionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerformancePrediction>
          }
          groupBy: {
            args: Prisma.PerformancePredictionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerformancePredictionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerformancePredictionCountArgs<ExtArgs>
            result: $Utils.Optional<PerformancePredictionCountAggregateOutputType> | number
          }
        }
      }
      StrugglePrediction: {
        payload: Prisma.$StrugglePredictionPayload<ExtArgs>
        fields: Prisma.StrugglePredictionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StrugglePredictionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrugglePredictionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StrugglePredictionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrugglePredictionPayload>
          }
          findFirst: {
            args: Prisma.StrugglePredictionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrugglePredictionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StrugglePredictionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrugglePredictionPayload>
          }
          findMany: {
            args: Prisma.StrugglePredictionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrugglePredictionPayload>[]
          }
          create: {
            args: Prisma.StrugglePredictionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrugglePredictionPayload>
          }
          createMany: {
            args: Prisma.StrugglePredictionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StrugglePredictionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrugglePredictionPayload>[]
          }
          delete: {
            args: Prisma.StrugglePredictionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrugglePredictionPayload>
          }
          update: {
            args: Prisma.StrugglePredictionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrugglePredictionPayload>
          }
          deleteMany: {
            args: Prisma.StrugglePredictionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StrugglePredictionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StrugglePredictionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StrugglePredictionPayload>
          }
          aggregate: {
            args: Prisma.StrugglePredictionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStrugglePrediction>
          }
          groupBy: {
            args: Prisma.StrugglePredictionGroupByArgs<ExtArgs>
            result: $Utils.Optional<StrugglePredictionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StrugglePredictionCountArgs<ExtArgs>
            result: $Utils.Optional<StrugglePredictionCountAggregateOutputType> | number
          }
        }
      }
      StruggleIndicator: {
        payload: Prisma.$StruggleIndicatorPayload<ExtArgs>
        fields: Prisma.StruggleIndicatorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StruggleIndicatorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StruggleIndicatorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StruggleIndicatorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StruggleIndicatorPayload>
          }
          findFirst: {
            args: Prisma.StruggleIndicatorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StruggleIndicatorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StruggleIndicatorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StruggleIndicatorPayload>
          }
          findMany: {
            args: Prisma.StruggleIndicatorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StruggleIndicatorPayload>[]
          }
          create: {
            args: Prisma.StruggleIndicatorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StruggleIndicatorPayload>
          }
          createMany: {
            args: Prisma.StruggleIndicatorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StruggleIndicatorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StruggleIndicatorPayload>[]
          }
          delete: {
            args: Prisma.StruggleIndicatorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StruggleIndicatorPayload>
          }
          update: {
            args: Prisma.StruggleIndicatorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StruggleIndicatorPayload>
          }
          deleteMany: {
            args: Prisma.StruggleIndicatorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StruggleIndicatorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StruggleIndicatorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StruggleIndicatorPayload>
          }
          aggregate: {
            args: Prisma.StruggleIndicatorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStruggleIndicator>
          }
          groupBy: {
            args: Prisma.StruggleIndicatorGroupByArgs<ExtArgs>
            result: $Utils.Optional<StruggleIndicatorGroupByOutputType>[]
          }
          count: {
            args: Prisma.StruggleIndicatorCountArgs<ExtArgs>
            result: $Utils.Optional<StruggleIndicatorCountAggregateOutputType> | number
          }
        }
      }
      InterventionRecommendation: {
        payload: Prisma.$InterventionRecommendationPayload<ExtArgs>
        fields: Prisma.InterventionRecommendationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterventionRecommendationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionRecommendationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterventionRecommendationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionRecommendationPayload>
          }
          findFirst: {
            args: Prisma.InterventionRecommendationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionRecommendationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterventionRecommendationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionRecommendationPayload>
          }
          findMany: {
            args: Prisma.InterventionRecommendationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionRecommendationPayload>[]
          }
          create: {
            args: Prisma.InterventionRecommendationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionRecommendationPayload>
          }
          createMany: {
            args: Prisma.InterventionRecommendationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterventionRecommendationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionRecommendationPayload>[]
          }
          delete: {
            args: Prisma.InterventionRecommendationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionRecommendationPayload>
          }
          update: {
            args: Prisma.InterventionRecommendationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionRecommendationPayload>
          }
          deleteMany: {
            args: Prisma.InterventionRecommendationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterventionRecommendationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InterventionRecommendationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterventionRecommendationPayload>
          }
          aggregate: {
            args: Prisma.InterventionRecommendationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterventionRecommendation>
          }
          groupBy: {
            args: Prisma.InterventionRecommendationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterventionRecommendationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterventionRecommendationCountArgs<ExtArgs>
            result: $Utils.Optional<InterventionRecommendationCountAggregateOutputType> | number
          }
        }
      }
      PredictionFeedback: {
        payload: Prisma.$PredictionFeedbackPayload<ExtArgs>
        fields: Prisma.PredictionFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PredictionFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PredictionFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionFeedbackPayload>
          }
          findFirst: {
            args: Prisma.PredictionFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PredictionFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionFeedbackPayload>
          }
          findMany: {
            args: Prisma.PredictionFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionFeedbackPayload>[]
          }
          create: {
            args: Prisma.PredictionFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionFeedbackPayload>
          }
          createMany: {
            args: Prisma.PredictionFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PredictionFeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionFeedbackPayload>[]
          }
          delete: {
            args: Prisma.PredictionFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionFeedbackPayload>
          }
          update: {
            args: Prisma.PredictionFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.PredictionFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PredictionFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PredictionFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionFeedbackPayload>
          }
          aggregate: {
            args: Prisma.PredictionFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePredictionFeedback>
          }
          groupBy: {
            args: Prisma.PredictionFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<PredictionFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.PredictionFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<PredictionFeedbackCountAggregateOutputType> | number
          }
        }
      }
      PerformanceMetric: {
        payload: Prisma.$PerformanceMetricPayload<ExtArgs>
        fields: Prisma.PerformanceMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerformanceMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerformanceMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          findFirst: {
            args: Prisma.PerformanceMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerformanceMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          findMany: {
            args: Prisma.PerformanceMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>[]
          }
          create: {
            args: Prisma.PerformanceMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          createMany: {
            args: Prisma.PerformanceMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PerformanceMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>[]
          }
          delete: {
            args: Prisma.PerformanceMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          update: {
            args: Prisma.PerformanceMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          deleteMany: {
            args: Prisma.PerformanceMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerformanceMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PerformanceMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          aggregate: {
            args: Prisma.PerformanceMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerformanceMetric>
          }
          groupBy: {
            args: Prisma.PerformanceMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerformanceMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerformanceMetricCountArgs<ExtArgs>
            result: $Utils.Optional<PerformanceMetricCountAggregateOutputType> | number
          }
        }
      }
      Exam: {
        payload: Prisma.$ExamPayload<ExtArgs>
        fields: Prisma.ExamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findFirst: {
            args: Prisma.ExamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findMany: {
            args: Prisma.ExamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          create: {
            args: Prisma.ExamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          createMany: {
            args: Prisma.ExamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          delete: {
            args: Prisma.ExamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          update: {
            args: Prisma.ExamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          deleteMany: {
            args: Prisma.ExamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          aggregate: {
            args: Prisma.ExamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExam>
          }
          groupBy: {
            args: Prisma.ExamGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamCountArgs<ExtArgs>
            result: $Utils.Optional<ExamCountAggregateOutputType> | number
          }
        }
      }
      CoursePriority: {
        payload: Prisma.$CoursePriorityPayload<ExtArgs>
        fields: Prisma.CoursePriorityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoursePriorityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePriorityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoursePriorityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePriorityPayload>
          }
          findFirst: {
            args: Prisma.CoursePriorityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePriorityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoursePriorityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePriorityPayload>
          }
          findMany: {
            args: Prisma.CoursePriorityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePriorityPayload>[]
          }
          create: {
            args: Prisma.CoursePriorityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePriorityPayload>
          }
          createMany: {
            args: Prisma.CoursePriorityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoursePriorityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePriorityPayload>[]
          }
          delete: {
            args: Prisma.CoursePriorityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePriorityPayload>
          }
          update: {
            args: Prisma.CoursePriorityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePriorityPayload>
          }
          deleteMany: {
            args: Prisma.CoursePriorityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoursePriorityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CoursePriorityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePriorityPayload>
          }
          aggregate: {
            args: Prisma.CoursePriorityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoursePriority>
          }
          groupBy: {
            args: Prisma.CoursePriorityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoursePriorityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoursePriorityCountArgs<ExtArgs>
            result: $Utils.Optional<CoursePriorityCountAggregateOutputType> | number
          }
        }
      }
      PriorityFeedback: {
        payload: Prisma.$PriorityFeedbackPayload<ExtArgs>
        fields: Prisma.PriorityFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PriorityFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriorityFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriorityFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriorityFeedbackPayload>
          }
          findFirst: {
            args: Prisma.PriorityFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriorityFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriorityFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriorityFeedbackPayload>
          }
          findMany: {
            args: Prisma.PriorityFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriorityFeedbackPayload>[]
          }
          create: {
            args: Prisma.PriorityFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriorityFeedbackPayload>
          }
          createMany: {
            args: Prisma.PriorityFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PriorityFeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriorityFeedbackPayload>[]
          }
          delete: {
            args: Prisma.PriorityFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriorityFeedbackPayload>
          }
          update: {
            args: Prisma.PriorityFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriorityFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.PriorityFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PriorityFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PriorityFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriorityFeedbackPayload>
          }
          aggregate: {
            args: Prisma.PriorityFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePriorityFeedback>
          }
          groupBy: {
            args: Prisma.PriorityFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriorityFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriorityFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<PriorityFeedbackCountAggregateOutputType> | number
          }
        }
      }
      Streak: {
        payload: Prisma.$StreakPayload<ExtArgs>
        fields: Prisma.StreakFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StreakFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StreakFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakPayload>
          }
          findFirst: {
            args: Prisma.StreakFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StreakFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakPayload>
          }
          findMany: {
            args: Prisma.StreakFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakPayload>[]
          }
          create: {
            args: Prisma.StreakCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakPayload>
          }
          createMany: {
            args: Prisma.StreakCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StreakCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakPayload>[]
          }
          delete: {
            args: Prisma.StreakDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakPayload>
          }
          update: {
            args: Prisma.StreakUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakPayload>
          }
          deleteMany: {
            args: Prisma.StreakDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StreakUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StreakUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StreakPayload>
          }
          aggregate: {
            args: Prisma.StreakAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStreak>
          }
          groupBy: {
            args: Prisma.StreakGroupByArgs<ExtArgs>
            result: $Utils.Optional<StreakGroupByOutputType>[]
          }
          count: {
            args: Prisma.StreakCountArgs<ExtArgs>
            result: $Utils.Optional<StreakCountAggregateOutputType> | number
          }
        }
      }
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      StudyGoal: {
        payload: Prisma.$StudyGoalPayload<ExtArgs>
        fields: Prisma.StudyGoalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudyGoalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGoalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudyGoalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGoalPayload>
          }
          findFirst: {
            args: Prisma.StudyGoalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGoalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudyGoalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGoalPayload>
          }
          findMany: {
            args: Prisma.StudyGoalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGoalPayload>[]
          }
          create: {
            args: Prisma.StudyGoalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGoalPayload>
          }
          createMany: {
            args: Prisma.StudyGoalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudyGoalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGoalPayload>[]
          }
          delete: {
            args: Prisma.StudyGoalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGoalPayload>
          }
          update: {
            args: Prisma.StudyGoalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGoalPayload>
          }
          deleteMany: {
            args: Prisma.StudyGoalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudyGoalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudyGoalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGoalPayload>
          }
          aggregate: {
            args: Prisma.StudyGoalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudyGoal>
          }
          groupBy: {
            args: Prisma.StudyGoalGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudyGoalGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudyGoalCountArgs<ExtArgs>
            result: $Utils.Optional<StudyGoalCountAggregateOutputType> | number
          }
        }
      }
      MissionAnalytics: {
        payload: Prisma.$MissionAnalyticsPayload<ExtArgs>
        fields: Prisma.MissionAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MissionAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MissionAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.MissionAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MissionAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionAnalyticsPayload>
          }
          findMany: {
            args: Prisma.MissionAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionAnalyticsPayload>[]
          }
          create: {
            args: Prisma.MissionAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionAnalyticsPayload>
          }
          createMany: {
            args: Prisma.MissionAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MissionAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.MissionAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionAnalyticsPayload>
          }
          update: {
            args: Prisma.MissionAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.MissionAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MissionAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MissionAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.MissionAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMissionAnalytics>
          }
          groupBy: {
            args: Prisma.MissionAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MissionAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.MissionAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<MissionAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      MissionFeedback: {
        payload: Prisma.$MissionFeedbackPayload<ExtArgs>
        fields: Prisma.MissionFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MissionFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MissionFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionFeedbackPayload>
          }
          findFirst: {
            args: Prisma.MissionFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MissionFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionFeedbackPayload>
          }
          findMany: {
            args: Prisma.MissionFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionFeedbackPayload>[]
          }
          create: {
            args: Prisma.MissionFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionFeedbackPayload>
          }
          createMany: {
            args: Prisma.MissionFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MissionFeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionFeedbackPayload>[]
          }
          delete: {
            args: Prisma.MissionFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionFeedbackPayload>
          }
          update: {
            args: Prisma.MissionFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.MissionFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MissionFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MissionFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionFeedbackPayload>
          }
          aggregate: {
            args: Prisma.MissionFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMissionFeedback>
          }
          groupBy: {
            args: Prisma.MissionFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<MissionFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.MissionFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<MissionFeedbackCountAggregateOutputType> | number
          }
        }
      }
      MissionStreak: {
        payload: Prisma.$MissionStreakPayload<ExtArgs>
        fields: Prisma.MissionStreakFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MissionStreakFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionStreakPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MissionStreakFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionStreakPayload>
          }
          findFirst: {
            args: Prisma.MissionStreakFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionStreakPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MissionStreakFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionStreakPayload>
          }
          findMany: {
            args: Prisma.MissionStreakFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionStreakPayload>[]
          }
          create: {
            args: Prisma.MissionStreakCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionStreakPayload>
          }
          createMany: {
            args: Prisma.MissionStreakCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MissionStreakCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionStreakPayload>[]
          }
          delete: {
            args: Prisma.MissionStreakDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionStreakPayload>
          }
          update: {
            args: Prisma.MissionStreakUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionStreakPayload>
          }
          deleteMany: {
            args: Prisma.MissionStreakDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MissionStreakUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MissionStreakUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionStreakPayload>
          }
          aggregate: {
            args: Prisma.MissionStreakAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMissionStreak>
          }
          groupBy: {
            args: Prisma.MissionStreakGroupByArgs<ExtArgs>
            result: $Utils.Optional<MissionStreakGroupByOutputType>[]
          }
          count: {
            args: Prisma.MissionStreakCountArgs<ExtArgs>
            result: $Utils.Optional<MissionStreakCountAggregateOutputType> | number
          }
        }
      }
      MissionReview: {
        payload: Prisma.$MissionReviewPayload<ExtArgs>
        fields: Prisma.MissionReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MissionReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MissionReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionReviewPayload>
          }
          findFirst: {
            args: Prisma.MissionReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MissionReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionReviewPayload>
          }
          findMany: {
            args: Prisma.MissionReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionReviewPayload>[]
          }
          create: {
            args: Prisma.MissionReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionReviewPayload>
          }
          createMany: {
            args: Prisma.MissionReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MissionReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionReviewPayload>[]
          }
          delete: {
            args: Prisma.MissionReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionReviewPayload>
          }
          update: {
            args: Prisma.MissionReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionReviewPayload>
          }
          deleteMany: {
            args: Prisma.MissionReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MissionReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MissionReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MissionReviewPayload>
          }
          aggregate: {
            args: Prisma.MissionReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMissionReview>
          }
          groupBy: {
            args: Prisma.MissionReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<MissionReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.MissionReviewCountArgs<ExtArgs>
            result: $Utils.Optional<MissionReviewCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    courses: number
    lectures: number
    studySessions: number
    missions: number
    reviews: number
    exams: number
    coursePriorities: number
    achievements: number
    studyGoals: number
    missionReviews: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | UserCountOutputTypeCountCoursesArgs
    lectures?: boolean | UserCountOutputTypeCountLecturesArgs
    studySessions?: boolean | UserCountOutputTypeCountStudySessionsArgs
    missions?: boolean | UserCountOutputTypeCountMissionsArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    exams?: boolean | UserCountOutputTypeCountExamsArgs
    coursePriorities?: boolean | UserCountOutputTypeCountCoursePrioritiesArgs
    achievements?: boolean | UserCountOutputTypeCountAchievementsArgs
    studyGoals?: boolean | UserCountOutputTypeCountStudyGoalsArgs
    missionReviews?: boolean | UserCountOutputTypeCountMissionReviewsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCoursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLecturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LectureWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStudySessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudySessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCoursePrioritiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoursePriorityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStudyGoalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyGoalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMissionReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MissionReviewWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    lectures: number
    cards: number
    exams: number
    coursePriorities: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lectures?: boolean | CourseCountOutputTypeCountLecturesArgs
    cards?: boolean | CourseCountOutputTypeCountCardsArgs
    exams?: boolean | CourseCountOutputTypeCountExamsArgs
    coursePriorities?: boolean | CourseCountOutputTypeCountCoursePrioritiesArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountLecturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LectureWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCoursePrioritiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoursePriorityWhereInput
  }


  /**
   * Count Type LectureCountOutputType
   */

  export type LectureCountOutputType = {
    contentChunks: number
    learningObjectives: number
    cards: number
  }

  export type LectureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contentChunks?: boolean | LectureCountOutputTypeCountContentChunksArgs
    learningObjectives?: boolean | LectureCountOutputTypeCountLearningObjectivesArgs
    cards?: boolean | LectureCountOutputTypeCountCardsArgs
  }

  // Custom InputTypes
  /**
   * LectureCountOutputType without action
   */
  export type LectureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureCountOutputType
     */
    select?: LectureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LectureCountOutputType without action
   */
  export type LectureCountOutputTypeCountContentChunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentChunkWhereInput
  }

  /**
   * LectureCountOutputType without action
   */
  export type LectureCountOutputTypeCountLearningObjectivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningObjectiveWhereInput
  }

  /**
   * LectureCountOutputType without action
   */
  export type LectureCountOutputTypeCountCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardWhereInput
  }


  /**
   * Count Type LearningObjectiveCountOutputType
   */

  export type LearningObjectiveCountOutputType = {
    cards: number
    prerequisites: number
    dependents: number
    performanceMetrics: number
    priorityFeedback: number
    strugglePredictions: number
    struggleIndicators: number
  }

  export type LearningObjectiveCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cards?: boolean | LearningObjectiveCountOutputTypeCountCardsArgs
    prerequisites?: boolean | LearningObjectiveCountOutputTypeCountPrerequisitesArgs
    dependents?: boolean | LearningObjectiveCountOutputTypeCountDependentsArgs
    performanceMetrics?: boolean | LearningObjectiveCountOutputTypeCountPerformanceMetricsArgs
    priorityFeedback?: boolean | LearningObjectiveCountOutputTypeCountPriorityFeedbackArgs
    strugglePredictions?: boolean | LearningObjectiveCountOutputTypeCountStrugglePredictionsArgs
    struggleIndicators?: boolean | LearningObjectiveCountOutputTypeCountStruggleIndicatorsArgs
  }

  // Custom InputTypes
  /**
   * LearningObjectiveCountOutputType without action
   */
  export type LearningObjectiveCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningObjectiveCountOutputType
     */
    select?: LearningObjectiveCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LearningObjectiveCountOutputType without action
   */
  export type LearningObjectiveCountOutputTypeCountCardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardWhereInput
  }

  /**
   * LearningObjectiveCountOutputType without action
   */
  export type LearningObjectiveCountOutputTypeCountPrerequisitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectivePrerequisiteWhereInput
  }

  /**
   * LearningObjectiveCountOutputType without action
   */
  export type LearningObjectiveCountOutputTypeCountDependentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectivePrerequisiteWhereInput
  }

  /**
   * LearningObjectiveCountOutputType without action
   */
  export type LearningObjectiveCountOutputTypeCountPerformanceMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceMetricWhereInput
  }

  /**
   * LearningObjectiveCountOutputType without action
   */
  export type LearningObjectiveCountOutputTypeCountPriorityFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriorityFeedbackWhereInput
  }

  /**
   * LearningObjectiveCountOutputType without action
   */
  export type LearningObjectiveCountOutputTypeCountStrugglePredictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StrugglePredictionWhereInput
  }

  /**
   * LearningObjectiveCountOutputType without action
   */
  export type LearningObjectiveCountOutputTypeCountStruggleIndicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StruggleIndicatorWhereInput
  }


  /**
   * Count Type MissionCountOutputType
   */

  export type MissionCountOutputType = {
    studySessions: number
    feedback: number
    interventions: number
  }

  export type MissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studySessions?: boolean | MissionCountOutputTypeCountStudySessionsArgs
    feedback?: boolean | MissionCountOutputTypeCountFeedbackArgs
    interventions?: boolean | MissionCountOutputTypeCountInterventionsArgs
  }

  // Custom InputTypes
  /**
   * MissionCountOutputType without action
   */
  export type MissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionCountOutputType
     */
    select?: MissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MissionCountOutputType without action
   */
  export type MissionCountOutputTypeCountStudySessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudySessionWhereInput
  }

  /**
   * MissionCountOutputType without action
   */
  export type MissionCountOutputTypeCountFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MissionFeedbackWhereInput
  }

  /**
   * MissionCountOutputType without action
   */
  export type MissionCountOutputTypeCountInterventionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterventionRecommendationWhereInput
  }


  /**
   * Count Type CardCountOutputType
   */

  export type CardCountOutputType = {
    reviews: number
  }

  export type CardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | CardCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * CardCountOutputType without action
   */
  export type CardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardCountOutputType
     */
    select?: CardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CardCountOutputType without action
   */
  export type CardCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * Count Type StudySessionCountOutputType
   */

  export type StudySessionCountOutputType = {
    reviews: number
    validationResponses: number
  }

  export type StudySessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | StudySessionCountOutputTypeCountReviewsArgs
    validationResponses?: boolean | StudySessionCountOutputTypeCountValidationResponsesArgs
  }

  // Custom InputTypes
  /**
   * StudySessionCountOutputType without action
   */
  export type StudySessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySessionCountOutputType
     */
    select?: StudySessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudySessionCountOutputType without action
   */
  export type StudySessionCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * StudySessionCountOutputType without action
   */
  export type StudySessionCountOutputTypeCountValidationResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ValidationResponseWhereInput
  }


  /**
   * Count Type ConceptCountOutputType
   */

  export type ConceptCountOutputType = {
    relatedFrom: number
    relatedTo: number
  }

  export type ConceptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relatedFrom?: boolean | ConceptCountOutputTypeCountRelatedFromArgs
    relatedTo?: boolean | ConceptCountOutputTypeCountRelatedToArgs
  }

  // Custom InputTypes
  /**
   * ConceptCountOutputType without action
   */
  export type ConceptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptCountOutputType
     */
    select?: ConceptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConceptCountOutputType without action
   */
  export type ConceptCountOutputTypeCountRelatedFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptRelationshipWhereInput
  }

  /**
   * ConceptCountOutputType without action
   */
  export type ConceptCountOutputTypeCountRelatedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptRelationshipWhereInput
  }


  /**
   * Count Type ValidationPromptCountOutputType
   */

  export type ValidationPromptCountOutputType = {
    responses: number
  }

  export type ValidationPromptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | ValidationPromptCountOutputTypeCountResponsesArgs
  }

  // Custom InputTypes
  /**
   * ValidationPromptCountOutputType without action
   */
  export type ValidationPromptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationPromptCountOutputType
     */
    select?: ValidationPromptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ValidationPromptCountOutputType without action
   */
  export type ValidationPromptCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ValidationResponseWhereInput
  }


  /**
   * Count Type BehavioralPatternCountOutputType
   */

  export type BehavioralPatternCountOutputType = {
    insights: number
  }

  export type BehavioralPatternCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insights?: boolean | BehavioralPatternCountOutputTypeCountInsightsArgs
  }

  // Custom InputTypes
  /**
   * BehavioralPatternCountOutputType without action
   */
  export type BehavioralPatternCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralPatternCountOutputType
     */
    select?: BehavioralPatternCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BehavioralPatternCountOutputType without action
   */
  export type BehavioralPatternCountOutputTypeCountInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightPatternWhereInput
  }


  /**
   * Count Type BehavioralInsightCountOutputType
   */

  export type BehavioralInsightCountOutputType = {
    patterns: number
  }

  export type BehavioralInsightCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patterns?: boolean | BehavioralInsightCountOutputTypeCountPatternsArgs
  }

  // Custom InputTypes
  /**
   * BehavioralInsightCountOutputType without action
   */
  export type BehavioralInsightCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInsightCountOutputType
     */
    select?: BehavioralInsightCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BehavioralInsightCountOutputType without action
   */
  export type BehavioralInsightCountOutputTypeCountPatternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightPatternWhereInput
  }


  /**
   * Count Type StrugglePredictionCountOutputType
   */

  export type StrugglePredictionCountOutputType = {
    indicators: number
    interventions: number
    feedbacks: number
  }

  export type StrugglePredictionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    indicators?: boolean | StrugglePredictionCountOutputTypeCountIndicatorsArgs
    interventions?: boolean | StrugglePredictionCountOutputTypeCountInterventionsArgs
    feedbacks?: boolean | StrugglePredictionCountOutputTypeCountFeedbacksArgs
  }

  // Custom InputTypes
  /**
   * StrugglePredictionCountOutputType without action
   */
  export type StrugglePredictionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrugglePredictionCountOutputType
     */
    select?: StrugglePredictionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StrugglePredictionCountOutputType without action
   */
  export type StrugglePredictionCountOutputTypeCountIndicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StruggleIndicatorWhereInput
  }

  /**
   * StrugglePredictionCountOutputType without action
   */
  export type StrugglePredictionCountOutputTypeCountInterventionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterventionRecommendationWhereInput
  }

  /**
   * StrugglePredictionCountOutputType without action
   */
  export type StrugglePredictionCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PredictionFeedbackWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    defaultMissionMinutes: number | null
  }

  export type UserSumAggregateOutputType = {
    defaultMissionMinutes: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    defaultMissionMinutes: number | null
    missionDifficulty: string | null
    preferredStudyTime: string | null
    autoGenerateMissions: boolean | null
    performanceTrackingEnabled: boolean | null
    includeInAnalytics: boolean | null
    lastMissionAdaptation: Date | null
    behavioralAnalysisEnabled: boolean | null
    learningStyleProfilingEnabled: boolean | null
    shareAnonymizedPatterns: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    defaultMissionMinutes: number | null
    missionDifficulty: string | null
    preferredStudyTime: string | null
    autoGenerateMissions: boolean | null
    performanceTrackingEnabled: boolean | null
    includeInAnalytics: boolean | null
    lastMissionAdaptation: Date | null
    behavioralAnalysisEnabled: boolean | null
    learningStyleProfilingEnabled: boolean | null
    shareAnonymizedPatterns: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    createdAt: number
    updatedAt: number
    defaultMissionMinutes: number
    missionDifficulty: number
    preferredStudyTime: number
    autoGenerateMissions: number
    performanceTrackingEnabled: number
    includeInAnalytics: number
    lastMissionAdaptation: number
    behavioralAnalysisEnabled: number
    learningStyleProfilingEnabled: number
    shareAnonymizedPatterns: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    defaultMissionMinutes?: true
  }

  export type UserSumAggregateInputType = {
    defaultMissionMinutes?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    defaultMissionMinutes?: true
    missionDifficulty?: true
    preferredStudyTime?: true
    autoGenerateMissions?: true
    performanceTrackingEnabled?: true
    includeInAnalytics?: true
    lastMissionAdaptation?: true
    behavioralAnalysisEnabled?: true
    learningStyleProfilingEnabled?: true
    shareAnonymizedPatterns?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    defaultMissionMinutes?: true
    missionDifficulty?: true
    preferredStudyTime?: true
    autoGenerateMissions?: true
    performanceTrackingEnabled?: true
    includeInAnalytics?: true
    lastMissionAdaptation?: true
    behavioralAnalysisEnabled?: true
    learningStyleProfilingEnabled?: true
    shareAnonymizedPatterns?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    defaultMissionMinutes?: true
    missionDifficulty?: true
    preferredStudyTime?: true
    autoGenerateMissions?: true
    performanceTrackingEnabled?: true
    includeInAnalytics?: true
    lastMissionAdaptation?: true
    behavioralAnalysisEnabled?: true
    learningStyleProfilingEnabled?: true
    shareAnonymizedPatterns?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string | null
    name: string | null
    createdAt: Date
    updatedAt: Date
    defaultMissionMinutes: number
    missionDifficulty: string
    preferredStudyTime: string | null
    autoGenerateMissions: boolean
    performanceTrackingEnabled: boolean
    includeInAnalytics: boolean
    lastMissionAdaptation: Date | null
    behavioralAnalysisEnabled: boolean
    learningStyleProfilingEnabled: boolean
    shareAnonymizedPatterns: boolean
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    defaultMissionMinutes?: boolean
    missionDifficulty?: boolean
    preferredStudyTime?: boolean
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: boolean
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: boolean | User$coursesArgs<ExtArgs>
    lectures?: boolean | User$lecturesArgs<ExtArgs>
    studySessions?: boolean | User$studySessionsArgs<ExtArgs>
    missions?: boolean | User$missionsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    exams?: boolean | User$examsArgs<ExtArgs>
    coursePriorities?: boolean | User$coursePrioritiesArgs<ExtArgs>
    streak?: boolean | User$streakArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    studyGoals?: boolean | User$studyGoalsArgs<ExtArgs>
    missionStreak?: boolean | User$missionStreakArgs<ExtArgs>
    missionReviews?: boolean | User$missionReviewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    defaultMissionMinutes?: boolean
    missionDifficulty?: boolean
    preferredStudyTime?: boolean
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: boolean
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    defaultMissionMinutes?: boolean
    missionDifficulty?: boolean
    preferredStudyTime?: boolean
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: boolean
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | User$coursesArgs<ExtArgs>
    lectures?: boolean | User$lecturesArgs<ExtArgs>
    studySessions?: boolean | User$studySessionsArgs<ExtArgs>
    missions?: boolean | User$missionsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    exams?: boolean | User$examsArgs<ExtArgs>
    coursePriorities?: boolean | User$coursePrioritiesArgs<ExtArgs>
    streak?: boolean | User$streakArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    studyGoals?: boolean | User$studyGoalsArgs<ExtArgs>
    missionStreak?: boolean | User$missionStreakArgs<ExtArgs>
    missionReviews?: boolean | User$missionReviewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      courses: Prisma.$CoursePayload<ExtArgs>[]
      lectures: Prisma.$LecturePayload<ExtArgs>[]
      studySessions: Prisma.$StudySessionPayload<ExtArgs>[]
      missions: Prisma.$MissionPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      exams: Prisma.$ExamPayload<ExtArgs>[]
      coursePriorities: Prisma.$CoursePriorityPayload<ExtArgs>[]
      streak: Prisma.$StreakPayload<ExtArgs> | null
      achievements: Prisma.$AchievementPayload<ExtArgs>[]
      studyGoals: Prisma.$StudyGoalPayload<ExtArgs>[]
      missionStreak: Prisma.$MissionStreakPayload<ExtArgs> | null
      missionReviews: Prisma.$MissionReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string | null
      name: string | null
      createdAt: Date
      updatedAt: Date
      defaultMissionMinutes: number
      missionDifficulty: string
      preferredStudyTime: string | null
      autoGenerateMissions: boolean
      performanceTrackingEnabled: boolean
      includeInAnalytics: boolean
      lastMissionAdaptation: Date | null
      behavioralAnalysisEnabled: boolean
      learningStyleProfilingEnabled: boolean
      shareAnonymizedPatterns: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courses<T extends User$coursesArgs<ExtArgs> = {}>(args?: Subset<T, User$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany"> | Null>
    lectures<T extends User$lecturesArgs<ExtArgs> = {}>(args?: Subset<T, User$lecturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findMany"> | Null>
    studySessions<T extends User$studySessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$studySessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "findMany"> | Null>
    missions<T extends User$missionsArgs<ExtArgs> = {}>(args?: Subset<T, User$missionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findMany"> | Null>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany"> | Null>
    exams<T extends User$examsArgs<ExtArgs> = {}>(args?: Subset<T, User$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany"> | Null>
    coursePriorities<T extends User$coursePrioritiesArgs<ExtArgs> = {}>(args?: Subset<T, User$coursePrioritiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePriorityPayload<ExtArgs>, T, "findMany"> | Null>
    streak<T extends User$streakArgs<ExtArgs> = {}>(args?: Subset<T, User$streakArgs<ExtArgs>>): Prisma__StreakClient<$Result.GetResult<Prisma.$StreakPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    achievements<T extends User$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, User$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany"> | Null>
    studyGoals<T extends User$studyGoalsArgs<ExtArgs> = {}>(args?: Subset<T, User$studyGoalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyGoalPayload<ExtArgs>, T, "findMany"> | Null>
    missionStreak<T extends User$missionStreakArgs<ExtArgs> = {}>(args?: Subset<T, User$missionStreakArgs<ExtArgs>>): Prisma__MissionStreakClient<$Result.GetResult<Prisma.$MissionStreakPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    missionReviews<T extends User$missionReviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$missionReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionReviewPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly defaultMissionMinutes: FieldRef<"User", 'Int'>
    readonly missionDifficulty: FieldRef<"User", 'String'>
    readonly preferredStudyTime: FieldRef<"User", 'String'>
    readonly autoGenerateMissions: FieldRef<"User", 'Boolean'>
    readonly performanceTrackingEnabled: FieldRef<"User", 'Boolean'>
    readonly includeInAnalytics: FieldRef<"User", 'Boolean'>
    readonly lastMissionAdaptation: FieldRef<"User", 'DateTime'>
    readonly behavioralAnalysisEnabled: FieldRef<"User", 'Boolean'>
    readonly learningStyleProfilingEnabled: FieldRef<"User", 'Boolean'>
    readonly shareAnonymizedPatterns: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.courses
   */
  export type User$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * User.lectures
   */
  export type User$lecturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
    where?: LectureWhereInput
    orderBy?: LectureOrderByWithRelationInput | LectureOrderByWithRelationInput[]
    cursor?: LectureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LectureScalarFieldEnum | LectureScalarFieldEnum[]
  }

  /**
   * User.studySessions
   */
  export type User$studySessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    where?: StudySessionWhereInput
    orderBy?: StudySessionOrderByWithRelationInput | StudySessionOrderByWithRelationInput[]
    cursor?: StudySessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudySessionScalarFieldEnum | StudySessionScalarFieldEnum[]
  }

  /**
   * User.missions
   */
  export type User$missionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    where?: MissionWhereInput
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    cursor?: MissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MissionScalarFieldEnum | MissionScalarFieldEnum[]
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.exams
   */
  export type User$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * User.coursePriorities
   */
  export type User$coursePrioritiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePriority
     */
    select?: CoursePrioritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePriorityInclude<ExtArgs> | null
    where?: CoursePriorityWhereInput
    orderBy?: CoursePriorityOrderByWithRelationInput | CoursePriorityOrderByWithRelationInput[]
    cursor?: CoursePriorityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoursePriorityScalarFieldEnum | CoursePriorityScalarFieldEnum[]
  }

  /**
   * User.streak
   */
  export type User$streakArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Streak
     */
    select?: StreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakInclude<ExtArgs> | null
    where?: StreakWhereInput
  }

  /**
   * User.achievements
   */
  export type User$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    cursor?: AchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * User.studyGoals
   */
  export type User$studyGoalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGoal
     */
    select?: StudyGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGoalInclude<ExtArgs> | null
    where?: StudyGoalWhereInput
    orderBy?: StudyGoalOrderByWithRelationInput | StudyGoalOrderByWithRelationInput[]
    cursor?: StudyGoalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudyGoalScalarFieldEnum | StudyGoalScalarFieldEnum[]
  }

  /**
   * User.missionStreak
   */
  export type User$missionStreakArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionStreak
     */
    select?: MissionStreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionStreakInclude<ExtArgs> | null
    where?: MissionStreakWhereInput
  }

  /**
   * User.missionReviews
   */
  export type User$missionReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionReview
     */
    select?: MissionReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionReviewInclude<ExtArgs> | null
    where?: MissionReviewWhereInput
    orderBy?: MissionReviewOrderByWithRelationInput | MissionReviewOrderByWithRelationInput[]
    cursor?: MissionReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MissionReviewScalarFieldEnum | MissionReviewScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    code: string | null
    term: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    code: string | null
    term: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    code: number
    term: number
    color: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CourseMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    code?: true
    term?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    code?: true
    term?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    code?: true
    term?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    userId: string
    name: string
    code: string | null
    term: string | null
    color: string | null
    createdAt: Date
    updatedAt: Date
    _count: CourseCountAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    code?: boolean
    term?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lectures?: boolean | Course$lecturesArgs<ExtArgs>
    cards?: boolean | Course$cardsArgs<ExtArgs>
    exams?: boolean | Course$examsArgs<ExtArgs>
    coursePriorities?: boolean | Course$coursePrioritiesArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    code?: boolean
    term?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    code?: boolean
    term?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lectures?: boolean | Course$lecturesArgs<ExtArgs>
    cards?: boolean | Course$cardsArgs<ExtArgs>
    exams?: boolean | Course$examsArgs<ExtArgs>
    coursePriorities?: boolean | Course$coursePrioritiesArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      lectures: Prisma.$LecturePayload<ExtArgs>[]
      cards: Prisma.$CardPayload<ExtArgs>[]
      exams: Prisma.$ExamPayload<ExtArgs>[]
      coursePriorities: Prisma.$CoursePriorityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      code: string | null
      term: string | null
      color: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lectures<T extends Course$lecturesArgs<ExtArgs> = {}>(args?: Subset<T, Course$lecturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findMany"> | Null>
    cards<T extends Course$cardsArgs<ExtArgs> = {}>(args?: Subset<T, Course$cardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findMany"> | Null>
    exams<T extends Course$examsArgs<ExtArgs> = {}>(args?: Subset<T, Course$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany"> | Null>
    coursePriorities<T extends Course$coursePrioritiesArgs<ExtArgs> = {}>(args?: Subset<T, Course$coursePrioritiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePriorityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */ 
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly userId: FieldRef<"Course", 'String'>
    readonly name: FieldRef<"Course", 'String'>
    readonly code: FieldRef<"Course", 'String'>
    readonly term: FieldRef<"Course", 'String'>
    readonly color: FieldRef<"Course", 'String'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
    readonly updatedAt: FieldRef<"Course", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
  }

  /**
   * Course.lectures
   */
  export type Course$lecturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
    where?: LectureWhereInput
    orderBy?: LectureOrderByWithRelationInput | LectureOrderByWithRelationInput[]
    cursor?: LectureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LectureScalarFieldEnum | LectureScalarFieldEnum[]
  }

  /**
   * Course.cards
   */
  export type Course$cardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    where?: CardWhereInput
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    cursor?: CardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * Course.exams
   */
  export type Course$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Course.coursePriorities
   */
  export type Course$coursePrioritiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePriority
     */
    select?: CoursePrioritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePriorityInclude<ExtArgs> | null
    where?: CoursePriorityWhereInput
    orderBy?: CoursePriorityOrderByWithRelationInput | CoursePriorityOrderByWithRelationInput[]
    cursor?: CoursePriorityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoursePriorityScalarFieldEnum | CoursePriorityScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model Lecture
   */

  export type AggregateLecture = {
    _count: LectureCountAggregateOutputType | null
    _avg: LectureAvgAggregateOutputType | null
    _sum: LectureSumAggregateOutputType | null
    _min: LectureMinAggregateOutputType | null
    _max: LectureMaxAggregateOutputType | null
  }

  export type LectureAvgAggregateOutputType = {
    fileSize: number | null
    processingProgress: number | null
    totalPages: number | null
    processedPages: number | null
    weekNumber: number | null
  }

  export type LectureSumAggregateOutputType = {
    fileSize: number | null
    processingProgress: number | null
    totalPages: number | null
    processedPages: number | null
    weekNumber: number | null
  }

  export type LectureMinAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    title: string | null
    fileName: string | null
    fileUrl: string | null
    fileSize: number | null
    processingStatus: $Enums.ProcessingStatus | null
    uploadedAt: Date | null
    processedAt: Date | null
    processingProgress: number | null
    totalPages: number | null
    processedPages: number | null
    processingStartedAt: Date | null
    estimatedCompletionAt: Date | null
    weekNumber: number | null
  }

  export type LectureMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    title: string | null
    fileName: string | null
    fileUrl: string | null
    fileSize: number | null
    processingStatus: $Enums.ProcessingStatus | null
    uploadedAt: Date | null
    processedAt: Date | null
    processingProgress: number | null
    totalPages: number | null
    processedPages: number | null
    processingStartedAt: Date | null
    estimatedCompletionAt: Date | null
    weekNumber: number | null
  }

  export type LectureCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    title: number
    fileName: number
    fileUrl: number
    fileSize: number
    processingStatus: number
    uploadedAt: number
    processedAt: number
    processingProgress: number
    totalPages: number
    processedPages: number
    processingStartedAt: number
    estimatedCompletionAt: number
    weekNumber: number
    topicTags: number
    _all: number
  }


  export type LectureAvgAggregateInputType = {
    fileSize?: true
    processingProgress?: true
    totalPages?: true
    processedPages?: true
    weekNumber?: true
  }

  export type LectureSumAggregateInputType = {
    fileSize?: true
    processingProgress?: true
    totalPages?: true
    processedPages?: true
    weekNumber?: true
  }

  export type LectureMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    title?: true
    fileName?: true
    fileUrl?: true
    fileSize?: true
    processingStatus?: true
    uploadedAt?: true
    processedAt?: true
    processingProgress?: true
    totalPages?: true
    processedPages?: true
    processingStartedAt?: true
    estimatedCompletionAt?: true
    weekNumber?: true
  }

  export type LectureMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    title?: true
    fileName?: true
    fileUrl?: true
    fileSize?: true
    processingStatus?: true
    uploadedAt?: true
    processedAt?: true
    processingProgress?: true
    totalPages?: true
    processedPages?: true
    processingStartedAt?: true
    estimatedCompletionAt?: true
    weekNumber?: true
  }

  export type LectureCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    title?: true
    fileName?: true
    fileUrl?: true
    fileSize?: true
    processingStatus?: true
    uploadedAt?: true
    processedAt?: true
    processingProgress?: true
    totalPages?: true
    processedPages?: true
    processingStartedAt?: true
    estimatedCompletionAt?: true
    weekNumber?: true
    topicTags?: true
    _all?: true
  }

  export type LectureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lecture to aggregate.
     */
    where?: LectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lectures to fetch.
     */
    orderBy?: LectureOrderByWithRelationInput | LectureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lectures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lectures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lectures
    **/
    _count?: true | LectureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LectureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LectureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LectureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LectureMaxAggregateInputType
  }

  export type GetLectureAggregateType<T extends LectureAggregateArgs> = {
        [P in keyof T & keyof AggregateLecture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLecture[P]>
      : GetScalarType<T[P], AggregateLecture[P]>
  }




  export type LectureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LectureWhereInput
    orderBy?: LectureOrderByWithAggregationInput | LectureOrderByWithAggregationInput[]
    by: LectureScalarFieldEnum[] | LectureScalarFieldEnum
    having?: LectureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LectureCountAggregateInputType | true
    _avg?: LectureAvgAggregateInputType
    _sum?: LectureSumAggregateInputType
    _min?: LectureMinAggregateInputType
    _max?: LectureMaxAggregateInputType
  }

  export type LectureGroupByOutputType = {
    id: string
    userId: string
    courseId: string
    title: string
    fileName: string
    fileUrl: string
    fileSize: number
    processingStatus: $Enums.ProcessingStatus
    uploadedAt: Date
    processedAt: Date | null
    processingProgress: number
    totalPages: number | null
    processedPages: number
    processingStartedAt: Date | null
    estimatedCompletionAt: Date | null
    weekNumber: number | null
    topicTags: string[]
    _count: LectureCountAggregateOutputType | null
    _avg: LectureAvgAggregateOutputType | null
    _sum: LectureSumAggregateOutputType | null
    _min: LectureMinAggregateOutputType | null
    _max: LectureMaxAggregateOutputType | null
  }

  type GetLectureGroupByPayload<T extends LectureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LectureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LectureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LectureGroupByOutputType[P]>
            : GetScalarType<T[P], LectureGroupByOutputType[P]>
        }
      >
    >


  export type LectureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    title?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileSize?: boolean
    processingStatus?: boolean
    uploadedAt?: boolean
    processedAt?: boolean
    processingProgress?: boolean
    totalPages?: boolean
    processedPages?: boolean
    processingStartedAt?: boolean
    estimatedCompletionAt?: boolean
    weekNumber?: boolean
    topicTags?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    contentChunks?: boolean | Lecture$contentChunksArgs<ExtArgs>
    learningObjectives?: boolean | Lecture$learningObjectivesArgs<ExtArgs>
    cards?: boolean | Lecture$cardsArgs<ExtArgs>
    _count?: boolean | LectureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lecture"]>

  export type LectureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    title?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileSize?: boolean
    processingStatus?: boolean
    uploadedAt?: boolean
    processedAt?: boolean
    processingProgress?: boolean
    totalPages?: boolean
    processedPages?: boolean
    processingStartedAt?: boolean
    estimatedCompletionAt?: boolean
    weekNumber?: boolean
    topicTags?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lecture"]>

  export type LectureSelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    title?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileSize?: boolean
    processingStatus?: boolean
    uploadedAt?: boolean
    processedAt?: boolean
    processingProgress?: boolean
    totalPages?: boolean
    processedPages?: boolean
    processingStartedAt?: boolean
    estimatedCompletionAt?: boolean
    weekNumber?: boolean
    topicTags?: boolean
  }

  export type LectureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
    contentChunks?: boolean | Lecture$contentChunksArgs<ExtArgs>
    learningObjectives?: boolean | Lecture$learningObjectivesArgs<ExtArgs>
    cards?: boolean | Lecture$cardsArgs<ExtArgs>
    _count?: boolean | LectureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LectureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $LecturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lecture"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
      contentChunks: Prisma.$ContentChunkPayload<ExtArgs>[]
      learningObjectives: Prisma.$LearningObjectivePayload<ExtArgs>[]
      cards: Prisma.$CardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      courseId: string
      title: string
      fileName: string
      fileUrl: string
      fileSize: number
      processingStatus: $Enums.ProcessingStatus
      uploadedAt: Date
      processedAt: Date | null
      processingProgress: number
      totalPages: number | null
      processedPages: number
      processingStartedAt: Date | null
      estimatedCompletionAt: Date | null
      weekNumber: number | null
      topicTags: string[]
    }, ExtArgs["result"]["lecture"]>
    composites: {}
  }

  type LectureGetPayload<S extends boolean | null | undefined | LectureDefaultArgs> = $Result.GetResult<Prisma.$LecturePayload, S>

  type LectureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LectureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LectureCountAggregateInputType | true
    }

  export interface LectureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lecture'], meta: { name: 'Lecture' } }
    /**
     * Find zero or one Lecture that matches the filter.
     * @param {LectureFindUniqueArgs} args - Arguments to find a Lecture
     * @example
     * // Get one Lecture
     * const lecture = await prisma.lecture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LectureFindUniqueArgs>(args: SelectSubset<T, LectureFindUniqueArgs<ExtArgs>>): Prisma__LectureClient<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lecture that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LectureFindUniqueOrThrowArgs} args - Arguments to find a Lecture
     * @example
     * // Get one Lecture
     * const lecture = await prisma.lecture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LectureFindUniqueOrThrowArgs>(args: SelectSubset<T, LectureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LectureClient<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lecture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureFindFirstArgs} args - Arguments to find a Lecture
     * @example
     * // Get one Lecture
     * const lecture = await prisma.lecture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LectureFindFirstArgs>(args?: SelectSubset<T, LectureFindFirstArgs<ExtArgs>>): Prisma__LectureClient<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lecture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureFindFirstOrThrowArgs} args - Arguments to find a Lecture
     * @example
     * // Get one Lecture
     * const lecture = await prisma.lecture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LectureFindFirstOrThrowArgs>(args?: SelectSubset<T, LectureFindFirstOrThrowArgs<ExtArgs>>): Prisma__LectureClient<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Lectures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lectures
     * const lectures = await prisma.lecture.findMany()
     * 
     * // Get first 10 Lectures
     * const lectures = await prisma.lecture.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lectureWithIdOnly = await prisma.lecture.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LectureFindManyArgs>(args?: SelectSubset<T, LectureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lecture.
     * @param {LectureCreateArgs} args - Arguments to create a Lecture.
     * @example
     * // Create one Lecture
     * const Lecture = await prisma.lecture.create({
     *   data: {
     *     // ... data to create a Lecture
     *   }
     * })
     * 
     */
    create<T extends LectureCreateArgs>(args: SelectSubset<T, LectureCreateArgs<ExtArgs>>): Prisma__LectureClient<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Lectures.
     * @param {LectureCreateManyArgs} args - Arguments to create many Lectures.
     * @example
     * // Create many Lectures
     * const lecture = await prisma.lecture.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LectureCreateManyArgs>(args?: SelectSubset<T, LectureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lectures and returns the data saved in the database.
     * @param {LectureCreateManyAndReturnArgs} args - Arguments to create many Lectures.
     * @example
     * // Create many Lectures
     * const lecture = await prisma.lecture.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lectures and only return the `id`
     * const lectureWithIdOnly = await prisma.lecture.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LectureCreateManyAndReturnArgs>(args?: SelectSubset<T, LectureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Lecture.
     * @param {LectureDeleteArgs} args - Arguments to delete one Lecture.
     * @example
     * // Delete one Lecture
     * const Lecture = await prisma.lecture.delete({
     *   where: {
     *     // ... filter to delete one Lecture
     *   }
     * })
     * 
     */
    delete<T extends LectureDeleteArgs>(args: SelectSubset<T, LectureDeleteArgs<ExtArgs>>): Prisma__LectureClient<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lecture.
     * @param {LectureUpdateArgs} args - Arguments to update one Lecture.
     * @example
     * // Update one Lecture
     * const lecture = await prisma.lecture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LectureUpdateArgs>(args: SelectSubset<T, LectureUpdateArgs<ExtArgs>>): Prisma__LectureClient<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Lectures.
     * @param {LectureDeleteManyArgs} args - Arguments to filter Lectures to delete.
     * @example
     * // Delete a few Lectures
     * const { count } = await prisma.lecture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LectureDeleteManyArgs>(args?: SelectSubset<T, LectureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lectures
     * const lecture = await prisma.lecture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LectureUpdateManyArgs>(args: SelectSubset<T, LectureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lecture.
     * @param {LectureUpsertArgs} args - Arguments to update or create a Lecture.
     * @example
     * // Update or create a Lecture
     * const lecture = await prisma.lecture.upsert({
     *   create: {
     *     // ... data to create a Lecture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lecture we want to update
     *   }
     * })
     */
    upsert<T extends LectureUpsertArgs>(args: SelectSubset<T, LectureUpsertArgs<ExtArgs>>): Prisma__LectureClient<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Lectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureCountArgs} args - Arguments to filter Lectures to count.
     * @example
     * // Count the number of Lectures
     * const count = await prisma.lecture.count({
     *   where: {
     *     // ... the filter for the Lectures we want to count
     *   }
     * })
    **/
    count<T extends LectureCountArgs>(
      args?: Subset<T, LectureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LectureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lecture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LectureAggregateArgs>(args: Subset<T, LectureAggregateArgs>): Prisma.PrismaPromise<GetLectureAggregateType<T>>

    /**
     * Group by Lecture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LectureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LectureGroupByArgs['orderBy'] }
        : { orderBy?: LectureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LectureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLectureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lecture model
   */
  readonly fields: LectureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lecture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LectureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    contentChunks<T extends Lecture$contentChunksArgs<ExtArgs> = {}>(args?: Subset<T, Lecture$contentChunksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentChunkPayload<ExtArgs>, T, "findMany"> | Null>
    learningObjectives<T extends Lecture$learningObjectivesArgs<ExtArgs> = {}>(args?: Subset<T, Lecture$learningObjectivesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningObjectivePayload<ExtArgs>, T, "findMany"> | Null>
    cards<T extends Lecture$cardsArgs<ExtArgs> = {}>(args?: Subset<T, Lecture$cardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lecture model
   */ 
  interface LectureFieldRefs {
    readonly id: FieldRef<"Lecture", 'String'>
    readonly userId: FieldRef<"Lecture", 'String'>
    readonly courseId: FieldRef<"Lecture", 'String'>
    readonly title: FieldRef<"Lecture", 'String'>
    readonly fileName: FieldRef<"Lecture", 'String'>
    readonly fileUrl: FieldRef<"Lecture", 'String'>
    readonly fileSize: FieldRef<"Lecture", 'Int'>
    readonly processingStatus: FieldRef<"Lecture", 'ProcessingStatus'>
    readonly uploadedAt: FieldRef<"Lecture", 'DateTime'>
    readonly processedAt: FieldRef<"Lecture", 'DateTime'>
    readonly processingProgress: FieldRef<"Lecture", 'Int'>
    readonly totalPages: FieldRef<"Lecture", 'Int'>
    readonly processedPages: FieldRef<"Lecture", 'Int'>
    readonly processingStartedAt: FieldRef<"Lecture", 'DateTime'>
    readonly estimatedCompletionAt: FieldRef<"Lecture", 'DateTime'>
    readonly weekNumber: FieldRef<"Lecture", 'Int'>
    readonly topicTags: FieldRef<"Lecture", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * Lecture findUnique
   */
  export type LectureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
    /**
     * Filter, which Lecture to fetch.
     */
    where: LectureWhereUniqueInput
  }

  /**
   * Lecture findUniqueOrThrow
   */
  export type LectureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
    /**
     * Filter, which Lecture to fetch.
     */
    where: LectureWhereUniqueInput
  }

  /**
   * Lecture findFirst
   */
  export type LectureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
    /**
     * Filter, which Lecture to fetch.
     */
    where?: LectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lectures to fetch.
     */
    orderBy?: LectureOrderByWithRelationInput | LectureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lectures.
     */
    cursor?: LectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lectures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lectures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lectures.
     */
    distinct?: LectureScalarFieldEnum | LectureScalarFieldEnum[]
  }

  /**
   * Lecture findFirstOrThrow
   */
  export type LectureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
    /**
     * Filter, which Lecture to fetch.
     */
    where?: LectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lectures to fetch.
     */
    orderBy?: LectureOrderByWithRelationInput | LectureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lectures.
     */
    cursor?: LectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lectures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lectures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lectures.
     */
    distinct?: LectureScalarFieldEnum | LectureScalarFieldEnum[]
  }

  /**
   * Lecture findMany
   */
  export type LectureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
    /**
     * Filter, which Lectures to fetch.
     */
    where?: LectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lectures to fetch.
     */
    orderBy?: LectureOrderByWithRelationInput | LectureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lectures.
     */
    cursor?: LectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lectures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lectures.
     */
    skip?: number
    distinct?: LectureScalarFieldEnum | LectureScalarFieldEnum[]
  }

  /**
   * Lecture create
   */
  export type LectureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
    /**
     * The data needed to create a Lecture.
     */
    data: XOR<LectureCreateInput, LectureUncheckedCreateInput>
  }

  /**
   * Lecture createMany
   */
  export type LectureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lectures.
     */
    data: LectureCreateManyInput | LectureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lecture createManyAndReturn
   */
  export type LectureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Lectures.
     */
    data: LectureCreateManyInput | LectureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lecture update
   */
  export type LectureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
    /**
     * The data needed to update a Lecture.
     */
    data: XOR<LectureUpdateInput, LectureUncheckedUpdateInput>
    /**
     * Choose, which Lecture to update.
     */
    where: LectureWhereUniqueInput
  }

  /**
   * Lecture updateMany
   */
  export type LectureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lectures.
     */
    data: XOR<LectureUpdateManyMutationInput, LectureUncheckedUpdateManyInput>
    /**
     * Filter which Lectures to update
     */
    where?: LectureWhereInput
  }

  /**
   * Lecture upsert
   */
  export type LectureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
    /**
     * The filter to search for the Lecture to update in case it exists.
     */
    where: LectureWhereUniqueInput
    /**
     * In case the Lecture found by the `where` argument doesn't exist, create a new Lecture with this data.
     */
    create: XOR<LectureCreateInput, LectureUncheckedCreateInput>
    /**
     * In case the Lecture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LectureUpdateInput, LectureUncheckedUpdateInput>
  }

  /**
   * Lecture delete
   */
  export type LectureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
    /**
     * Filter which Lecture to delete.
     */
    where: LectureWhereUniqueInput
  }

  /**
   * Lecture deleteMany
   */
  export type LectureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lectures to delete
     */
    where?: LectureWhereInput
  }

  /**
   * Lecture.contentChunks
   */
  export type Lecture$contentChunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentChunk
     */
    select?: ContentChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentChunkInclude<ExtArgs> | null
    where?: ContentChunkWhereInput
    orderBy?: ContentChunkOrderByWithRelationInput | ContentChunkOrderByWithRelationInput[]
    cursor?: ContentChunkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentChunkScalarFieldEnum | ContentChunkScalarFieldEnum[]
  }

  /**
   * Lecture.learningObjectives
   */
  export type Lecture$learningObjectivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningObjective
     */
    select?: LearningObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningObjectiveInclude<ExtArgs> | null
    where?: LearningObjectiveWhereInput
    orderBy?: LearningObjectiveOrderByWithRelationInput | LearningObjectiveOrderByWithRelationInput[]
    cursor?: LearningObjectiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearningObjectiveScalarFieldEnum | LearningObjectiveScalarFieldEnum[]
  }

  /**
   * Lecture.cards
   */
  export type Lecture$cardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    where?: CardWhereInput
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    cursor?: CardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * Lecture without action
   */
  export type LectureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
  }


  /**
   * Model ContentChunk
   */

  export type AggregateContentChunk = {
    _count: ContentChunkCountAggregateOutputType | null
    _avg: ContentChunkAvgAggregateOutputType | null
    _sum: ContentChunkSumAggregateOutputType | null
    _min: ContentChunkMinAggregateOutputType | null
    _max: ContentChunkMaxAggregateOutputType | null
  }

  export type ContentChunkAvgAggregateOutputType = {
    chunkIndex: number | null
    pageNumber: number | null
  }

  export type ContentChunkSumAggregateOutputType = {
    chunkIndex: number | null
    pageNumber: number | null
  }

  export type ContentChunkMinAggregateOutputType = {
    id: string | null
    lectureId: string | null
    content: string | null
    chunkIndex: number | null
    pageNumber: number | null
    createdAt: Date | null
  }

  export type ContentChunkMaxAggregateOutputType = {
    id: string | null
    lectureId: string | null
    content: string | null
    chunkIndex: number | null
    pageNumber: number | null
    createdAt: Date | null
  }

  export type ContentChunkCountAggregateOutputType = {
    id: number
    lectureId: number
    content: number
    chunkIndex: number
    pageNumber: number
    createdAt: number
    _all: number
  }


  export type ContentChunkAvgAggregateInputType = {
    chunkIndex?: true
    pageNumber?: true
  }

  export type ContentChunkSumAggregateInputType = {
    chunkIndex?: true
    pageNumber?: true
  }

  export type ContentChunkMinAggregateInputType = {
    id?: true
    lectureId?: true
    content?: true
    chunkIndex?: true
    pageNumber?: true
    createdAt?: true
  }

  export type ContentChunkMaxAggregateInputType = {
    id?: true
    lectureId?: true
    content?: true
    chunkIndex?: true
    pageNumber?: true
    createdAt?: true
  }

  export type ContentChunkCountAggregateInputType = {
    id?: true
    lectureId?: true
    content?: true
    chunkIndex?: true
    pageNumber?: true
    createdAt?: true
    _all?: true
  }

  export type ContentChunkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentChunk to aggregate.
     */
    where?: ContentChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentChunks to fetch.
     */
    orderBy?: ContentChunkOrderByWithRelationInput | ContentChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentChunks
    **/
    _count?: true | ContentChunkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentChunkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentChunkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentChunkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentChunkMaxAggregateInputType
  }

  export type GetContentChunkAggregateType<T extends ContentChunkAggregateArgs> = {
        [P in keyof T & keyof AggregateContentChunk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentChunk[P]>
      : GetScalarType<T[P], AggregateContentChunk[P]>
  }




  export type ContentChunkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentChunkWhereInput
    orderBy?: ContentChunkOrderByWithAggregationInput | ContentChunkOrderByWithAggregationInput[]
    by: ContentChunkScalarFieldEnum[] | ContentChunkScalarFieldEnum
    having?: ContentChunkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentChunkCountAggregateInputType | true
    _avg?: ContentChunkAvgAggregateInputType
    _sum?: ContentChunkSumAggregateInputType
    _min?: ContentChunkMinAggregateInputType
    _max?: ContentChunkMaxAggregateInputType
  }

  export type ContentChunkGroupByOutputType = {
    id: string
    lectureId: string
    content: string
    chunkIndex: number
    pageNumber: number | null
    createdAt: Date
    _count: ContentChunkCountAggregateOutputType | null
    _avg: ContentChunkAvgAggregateOutputType | null
    _sum: ContentChunkSumAggregateOutputType | null
    _min: ContentChunkMinAggregateOutputType | null
    _max: ContentChunkMaxAggregateOutputType | null
  }

  type GetContentChunkGroupByPayload<T extends ContentChunkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentChunkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentChunkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentChunkGroupByOutputType[P]>
            : GetScalarType<T[P], ContentChunkGroupByOutputType[P]>
        }
      >
    >


  export type ContentChunkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lectureId?: boolean
    content?: boolean
    chunkIndex?: boolean
    pageNumber?: boolean
    createdAt?: boolean
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentChunk"]>

  export type ContentChunkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lectureId?: boolean
    content?: boolean
    chunkIndex?: boolean
    pageNumber?: boolean
    createdAt?: boolean
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentChunk"]>

  export type ContentChunkSelectScalar = {
    id?: boolean
    lectureId?: boolean
    content?: boolean
    chunkIndex?: boolean
    pageNumber?: boolean
    createdAt?: boolean
  }

  export type ContentChunkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
  }
  export type ContentChunkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
  }

  export type $ContentChunkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentChunk"
    objects: {
      lecture: Prisma.$LecturePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lectureId: string
      content: string
      chunkIndex: number
      pageNumber: number | null
      createdAt: Date
    }, ExtArgs["result"]["contentChunk"]>
    composites: {}
  }

  type ContentChunkGetPayload<S extends boolean | null | undefined | ContentChunkDefaultArgs> = $Result.GetResult<Prisma.$ContentChunkPayload, S>

  type ContentChunkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContentChunkFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContentChunkCountAggregateInputType | true
    }

  export interface ContentChunkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentChunk'], meta: { name: 'ContentChunk' } }
    /**
     * Find zero or one ContentChunk that matches the filter.
     * @param {ContentChunkFindUniqueArgs} args - Arguments to find a ContentChunk
     * @example
     * // Get one ContentChunk
     * const contentChunk = await prisma.contentChunk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentChunkFindUniqueArgs>(args: SelectSubset<T, ContentChunkFindUniqueArgs<ExtArgs>>): Prisma__ContentChunkClient<$Result.GetResult<Prisma.$ContentChunkPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContentChunk that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContentChunkFindUniqueOrThrowArgs} args - Arguments to find a ContentChunk
     * @example
     * // Get one ContentChunk
     * const contentChunk = await prisma.contentChunk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentChunkFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentChunkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentChunkClient<$Result.GetResult<Prisma.$ContentChunkPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContentChunk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentChunkFindFirstArgs} args - Arguments to find a ContentChunk
     * @example
     * // Get one ContentChunk
     * const contentChunk = await prisma.contentChunk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentChunkFindFirstArgs>(args?: SelectSubset<T, ContentChunkFindFirstArgs<ExtArgs>>): Prisma__ContentChunkClient<$Result.GetResult<Prisma.$ContentChunkPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContentChunk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentChunkFindFirstOrThrowArgs} args - Arguments to find a ContentChunk
     * @example
     * // Get one ContentChunk
     * const contentChunk = await prisma.contentChunk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentChunkFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentChunkFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentChunkClient<$Result.GetResult<Prisma.$ContentChunkPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContentChunks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentChunkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentChunks
     * const contentChunks = await prisma.contentChunk.findMany()
     * 
     * // Get first 10 ContentChunks
     * const contentChunks = await prisma.contentChunk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentChunkWithIdOnly = await prisma.contentChunk.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentChunkFindManyArgs>(args?: SelectSubset<T, ContentChunkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentChunkPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContentChunk.
     * @param {ContentChunkCreateArgs} args - Arguments to create a ContentChunk.
     * @example
     * // Create one ContentChunk
     * const ContentChunk = await prisma.contentChunk.create({
     *   data: {
     *     // ... data to create a ContentChunk
     *   }
     * })
     * 
     */
    create<T extends ContentChunkCreateArgs>(args: SelectSubset<T, ContentChunkCreateArgs<ExtArgs>>): Prisma__ContentChunkClient<$Result.GetResult<Prisma.$ContentChunkPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContentChunks.
     * @param {ContentChunkCreateManyArgs} args - Arguments to create many ContentChunks.
     * @example
     * // Create many ContentChunks
     * const contentChunk = await prisma.contentChunk.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentChunkCreateManyArgs>(args?: SelectSubset<T, ContentChunkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentChunks and returns the data saved in the database.
     * @param {ContentChunkCreateManyAndReturnArgs} args - Arguments to create many ContentChunks.
     * @example
     * // Create many ContentChunks
     * const contentChunk = await prisma.contentChunk.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentChunks and only return the `id`
     * const contentChunkWithIdOnly = await prisma.contentChunk.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentChunkCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentChunkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentChunkPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContentChunk.
     * @param {ContentChunkDeleteArgs} args - Arguments to delete one ContentChunk.
     * @example
     * // Delete one ContentChunk
     * const ContentChunk = await prisma.contentChunk.delete({
     *   where: {
     *     // ... filter to delete one ContentChunk
     *   }
     * })
     * 
     */
    delete<T extends ContentChunkDeleteArgs>(args: SelectSubset<T, ContentChunkDeleteArgs<ExtArgs>>): Prisma__ContentChunkClient<$Result.GetResult<Prisma.$ContentChunkPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContentChunk.
     * @param {ContentChunkUpdateArgs} args - Arguments to update one ContentChunk.
     * @example
     * // Update one ContentChunk
     * const contentChunk = await prisma.contentChunk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentChunkUpdateArgs>(args: SelectSubset<T, ContentChunkUpdateArgs<ExtArgs>>): Prisma__ContentChunkClient<$Result.GetResult<Prisma.$ContentChunkPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContentChunks.
     * @param {ContentChunkDeleteManyArgs} args - Arguments to filter ContentChunks to delete.
     * @example
     * // Delete a few ContentChunks
     * const { count } = await prisma.contentChunk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentChunkDeleteManyArgs>(args?: SelectSubset<T, ContentChunkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentChunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentChunkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentChunks
     * const contentChunk = await prisma.contentChunk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentChunkUpdateManyArgs>(args: SelectSubset<T, ContentChunkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContentChunk.
     * @param {ContentChunkUpsertArgs} args - Arguments to update or create a ContentChunk.
     * @example
     * // Update or create a ContentChunk
     * const contentChunk = await prisma.contentChunk.upsert({
     *   create: {
     *     // ... data to create a ContentChunk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentChunk we want to update
     *   }
     * })
     */
    upsert<T extends ContentChunkUpsertArgs>(args: SelectSubset<T, ContentChunkUpsertArgs<ExtArgs>>): Prisma__ContentChunkClient<$Result.GetResult<Prisma.$ContentChunkPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContentChunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentChunkCountArgs} args - Arguments to filter ContentChunks to count.
     * @example
     * // Count the number of ContentChunks
     * const count = await prisma.contentChunk.count({
     *   where: {
     *     // ... the filter for the ContentChunks we want to count
     *   }
     * })
    **/
    count<T extends ContentChunkCountArgs>(
      args?: Subset<T, ContentChunkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentChunkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentChunk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentChunkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentChunkAggregateArgs>(args: Subset<T, ContentChunkAggregateArgs>): Prisma.PrismaPromise<GetContentChunkAggregateType<T>>

    /**
     * Group by ContentChunk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentChunkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentChunkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentChunkGroupByArgs['orderBy'] }
        : { orderBy?: ContentChunkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentChunkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentChunkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentChunk model
   */
  readonly fields: ContentChunkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentChunk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentChunkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lecture<T extends LectureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LectureDefaultArgs<ExtArgs>>): Prisma__LectureClient<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentChunk model
   */ 
  interface ContentChunkFieldRefs {
    readonly id: FieldRef<"ContentChunk", 'String'>
    readonly lectureId: FieldRef<"ContentChunk", 'String'>
    readonly content: FieldRef<"ContentChunk", 'String'>
    readonly chunkIndex: FieldRef<"ContentChunk", 'Int'>
    readonly pageNumber: FieldRef<"ContentChunk", 'Int'>
    readonly createdAt: FieldRef<"ContentChunk", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContentChunk findUnique
   */
  export type ContentChunkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentChunk
     */
    select?: ContentChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentChunkInclude<ExtArgs> | null
    /**
     * Filter, which ContentChunk to fetch.
     */
    where: ContentChunkWhereUniqueInput
  }

  /**
   * ContentChunk findUniqueOrThrow
   */
  export type ContentChunkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentChunk
     */
    select?: ContentChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentChunkInclude<ExtArgs> | null
    /**
     * Filter, which ContentChunk to fetch.
     */
    where: ContentChunkWhereUniqueInput
  }

  /**
   * ContentChunk findFirst
   */
  export type ContentChunkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentChunk
     */
    select?: ContentChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentChunkInclude<ExtArgs> | null
    /**
     * Filter, which ContentChunk to fetch.
     */
    where?: ContentChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentChunks to fetch.
     */
    orderBy?: ContentChunkOrderByWithRelationInput | ContentChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentChunks.
     */
    cursor?: ContentChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentChunks.
     */
    distinct?: ContentChunkScalarFieldEnum | ContentChunkScalarFieldEnum[]
  }

  /**
   * ContentChunk findFirstOrThrow
   */
  export type ContentChunkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentChunk
     */
    select?: ContentChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentChunkInclude<ExtArgs> | null
    /**
     * Filter, which ContentChunk to fetch.
     */
    where?: ContentChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentChunks to fetch.
     */
    orderBy?: ContentChunkOrderByWithRelationInput | ContentChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentChunks.
     */
    cursor?: ContentChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentChunks.
     */
    distinct?: ContentChunkScalarFieldEnum | ContentChunkScalarFieldEnum[]
  }

  /**
   * ContentChunk findMany
   */
  export type ContentChunkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentChunk
     */
    select?: ContentChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentChunkInclude<ExtArgs> | null
    /**
     * Filter, which ContentChunks to fetch.
     */
    where?: ContentChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentChunks to fetch.
     */
    orderBy?: ContentChunkOrderByWithRelationInput | ContentChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentChunks.
     */
    cursor?: ContentChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentChunks.
     */
    skip?: number
    distinct?: ContentChunkScalarFieldEnum | ContentChunkScalarFieldEnum[]
  }

  /**
   * ContentChunk create
   */
  export type ContentChunkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentChunk
     */
    select?: ContentChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentChunkInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentChunk.
     */
    data: XOR<ContentChunkCreateInput, ContentChunkUncheckedCreateInput>
  }

  /**
   * ContentChunk createMany
   */
  export type ContentChunkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentChunks.
     */
    data: ContentChunkCreateManyInput | ContentChunkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentChunk createManyAndReturn
   */
  export type ContentChunkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentChunk
     */
    select?: ContentChunkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContentChunks.
     */
    data: ContentChunkCreateManyInput | ContentChunkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentChunkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentChunk update
   */
  export type ContentChunkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentChunk
     */
    select?: ContentChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentChunkInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentChunk.
     */
    data: XOR<ContentChunkUpdateInput, ContentChunkUncheckedUpdateInput>
    /**
     * Choose, which ContentChunk to update.
     */
    where: ContentChunkWhereUniqueInput
  }

  /**
   * ContentChunk updateMany
   */
  export type ContentChunkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentChunks.
     */
    data: XOR<ContentChunkUpdateManyMutationInput, ContentChunkUncheckedUpdateManyInput>
    /**
     * Filter which ContentChunks to update
     */
    where?: ContentChunkWhereInput
  }

  /**
   * ContentChunk upsert
   */
  export type ContentChunkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentChunk
     */
    select?: ContentChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentChunkInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentChunk to update in case it exists.
     */
    where: ContentChunkWhereUniqueInput
    /**
     * In case the ContentChunk found by the `where` argument doesn't exist, create a new ContentChunk with this data.
     */
    create: XOR<ContentChunkCreateInput, ContentChunkUncheckedCreateInput>
    /**
     * In case the ContentChunk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentChunkUpdateInput, ContentChunkUncheckedUpdateInput>
  }

  /**
   * ContentChunk delete
   */
  export type ContentChunkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentChunk
     */
    select?: ContentChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentChunkInclude<ExtArgs> | null
    /**
     * Filter which ContentChunk to delete.
     */
    where: ContentChunkWhereUniqueInput
  }

  /**
   * ContentChunk deleteMany
   */
  export type ContentChunkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentChunks to delete
     */
    where?: ContentChunkWhereInput
  }

  /**
   * ContentChunk without action
   */
  export type ContentChunkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentChunk
     */
    select?: ContentChunkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentChunkInclude<ExtArgs> | null
  }


  /**
   * Model LearningObjective
   */

  export type AggregateLearningObjective = {
    _count: LearningObjectiveCountAggregateOutputType | null
    _avg: LearningObjectiveAvgAggregateOutputType | null
    _sum: LearningObjectiveSumAggregateOutputType | null
    _min: LearningObjectiveMinAggregateOutputType | null
    _max: LearningObjectiveMaxAggregateOutputType | null
  }

  export type LearningObjectiveAvgAggregateOutputType = {
    pageStart: number | null
    pageEnd: number | null
    totalStudyTimeMs: number | null
    weaknessScore: number | null
  }

  export type LearningObjectiveSumAggregateOutputType = {
    pageStart: number | null
    pageEnd: number | null
    totalStudyTimeMs: number | null
    weaknessScore: number | null
  }

  export type LearningObjectiveMinAggregateOutputType = {
    id: string | null
    lectureId: string | null
    objective: string | null
    complexity: $Enums.ObjectiveComplexity | null
    pageStart: number | null
    pageEnd: number | null
    isHighYield: boolean | null
    extractedBy: string | null
    createdAt: Date | null
    masteryLevel: $Enums.MasteryLevel | null
    totalStudyTimeMs: number | null
    lastStudiedAt: Date | null
    weaknessScore: number | null
  }

  export type LearningObjectiveMaxAggregateOutputType = {
    id: string | null
    lectureId: string | null
    objective: string | null
    complexity: $Enums.ObjectiveComplexity | null
    pageStart: number | null
    pageEnd: number | null
    isHighYield: boolean | null
    extractedBy: string | null
    createdAt: Date | null
    masteryLevel: $Enums.MasteryLevel | null
    totalStudyTimeMs: number | null
    lastStudiedAt: Date | null
    weaknessScore: number | null
  }

  export type LearningObjectiveCountAggregateOutputType = {
    id: number
    lectureId: number
    objective: number
    complexity: number
    pageStart: number
    pageEnd: number
    isHighYield: number
    boardExamTags: number
    extractedBy: number
    createdAt: number
    masteryLevel: number
    totalStudyTimeMs: number
    lastStudiedAt: number
    weaknessScore: number
    _all: number
  }


  export type LearningObjectiveAvgAggregateInputType = {
    pageStart?: true
    pageEnd?: true
    totalStudyTimeMs?: true
    weaknessScore?: true
  }

  export type LearningObjectiveSumAggregateInputType = {
    pageStart?: true
    pageEnd?: true
    totalStudyTimeMs?: true
    weaknessScore?: true
  }

  export type LearningObjectiveMinAggregateInputType = {
    id?: true
    lectureId?: true
    objective?: true
    complexity?: true
    pageStart?: true
    pageEnd?: true
    isHighYield?: true
    extractedBy?: true
    createdAt?: true
    masteryLevel?: true
    totalStudyTimeMs?: true
    lastStudiedAt?: true
    weaknessScore?: true
  }

  export type LearningObjectiveMaxAggregateInputType = {
    id?: true
    lectureId?: true
    objective?: true
    complexity?: true
    pageStart?: true
    pageEnd?: true
    isHighYield?: true
    extractedBy?: true
    createdAt?: true
    masteryLevel?: true
    totalStudyTimeMs?: true
    lastStudiedAt?: true
    weaknessScore?: true
  }

  export type LearningObjectiveCountAggregateInputType = {
    id?: true
    lectureId?: true
    objective?: true
    complexity?: true
    pageStart?: true
    pageEnd?: true
    isHighYield?: true
    boardExamTags?: true
    extractedBy?: true
    createdAt?: true
    masteryLevel?: true
    totalStudyTimeMs?: true
    lastStudiedAt?: true
    weaknessScore?: true
    _all?: true
  }

  export type LearningObjectiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningObjective to aggregate.
     */
    where?: LearningObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningObjectives to fetch.
     */
    orderBy?: LearningObjectiveOrderByWithRelationInput | LearningObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningObjectives
    **/
    _count?: true | LearningObjectiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LearningObjectiveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LearningObjectiveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningObjectiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningObjectiveMaxAggregateInputType
  }

  export type GetLearningObjectiveAggregateType<T extends LearningObjectiveAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningObjective]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningObjective[P]>
      : GetScalarType<T[P], AggregateLearningObjective[P]>
  }




  export type LearningObjectiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningObjectiveWhereInput
    orderBy?: LearningObjectiveOrderByWithAggregationInput | LearningObjectiveOrderByWithAggregationInput[]
    by: LearningObjectiveScalarFieldEnum[] | LearningObjectiveScalarFieldEnum
    having?: LearningObjectiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningObjectiveCountAggregateInputType | true
    _avg?: LearningObjectiveAvgAggregateInputType
    _sum?: LearningObjectiveSumAggregateInputType
    _min?: LearningObjectiveMinAggregateInputType
    _max?: LearningObjectiveMaxAggregateInputType
  }

  export type LearningObjectiveGroupByOutputType = {
    id: string
    lectureId: string
    objective: string
    complexity: $Enums.ObjectiveComplexity
    pageStart: number | null
    pageEnd: number | null
    isHighYield: boolean
    boardExamTags: string[]
    extractedBy: string
    createdAt: Date
    masteryLevel: $Enums.MasteryLevel
    totalStudyTimeMs: number
    lastStudiedAt: Date | null
    weaknessScore: number
    _count: LearningObjectiveCountAggregateOutputType | null
    _avg: LearningObjectiveAvgAggregateOutputType | null
    _sum: LearningObjectiveSumAggregateOutputType | null
    _min: LearningObjectiveMinAggregateOutputType | null
    _max: LearningObjectiveMaxAggregateOutputType | null
  }

  type GetLearningObjectiveGroupByPayload<T extends LearningObjectiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningObjectiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningObjectiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningObjectiveGroupByOutputType[P]>
            : GetScalarType<T[P], LearningObjectiveGroupByOutputType[P]>
        }
      >
    >


  export type LearningObjectiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lectureId?: boolean
    objective?: boolean
    complexity?: boolean
    pageStart?: boolean
    pageEnd?: boolean
    isHighYield?: boolean
    boardExamTags?: boolean
    extractedBy?: boolean
    createdAt?: boolean
    masteryLevel?: boolean
    totalStudyTimeMs?: boolean
    lastStudiedAt?: boolean
    weaknessScore?: boolean
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
    cards?: boolean | LearningObjective$cardsArgs<ExtArgs>
    prerequisites?: boolean | LearningObjective$prerequisitesArgs<ExtArgs>
    dependents?: boolean | LearningObjective$dependentsArgs<ExtArgs>
    performanceMetrics?: boolean | LearningObjective$performanceMetricsArgs<ExtArgs>
    priorityFeedback?: boolean | LearningObjective$priorityFeedbackArgs<ExtArgs>
    strugglePredictions?: boolean | LearningObjective$strugglePredictionsArgs<ExtArgs>
    struggleIndicators?: boolean | LearningObjective$struggleIndicatorsArgs<ExtArgs>
    _count?: boolean | LearningObjectiveCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningObjective"]>

  export type LearningObjectiveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lectureId?: boolean
    objective?: boolean
    complexity?: boolean
    pageStart?: boolean
    pageEnd?: boolean
    isHighYield?: boolean
    boardExamTags?: boolean
    extractedBy?: boolean
    createdAt?: boolean
    masteryLevel?: boolean
    totalStudyTimeMs?: boolean
    lastStudiedAt?: boolean
    weaknessScore?: boolean
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learningObjective"]>

  export type LearningObjectiveSelectScalar = {
    id?: boolean
    lectureId?: boolean
    objective?: boolean
    complexity?: boolean
    pageStart?: boolean
    pageEnd?: boolean
    isHighYield?: boolean
    boardExamTags?: boolean
    extractedBy?: boolean
    createdAt?: boolean
    masteryLevel?: boolean
    totalStudyTimeMs?: boolean
    lastStudiedAt?: boolean
    weaknessScore?: boolean
  }

  export type LearningObjectiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
    cards?: boolean | LearningObjective$cardsArgs<ExtArgs>
    prerequisites?: boolean | LearningObjective$prerequisitesArgs<ExtArgs>
    dependents?: boolean | LearningObjective$dependentsArgs<ExtArgs>
    performanceMetrics?: boolean | LearningObjective$performanceMetricsArgs<ExtArgs>
    priorityFeedback?: boolean | LearningObjective$priorityFeedbackArgs<ExtArgs>
    strugglePredictions?: boolean | LearningObjective$strugglePredictionsArgs<ExtArgs>
    struggleIndicators?: boolean | LearningObjective$struggleIndicatorsArgs<ExtArgs>
    _count?: boolean | LearningObjectiveCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LearningObjectiveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
  }

  export type $LearningObjectivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningObjective"
    objects: {
      lecture: Prisma.$LecturePayload<ExtArgs>
      cards: Prisma.$CardPayload<ExtArgs>[]
      prerequisites: Prisma.$ObjectivePrerequisitePayload<ExtArgs>[]
      dependents: Prisma.$ObjectivePrerequisitePayload<ExtArgs>[]
      performanceMetrics: Prisma.$PerformanceMetricPayload<ExtArgs>[]
      priorityFeedback: Prisma.$PriorityFeedbackPayload<ExtArgs>[]
      strugglePredictions: Prisma.$StrugglePredictionPayload<ExtArgs>[]
      struggleIndicators: Prisma.$StruggleIndicatorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lectureId: string
      objective: string
      complexity: $Enums.ObjectiveComplexity
      pageStart: number | null
      pageEnd: number | null
      isHighYield: boolean
      boardExamTags: string[]
      extractedBy: string
      createdAt: Date
      masteryLevel: $Enums.MasteryLevel
      totalStudyTimeMs: number
      lastStudiedAt: Date | null
      weaknessScore: number
    }, ExtArgs["result"]["learningObjective"]>
    composites: {}
  }

  type LearningObjectiveGetPayload<S extends boolean | null | undefined | LearningObjectiveDefaultArgs> = $Result.GetResult<Prisma.$LearningObjectivePayload, S>

  type LearningObjectiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LearningObjectiveFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LearningObjectiveCountAggregateInputType | true
    }

  export interface LearningObjectiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningObjective'], meta: { name: 'LearningObjective' } }
    /**
     * Find zero or one LearningObjective that matches the filter.
     * @param {LearningObjectiveFindUniqueArgs} args - Arguments to find a LearningObjective
     * @example
     * // Get one LearningObjective
     * const learningObjective = await prisma.learningObjective.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearningObjectiveFindUniqueArgs>(args: SelectSubset<T, LearningObjectiveFindUniqueArgs<ExtArgs>>): Prisma__LearningObjectiveClient<$Result.GetResult<Prisma.$LearningObjectivePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LearningObjective that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LearningObjectiveFindUniqueOrThrowArgs} args - Arguments to find a LearningObjective
     * @example
     * // Get one LearningObjective
     * const learningObjective = await prisma.learningObjective.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearningObjectiveFindUniqueOrThrowArgs>(args: SelectSubset<T, LearningObjectiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearningObjectiveClient<$Result.GetResult<Prisma.$LearningObjectivePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LearningObjective that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningObjectiveFindFirstArgs} args - Arguments to find a LearningObjective
     * @example
     * // Get one LearningObjective
     * const learningObjective = await prisma.learningObjective.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearningObjectiveFindFirstArgs>(args?: SelectSubset<T, LearningObjectiveFindFirstArgs<ExtArgs>>): Prisma__LearningObjectiveClient<$Result.GetResult<Prisma.$LearningObjectivePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LearningObjective that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningObjectiveFindFirstOrThrowArgs} args - Arguments to find a LearningObjective
     * @example
     * // Get one LearningObjective
     * const learningObjective = await prisma.learningObjective.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearningObjectiveFindFirstOrThrowArgs>(args?: SelectSubset<T, LearningObjectiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearningObjectiveClient<$Result.GetResult<Prisma.$LearningObjectivePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LearningObjectives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningObjectiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningObjectives
     * const learningObjectives = await prisma.learningObjective.findMany()
     * 
     * // Get first 10 LearningObjectives
     * const learningObjectives = await prisma.learningObjective.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learningObjectiveWithIdOnly = await prisma.learningObjective.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LearningObjectiveFindManyArgs>(args?: SelectSubset<T, LearningObjectiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningObjectivePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LearningObjective.
     * @param {LearningObjectiveCreateArgs} args - Arguments to create a LearningObjective.
     * @example
     * // Create one LearningObjective
     * const LearningObjective = await prisma.learningObjective.create({
     *   data: {
     *     // ... data to create a LearningObjective
     *   }
     * })
     * 
     */
    create<T extends LearningObjectiveCreateArgs>(args: SelectSubset<T, LearningObjectiveCreateArgs<ExtArgs>>): Prisma__LearningObjectiveClient<$Result.GetResult<Prisma.$LearningObjectivePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LearningObjectives.
     * @param {LearningObjectiveCreateManyArgs} args - Arguments to create many LearningObjectives.
     * @example
     * // Create many LearningObjectives
     * const learningObjective = await prisma.learningObjective.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearningObjectiveCreateManyArgs>(args?: SelectSubset<T, LearningObjectiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearningObjectives and returns the data saved in the database.
     * @param {LearningObjectiveCreateManyAndReturnArgs} args - Arguments to create many LearningObjectives.
     * @example
     * // Create many LearningObjectives
     * const learningObjective = await prisma.learningObjective.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearningObjectives and only return the `id`
     * const learningObjectiveWithIdOnly = await prisma.learningObjective.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearningObjectiveCreateManyAndReturnArgs>(args?: SelectSubset<T, LearningObjectiveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningObjectivePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LearningObjective.
     * @param {LearningObjectiveDeleteArgs} args - Arguments to delete one LearningObjective.
     * @example
     * // Delete one LearningObjective
     * const LearningObjective = await prisma.learningObjective.delete({
     *   where: {
     *     // ... filter to delete one LearningObjective
     *   }
     * })
     * 
     */
    delete<T extends LearningObjectiveDeleteArgs>(args: SelectSubset<T, LearningObjectiveDeleteArgs<ExtArgs>>): Prisma__LearningObjectiveClient<$Result.GetResult<Prisma.$LearningObjectivePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LearningObjective.
     * @param {LearningObjectiveUpdateArgs} args - Arguments to update one LearningObjective.
     * @example
     * // Update one LearningObjective
     * const learningObjective = await prisma.learningObjective.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearningObjectiveUpdateArgs>(args: SelectSubset<T, LearningObjectiveUpdateArgs<ExtArgs>>): Prisma__LearningObjectiveClient<$Result.GetResult<Prisma.$LearningObjectivePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LearningObjectives.
     * @param {LearningObjectiveDeleteManyArgs} args - Arguments to filter LearningObjectives to delete.
     * @example
     * // Delete a few LearningObjectives
     * const { count } = await prisma.learningObjective.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearningObjectiveDeleteManyArgs>(args?: SelectSubset<T, LearningObjectiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningObjectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningObjectiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningObjectives
     * const learningObjective = await prisma.learningObjective.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearningObjectiveUpdateManyArgs>(args: SelectSubset<T, LearningObjectiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LearningObjective.
     * @param {LearningObjectiveUpsertArgs} args - Arguments to update or create a LearningObjective.
     * @example
     * // Update or create a LearningObjective
     * const learningObjective = await prisma.learningObjective.upsert({
     *   create: {
     *     // ... data to create a LearningObjective
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningObjective we want to update
     *   }
     * })
     */
    upsert<T extends LearningObjectiveUpsertArgs>(args: SelectSubset<T, LearningObjectiveUpsertArgs<ExtArgs>>): Prisma__LearningObjectiveClient<$Result.GetResult<Prisma.$LearningObjectivePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LearningObjectives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningObjectiveCountArgs} args - Arguments to filter LearningObjectives to count.
     * @example
     * // Count the number of LearningObjectives
     * const count = await prisma.learningObjective.count({
     *   where: {
     *     // ... the filter for the LearningObjectives we want to count
     *   }
     * })
    **/
    count<T extends LearningObjectiveCountArgs>(
      args?: Subset<T, LearningObjectiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningObjectiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningObjective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningObjectiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningObjectiveAggregateArgs>(args: Subset<T, LearningObjectiveAggregateArgs>): Prisma.PrismaPromise<GetLearningObjectiveAggregateType<T>>

    /**
     * Group by LearningObjective.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningObjectiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningObjectiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningObjectiveGroupByArgs['orderBy'] }
        : { orderBy?: LearningObjectiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningObjectiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningObjectiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningObjective model
   */
  readonly fields: LearningObjectiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningObjective.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningObjectiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lecture<T extends LectureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LectureDefaultArgs<ExtArgs>>): Prisma__LectureClient<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cards<T extends LearningObjective$cardsArgs<ExtArgs> = {}>(args?: Subset<T, LearningObjective$cardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findMany"> | Null>
    prerequisites<T extends LearningObjective$prerequisitesArgs<ExtArgs> = {}>(args?: Subset<T, LearningObjective$prerequisitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectivePrerequisitePayload<ExtArgs>, T, "findMany"> | Null>
    dependents<T extends LearningObjective$dependentsArgs<ExtArgs> = {}>(args?: Subset<T, LearningObjective$dependentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectivePrerequisitePayload<ExtArgs>, T, "findMany"> | Null>
    performanceMetrics<T extends LearningObjective$performanceMetricsArgs<ExtArgs> = {}>(args?: Subset<T, LearningObjective$performanceMetricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findMany"> | Null>
    priorityFeedback<T extends LearningObjective$priorityFeedbackArgs<ExtArgs> = {}>(args?: Subset<T, LearningObjective$priorityFeedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriorityFeedbackPayload<ExtArgs>, T, "findMany"> | Null>
    strugglePredictions<T extends LearningObjective$strugglePredictionsArgs<ExtArgs> = {}>(args?: Subset<T, LearningObjective$strugglePredictionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrugglePredictionPayload<ExtArgs>, T, "findMany"> | Null>
    struggleIndicators<T extends LearningObjective$struggleIndicatorsArgs<ExtArgs> = {}>(args?: Subset<T, LearningObjective$struggleIndicatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StruggleIndicatorPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearningObjective model
   */ 
  interface LearningObjectiveFieldRefs {
    readonly id: FieldRef<"LearningObjective", 'String'>
    readonly lectureId: FieldRef<"LearningObjective", 'String'>
    readonly objective: FieldRef<"LearningObjective", 'String'>
    readonly complexity: FieldRef<"LearningObjective", 'ObjectiveComplexity'>
    readonly pageStart: FieldRef<"LearningObjective", 'Int'>
    readonly pageEnd: FieldRef<"LearningObjective", 'Int'>
    readonly isHighYield: FieldRef<"LearningObjective", 'Boolean'>
    readonly boardExamTags: FieldRef<"LearningObjective", 'String[]'>
    readonly extractedBy: FieldRef<"LearningObjective", 'String'>
    readonly createdAt: FieldRef<"LearningObjective", 'DateTime'>
    readonly masteryLevel: FieldRef<"LearningObjective", 'MasteryLevel'>
    readonly totalStudyTimeMs: FieldRef<"LearningObjective", 'Int'>
    readonly lastStudiedAt: FieldRef<"LearningObjective", 'DateTime'>
    readonly weaknessScore: FieldRef<"LearningObjective", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * LearningObjective findUnique
   */
  export type LearningObjectiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningObjective
     */
    select?: LearningObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which LearningObjective to fetch.
     */
    where: LearningObjectiveWhereUniqueInput
  }

  /**
   * LearningObjective findUniqueOrThrow
   */
  export type LearningObjectiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningObjective
     */
    select?: LearningObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which LearningObjective to fetch.
     */
    where: LearningObjectiveWhereUniqueInput
  }

  /**
   * LearningObjective findFirst
   */
  export type LearningObjectiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningObjective
     */
    select?: LearningObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which LearningObjective to fetch.
     */
    where?: LearningObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningObjectives to fetch.
     */
    orderBy?: LearningObjectiveOrderByWithRelationInput | LearningObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningObjectives.
     */
    cursor?: LearningObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningObjectives.
     */
    distinct?: LearningObjectiveScalarFieldEnum | LearningObjectiveScalarFieldEnum[]
  }

  /**
   * LearningObjective findFirstOrThrow
   */
  export type LearningObjectiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningObjective
     */
    select?: LearningObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which LearningObjective to fetch.
     */
    where?: LearningObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningObjectives to fetch.
     */
    orderBy?: LearningObjectiveOrderByWithRelationInput | LearningObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningObjectives.
     */
    cursor?: LearningObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningObjectives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningObjectives.
     */
    distinct?: LearningObjectiveScalarFieldEnum | LearningObjectiveScalarFieldEnum[]
  }

  /**
   * LearningObjective findMany
   */
  export type LearningObjectiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningObjective
     */
    select?: LearningObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningObjectiveInclude<ExtArgs> | null
    /**
     * Filter, which LearningObjectives to fetch.
     */
    where?: LearningObjectiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningObjectives to fetch.
     */
    orderBy?: LearningObjectiveOrderByWithRelationInput | LearningObjectiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningObjectives.
     */
    cursor?: LearningObjectiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningObjectives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningObjectives.
     */
    skip?: number
    distinct?: LearningObjectiveScalarFieldEnum | LearningObjectiveScalarFieldEnum[]
  }

  /**
   * LearningObjective create
   */
  export type LearningObjectiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningObjective
     */
    select?: LearningObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningObjectiveInclude<ExtArgs> | null
    /**
     * The data needed to create a LearningObjective.
     */
    data: XOR<LearningObjectiveCreateInput, LearningObjectiveUncheckedCreateInput>
  }

  /**
   * LearningObjective createMany
   */
  export type LearningObjectiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningObjectives.
     */
    data: LearningObjectiveCreateManyInput | LearningObjectiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearningObjective createManyAndReturn
   */
  export type LearningObjectiveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningObjective
     */
    select?: LearningObjectiveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LearningObjectives.
     */
    data: LearningObjectiveCreateManyInput | LearningObjectiveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningObjectiveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearningObjective update
   */
  export type LearningObjectiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningObjective
     */
    select?: LearningObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningObjectiveInclude<ExtArgs> | null
    /**
     * The data needed to update a LearningObjective.
     */
    data: XOR<LearningObjectiveUpdateInput, LearningObjectiveUncheckedUpdateInput>
    /**
     * Choose, which LearningObjective to update.
     */
    where: LearningObjectiveWhereUniqueInput
  }

  /**
   * LearningObjective updateMany
   */
  export type LearningObjectiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningObjectives.
     */
    data: XOR<LearningObjectiveUpdateManyMutationInput, LearningObjectiveUncheckedUpdateManyInput>
    /**
     * Filter which LearningObjectives to update
     */
    where?: LearningObjectiveWhereInput
  }

  /**
   * LearningObjective upsert
   */
  export type LearningObjectiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningObjective
     */
    select?: LearningObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningObjectiveInclude<ExtArgs> | null
    /**
     * The filter to search for the LearningObjective to update in case it exists.
     */
    where: LearningObjectiveWhereUniqueInput
    /**
     * In case the LearningObjective found by the `where` argument doesn't exist, create a new LearningObjective with this data.
     */
    create: XOR<LearningObjectiveCreateInput, LearningObjectiveUncheckedCreateInput>
    /**
     * In case the LearningObjective was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningObjectiveUpdateInput, LearningObjectiveUncheckedUpdateInput>
  }

  /**
   * LearningObjective delete
   */
  export type LearningObjectiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningObjective
     */
    select?: LearningObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningObjectiveInclude<ExtArgs> | null
    /**
     * Filter which LearningObjective to delete.
     */
    where: LearningObjectiveWhereUniqueInput
  }

  /**
   * LearningObjective deleteMany
   */
  export type LearningObjectiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningObjectives to delete
     */
    where?: LearningObjectiveWhereInput
  }

  /**
   * LearningObjective.cards
   */
  export type LearningObjective$cardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    where?: CardWhereInput
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    cursor?: CardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * LearningObjective.prerequisites
   */
  export type LearningObjective$prerequisitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectivePrerequisite
     */
    select?: ObjectivePrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectivePrerequisiteInclude<ExtArgs> | null
    where?: ObjectivePrerequisiteWhereInput
    orderBy?: ObjectivePrerequisiteOrderByWithRelationInput | ObjectivePrerequisiteOrderByWithRelationInput[]
    cursor?: ObjectivePrerequisiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjectivePrerequisiteScalarFieldEnum | ObjectivePrerequisiteScalarFieldEnum[]
  }

  /**
   * LearningObjective.dependents
   */
  export type LearningObjective$dependentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectivePrerequisite
     */
    select?: ObjectivePrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectivePrerequisiteInclude<ExtArgs> | null
    where?: ObjectivePrerequisiteWhereInput
    orderBy?: ObjectivePrerequisiteOrderByWithRelationInput | ObjectivePrerequisiteOrderByWithRelationInput[]
    cursor?: ObjectivePrerequisiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObjectivePrerequisiteScalarFieldEnum | ObjectivePrerequisiteScalarFieldEnum[]
  }

  /**
   * LearningObjective.performanceMetrics
   */
  export type LearningObjective$performanceMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    where?: PerformanceMetricWhereInput
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    cursor?: PerformanceMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PerformanceMetricScalarFieldEnum | PerformanceMetricScalarFieldEnum[]
  }

  /**
   * LearningObjective.priorityFeedback
   */
  export type LearningObjective$priorityFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriorityFeedback
     */
    select?: PriorityFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriorityFeedbackInclude<ExtArgs> | null
    where?: PriorityFeedbackWhereInput
    orderBy?: PriorityFeedbackOrderByWithRelationInput | PriorityFeedbackOrderByWithRelationInput[]
    cursor?: PriorityFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PriorityFeedbackScalarFieldEnum | PriorityFeedbackScalarFieldEnum[]
  }

  /**
   * LearningObjective.strugglePredictions
   */
  export type LearningObjective$strugglePredictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrugglePrediction
     */
    select?: StrugglePredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrugglePredictionInclude<ExtArgs> | null
    where?: StrugglePredictionWhereInput
    orderBy?: StrugglePredictionOrderByWithRelationInput | StrugglePredictionOrderByWithRelationInput[]
    cursor?: StrugglePredictionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StrugglePredictionScalarFieldEnum | StrugglePredictionScalarFieldEnum[]
  }

  /**
   * LearningObjective.struggleIndicators
   */
  export type LearningObjective$struggleIndicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StruggleIndicator
     */
    select?: StruggleIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StruggleIndicatorInclude<ExtArgs> | null
    where?: StruggleIndicatorWhereInput
    orderBy?: StruggleIndicatorOrderByWithRelationInput | StruggleIndicatorOrderByWithRelationInput[]
    cursor?: StruggleIndicatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StruggleIndicatorScalarFieldEnum | StruggleIndicatorScalarFieldEnum[]
  }

  /**
   * LearningObjective without action
   */
  export type LearningObjectiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningObjective
     */
    select?: LearningObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningObjectiveInclude<ExtArgs> | null
  }


  /**
   * Model ObjectivePrerequisite
   */

  export type AggregateObjectivePrerequisite = {
    _count: ObjectivePrerequisiteCountAggregateOutputType | null
    _avg: ObjectivePrerequisiteAvgAggregateOutputType | null
    _sum: ObjectivePrerequisiteSumAggregateOutputType | null
    _min: ObjectivePrerequisiteMinAggregateOutputType | null
    _max: ObjectivePrerequisiteMaxAggregateOutputType | null
  }

  export type ObjectivePrerequisiteAvgAggregateOutputType = {
    strength: number | null
  }

  export type ObjectivePrerequisiteSumAggregateOutputType = {
    strength: number | null
  }

  export type ObjectivePrerequisiteMinAggregateOutputType = {
    id: string | null
    objectiveId: string | null
    prerequisiteId: string | null
    strength: number | null
  }

  export type ObjectivePrerequisiteMaxAggregateOutputType = {
    id: string | null
    objectiveId: string | null
    prerequisiteId: string | null
    strength: number | null
  }

  export type ObjectivePrerequisiteCountAggregateOutputType = {
    id: number
    objectiveId: number
    prerequisiteId: number
    strength: number
    _all: number
  }


  export type ObjectivePrerequisiteAvgAggregateInputType = {
    strength?: true
  }

  export type ObjectivePrerequisiteSumAggregateInputType = {
    strength?: true
  }

  export type ObjectivePrerequisiteMinAggregateInputType = {
    id?: true
    objectiveId?: true
    prerequisiteId?: true
    strength?: true
  }

  export type ObjectivePrerequisiteMaxAggregateInputType = {
    id?: true
    objectiveId?: true
    prerequisiteId?: true
    strength?: true
  }

  export type ObjectivePrerequisiteCountAggregateInputType = {
    id?: true
    objectiveId?: true
    prerequisiteId?: true
    strength?: true
    _all?: true
  }

  export type ObjectivePrerequisiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObjectivePrerequisite to aggregate.
     */
    where?: ObjectivePrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectivePrerequisites to fetch.
     */
    orderBy?: ObjectivePrerequisiteOrderByWithRelationInput | ObjectivePrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObjectivePrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectivePrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectivePrerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ObjectivePrerequisites
    **/
    _count?: true | ObjectivePrerequisiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObjectivePrerequisiteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObjectivePrerequisiteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObjectivePrerequisiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObjectivePrerequisiteMaxAggregateInputType
  }

  export type GetObjectivePrerequisiteAggregateType<T extends ObjectivePrerequisiteAggregateArgs> = {
        [P in keyof T & keyof AggregateObjectivePrerequisite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObjectivePrerequisite[P]>
      : GetScalarType<T[P], AggregateObjectivePrerequisite[P]>
  }




  export type ObjectivePrerequisiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ObjectivePrerequisiteWhereInput
    orderBy?: ObjectivePrerequisiteOrderByWithAggregationInput | ObjectivePrerequisiteOrderByWithAggregationInput[]
    by: ObjectivePrerequisiteScalarFieldEnum[] | ObjectivePrerequisiteScalarFieldEnum
    having?: ObjectivePrerequisiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObjectivePrerequisiteCountAggregateInputType | true
    _avg?: ObjectivePrerequisiteAvgAggregateInputType
    _sum?: ObjectivePrerequisiteSumAggregateInputType
    _min?: ObjectivePrerequisiteMinAggregateInputType
    _max?: ObjectivePrerequisiteMaxAggregateInputType
  }

  export type ObjectivePrerequisiteGroupByOutputType = {
    id: string
    objectiveId: string
    prerequisiteId: string
    strength: number
    _count: ObjectivePrerequisiteCountAggregateOutputType | null
    _avg: ObjectivePrerequisiteAvgAggregateOutputType | null
    _sum: ObjectivePrerequisiteSumAggregateOutputType | null
    _min: ObjectivePrerequisiteMinAggregateOutputType | null
    _max: ObjectivePrerequisiteMaxAggregateOutputType | null
  }

  type GetObjectivePrerequisiteGroupByPayload<T extends ObjectivePrerequisiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObjectivePrerequisiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObjectivePrerequisiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObjectivePrerequisiteGroupByOutputType[P]>
            : GetScalarType<T[P], ObjectivePrerequisiteGroupByOutputType[P]>
        }
      >
    >


  export type ObjectivePrerequisiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    objectiveId?: boolean
    prerequisiteId?: boolean
    strength?: boolean
    objective?: boolean | LearningObjectiveDefaultArgs<ExtArgs>
    prerequisite?: boolean | LearningObjectiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["objectivePrerequisite"]>

  export type ObjectivePrerequisiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    objectiveId?: boolean
    prerequisiteId?: boolean
    strength?: boolean
    objective?: boolean | LearningObjectiveDefaultArgs<ExtArgs>
    prerequisite?: boolean | LearningObjectiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["objectivePrerequisite"]>

  export type ObjectivePrerequisiteSelectScalar = {
    id?: boolean
    objectiveId?: boolean
    prerequisiteId?: boolean
    strength?: boolean
  }

  export type ObjectivePrerequisiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    objective?: boolean | LearningObjectiveDefaultArgs<ExtArgs>
    prerequisite?: boolean | LearningObjectiveDefaultArgs<ExtArgs>
  }
  export type ObjectivePrerequisiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    objective?: boolean | LearningObjectiveDefaultArgs<ExtArgs>
    prerequisite?: boolean | LearningObjectiveDefaultArgs<ExtArgs>
  }

  export type $ObjectivePrerequisitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ObjectivePrerequisite"
    objects: {
      objective: Prisma.$LearningObjectivePayload<ExtArgs>
      prerequisite: Prisma.$LearningObjectivePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      objectiveId: string
      prerequisiteId: string
      strength: number
    }, ExtArgs["result"]["objectivePrerequisite"]>
    composites: {}
  }

  type ObjectivePrerequisiteGetPayload<S extends boolean | null | undefined | ObjectivePrerequisiteDefaultArgs> = $Result.GetResult<Prisma.$ObjectivePrerequisitePayload, S>

  type ObjectivePrerequisiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ObjectivePrerequisiteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ObjectivePrerequisiteCountAggregateInputType | true
    }

  export interface ObjectivePrerequisiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ObjectivePrerequisite'], meta: { name: 'ObjectivePrerequisite' } }
    /**
     * Find zero or one ObjectivePrerequisite that matches the filter.
     * @param {ObjectivePrerequisiteFindUniqueArgs} args - Arguments to find a ObjectivePrerequisite
     * @example
     * // Get one ObjectivePrerequisite
     * const objectivePrerequisite = await prisma.objectivePrerequisite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ObjectivePrerequisiteFindUniqueArgs>(args: SelectSubset<T, ObjectivePrerequisiteFindUniqueArgs<ExtArgs>>): Prisma__ObjectivePrerequisiteClient<$Result.GetResult<Prisma.$ObjectivePrerequisitePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ObjectivePrerequisite that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ObjectivePrerequisiteFindUniqueOrThrowArgs} args - Arguments to find a ObjectivePrerequisite
     * @example
     * // Get one ObjectivePrerequisite
     * const objectivePrerequisite = await prisma.objectivePrerequisite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ObjectivePrerequisiteFindUniqueOrThrowArgs>(args: SelectSubset<T, ObjectivePrerequisiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ObjectivePrerequisiteClient<$Result.GetResult<Prisma.$ObjectivePrerequisitePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ObjectivePrerequisite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectivePrerequisiteFindFirstArgs} args - Arguments to find a ObjectivePrerequisite
     * @example
     * // Get one ObjectivePrerequisite
     * const objectivePrerequisite = await prisma.objectivePrerequisite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ObjectivePrerequisiteFindFirstArgs>(args?: SelectSubset<T, ObjectivePrerequisiteFindFirstArgs<ExtArgs>>): Prisma__ObjectivePrerequisiteClient<$Result.GetResult<Prisma.$ObjectivePrerequisitePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ObjectivePrerequisite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectivePrerequisiteFindFirstOrThrowArgs} args - Arguments to find a ObjectivePrerequisite
     * @example
     * // Get one ObjectivePrerequisite
     * const objectivePrerequisite = await prisma.objectivePrerequisite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ObjectivePrerequisiteFindFirstOrThrowArgs>(args?: SelectSubset<T, ObjectivePrerequisiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ObjectivePrerequisiteClient<$Result.GetResult<Prisma.$ObjectivePrerequisitePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ObjectivePrerequisites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectivePrerequisiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ObjectivePrerequisites
     * const objectivePrerequisites = await prisma.objectivePrerequisite.findMany()
     * 
     * // Get first 10 ObjectivePrerequisites
     * const objectivePrerequisites = await prisma.objectivePrerequisite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const objectivePrerequisiteWithIdOnly = await prisma.objectivePrerequisite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ObjectivePrerequisiteFindManyArgs>(args?: SelectSubset<T, ObjectivePrerequisiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectivePrerequisitePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ObjectivePrerequisite.
     * @param {ObjectivePrerequisiteCreateArgs} args - Arguments to create a ObjectivePrerequisite.
     * @example
     * // Create one ObjectivePrerequisite
     * const ObjectivePrerequisite = await prisma.objectivePrerequisite.create({
     *   data: {
     *     // ... data to create a ObjectivePrerequisite
     *   }
     * })
     * 
     */
    create<T extends ObjectivePrerequisiteCreateArgs>(args: SelectSubset<T, ObjectivePrerequisiteCreateArgs<ExtArgs>>): Prisma__ObjectivePrerequisiteClient<$Result.GetResult<Prisma.$ObjectivePrerequisitePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ObjectivePrerequisites.
     * @param {ObjectivePrerequisiteCreateManyArgs} args - Arguments to create many ObjectivePrerequisites.
     * @example
     * // Create many ObjectivePrerequisites
     * const objectivePrerequisite = await prisma.objectivePrerequisite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ObjectivePrerequisiteCreateManyArgs>(args?: SelectSubset<T, ObjectivePrerequisiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ObjectivePrerequisites and returns the data saved in the database.
     * @param {ObjectivePrerequisiteCreateManyAndReturnArgs} args - Arguments to create many ObjectivePrerequisites.
     * @example
     * // Create many ObjectivePrerequisites
     * const objectivePrerequisite = await prisma.objectivePrerequisite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ObjectivePrerequisites and only return the `id`
     * const objectivePrerequisiteWithIdOnly = await prisma.objectivePrerequisite.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ObjectivePrerequisiteCreateManyAndReturnArgs>(args?: SelectSubset<T, ObjectivePrerequisiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ObjectivePrerequisitePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ObjectivePrerequisite.
     * @param {ObjectivePrerequisiteDeleteArgs} args - Arguments to delete one ObjectivePrerequisite.
     * @example
     * // Delete one ObjectivePrerequisite
     * const ObjectivePrerequisite = await prisma.objectivePrerequisite.delete({
     *   where: {
     *     // ... filter to delete one ObjectivePrerequisite
     *   }
     * })
     * 
     */
    delete<T extends ObjectivePrerequisiteDeleteArgs>(args: SelectSubset<T, ObjectivePrerequisiteDeleteArgs<ExtArgs>>): Prisma__ObjectivePrerequisiteClient<$Result.GetResult<Prisma.$ObjectivePrerequisitePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ObjectivePrerequisite.
     * @param {ObjectivePrerequisiteUpdateArgs} args - Arguments to update one ObjectivePrerequisite.
     * @example
     * // Update one ObjectivePrerequisite
     * const objectivePrerequisite = await prisma.objectivePrerequisite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ObjectivePrerequisiteUpdateArgs>(args: SelectSubset<T, ObjectivePrerequisiteUpdateArgs<ExtArgs>>): Prisma__ObjectivePrerequisiteClient<$Result.GetResult<Prisma.$ObjectivePrerequisitePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ObjectivePrerequisites.
     * @param {ObjectivePrerequisiteDeleteManyArgs} args - Arguments to filter ObjectivePrerequisites to delete.
     * @example
     * // Delete a few ObjectivePrerequisites
     * const { count } = await prisma.objectivePrerequisite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ObjectivePrerequisiteDeleteManyArgs>(args?: SelectSubset<T, ObjectivePrerequisiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ObjectivePrerequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectivePrerequisiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ObjectivePrerequisites
     * const objectivePrerequisite = await prisma.objectivePrerequisite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ObjectivePrerequisiteUpdateManyArgs>(args: SelectSubset<T, ObjectivePrerequisiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ObjectivePrerequisite.
     * @param {ObjectivePrerequisiteUpsertArgs} args - Arguments to update or create a ObjectivePrerequisite.
     * @example
     * // Update or create a ObjectivePrerequisite
     * const objectivePrerequisite = await prisma.objectivePrerequisite.upsert({
     *   create: {
     *     // ... data to create a ObjectivePrerequisite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ObjectivePrerequisite we want to update
     *   }
     * })
     */
    upsert<T extends ObjectivePrerequisiteUpsertArgs>(args: SelectSubset<T, ObjectivePrerequisiteUpsertArgs<ExtArgs>>): Prisma__ObjectivePrerequisiteClient<$Result.GetResult<Prisma.$ObjectivePrerequisitePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ObjectivePrerequisites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectivePrerequisiteCountArgs} args - Arguments to filter ObjectivePrerequisites to count.
     * @example
     * // Count the number of ObjectivePrerequisites
     * const count = await prisma.objectivePrerequisite.count({
     *   where: {
     *     // ... the filter for the ObjectivePrerequisites we want to count
     *   }
     * })
    **/
    count<T extends ObjectivePrerequisiteCountArgs>(
      args?: Subset<T, ObjectivePrerequisiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObjectivePrerequisiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ObjectivePrerequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectivePrerequisiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObjectivePrerequisiteAggregateArgs>(args: Subset<T, ObjectivePrerequisiteAggregateArgs>): Prisma.PrismaPromise<GetObjectivePrerequisiteAggregateType<T>>

    /**
     * Group by ObjectivePrerequisite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObjectivePrerequisiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObjectivePrerequisiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObjectivePrerequisiteGroupByArgs['orderBy'] }
        : { orderBy?: ObjectivePrerequisiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObjectivePrerequisiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObjectivePrerequisiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ObjectivePrerequisite model
   */
  readonly fields: ObjectivePrerequisiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ObjectivePrerequisite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ObjectivePrerequisiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    objective<T extends LearningObjectiveDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearningObjectiveDefaultArgs<ExtArgs>>): Prisma__LearningObjectiveClient<$Result.GetResult<Prisma.$LearningObjectivePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    prerequisite<T extends LearningObjectiveDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearningObjectiveDefaultArgs<ExtArgs>>): Prisma__LearningObjectiveClient<$Result.GetResult<Prisma.$LearningObjectivePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ObjectivePrerequisite model
   */ 
  interface ObjectivePrerequisiteFieldRefs {
    readonly id: FieldRef<"ObjectivePrerequisite", 'String'>
    readonly objectiveId: FieldRef<"ObjectivePrerequisite", 'String'>
    readonly prerequisiteId: FieldRef<"ObjectivePrerequisite", 'String'>
    readonly strength: FieldRef<"ObjectivePrerequisite", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * ObjectivePrerequisite findUnique
   */
  export type ObjectivePrerequisiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectivePrerequisite
     */
    select?: ObjectivePrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectivePrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which ObjectivePrerequisite to fetch.
     */
    where: ObjectivePrerequisiteWhereUniqueInput
  }

  /**
   * ObjectivePrerequisite findUniqueOrThrow
   */
  export type ObjectivePrerequisiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectivePrerequisite
     */
    select?: ObjectivePrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectivePrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which ObjectivePrerequisite to fetch.
     */
    where: ObjectivePrerequisiteWhereUniqueInput
  }

  /**
   * ObjectivePrerequisite findFirst
   */
  export type ObjectivePrerequisiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectivePrerequisite
     */
    select?: ObjectivePrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectivePrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which ObjectivePrerequisite to fetch.
     */
    where?: ObjectivePrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectivePrerequisites to fetch.
     */
    orderBy?: ObjectivePrerequisiteOrderByWithRelationInput | ObjectivePrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObjectivePrerequisites.
     */
    cursor?: ObjectivePrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectivePrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectivePrerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObjectivePrerequisites.
     */
    distinct?: ObjectivePrerequisiteScalarFieldEnum | ObjectivePrerequisiteScalarFieldEnum[]
  }

  /**
   * ObjectivePrerequisite findFirstOrThrow
   */
  export type ObjectivePrerequisiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectivePrerequisite
     */
    select?: ObjectivePrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectivePrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which ObjectivePrerequisite to fetch.
     */
    where?: ObjectivePrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectivePrerequisites to fetch.
     */
    orderBy?: ObjectivePrerequisiteOrderByWithRelationInput | ObjectivePrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ObjectivePrerequisites.
     */
    cursor?: ObjectivePrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectivePrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectivePrerequisites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ObjectivePrerequisites.
     */
    distinct?: ObjectivePrerequisiteScalarFieldEnum | ObjectivePrerequisiteScalarFieldEnum[]
  }

  /**
   * ObjectivePrerequisite findMany
   */
  export type ObjectivePrerequisiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectivePrerequisite
     */
    select?: ObjectivePrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectivePrerequisiteInclude<ExtArgs> | null
    /**
     * Filter, which ObjectivePrerequisites to fetch.
     */
    where?: ObjectivePrerequisiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ObjectivePrerequisites to fetch.
     */
    orderBy?: ObjectivePrerequisiteOrderByWithRelationInput | ObjectivePrerequisiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ObjectivePrerequisites.
     */
    cursor?: ObjectivePrerequisiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ObjectivePrerequisites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ObjectivePrerequisites.
     */
    skip?: number
    distinct?: ObjectivePrerequisiteScalarFieldEnum | ObjectivePrerequisiteScalarFieldEnum[]
  }

  /**
   * ObjectivePrerequisite create
   */
  export type ObjectivePrerequisiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectivePrerequisite
     */
    select?: ObjectivePrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectivePrerequisiteInclude<ExtArgs> | null
    /**
     * The data needed to create a ObjectivePrerequisite.
     */
    data: XOR<ObjectivePrerequisiteCreateInput, ObjectivePrerequisiteUncheckedCreateInput>
  }

  /**
   * ObjectivePrerequisite createMany
   */
  export type ObjectivePrerequisiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ObjectivePrerequisites.
     */
    data: ObjectivePrerequisiteCreateManyInput | ObjectivePrerequisiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ObjectivePrerequisite createManyAndReturn
   */
  export type ObjectivePrerequisiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectivePrerequisite
     */
    select?: ObjectivePrerequisiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ObjectivePrerequisites.
     */
    data: ObjectivePrerequisiteCreateManyInput | ObjectivePrerequisiteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectivePrerequisiteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ObjectivePrerequisite update
   */
  export type ObjectivePrerequisiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectivePrerequisite
     */
    select?: ObjectivePrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectivePrerequisiteInclude<ExtArgs> | null
    /**
     * The data needed to update a ObjectivePrerequisite.
     */
    data: XOR<ObjectivePrerequisiteUpdateInput, ObjectivePrerequisiteUncheckedUpdateInput>
    /**
     * Choose, which ObjectivePrerequisite to update.
     */
    where: ObjectivePrerequisiteWhereUniqueInput
  }

  /**
   * ObjectivePrerequisite updateMany
   */
  export type ObjectivePrerequisiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ObjectivePrerequisites.
     */
    data: XOR<ObjectivePrerequisiteUpdateManyMutationInput, ObjectivePrerequisiteUncheckedUpdateManyInput>
    /**
     * Filter which ObjectivePrerequisites to update
     */
    where?: ObjectivePrerequisiteWhereInput
  }

  /**
   * ObjectivePrerequisite upsert
   */
  export type ObjectivePrerequisiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectivePrerequisite
     */
    select?: ObjectivePrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectivePrerequisiteInclude<ExtArgs> | null
    /**
     * The filter to search for the ObjectivePrerequisite to update in case it exists.
     */
    where: ObjectivePrerequisiteWhereUniqueInput
    /**
     * In case the ObjectivePrerequisite found by the `where` argument doesn't exist, create a new ObjectivePrerequisite with this data.
     */
    create: XOR<ObjectivePrerequisiteCreateInput, ObjectivePrerequisiteUncheckedCreateInput>
    /**
     * In case the ObjectivePrerequisite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObjectivePrerequisiteUpdateInput, ObjectivePrerequisiteUncheckedUpdateInput>
  }

  /**
   * ObjectivePrerequisite delete
   */
  export type ObjectivePrerequisiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectivePrerequisite
     */
    select?: ObjectivePrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectivePrerequisiteInclude<ExtArgs> | null
    /**
     * Filter which ObjectivePrerequisite to delete.
     */
    where: ObjectivePrerequisiteWhereUniqueInput
  }

  /**
   * ObjectivePrerequisite deleteMany
   */
  export type ObjectivePrerequisiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ObjectivePrerequisites to delete
     */
    where?: ObjectivePrerequisiteWhereInput
  }

  /**
   * ObjectivePrerequisite without action
   */
  export type ObjectivePrerequisiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObjectivePrerequisite
     */
    select?: ObjectivePrerequisiteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ObjectivePrerequisiteInclude<ExtArgs> | null
  }


  /**
   * Model Mission
   */

  export type AggregateMission = {
    _count: MissionCountAggregateOutputType | null
    _avg: MissionAvgAggregateOutputType | null
    _sum: MissionSumAggregateOutputType | null
    _min: MissionMinAggregateOutputType | null
    _max: MissionMaxAggregateOutputType | null
  }

  export type MissionAvgAggregateOutputType = {
    estimatedMinutes: number | null
    actualMinutes: number | null
    completedObjectivesCount: number | null
    reviewCardCount: number | null
    newContentCount: number | null
    successScore: number | null
    difficultyRating: number | null
  }

  export type MissionSumAggregateOutputType = {
    estimatedMinutes: number | null
    actualMinutes: number | null
    completedObjectivesCount: number | null
    reviewCardCount: number | null
    newContentCount: number | null
    successScore: number | null
    difficultyRating: number | null
  }

  export type MissionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    status: $Enums.MissionStatus | null
    estimatedMinutes: number | null
    completedAt: Date | null
    actualMinutes: number | null
    completedObjectivesCount: number | null
    reviewCardCount: number | null
    newContentCount: number | null
    successScore: number | null
    difficultyRating: number | null
  }

  export type MissionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    status: $Enums.MissionStatus | null
    estimatedMinutes: number | null
    completedAt: Date | null
    actualMinutes: number | null
    completedObjectivesCount: number | null
    reviewCardCount: number | null
    newContentCount: number | null
    successScore: number | null
    difficultyRating: number | null
  }

  export type MissionCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    status: number
    estimatedMinutes: number
    completedAt: number
    actualMinutes: number
    completedObjectivesCount: number
    objectives: number
    reviewCardCount: number
    newContentCount: number
    successScore: number
    difficultyRating: number
    _all: number
  }


  export type MissionAvgAggregateInputType = {
    estimatedMinutes?: true
    actualMinutes?: true
    completedObjectivesCount?: true
    reviewCardCount?: true
    newContentCount?: true
    successScore?: true
    difficultyRating?: true
  }

  export type MissionSumAggregateInputType = {
    estimatedMinutes?: true
    actualMinutes?: true
    completedObjectivesCount?: true
    reviewCardCount?: true
    newContentCount?: true
    successScore?: true
    difficultyRating?: true
  }

  export type MissionMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    status?: true
    estimatedMinutes?: true
    completedAt?: true
    actualMinutes?: true
    completedObjectivesCount?: true
    reviewCardCount?: true
    newContentCount?: true
    successScore?: true
    difficultyRating?: true
  }

  export type MissionMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    status?: true
    estimatedMinutes?: true
    completedAt?: true
    actualMinutes?: true
    completedObjectivesCount?: true
    reviewCardCount?: true
    newContentCount?: true
    successScore?: true
    difficultyRating?: true
  }

  export type MissionCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    status?: true
    estimatedMinutes?: true
    completedAt?: true
    actualMinutes?: true
    completedObjectivesCount?: true
    objectives?: true
    reviewCardCount?: true
    newContentCount?: true
    successScore?: true
    difficultyRating?: true
    _all?: true
  }

  export type MissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mission to aggregate.
     */
    where?: MissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Missions to fetch.
     */
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Missions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Missions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Missions
    **/
    _count?: true | MissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MissionMaxAggregateInputType
  }

  export type GetMissionAggregateType<T extends MissionAggregateArgs> = {
        [P in keyof T & keyof AggregateMission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMission[P]>
      : GetScalarType<T[P], AggregateMission[P]>
  }




  export type MissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MissionWhereInput
    orderBy?: MissionOrderByWithAggregationInput | MissionOrderByWithAggregationInput[]
    by: MissionScalarFieldEnum[] | MissionScalarFieldEnum
    having?: MissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MissionCountAggregateInputType | true
    _avg?: MissionAvgAggregateInputType
    _sum?: MissionSumAggregateInputType
    _min?: MissionMinAggregateInputType
    _max?: MissionMaxAggregateInputType
  }

  export type MissionGroupByOutputType = {
    id: string
    userId: string
    date: Date
    status: $Enums.MissionStatus
    estimatedMinutes: number
    completedAt: Date | null
    actualMinutes: number | null
    completedObjectivesCount: number
    objectives: JsonValue
    reviewCardCount: number
    newContentCount: number
    successScore: number | null
    difficultyRating: number | null
    _count: MissionCountAggregateOutputType | null
    _avg: MissionAvgAggregateOutputType | null
    _sum: MissionSumAggregateOutputType | null
    _min: MissionMinAggregateOutputType | null
    _max: MissionMaxAggregateOutputType | null
  }

  type GetMissionGroupByPayload<T extends MissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MissionGroupByOutputType[P]>
            : GetScalarType<T[P], MissionGroupByOutputType[P]>
        }
      >
    >


  export type MissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    status?: boolean
    estimatedMinutes?: boolean
    completedAt?: boolean
    actualMinutes?: boolean
    completedObjectivesCount?: boolean
    objectives?: boolean
    reviewCardCount?: boolean
    newContentCount?: boolean
    successScore?: boolean
    difficultyRating?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    studySessions?: boolean | Mission$studySessionsArgs<ExtArgs>
    feedback?: boolean | Mission$feedbackArgs<ExtArgs>
    interventions?: boolean | Mission$interventionsArgs<ExtArgs>
    _count?: boolean | MissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mission"]>

  export type MissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    status?: boolean
    estimatedMinutes?: boolean
    completedAt?: boolean
    actualMinutes?: boolean
    completedObjectivesCount?: boolean
    objectives?: boolean
    reviewCardCount?: boolean
    newContentCount?: boolean
    successScore?: boolean
    difficultyRating?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mission"]>

  export type MissionSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    status?: boolean
    estimatedMinutes?: boolean
    completedAt?: boolean
    actualMinutes?: boolean
    completedObjectivesCount?: boolean
    objectives?: boolean
    reviewCardCount?: boolean
    newContentCount?: boolean
    successScore?: boolean
    difficultyRating?: boolean
  }

  export type MissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    studySessions?: boolean | Mission$studySessionsArgs<ExtArgs>
    feedback?: boolean | Mission$feedbackArgs<ExtArgs>
    interventions?: boolean | Mission$interventionsArgs<ExtArgs>
    _count?: boolean | MissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mission"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      studySessions: Prisma.$StudySessionPayload<ExtArgs>[]
      feedback: Prisma.$MissionFeedbackPayload<ExtArgs>[]
      interventions: Prisma.$InterventionRecommendationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: Date
      status: $Enums.MissionStatus
      estimatedMinutes: number
      completedAt: Date | null
      actualMinutes: number | null
      completedObjectivesCount: number
      objectives: Prisma.JsonValue
      reviewCardCount: number
      newContentCount: number
      successScore: number | null
      difficultyRating: number | null
    }, ExtArgs["result"]["mission"]>
    composites: {}
  }

  type MissionGetPayload<S extends boolean | null | undefined | MissionDefaultArgs> = $Result.GetResult<Prisma.$MissionPayload, S>

  type MissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MissionCountAggregateInputType | true
    }

  export interface MissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mission'], meta: { name: 'Mission' } }
    /**
     * Find zero or one Mission that matches the filter.
     * @param {MissionFindUniqueArgs} args - Arguments to find a Mission
     * @example
     * // Get one Mission
     * const mission = await prisma.mission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MissionFindUniqueArgs>(args: SelectSubset<T, MissionFindUniqueArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Mission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MissionFindUniqueOrThrowArgs} args - Arguments to find a Mission
     * @example
     * // Get one Mission
     * const mission = await prisma.mission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MissionFindUniqueOrThrowArgs>(args: SelectSubset<T, MissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Mission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionFindFirstArgs} args - Arguments to find a Mission
     * @example
     * // Get one Mission
     * const mission = await prisma.mission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MissionFindFirstArgs>(args?: SelectSubset<T, MissionFindFirstArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Mission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionFindFirstOrThrowArgs} args - Arguments to find a Mission
     * @example
     * // Get one Mission
     * const mission = await prisma.mission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MissionFindFirstOrThrowArgs>(args?: SelectSubset<T, MissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Missions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Missions
     * const missions = await prisma.mission.findMany()
     * 
     * // Get first 10 Missions
     * const missions = await prisma.mission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const missionWithIdOnly = await prisma.mission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MissionFindManyArgs>(args?: SelectSubset<T, MissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Mission.
     * @param {MissionCreateArgs} args - Arguments to create a Mission.
     * @example
     * // Create one Mission
     * const Mission = await prisma.mission.create({
     *   data: {
     *     // ... data to create a Mission
     *   }
     * })
     * 
     */
    create<T extends MissionCreateArgs>(args: SelectSubset<T, MissionCreateArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Missions.
     * @param {MissionCreateManyArgs} args - Arguments to create many Missions.
     * @example
     * // Create many Missions
     * const mission = await prisma.mission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MissionCreateManyArgs>(args?: SelectSubset<T, MissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Missions and returns the data saved in the database.
     * @param {MissionCreateManyAndReturnArgs} args - Arguments to create many Missions.
     * @example
     * // Create many Missions
     * const mission = await prisma.mission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Missions and only return the `id`
     * const missionWithIdOnly = await prisma.mission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MissionCreateManyAndReturnArgs>(args?: SelectSubset<T, MissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Mission.
     * @param {MissionDeleteArgs} args - Arguments to delete one Mission.
     * @example
     * // Delete one Mission
     * const Mission = await prisma.mission.delete({
     *   where: {
     *     // ... filter to delete one Mission
     *   }
     * })
     * 
     */
    delete<T extends MissionDeleteArgs>(args: SelectSubset<T, MissionDeleteArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Mission.
     * @param {MissionUpdateArgs} args - Arguments to update one Mission.
     * @example
     * // Update one Mission
     * const mission = await prisma.mission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MissionUpdateArgs>(args: SelectSubset<T, MissionUpdateArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Missions.
     * @param {MissionDeleteManyArgs} args - Arguments to filter Missions to delete.
     * @example
     * // Delete a few Missions
     * const { count } = await prisma.mission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MissionDeleteManyArgs>(args?: SelectSubset<T, MissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Missions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Missions
     * const mission = await prisma.mission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MissionUpdateManyArgs>(args: SelectSubset<T, MissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mission.
     * @param {MissionUpsertArgs} args - Arguments to update or create a Mission.
     * @example
     * // Update or create a Mission
     * const mission = await prisma.mission.upsert({
     *   create: {
     *     // ... data to create a Mission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mission we want to update
     *   }
     * })
     */
    upsert<T extends MissionUpsertArgs>(args: SelectSubset<T, MissionUpsertArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Missions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionCountArgs} args - Arguments to filter Missions to count.
     * @example
     * // Count the number of Missions
     * const count = await prisma.mission.count({
     *   where: {
     *     // ... the filter for the Missions we want to count
     *   }
     * })
    **/
    count<T extends MissionCountArgs>(
      args?: Subset<T, MissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MissionAggregateArgs>(args: Subset<T, MissionAggregateArgs>): Prisma.PrismaPromise<GetMissionAggregateType<T>>

    /**
     * Group by Mission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MissionGroupByArgs['orderBy'] }
        : { orderBy?: MissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mission model
   */
  readonly fields: MissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    studySessions<T extends Mission$studySessionsArgs<ExtArgs> = {}>(args?: Subset<T, Mission$studySessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "findMany"> | Null>
    feedback<T extends Mission$feedbackArgs<ExtArgs> = {}>(args?: Subset<T, Mission$feedbackArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionFeedbackPayload<ExtArgs>, T, "findMany"> | Null>
    interventions<T extends Mission$interventionsArgs<ExtArgs> = {}>(args?: Subset<T, Mission$interventionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionRecommendationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mission model
   */ 
  interface MissionFieldRefs {
    readonly id: FieldRef<"Mission", 'String'>
    readonly userId: FieldRef<"Mission", 'String'>
    readonly date: FieldRef<"Mission", 'DateTime'>
    readonly status: FieldRef<"Mission", 'MissionStatus'>
    readonly estimatedMinutes: FieldRef<"Mission", 'Int'>
    readonly completedAt: FieldRef<"Mission", 'DateTime'>
    readonly actualMinutes: FieldRef<"Mission", 'Int'>
    readonly completedObjectivesCount: FieldRef<"Mission", 'Int'>
    readonly objectives: FieldRef<"Mission", 'Json'>
    readonly reviewCardCount: FieldRef<"Mission", 'Int'>
    readonly newContentCount: FieldRef<"Mission", 'Int'>
    readonly successScore: FieldRef<"Mission", 'Float'>
    readonly difficultyRating: FieldRef<"Mission", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Mission findUnique
   */
  export type MissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Mission to fetch.
     */
    where: MissionWhereUniqueInput
  }

  /**
   * Mission findUniqueOrThrow
   */
  export type MissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Mission to fetch.
     */
    where: MissionWhereUniqueInput
  }

  /**
   * Mission findFirst
   */
  export type MissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Mission to fetch.
     */
    where?: MissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Missions to fetch.
     */
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Missions.
     */
    cursor?: MissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Missions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Missions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Missions.
     */
    distinct?: MissionScalarFieldEnum | MissionScalarFieldEnum[]
  }

  /**
   * Mission findFirstOrThrow
   */
  export type MissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Mission to fetch.
     */
    where?: MissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Missions to fetch.
     */
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Missions.
     */
    cursor?: MissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Missions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Missions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Missions.
     */
    distinct?: MissionScalarFieldEnum | MissionScalarFieldEnum[]
  }

  /**
   * Mission findMany
   */
  export type MissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter, which Missions to fetch.
     */
    where?: MissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Missions to fetch.
     */
    orderBy?: MissionOrderByWithRelationInput | MissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Missions.
     */
    cursor?: MissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Missions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Missions.
     */
    skip?: number
    distinct?: MissionScalarFieldEnum | MissionScalarFieldEnum[]
  }

  /**
   * Mission create
   */
  export type MissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Mission.
     */
    data: XOR<MissionCreateInput, MissionUncheckedCreateInput>
  }

  /**
   * Mission createMany
   */
  export type MissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Missions.
     */
    data: MissionCreateManyInput | MissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mission createManyAndReturn
   */
  export type MissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Missions.
     */
    data: MissionCreateManyInput | MissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mission update
   */
  export type MissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Mission.
     */
    data: XOR<MissionUpdateInput, MissionUncheckedUpdateInput>
    /**
     * Choose, which Mission to update.
     */
    where: MissionWhereUniqueInput
  }

  /**
   * Mission updateMany
   */
  export type MissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Missions.
     */
    data: XOR<MissionUpdateManyMutationInput, MissionUncheckedUpdateManyInput>
    /**
     * Filter which Missions to update
     */
    where?: MissionWhereInput
  }

  /**
   * Mission upsert
   */
  export type MissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Mission to update in case it exists.
     */
    where: MissionWhereUniqueInput
    /**
     * In case the Mission found by the `where` argument doesn't exist, create a new Mission with this data.
     */
    create: XOR<MissionCreateInput, MissionUncheckedCreateInput>
    /**
     * In case the Mission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MissionUpdateInput, MissionUncheckedUpdateInput>
  }

  /**
   * Mission delete
   */
  export type MissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    /**
     * Filter which Mission to delete.
     */
    where: MissionWhereUniqueInput
  }

  /**
   * Mission deleteMany
   */
  export type MissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Missions to delete
     */
    where?: MissionWhereInput
  }

  /**
   * Mission.studySessions
   */
  export type Mission$studySessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    where?: StudySessionWhereInput
    orderBy?: StudySessionOrderByWithRelationInput | StudySessionOrderByWithRelationInput[]
    cursor?: StudySessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudySessionScalarFieldEnum | StudySessionScalarFieldEnum[]
  }

  /**
   * Mission.feedback
   */
  export type Mission$feedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionFeedback
     */
    select?: MissionFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionFeedbackInclude<ExtArgs> | null
    where?: MissionFeedbackWhereInput
    orderBy?: MissionFeedbackOrderByWithRelationInput | MissionFeedbackOrderByWithRelationInput[]
    cursor?: MissionFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MissionFeedbackScalarFieldEnum | MissionFeedbackScalarFieldEnum[]
  }

  /**
   * Mission.interventions
   */
  export type Mission$interventionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionRecommendation
     */
    select?: InterventionRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionRecommendationInclude<ExtArgs> | null
    where?: InterventionRecommendationWhereInput
    orderBy?: InterventionRecommendationOrderByWithRelationInput | InterventionRecommendationOrderByWithRelationInput[]
    cursor?: InterventionRecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterventionRecommendationScalarFieldEnum | InterventionRecommendationScalarFieldEnum[]
  }

  /**
   * Mission without action
   */
  export type MissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
  }


  /**
   * Model Card
   */

  export type AggregateCard = {
    _count: CardCountAggregateOutputType | null
    _avg: CardAvgAggregateOutputType | null
    _sum: CardSumAggregateOutputType | null
    _min: CardMinAggregateOutputType | null
    _max: CardMaxAggregateOutputType | null
  }

  export type CardAvgAggregateOutputType = {
    difficulty: number | null
    stability: number | null
    retrievability: number | null
    reviewCount: number | null
    lapseCount: number | null
  }

  export type CardSumAggregateOutputType = {
    difficulty: number | null
    stability: number | null
    retrievability: number | null
    reviewCount: number | null
    lapseCount: number | null
  }

  export type CardMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    lectureId: string | null
    objectiveId: string | null
    front: string | null
    back: string | null
    cardType: $Enums.CardType | null
    createdAt: Date | null
    difficulty: number | null
    stability: number | null
    retrievability: number | null
    lastReviewedAt: Date | null
    nextReviewAt: Date | null
    reviewCount: number | null
    lapseCount: number | null
  }

  export type CardMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    lectureId: string | null
    objectiveId: string | null
    front: string | null
    back: string | null
    cardType: $Enums.CardType | null
    createdAt: Date | null
    difficulty: number | null
    stability: number | null
    retrievability: number | null
    lastReviewedAt: Date | null
    nextReviewAt: Date | null
    reviewCount: number | null
    lapseCount: number | null
  }

  export type CardCountAggregateOutputType = {
    id: number
    courseId: number
    lectureId: number
    objectiveId: number
    front: number
    back: number
    cardType: number
    createdAt: number
    difficulty: number
    stability: number
    retrievability: number
    lastReviewedAt: number
    nextReviewAt: number
    reviewCount: number
    lapseCount: number
    _all: number
  }


  export type CardAvgAggregateInputType = {
    difficulty?: true
    stability?: true
    retrievability?: true
    reviewCount?: true
    lapseCount?: true
  }

  export type CardSumAggregateInputType = {
    difficulty?: true
    stability?: true
    retrievability?: true
    reviewCount?: true
    lapseCount?: true
  }

  export type CardMinAggregateInputType = {
    id?: true
    courseId?: true
    lectureId?: true
    objectiveId?: true
    front?: true
    back?: true
    cardType?: true
    createdAt?: true
    difficulty?: true
    stability?: true
    retrievability?: true
    lastReviewedAt?: true
    nextReviewAt?: true
    reviewCount?: true
    lapseCount?: true
  }

  export type CardMaxAggregateInputType = {
    id?: true
    courseId?: true
    lectureId?: true
    objectiveId?: true
    front?: true
    back?: true
    cardType?: true
    createdAt?: true
    difficulty?: true
    stability?: true
    retrievability?: true
    lastReviewedAt?: true
    nextReviewAt?: true
    reviewCount?: true
    lapseCount?: true
  }

  export type CardCountAggregateInputType = {
    id?: true
    courseId?: true
    lectureId?: true
    objectiveId?: true
    front?: true
    back?: true
    cardType?: true
    createdAt?: true
    difficulty?: true
    stability?: true
    retrievability?: true
    lastReviewedAt?: true
    nextReviewAt?: true
    reviewCount?: true
    lapseCount?: true
    _all?: true
  }

  export type CardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Card to aggregate.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cards
    **/
    _count?: true | CardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CardMaxAggregateInputType
  }

  export type GetCardAggregateType<T extends CardAggregateArgs> = {
        [P in keyof T & keyof AggregateCard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCard[P]>
      : GetScalarType<T[P], AggregateCard[P]>
  }




  export type CardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardWhereInput
    orderBy?: CardOrderByWithAggregationInput | CardOrderByWithAggregationInput[]
    by: CardScalarFieldEnum[] | CardScalarFieldEnum
    having?: CardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CardCountAggregateInputType | true
    _avg?: CardAvgAggregateInputType
    _sum?: CardSumAggregateInputType
    _min?: CardMinAggregateInputType
    _max?: CardMaxAggregateInputType
  }

  export type CardGroupByOutputType = {
    id: string
    courseId: string
    lectureId: string | null
    objectiveId: string | null
    front: string
    back: string
    cardType: $Enums.CardType
    createdAt: Date
    difficulty: number
    stability: number
    retrievability: number
    lastReviewedAt: Date | null
    nextReviewAt: Date | null
    reviewCount: number
    lapseCount: number
    _count: CardCountAggregateOutputType | null
    _avg: CardAvgAggregateOutputType | null
    _sum: CardSumAggregateOutputType | null
    _min: CardMinAggregateOutputType | null
    _max: CardMaxAggregateOutputType | null
  }

  type GetCardGroupByPayload<T extends CardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CardGroupByOutputType[P]>
            : GetScalarType<T[P], CardGroupByOutputType[P]>
        }
      >
    >


  export type CardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    lectureId?: boolean
    objectiveId?: boolean
    front?: boolean
    back?: boolean
    cardType?: boolean
    createdAt?: boolean
    difficulty?: boolean
    stability?: boolean
    retrievability?: boolean
    lastReviewedAt?: boolean
    nextReviewAt?: boolean
    reviewCount?: boolean
    lapseCount?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    lecture?: boolean | Card$lectureArgs<ExtArgs>
    objective?: boolean | Card$objectiveArgs<ExtArgs>
    reviews?: boolean | Card$reviewsArgs<ExtArgs>
    _count?: boolean | CardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["card"]>

  export type CardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    lectureId?: boolean
    objectiveId?: boolean
    front?: boolean
    back?: boolean
    cardType?: boolean
    createdAt?: boolean
    difficulty?: boolean
    stability?: boolean
    retrievability?: boolean
    lastReviewedAt?: boolean
    nextReviewAt?: boolean
    reviewCount?: boolean
    lapseCount?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
    lecture?: boolean | Card$lectureArgs<ExtArgs>
    objective?: boolean | Card$objectiveArgs<ExtArgs>
  }, ExtArgs["result"]["card"]>

  export type CardSelectScalar = {
    id?: boolean
    courseId?: boolean
    lectureId?: boolean
    objectiveId?: boolean
    front?: boolean
    back?: boolean
    cardType?: boolean
    createdAt?: boolean
    difficulty?: boolean
    stability?: boolean
    retrievability?: boolean
    lastReviewedAt?: boolean
    nextReviewAt?: boolean
    reviewCount?: boolean
    lapseCount?: boolean
  }

  export type CardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    lecture?: boolean | Card$lectureArgs<ExtArgs>
    objective?: boolean | Card$objectiveArgs<ExtArgs>
    reviews?: boolean | Card$reviewsArgs<ExtArgs>
    _count?: boolean | CardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
    lecture?: boolean | Card$lectureArgs<ExtArgs>
    objective?: boolean | Card$objectiveArgs<ExtArgs>
  }

  export type $CardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Card"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
      lecture: Prisma.$LecturePayload<ExtArgs> | null
      objective: Prisma.$LearningObjectivePayload<ExtArgs> | null
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      lectureId: string | null
      objectiveId: string | null
      front: string
      back: string
      cardType: $Enums.CardType
      createdAt: Date
      difficulty: number
      stability: number
      retrievability: number
      lastReviewedAt: Date | null
      nextReviewAt: Date | null
      reviewCount: number
      lapseCount: number
    }, ExtArgs["result"]["card"]>
    composites: {}
  }

  type CardGetPayload<S extends boolean | null | undefined | CardDefaultArgs> = $Result.GetResult<Prisma.$CardPayload, S>

  type CardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CardCountAggregateInputType | true
    }

  export interface CardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Card'], meta: { name: 'Card' } }
    /**
     * Find zero or one Card that matches the filter.
     * @param {CardFindUniqueArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CardFindUniqueArgs>(args: SelectSubset<T, CardFindUniqueArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Card that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CardFindUniqueOrThrowArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CardFindUniqueOrThrowArgs>(args: SelectSubset<T, CardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Card that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardFindFirstArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CardFindFirstArgs>(args?: SelectSubset<T, CardFindFirstArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Card that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardFindFirstOrThrowArgs} args - Arguments to find a Card
     * @example
     * // Get one Card
     * const card = await prisma.card.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CardFindFirstOrThrowArgs>(args?: SelectSubset<T, CardFindFirstOrThrowArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cards
     * const cards = await prisma.card.findMany()
     * 
     * // Get first 10 Cards
     * const cards = await prisma.card.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cardWithIdOnly = await prisma.card.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CardFindManyArgs>(args?: SelectSubset<T, CardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Card.
     * @param {CardCreateArgs} args - Arguments to create a Card.
     * @example
     * // Create one Card
     * const Card = await prisma.card.create({
     *   data: {
     *     // ... data to create a Card
     *   }
     * })
     * 
     */
    create<T extends CardCreateArgs>(args: SelectSubset<T, CardCreateArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cards.
     * @param {CardCreateManyArgs} args - Arguments to create many Cards.
     * @example
     * // Create many Cards
     * const card = await prisma.card.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CardCreateManyArgs>(args?: SelectSubset<T, CardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cards and returns the data saved in the database.
     * @param {CardCreateManyAndReturnArgs} args - Arguments to create many Cards.
     * @example
     * // Create many Cards
     * const card = await prisma.card.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cards and only return the `id`
     * const cardWithIdOnly = await prisma.card.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CardCreateManyAndReturnArgs>(args?: SelectSubset<T, CardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Card.
     * @param {CardDeleteArgs} args - Arguments to delete one Card.
     * @example
     * // Delete one Card
     * const Card = await prisma.card.delete({
     *   where: {
     *     // ... filter to delete one Card
     *   }
     * })
     * 
     */
    delete<T extends CardDeleteArgs>(args: SelectSubset<T, CardDeleteArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Card.
     * @param {CardUpdateArgs} args - Arguments to update one Card.
     * @example
     * // Update one Card
     * const card = await prisma.card.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CardUpdateArgs>(args: SelectSubset<T, CardUpdateArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cards.
     * @param {CardDeleteManyArgs} args - Arguments to filter Cards to delete.
     * @example
     * // Delete a few Cards
     * const { count } = await prisma.card.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CardDeleteManyArgs>(args?: SelectSubset<T, CardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cards
     * const card = await prisma.card.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CardUpdateManyArgs>(args: SelectSubset<T, CardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Card.
     * @param {CardUpsertArgs} args - Arguments to update or create a Card.
     * @example
     * // Update or create a Card
     * const card = await prisma.card.upsert({
     *   create: {
     *     // ... data to create a Card
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Card we want to update
     *   }
     * })
     */
    upsert<T extends CardUpsertArgs>(args: SelectSubset<T, CardUpsertArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardCountArgs} args - Arguments to filter Cards to count.
     * @example
     * // Count the number of Cards
     * const count = await prisma.card.count({
     *   where: {
     *     // ... the filter for the Cards we want to count
     *   }
     * })
    **/
    count<T extends CardCountArgs>(
      args?: Subset<T, CardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CardAggregateArgs>(args: Subset<T, CardAggregateArgs>): Prisma.PrismaPromise<GetCardAggregateType<T>>

    /**
     * Group by Card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CardGroupByArgs['orderBy'] }
        : { orderBy?: CardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Card model
   */
  readonly fields: CardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Card.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lecture<T extends Card$lectureArgs<ExtArgs> = {}>(args?: Subset<T, Card$lectureArgs<ExtArgs>>): Prisma__LectureClient<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    objective<T extends Card$objectiveArgs<ExtArgs> = {}>(args?: Subset<T, Card$objectiveArgs<ExtArgs>>): Prisma__LearningObjectiveClient<$Result.GetResult<Prisma.$LearningObjectivePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reviews<T extends Card$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Card$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Card model
   */ 
  interface CardFieldRefs {
    readonly id: FieldRef<"Card", 'String'>
    readonly courseId: FieldRef<"Card", 'String'>
    readonly lectureId: FieldRef<"Card", 'String'>
    readonly objectiveId: FieldRef<"Card", 'String'>
    readonly front: FieldRef<"Card", 'String'>
    readonly back: FieldRef<"Card", 'String'>
    readonly cardType: FieldRef<"Card", 'CardType'>
    readonly createdAt: FieldRef<"Card", 'DateTime'>
    readonly difficulty: FieldRef<"Card", 'Float'>
    readonly stability: FieldRef<"Card", 'Float'>
    readonly retrievability: FieldRef<"Card", 'Float'>
    readonly lastReviewedAt: FieldRef<"Card", 'DateTime'>
    readonly nextReviewAt: FieldRef<"Card", 'DateTime'>
    readonly reviewCount: FieldRef<"Card", 'Int'>
    readonly lapseCount: FieldRef<"Card", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Card findUnique
   */
  export type CardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card findUniqueOrThrow
   */
  export type CardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card findFirst
   */
  export type CardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cards.
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cards.
     */
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * Card findFirstOrThrow
   */
  export type CardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Card to fetch.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cards.
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cards.
     */
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * Card findMany
   */
  export type CardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter, which Cards to fetch.
     */
    where?: CardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cards to fetch.
     */
    orderBy?: CardOrderByWithRelationInput | CardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cards.
     */
    cursor?: CardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cards.
     */
    skip?: number
    distinct?: CardScalarFieldEnum | CardScalarFieldEnum[]
  }

  /**
   * Card create
   */
  export type CardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * The data needed to create a Card.
     */
    data: XOR<CardCreateInput, CardUncheckedCreateInput>
  }

  /**
   * Card createMany
   */
  export type CardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cards.
     */
    data: CardCreateManyInput | CardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Card createManyAndReturn
   */
  export type CardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Cards.
     */
    data: CardCreateManyInput | CardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Card update
   */
  export type CardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * The data needed to update a Card.
     */
    data: XOR<CardUpdateInput, CardUncheckedUpdateInput>
    /**
     * Choose, which Card to update.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card updateMany
   */
  export type CardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cards.
     */
    data: XOR<CardUpdateManyMutationInput, CardUncheckedUpdateManyInput>
    /**
     * Filter which Cards to update
     */
    where?: CardWhereInput
  }

  /**
   * Card upsert
   */
  export type CardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * The filter to search for the Card to update in case it exists.
     */
    where: CardWhereUniqueInput
    /**
     * In case the Card found by the `where` argument doesn't exist, create a new Card with this data.
     */
    create: XOR<CardCreateInput, CardUncheckedCreateInput>
    /**
     * In case the Card was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CardUpdateInput, CardUncheckedUpdateInput>
  }

  /**
   * Card delete
   */
  export type CardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
    /**
     * Filter which Card to delete.
     */
    where: CardWhereUniqueInput
  }

  /**
   * Card deleteMany
   */
  export type CardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cards to delete
     */
    where?: CardWhereInput
  }

  /**
   * Card.lecture
   */
  export type Card$lectureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
    where?: LectureWhereInput
  }

  /**
   * Card.objective
   */
  export type Card$objectiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningObjective
     */
    select?: LearningObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningObjectiveInclude<ExtArgs> | null
    where?: LearningObjectiveWhereInput
  }

  /**
   * Card.reviews
   */
  export type Card$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Card without action
   */
  export type CardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Card
     */
    select?: CardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CardInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    timeSpentMs: number | null
    difficultyBefore: number | null
    stabilityBefore: number | null
    difficultyAfter: number | null
    stabilityAfter: number | null
  }

  export type ReviewSumAggregateOutputType = {
    timeSpentMs: number | null
    difficultyBefore: number | null
    stabilityBefore: number | null
    difficultyAfter: number | null
    stabilityAfter: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    userId: string | null
    cardId: string | null
    sessionId: string | null
    rating: $Enums.ReviewRating | null
    timeSpentMs: number | null
    reviewedAt: Date | null
    difficultyBefore: number | null
    stabilityBefore: number | null
    difficultyAfter: number | null
    stabilityAfter: number | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    cardId: string | null
    sessionId: string | null
    rating: $Enums.ReviewRating | null
    timeSpentMs: number | null
    reviewedAt: Date | null
    difficultyBefore: number | null
    stabilityBefore: number | null
    difficultyAfter: number | null
    stabilityAfter: number | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    userId: number
    cardId: number
    sessionId: number
    rating: number
    timeSpentMs: number
    reviewedAt: number
    difficultyBefore: number
    stabilityBefore: number
    difficultyAfter: number
    stabilityAfter: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    timeSpentMs?: true
    difficultyBefore?: true
    stabilityBefore?: true
    difficultyAfter?: true
    stabilityAfter?: true
  }

  export type ReviewSumAggregateInputType = {
    timeSpentMs?: true
    difficultyBefore?: true
    stabilityBefore?: true
    difficultyAfter?: true
    stabilityAfter?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    userId?: true
    cardId?: true
    sessionId?: true
    rating?: true
    timeSpentMs?: true
    reviewedAt?: true
    difficultyBefore?: true
    stabilityBefore?: true
    difficultyAfter?: true
    stabilityAfter?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    userId?: true
    cardId?: true
    sessionId?: true
    rating?: true
    timeSpentMs?: true
    reviewedAt?: true
    difficultyBefore?: true
    stabilityBefore?: true
    difficultyAfter?: true
    stabilityAfter?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    userId?: true
    cardId?: true
    sessionId?: true
    rating?: true
    timeSpentMs?: true
    reviewedAt?: true
    difficultyBefore?: true
    stabilityBefore?: true
    difficultyAfter?: true
    stabilityAfter?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    userId: string
    cardId: string
    sessionId: string | null
    rating: $Enums.ReviewRating
    timeSpentMs: number
    reviewedAt: Date
    difficultyBefore: number
    stabilityBefore: number
    difficultyAfter: number
    stabilityAfter: number
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cardId?: boolean
    sessionId?: boolean
    rating?: boolean
    timeSpentMs?: boolean
    reviewedAt?: boolean
    difficultyBefore?: boolean
    stabilityBefore?: boolean
    difficultyAfter?: boolean
    stabilityAfter?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    card?: boolean | CardDefaultArgs<ExtArgs>
    session?: boolean | Review$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    cardId?: boolean
    sessionId?: boolean
    rating?: boolean
    timeSpentMs?: boolean
    reviewedAt?: boolean
    difficultyBefore?: boolean
    stabilityBefore?: boolean
    difficultyAfter?: boolean
    stabilityAfter?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    card?: boolean | CardDefaultArgs<ExtArgs>
    session?: boolean | Review$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    userId?: boolean
    cardId?: boolean
    sessionId?: boolean
    rating?: boolean
    timeSpentMs?: boolean
    reviewedAt?: boolean
    difficultyBefore?: boolean
    stabilityBefore?: boolean
    difficultyAfter?: boolean
    stabilityAfter?: boolean
  }

  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    card?: boolean | CardDefaultArgs<ExtArgs>
    session?: boolean | Review$sessionArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    card?: boolean | CardDefaultArgs<ExtArgs>
    session?: boolean | Review$sessionArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      card: Prisma.$CardPayload<ExtArgs>
      session: Prisma.$StudySessionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      cardId: string
      sessionId: string | null
      rating: $Enums.ReviewRating
      timeSpentMs: number
      reviewedAt: Date
      difficultyBefore: number
      stabilityBefore: number
      difficultyAfter: number
      stabilityAfter: number
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    card<T extends CardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CardDefaultArgs<ExtArgs>>): Prisma__CardClient<$Result.GetResult<Prisma.$CardPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    session<T extends Review$sessionArgs<ExtArgs> = {}>(args?: Subset<T, Review$sessionArgs<ExtArgs>>): Prisma__StudySessionClient<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */ 
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly userId: FieldRef<"Review", 'String'>
    readonly cardId: FieldRef<"Review", 'String'>
    readonly sessionId: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'ReviewRating'>
    readonly timeSpentMs: FieldRef<"Review", 'Int'>
    readonly reviewedAt: FieldRef<"Review", 'DateTime'>
    readonly difficultyBefore: FieldRef<"Review", 'Float'>
    readonly stabilityBefore: FieldRef<"Review", 'Float'>
    readonly difficultyAfter: FieldRef<"Review", 'Float'>
    readonly stabilityAfter: FieldRef<"Review", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
  }

  /**
   * Review.session
   */
  export type Review$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    where?: StudySessionWhereInput
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model StudySession
   */

  export type AggregateStudySession = {
    _count: StudySessionCountAggregateOutputType | null
    _avg: StudySessionAvgAggregateOutputType | null
    _sum: StudySessionSumAggregateOutputType | null
    _min: StudySessionMinAggregateOutputType | null
    _max: StudySessionMaxAggregateOutputType | null
  }

  export type StudySessionAvgAggregateOutputType = {
    durationMs: number | null
    reviewsCompleted: number | null
    newCardsStudied: number | null
    currentObjectiveIndex: number | null
  }

  export type StudySessionSumAggregateOutputType = {
    durationMs: number | null
    reviewsCompleted: number | null
    newCardsStudied: number | null
    currentObjectiveIndex: number | null
  }

  export type StudySessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    missionId: string | null
    startedAt: Date | null
    completedAt: Date | null
    durationMs: number | null
    reviewsCompleted: number | null
    newCardsStudied: number | null
    sessionNotes: string | null
    currentObjectiveIndex: number | null
  }

  export type StudySessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    missionId: string | null
    startedAt: Date | null
    completedAt: Date | null
    durationMs: number | null
    reviewsCompleted: number | null
    newCardsStudied: number | null
    sessionNotes: string | null
    currentObjectiveIndex: number | null
  }

  export type StudySessionCountAggregateOutputType = {
    id: number
    userId: number
    missionId: number
    startedAt: number
    completedAt: number
    durationMs: number
    reviewsCompleted: number
    newCardsStudied: number
    sessionNotes: number
    currentObjectiveIndex: number
    missionObjectives: number
    objectiveCompletions: number
    _all: number
  }


  export type StudySessionAvgAggregateInputType = {
    durationMs?: true
    reviewsCompleted?: true
    newCardsStudied?: true
    currentObjectiveIndex?: true
  }

  export type StudySessionSumAggregateInputType = {
    durationMs?: true
    reviewsCompleted?: true
    newCardsStudied?: true
    currentObjectiveIndex?: true
  }

  export type StudySessionMinAggregateInputType = {
    id?: true
    userId?: true
    missionId?: true
    startedAt?: true
    completedAt?: true
    durationMs?: true
    reviewsCompleted?: true
    newCardsStudied?: true
    sessionNotes?: true
    currentObjectiveIndex?: true
  }

  export type StudySessionMaxAggregateInputType = {
    id?: true
    userId?: true
    missionId?: true
    startedAt?: true
    completedAt?: true
    durationMs?: true
    reviewsCompleted?: true
    newCardsStudied?: true
    sessionNotes?: true
    currentObjectiveIndex?: true
  }

  export type StudySessionCountAggregateInputType = {
    id?: true
    userId?: true
    missionId?: true
    startedAt?: true
    completedAt?: true
    durationMs?: true
    reviewsCompleted?: true
    newCardsStudied?: true
    sessionNotes?: true
    currentObjectiveIndex?: true
    missionObjectives?: true
    objectiveCompletions?: true
    _all?: true
  }

  export type StudySessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudySession to aggregate.
     */
    where?: StudySessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudySessions to fetch.
     */
    orderBy?: StudySessionOrderByWithRelationInput | StudySessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudySessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudySessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudySessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudySessions
    **/
    _count?: true | StudySessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudySessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudySessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudySessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudySessionMaxAggregateInputType
  }

  export type GetStudySessionAggregateType<T extends StudySessionAggregateArgs> = {
        [P in keyof T & keyof AggregateStudySession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudySession[P]>
      : GetScalarType<T[P], AggregateStudySession[P]>
  }




  export type StudySessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudySessionWhereInput
    orderBy?: StudySessionOrderByWithAggregationInput | StudySessionOrderByWithAggregationInput[]
    by: StudySessionScalarFieldEnum[] | StudySessionScalarFieldEnum
    having?: StudySessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudySessionCountAggregateInputType | true
    _avg?: StudySessionAvgAggregateInputType
    _sum?: StudySessionSumAggregateInputType
    _min?: StudySessionMinAggregateInputType
    _max?: StudySessionMaxAggregateInputType
  }

  export type StudySessionGroupByOutputType = {
    id: string
    userId: string
    missionId: string | null
    startedAt: Date
    completedAt: Date | null
    durationMs: number | null
    reviewsCompleted: number
    newCardsStudied: number
    sessionNotes: string | null
    currentObjectiveIndex: number
    missionObjectives: JsonValue | null
    objectiveCompletions: JsonValue | null
    _count: StudySessionCountAggregateOutputType | null
    _avg: StudySessionAvgAggregateOutputType | null
    _sum: StudySessionSumAggregateOutputType | null
    _min: StudySessionMinAggregateOutputType | null
    _max: StudySessionMaxAggregateOutputType | null
  }

  type GetStudySessionGroupByPayload<T extends StudySessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudySessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudySessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudySessionGroupByOutputType[P]>
            : GetScalarType<T[P], StudySessionGroupByOutputType[P]>
        }
      >
    >


  export type StudySessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    missionId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    durationMs?: boolean
    reviewsCompleted?: boolean
    newCardsStudied?: boolean
    sessionNotes?: boolean
    currentObjectiveIndex?: boolean
    missionObjectives?: boolean
    objectiveCompletions?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    mission?: boolean | StudySession$missionArgs<ExtArgs>
    reviews?: boolean | StudySession$reviewsArgs<ExtArgs>
    validationResponses?: boolean | StudySession$validationResponsesArgs<ExtArgs>
    _count?: boolean | StudySessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studySession"]>

  export type StudySessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    missionId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    durationMs?: boolean
    reviewsCompleted?: boolean
    newCardsStudied?: boolean
    sessionNotes?: boolean
    currentObjectiveIndex?: boolean
    missionObjectives?: boolean
    objectiveCompletions?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    mission?: boolean | StudySession$missionArgs<ExtArgs>
  }, ExtArgs["result"]["studySession"]>

  export type StudySessionSelectScalar = {
    id?: boolean
    userId?: boolean
    missionId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    durationMs?: boolean
    reviewsCompleted?: boolean
    newCardsStudied?: boolean
    sessionNotes?: boolean
    currentObjectiveIndex?: boolean
    missionObjectives?: boolean
    objectiveCompletions?: boolean
  }

  export type StudySessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    mission?: boolean | StudySession$missionArgs<ExtArgs>
    reviews?: boolean | StudySession$reviewsArgs<ExtArgs>
    validationResponses?: boolean | StudySession$validationResponsesArgs<ExtArgs>
    _count?: boolean | StudySessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudySessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    mission?: boolean | StudySession$missionArgs<ExtArgs>
  }

  export type $StudySessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudySession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      mission: Prisma.$MissionPayload<ExtArgs> | null
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      validationResponses: Prisma.$ValidationResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      missionId: string | null
      startedAt: Date
      completedAt: Date | null
      durationMs: number | null
      reviewsCompleted: number
      newCardsStudied: number
      sessionNotes: string | null
      currentObjectiveIndex: number
      missionObjectives: Prisma.JsonValue | null
      objectiveCompletions: Prisma.JsonValue | null
    }, ExtArgs["result"]["studySession"]>
    composites: {}
  }

  type StudySessionGetPayload<S extends boolean | null | undefined | StudySessionDefaultArgs> = $Result.GetResult<Prisma.$StudySessionPayload, S>

  type StudySessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudySessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudySessionCountAggregateInputType | true
    }

  export interface StudySessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudySession'], meta: { name: 'StudySession' } }
    /**
     * Find zero or one StudySession that matches the filter.
     * @param {StudySessionFindUniqueArgs} args - Arguments to find a StudySession
     * @example
     * // Get one StudySession
     * const studySession = await prisma.studySession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudySessionFindUniqueArgs>(args: SelectSubset<T, StudySessionFindUniqueArgs<ExtArgs>>): Prisma__StudySessionClient<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudySession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudySessionFindUniqueOrThrowArgs} args - Arguments to find a StudySession
     * @example
     * // Get one StudySession
     * const studySession = await prisma.studySession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudySessionFindUniqueOrThrowArgs>(args: SelectSubset<T, StudySessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudySessionClient<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudySession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudySessionFindFirstArgs} args - Arguments to find a StudySession
     * @example
     * // Get one StudySession
     * const studySession = await prisma.studySession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudySessionFindFirstArgs>(args?: SelectSubset<T, StudySessionFindFirstArgs<ExtArgs>>): Prisma__StudySessionClient<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudySession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudySessionFindFirstOrThrowArgs} args - Arguments to find a StudySession
     * @example
     * // Get one StudySession
     * const studySession = await prisma.studySession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudySessionFindFirstOrThrowArgs>(args?: SelectSubset<T, StudySessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudySessionClient<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudySessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudySessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudySessions
     * const studySessions = await prisma.studySession.findMany()
     * 
     * // Get first 10 StudySessions
     * const studySessions = await prisma.studySession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studySessionWithIdOnly = await prisma.studySession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudySessionFindManyArgs>(args?: SelectSubset<T, StudySessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudySession.
     * @param {StudySessionCreateArgs} args - Arguments to create a StudySession.
     * @example
     * // Create one StudySession
     * const StudySession = await prisma.studySession.create({
     *   data: {
     *     // ... data to create a StudySession
     *   }
     * })
     * 
     */
    create<T extends StudySessionCreateArgs>(args: SelectSubset<T, StudySessionCreateArgs<ExtArgs>>): Prisma__StudySessionClient<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudySessions.
     * @param {StudySessionCreateManyArgs} args - Arguments to create many StudySessions.
     * @example
     * // Create many StudySessions
     * const studySession = await prisma.studySession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudySessionCreateManyArgs>(args?: SelectSubset<T, StudySessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudySessions and returns the data saved in the database.
     * @param {StudySessionCreateManyAndReturnArgs} args - Arguments to create many StudySessions.
     * @example
     * // Create many StudySessions
     * const studySession = await prisma.studySession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudySessions and only return the `id`
     * const studySessionWithIdOnly = await prisma.studySession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudySessionCreateManyAndReturnArgs>(args?: SelectSubset<T, StudySessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudySession.
     * @param {StudySessionDeleteArgs} args - Arguments to delete one StudySession.
     * @example
     * // Delete one StudySession
     * const StudySession = await prisma.studySession.delete({
     *   where: {
     *     // ... filter to delete one StudySession
     *   }
     * })
     * 
     */
    delete<T extends StudySessionDeleteArgs>(args: SelectSubset<T, StudySessionDeleteArgs<ExtArgs>>): Prisma__StudySessionClient<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudySession.
     * @param {StudySessionUpdateArgs} args - Arguments to update one StudySession.
     * @example
     * // Update one StudySession
     * const studySession = await prisma.studySession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudySessionUpdateArgs>(args: SelectSubset<T, StudySessionUpdateArgs<ExtArgs>>): Prisma__StudySessionClient<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudySessions.
     * @param {StudySessionDeleteManyArgs} args - Arguments to filter StudySessions to delete.
     * @example
     * // Delete a few StudySessions
     * const { count } = await prisma.studySession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudySessionDeleteManyArgs>(args?: SelectSubset<T, StudySessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudySessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudySessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudySessions
     * const studySession = await prisma.studySession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudySessionUpdateManyArgs>(args: SelectSubset<T, StudySessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudySession.
     * @param {StudySessionUpsertArgs} args - Arguments to update or create a StudySession.
     * @example
     * // Update or create a StudySession
     * const studySession = await prisma.studySession.upsert({
     *   create: {
     *     // ... data to create a StudySession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudySession we want to update
     *   }
     * })
     */
    upsert<T extends StudySessionUpsertArgs>(args: SelectSubset<T, StudySessionUpsertArgs<ExtArgs>>): Prisma__StudySessionClient<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudySessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudySessionCountArgs} args - Arguments to filter StudySessions to count.
     * @example
     * // Count the number of StudySessions
     * const count = await prisma.studySession.count({
     *   where: {
     *     // ... the filter for the StudySessions we want to count
     *   }
     * })
    **/
    count<T extends StudySessionCountArgs>(
      args?: Subset<T, StudySessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudySessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudySession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudySessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudySessionAggregateArgs>(args: Subset<T, StudySessionAggregateArgs>): Prisma.PrismaPromise<GetStudySessionAggregateType<T>>

    /**
     * Group by StudySession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudySessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudySessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudySessionGroupByArgs['orderBy'] }
        : { orderBy?: StudySessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudySessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudySessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudySession model
   */
  readonly fields: StudySessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudySession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudySessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    mission<T extends StudySession$missionArgs<ExtArgs> = {}>(args?: Subset<T, StudySession$missionArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reviews<T extends StudySession$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, StudySession$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany"> | Null>
    validationResponses<T extends StudySession$validationResponsesArgs<ExtArgs> = {}>(args?: Subset<T, StudySession$validationResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ValidationResponsePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudySession model
   */ 
  interface StudySessionFieldRefs {
    readonly id: FieldRef<"StudySession", 'String'>
    readonly userId: FieldRef<"StudySession", 'String'>
    readonly missionId: FieldRef<"StudySession", 'String'>
    readonly startedAt: FieldRef<"StudySession", 'DateTime'>
    readonly completedAt: FieldRef<"StudySession", 'DateTime'>
    readonly durationMs: FieldRef<"StudySession", 'Int'>
    readonly reviewsCompleted: FieldRef<"StudySession", 'Int'>
    readonly newCardsStudied: FieldRef<"StudySession", 'Int'>
    readonly sessionNotes: FieldRef<"StudySession", 'String'>
    readonly currentObjectiveIndex: FieldRef<"StudySession", 'Int'>
    readonly missionObjectives: FieldRef<"StudySession", 'Json'>
    readonly objectiveCompletions: FieldRef<"StudySession", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * StudySession findUnique
   */
  export type StudySessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    /**
     * Filter, which StudySession to fetch.
     */
    where: StudySessionWhereUniqueInput
  }

  /**
   * StudySession findUniqueOrThrow
   */
  export type StudySessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    /**
     * Filter, which StudySession to fetch.
     */
    where: StudySessionWhereUniqueInput
  }

  /**
   * StudySession findFirst
   */
  export type StudySessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    /**
     * Filter, which StudySession to fetch.
     */
    where?: StudySessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudySessions to fetch.
     */
    orderBy?: StudySessionOrderByWithRelationInput | StudySessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudySessions.
     */
    cursor?: StudySessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudySessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudySessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudySessions.
     */
    distinct?: StudySessionScalarFieldEnum | StudySessionScalarFieldEnum[]
  }

  /**
   * StudySession findFirstOrThrow
   */
  export type StudySessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    /**
     * Filter, which StudySession to fetch.
     */
    where?: StudySessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudySessions to fetch.
     */
    orderBy?: StudySessionOrderByWithRelationInput | StudySessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudySessions.
     */
    cursor?: StudySessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudySessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudySessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudySessions.
     */
    distinct?: StudySessionScalarFieldEnum | StudySessionScalarFieldEnum[]
  }

  /**
   * StudySession findMany
   */
  export type StudySessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    /**
     * Filter, which StudySessions to fetch.
     */
    where?: StudySessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudySessions to fetch.
     */
    orderBy?: StudySessionOrderByWithRelationInput | StudySessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudySessions.
     */
    cursor?: StudySessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudySessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudySessions.
     */
    skip?: number
    distinct?: StudySessionScalarFieldEnum | StudySessionScalarFieldEnum[]
  }

  /**
   * StudySession create
   */
  export type StudySessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    /**
     * The data needed to create a StudySession.
     */
    data: XOR<StudySessionCreateInput, StudySessionUncheckedCreateInput>
  }

  /**
   * StudySession createMany
   */
  export type StudySessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudySessions.
     */
    data: StudySessionCreateManyInput | StudySessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudySession createManyAndReturn
   */
  export type StudySessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudySessions.
     */
    data: StudySessionCreateManyInput | StudySessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudySession update
   */
  export type StudySessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    /**
     * The data needed to update a StudySession.
     */
    data: XOR<StudySessionUpdateInput, StudySessionUncheckedUpdateInput>
    /**
     * Choose, which StudySession to update.
     */
    where: StudySessionWhereUniqueInput
  }

  /**
   * StudySession updateMany
   */
  export type StudySessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudySessions.
     */
    data: XOR<StudySessionUpdateManyMutationInput, StudySessionUncheckedUpdateManyInput>
    /**
     * Filter which StudySessions to update
     */
    where?: StudySessionWhereInput
  }

  /**
   * StudySession upsert
   */
  export type StudySessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    /**
     * The filter to search for the StudySession to update in case it exists.
     */
    where: StudySessionWhereUniqueInput
    /**
     * In case the StudySession found by the `where` argument doesn't exist, create a new StudySession with this data.
     */
    create: XOR<StudySessionCreateInput, StudySessionUncheckedCreateInput>
    /**
     * In case the StudySession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudySessionUpdateInput, StudySessionUncheckedUpdateInput>
  }

  /**
   * StudySession delete
   */
  export type StudySessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    /**
     * Filter which StudySession to delete.
     */
    where: StudySessionWhereUniqueInput
  }

  /**
   * StudySession deleteMany
   */
  export type StudySessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudySessions to delete
     */
    where?: StudySessionWhereInput
  }

  /**
   * StudySession.mission
   */
  export type StudySession$missionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    where?: MissionWhereInput
  }

  /**
   * StudySession.reviews
   */
  export type StudySession$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * StudySession.validationResponses
   */
  export type StudySession$validationResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationResponse
     */
    select?: ValidationResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationResponseInclude<ExtArgs> | null
    where?: ValidationResponseWhereInput
    orderBy?: ValidationResponseOrderByWithRelationInput | ValidationResponseOrderByWithRelationInput[]
    cursor?: ValidationResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ValidationResponseScalarFieldEnum | ValidationResponseScalarFieldEnum[]
  }

  /**
   * StudySession without action
   */
  export type StudySessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
  }


  /**
   * Model Concept
   */

  export type AggregateConcept = {
    _count: ConceptCountAggregateOutputType | null
    _min: ConceptMinAggregateOutputType | null
    _max: ConceptMaxAggregateOutputType | null
  }

  export type ConceptMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
  }

  export type ConceptMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
  }

  export type ConceptCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    createdAt: number
    _all: number
  }


  export type ConceptMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    createdAt?: true
  }

  export type ConceptMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    createdAt?: true
  }

  export type ConceptCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    createdAt?: true
    _all?: true
  }

  export type ConceptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Concept to aggregate.
     */
    where?: ConceptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Concepts to fetch.
     */
    orderBy?: ConceptOrderByWithRelationInput | ConceptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConceptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Concepts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Concepts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Concepts
    **/
    _count?: true | ConceptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConceptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConceptMaxAggregateInputType
  }

  export type GetConceptAggregateType<T extends ConceptAggregateArgs> = {
        [P in keyof T & keyof AggregateConcept]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConcept[P]>
      : GetScalarType<T[P], AggregateConcept[P]>
  }




  export type ConceptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptWhereInput
    orderBy?: ConceptOrderByWithAggregationInput | ConceptOrderByWithAggregationInput[]
    by: ConceptScalarFieldEnum[] | ConceptScalarFieldEnum
    having?: ConceptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConceptCountAggregateInputType | true
    _min?: ConceptMinAggregateInputType
    _max?: ConceptMaxAggregateInputType
  }

  export type ConceptGroupByOutputType = {
    id: string
    name: string
    description: string | null
    category: string | null
    createdAt: Date
    _count: ConceptCountAggregateOutputType | null
    _min: ConceptMinAggregateOutputType | null
    _max: ConceptMaxAggregateOutputType | null
  }

  type GetConceptGroupByPayload<T extends ConceptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConceptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConceptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConceptGroupByOutputType[P]>
            : GetScalarType<T[P], ConceptGroupByOutputType[P]>
        }
      >
    >


  export type ConceptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    relatedFrom?: boolean | Concept$relatedFromArgs<ExtArgs>
    relatedTo?: boolean | Concept$relatedToArgs<ExtArgs>
    _count?: boolean | ConceptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["concept"]>

  export type ConceptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["concept"]>

  export type ConceptSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
  }

  export type ConceptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relatedFrom?: boolean | Concept$relatedFromArgs<ExtArgs>
    relatedTo?: boolean | Concept$relatedToArgs<ExtArgs>
    _count?: boolean | ConceptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConceptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ConceptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Concept"
    objects: {
      relatedFrom: Prisma.$ConceptRelationshipPayload<ExtArgs>[]
      relatedTo: Prisma.$ConceptRelationshipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      category: string | null
      createdAt: Date
    }, ExtArgs["result"]["concept"]>
    composites: {}
  }

  type ConceptGetPayload<S extends boolean | null | undefined | ConceptDefaultArgs> = $Result.GetResult<Prisma.$ConceptPayload, S>

  type ConceptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConceptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConceptCountAggregateInputType | true
    }

  export interface ConceptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Concept'], meta: { name: 'Concept' } }
    /**
     * Find zero or one Concept that matches the filter.
     * @param {ConceptFindUniqueArgs} args - Arguments to find a Concept
     * @example
     * // Get one Concept
     * const concept = await prisma.concept.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConceptFindUniqueArgs>(args: SelectSubset<T, ConceptFindUniqueArgs<ExtArgs>>): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Concept that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConceptFindUniqueOrThrowArgs} args - Arguments to find a Concept
     * @example
     * // Get one Concept
     * const concept = await prisma.concept.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConceptFindUniqueOrThrowArgs>(args: SelectSubset<T, ConceptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Concept that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptFindFirstArgs} args - Arguments to find a Concept
     * @example
     * // Get one Concept
     * const concept = await prisma.concept.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConceptFindFirstArgs>(args?: SelectSubset<T, ConceptFindFirstArgs<ExtArgs>>): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Concept that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptFindFirstOrThrowArgs} args - Arguments to find a Concept
     * @example
     * // Get one Concept
     * const concept = await prisma.concept.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConceptFindFirstOrThrowArgs>(args?: SelectSubset<T, ConceptFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Concepts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Concepts
     * const concepts = await prisma.concept.findMany()
     * 
     * // Get first 10 Concepts
     * const concepts = await prisma.concept.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conceptWithIdOnly = await prisma.concept.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConceptFindManyArgs>(args?: SelectSubset<T, ConceptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Concept.
     * @param {ConceptCreateArgs} args - Arguments to create a Concept.
     * @example
     * // Create one Concept
     * const Concept = await prisma.concept.create({
     *   data: {
     *     // ... data to create a Concept
     *   }
     * })
     * 
     */
    create<T extends ConceptCreateArgs>(args: SelectSubset<T, ConceptCreateArgs<ExtArgs>>): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Concepts.
     * @param {ConceptCreateManyArgs} args - Arguments to create many Concepts.
     * @example
     * // Create many Concepts
     * const concept = await prisma.concept.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConceptCreateManyArgs>(args?: SelectSubset<T, ConceptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Concepts and returns the data saved in the database.
     * @param {ConceptCreateManyAndReturnArgs} args - Arguments to create many Concepts.
     * @example
     * // Create many Concepts
     * const concept = await prisma.concept.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Concepts and only return the `id`
     * const conceptWithIdOnly = await prisma.concept.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConceptCreateManyAndReturnArgs>(args?: SelectSubset<T, ConceptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Concept.
     * @param {ConceptDeleteArgs} args - Arguments to delete one Concept.
     * @example
     * // Delete one Concept
     * const Concept = await prisma.concept.delete({
     *   where: {
     *     // ... filter to delete one Concept
     *   }
     * })
     * 
     */
    delete<T extends ConceptDeleteArgs>(args: SelectSubset<T, ConceptDeleteArgs<ExtArgs>>): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Concept.
     * @param {ConceptUpdateArgs} args - Arguments to update one Concept.
     * @example
     * // Update one Concept
     * const concept = await prisma.concept.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConceptUpdateArgs>(args: SelectSubset<T, ConceptUpdateArgs<ExtArgs>>): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Concepts.
     * @param {ConceptDeleteManyArgs} args - Arguments to filter Concepts to delete.
     * @example
     * // Delete a few Concepts
     * const { count } = await prisma.concept.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConceptDeleteManyArgs>(args?: SelectSubset<T, ConceptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Concepts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Concepts
     * const concept = await prisma.concept.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConceptUpdateManyArgs>(args: SelectSubset<T, ConceptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Concept.
     * @param {ConceptUpsertArgs} args - Arguments to update or create a Concept.
     * @example
     * // Update or create a Concept
     * const concept = await prisma.concept.upsert({
     *   create: {
     *     // ... data to create a Concept
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Concept we want to update
     *   }
     * })
     */
    upsert<T extends ConceptUpsertArgs>(args: SelectSubset<T, ConceptUpsertArgs<ExtArgs>>): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Concepts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptCountArgs} args - Arguments to filter Concepts to count.
     * @example
     * // Count the number of Concepts
     * const count = await prisma.concept.count({
     *   where: {
     *     // ... the filter for the Concepts we want to count
     *   }
     * })
    **/
    count<T extends ConceptCountArgs>(
      args?: Subset<T, ConceptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConceptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Concept.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConceptAggregateArgs>(args: Subset<T, ConceptAggregateArgs>): Prisma.PrismaPromise<GetConceptAggregateType<T>>

    /**
     * Group by Concept.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConceptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConceptGroupByArgs['orderBy'] }
        : { orderBy?: ConceptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConceptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConceptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Concept model
   */
  readonly fields: ConceptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Concept.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConceptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    relatedFrom<T extends Concept$relatedFromArgs<ExtArgs> = {}>(args?: Subset<T, Concept$relatedFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptRelationshipPayload<ExtArgs>, T, "findMany"> | Null>
    relatedTo<T extends Concept$relatedToArgs<ExtArgs> = {}>(args?: Subset<T, Concept$relatedToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptRelationshipPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Concept model
   */ 
  interface ConceptFieldRefs {
    readonly id: FieldRef<"Concept", 'String'>
    readonly name: FieldRef<"Concept", 'String'>
    readonly description: FieldRef<"Concept", 'String'>
    readonly category: FieldRef<"Concept", 'String'>
    readonly createdAt: FieldRef<"Concept", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Concept findUnique
   */
  export type ConceptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
    /**
     * Filter, which Concept to fetch.
     */
    where: ConceptWhereUniqueInput
  }

  /**
   * Concept findUniqueOrThrow
   */
  export type ConceptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
    /**
     * Filter, which Concept to fetch.
     */
    where: ConceptWhereUniqueInput
  }

  /**
   * Concept findFirst
   */
  export type ConceptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
    /**
     * Filter, which Concept to fetch.
     */
    where?: ConceptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Concepts to fetch.
     */
    orderBy?: ConceptOrderByWithRelationInput | ConceptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Concepts.
     */
    cursor?: ConceptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Concepts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Concepts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Concepts.
     */
    distinct?: ConceptScalarFieldEnum | ConceptScalarFieldEnum[]
  }

  /**
   * Concept findFirstOrThrow
   */
  export type ConceptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
    /**
     * Filter, which Concept to fetch.
     */
    where?: ConceptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Concepts to fetch.
     */
    orderBy?: ConceptOrderByWithRelationInput | ConceptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Concepts.
     */
    cursor?: ConceptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Concepts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Concepts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Concepts.
     */
    distinct?: ConceptScalarFieldEnum | ConceptScalarFieldEnum[]
  }

  /**
   * Concept findMany
   */
  export type ConceptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
    /**
     * Filter, which Concepts to fetch.
     */
    where?: ConceptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Concepts to fetch.
     */
    orderBy?: ConceptOrderByWithRelationInput | ConceptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Concepts.
     */
    cursor?: ConceptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Concepts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Concepts.
     */
    skip?: number
    distinct?: ConceptScalarFieldEnum | ConceptScalarFieldEnum[]
  }

  /**
   * Concept create
   */
  export type ConceptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
    /**
     * The data needed to create a Concept.
     */
    data: XOR<ConceptCreateInput, ConceptUncheckedCreateInput>
  }

  /**
   * Concept createMany
   */
  export type ConceptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Concepts.
     */
    data: ConceptCreateManyInput | ConceptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Concept createManyAndReturn
   */
  export type ConceptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Concepts.
     */
    data: ConceptCreateManyInput | ConceptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Concept update
   */
  export type ConceptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
    /**
     * The data needed to update a Concept.
     */
    data: XOR<ConceptUpdateInput, ConceptUncheckedUpdateInput>
    /**
     * Choose, which Concept to update.
     */
    where: ConceptWhereUniqueInput
  }

  /**
   * Concept updateMany
   */
  export type ConceptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Concepts.
     */
    data: XOR<ConceptUpdateManyMutationInput, ConceptUncheckedUpdateManyInput>
    /**
     * Filter which Concepts to update
     */
    where?: ConceptWhereInput
  }

  /**
   * Concept upsert
   */
  export type ConceptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
    /**
     * The filter to search for the Concept to update in case it exists.
     */
    where: ConceptWhereUniqueInput
    /**
     * In case the Concept found by the `where` argument doesn't exist, create a new Concept with this data.
     */
    create: XOR<ConceptCreateInput, ConceptUncheckedCreateInput>
    /**
     * In case the Concept was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConceptUpdateInput, ConceptUncheckedUpdateInput>
  }

  /**
   * Concept delete
   */
  export type ConceptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
    /**
     * Filter which Concept to delete.
     */
    where: ConceptWhereUniqueInput
  }

  /**
   * Concept deleteMany
   */
  export type ConceptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Concepts to delete
     */
    where?: ConceptWhereInput
  }

  /**
   * Concept.relatedFrom
   */
  export type Concept$relatedFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptRelationship
     */
    select?: ConceptRelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptRelationshipInclude<ExtArgs> | null
    where?: ConceptRelationshipWhereInput
    orderBy?: ConceptRelationshipOrderByWithRelationInput | ConceptRelationshipOrderByWithRelationInput[]
    cursor?: ConceptRelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConceptRelationshipScalarFieldEnum | ConceptRelationshipScalarFieldEnum[]
  }

  /**
   * Concept.relatedTo
   */
  export type Concept$relatedToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptRelationship
     */
    select?: ConceptRelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptRelationshipInclude<ExtArgs> | null
    where?: ConceptRelationshipWhereInput
    orderBy?: ConceptRelationshipOrderByWithRelationInput | ConceptRelationshipOrderByWithRelationInput[]
    cursor?: ConceptRelationshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConceptRelationshipScalarFieldEnum | ConceptRelationshipScalarFieldEnum[]
  }

  /**
   * Concept without action
   */
  export type ConceptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Concept
     */
    select?: ConceptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptInclude<ExtArgs> | null
  }


  /**
   * Model ConceptRelationship
   */

  export type AggregateConceptRelationship = {
    _count: ConceptRelationshipCountAggregateOutputType | null
    _avg: ConceptRelationshipAvgAggregateOutputType | null
    _sum: ConceptRelationshipSumAggregateOutputType | null
    _min: ConceptRelationshipMinAggregateOutputType | null
    _max: ConceptRelationshipMaxAggregateOutputType | null
  }

  export type ConceptRelationshipAvgAggregateOutputType = {
    strength: number | null
  }

  export type ConceptRelationshipSumAggregateOutputType = {
    strength: number | null
  }

  export type ConceptRelationshipMinAggregateOutputType = {
    id: string | null
    fromConceptId: string | null
    toConceptId: string | null
    relationship: $Enums.RelationshipType | null
    strength: number | null
    createdAt: Date | null
  }

  export type ConceptRelationshipMaxAggregateOutputType = {
    id: string | null
    fromConceptId: string | null
    toConceptId: string | null
    relationship: $Enums.RelationshipType | null
    strength: number | null
    createdAt: Date | null
  }

  export type ConceptRelationshipCountAggregateOutputType = {
    id: number
    fromConceptId: number
    toConceptId: number
    relationship: number
    strength: number
    createdAt: number
    _all: number
  }


  export type ConceptRelationshipAvgAggregateInputType = {
    strength?: true
  }

  export type ConceptRelationshipSumAggregateInputType = {
    strength?: true
  }

  export type ConceptRelationshipMinAggregateInputType = {
    id?: true
    fromConceptId?: true
    toConceptId?: true
    relationship?: true
    strength?: true
    createdAt?: true
  }

  export type ConceptRelationshipMaxAggregateInputType = {
    id?: true
    fromConceptId?: true
    toConceptId?: true
    relationship?: true
    strength?: true
    createdAt?: true
  }

  export type ConceptRelationshipCountAggregateInputType = {
    id?: true
    fromConceptId?: true
    toConceptId?: true
    relationship?: true
    strength?: true
    createdAt?: true
    _all?: true
  }

  export type ConceptRelationshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConceptRelationship to aggregate.
     */
    where?: ConceptRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptRelationships to fetch.
     */
    orderBy?: ConceptRelationshipOrderByWithRelationInput | ConceptRelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConceptRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptRelationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConceptRelationships
    **/
    _count?: true | ConceptRelationshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConceptRelationshipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConceptRelationshipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConceptRelationshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConceptRelationshipMaxAggregateInputType
  }

  export type GetConceptRelationshipAggregateType<T extends ConceptRelationshipAggregateArgs> = {
        [P in keyof T & keyof AggregateConceptRelationship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConceptRelationship[P]>
      : GetScalarType<T[P], AggregateConceptRelationship[P]>
  }




  export type ConceptRelationshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConceptRelationshipWhereInput
    orderBy?: ConceptRelationshipOrderByWithAggregationInput | ConceptRelationshipOrderByWithAggregationInput[]
    by: ConceptRelationshipScalarFieldEnum[] | ConceptRelationshipScalarFieldEnum
    having?: ConceptRelationshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConceptRelationshipCountAggregateInputType | true
    _avg?: ConceptRelationshipAvgAggregateInputType
    _sum?: ConceptRelationshipSumAggregateInputType
    _min?: ConceptRelationshipMinAggregateInputType
    _max?: ConceptRelationshipMaxAggregateInputType
  }

  export type ConceptRelationshipGroupByOutputType = {
    id: string
    fromConceptId: string
    toConceptId: string
    relationship: $Enums.RelationshipType
    strength: number
    createdAt: Date
    _count: ConceptRelationshipCountAggregateOutputType | null
    _avg: ConceptRelationshipAvgAggregateOutputType | null
    _sum: ConceptRelationshipSumAggregateOutputType | null
    _min: ConceptRelationshipMinAggregateOutputType | null
    _max: ConceptRelationshipMaxAggregateOutputType | null
  }

  type GetConceptRelationshipGroupByPayload<T extends ConceptRelationshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConceptRelationshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConceptRelationshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConceptRelationshipGroupByOutputType[P]>
            : GetScalarType<T[P], ConceptRelationshipGroupByOutputType[P]>
        }
      >
    >


  export type ConceptRelationshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromConceptId?: boolean
    toConceptId?: boolean
    relationship?: boolean
    strength?: boolean
    createdAt?: boolean
    fromConcept?: boolean | ConceptDefaultArgs<ExtArgs>
    toConcept?: boolean | ConceptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conceptRelationship"]>

  export type ConceptRelationshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromConceptId?: boolean
    toConceptId?: boolean
    relationship?: boolean
    strength?: boolean
    createdAt?: boolean
    fromConcept?: boolean | ConceptDefaultArgs<ExtArgs>
    toConcept?: boolean | ConceptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conceptRelationship"]>

  export type ConceptRelationshipSelectScalar = {
    id?: boolean
    fromConceptId?: boolean
    toConceptId?: boolean
    relationship?: boolean
    strength?: boolean
    createdAt?: boolean
  }

  export type ConceptRelationshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromConcept?: boolean | ConceptDefaultArgs<ExtArgs>
    toConcept?: boolean | ConceptDefaultArgs<ExtArgs>
  }
  export type ConceptRelationshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromConcept?: boolean | ConceptDefaultArgs<ExtArgs>
    toConcept?: boolean | ConceptDefaultArgs<ExtArgs>
  }

  export type $ConceptRelationshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConceptRelationship"
    objects: {
      fromConcept: Prisma.$ConceptPayload<ExtArgs>
      toConcept: Prisma.$ConceptPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fromConceptId: string
      toConceptId: string
      relationship: $Enums.RelationshipType
      strength: number
      createdAt: Date
    }, ExtArgs["result"]["conceptRelationship"]>
    composites: {}
  }

  type ConceptRelationshipGetPayload<S extends boolean | null | undefined | ConceptRelationshipDefaultArgs> = $Result.GetResult<Prisma.$ConceptRelationshipPayload, S>

  type ConceptRelationshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConceptRelationshipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConceptRelationshipCountAggregateInputType | true
    }

  export interface ConceptRelationshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConceptRelationship'], meta: { name: 'ConceptRelationship' } }
    /**
     * Find zero or one ConceptRelationship that matches the filter.
     * @param {ConceptRelationshipFindUniqueArgs} args - Arguments to find a ConceptRelationship
     * @example
     * // Get one ConceptRelationship
     * const conceptRelationship = await prisma.conceptRelationship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConceptRelationshipFindUniqueArgs>(args: SelectSubset<T, ConceptRelationshipFindUniqueArgs<ExtArgs>>): Prisma__ConceptRelationshipClient<$Result.GetResult<Prisma.$ConceptRelationshipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ConceptRelationship that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConceptRelationshipFindUniqueOrThrowArgs} args - Arguments to find a ConceptRelationship
     * @example
     * // Get one ConceptRelationship
     * const conceptRelationship = await prisma.conceptRelationship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConceptRelationshipFindUniqueOrThrowArgs>(args: SelectSubset<T, ConceptRelationshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConceptRelationshipClient<$Result.GetResult<Prisma.$ConceptRelationshipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ConceptRelationship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptRelationshipFindFirstArgs} args - Arguments to find a ConceptRelationship
     * @example
     * // Get one ConceptRelationship
     * const conceptRelationship = await prisma.conceptRelationship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConceptRelationshipFindFirstArgs>(args?: SelectSubset<T, ConceptRelationshipFindFirstArgs<ExtArgs>>): Prisma__ConceptRelationshipClient<$Result.GetResult<Prisma.$ConceptRelationshipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ConceptRelationship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptRelationshipFindFirstOrThrowArgs} args - Arguments to find a ConceptRelationship
     * @example
     * // Get one ConceptRelationship
     * const conceptRelationship = await prisma.conceptRelationship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConceptRelationshipFindFirstOrThrowArgs>(args?: SelectSubset<T, ConceptRelationshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConceptRelationshipClient<$Result.GetResult<Prisma.$ConceptRelationshipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ConceptRelationships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptRelationshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConceptRelationships
     * const conceptRelationships = await prisma.conceptRelationship.findMany()
     * 
     * // Get first 10 ConceptRelationships
     * const conceptRelationships = await prisma.conceptRelationship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conceptRelationshipWithIdOnly = await prisma.conceptRelationship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConceptRelationshipFindManyArgs>(args?: SelectSubset<T, ConceptRelationshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptRelationshipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ConceptRelationship.
     * @param {ConceptRelationshipCreateArgs} args - Arguments to create a ConceptRelationship.
     * @example
     * // Create one ConceptRelationship
     * const ConceptRelationship = await prisma.conceptRelationship.create({
     *   data: {
     *     // ... data to create a ConceptRelationship
     *   }
     * })
     * 
     */
    create<T extends ConceptRelationshipCreateArgs>(args: SelectSubset<T, ConceptRelationshipCreateArgs<ExtArgs>>): Prisma__ConceptRelationshipClient<$Result.GetResult<Prisma.$ConceptRelationshipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ConceptRelationships.
     * @param {ConceptRelationshipCreateManyArgs} args - Arguments to create many ConceptRelationships.
     * @example
     * // Create many ConceptRelationships
     * const conceptRelationship = await prisma.conceptRelationship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConceptRelationshipCreateManyArgs>(args?: SelectSubset<T, ConceptRelationshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConceptRelationships and returns the data saved in the database.
     * @param {ConceptRelationshipCreateManyAndReturnArgs} args - Arguments to create many ConceptRelationships.
     * @example
     * // Create many ConceptRelationships
     * const conceptRelationship = await prisma.conceptRelationship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConceptRelationships and only return the `id`
     * const conceptRelationshipWithIdOnly = await prisma.conceptRelationship.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConceptRelationshipCreateManyAndReturnArgs>(args?: SelectSubset<T, ConceptRelationshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConceptRelationshipPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ConceptRelationship.
     * @param {ConceptRelationshipDeleteArgs} args - Arguments to delete one ConceptRelationship.
     * @example
     * // Delete one ConceptRelationship
     * const ConceptRelationship = await prisma.conceptRelationship.delete({
     *   where: {
     *     // ... filter to delete one ConceptRelationship
     *   }
     * })
     * 
     */
    delete<T extends ConceptRelationshipDeleteArgs>(args: SelectSubset<T, ConceptRelationshipDeleteArgs<ExtArgs>>): Prisma__ConceptRelationshipClient<$Result.GetResult<Prisma.$ConceptRelationshipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ConceptRelationship.
     * @param {ConceptRelationshipUpdateArgs} args - Arguments to update one ConceptRelationship.
     * @example
     * // Update one ConceptRelationship
     * const conceptRelationship = await prisma.conceptRelationship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConceptRelationshipUpdateArgs>(args: SelectSubset<T, ConceptRelationshipUpdateArgs<ExtArgs>>): Prisma__ConceptRelationshipClient<$Result.GetResult<Prisma.$ConceptRelationshipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ConceptRelationships.
     * @param {ConceptRelationshipDeleteManyArgs} args - Arguments to filter ConceptRelationships to delete.
     * @example
     * // Delete a few ConceptRelationships
     * const { count } = await prisma.conceptRelationship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConceptRelationshipDeleteManyArgs>(args?: SelectSubset<T, ConceptRelationshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConceptRelationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptRelationshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConceptRelationships
     * const conceptRelationship = await prisma.conceptRelationship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConceptRelationshipUpdateManyArgs>(args: SelectSubset<T, ConceptRelationshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ConceptRelationship.
     * @param {ConceptRelationshipUpsertArgs} args - Arguments to update or create a ConceptRelationship.
     * @example
     * // Update or create a ConceptRelationship
     * const conceptRelationship = await prisma.conceptRelationship.upsert({
     *   create: {
     *     // ... data to create a ConceptRelationship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConceptRelationship we want to update
     *   }
     * })
     */
    upsert<T extends ConceptRelationshipUpsertArgs>(args: SelectSubset<T, ConceptRelationshipUpsertArgs<ExtArgs>>): Prisma__ConceptRelationshipClient<$Result.GetResult<Prisma.$ConceptRelationshipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ConceptRelationships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptRelationshipCountArgs} args - Arguments to filter ConceptRelationships to count.
     * @example
     * // Count the number of ConceptRelationships
     * const count = await prisma.conceptRelationship.count({
     *   where: {
     *     // ... the filter for the ConceptRelationships we want to count
     *   }
     * })
    **/
    count<T extends ConceptRelationshipCountArgs>(
      args?: Subset<T, ConceptRelationshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConceptRelationshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConceptRelationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptRelationshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConceptRelationshipAggregateArgs>(args: Subset<T, ConceptRelationshipAggregateArgs>): Prisma.PrismaPromise<GetConceptRelationshipAggregateType<T>>

    /**
     * Group by ConceptRelationship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConceptRelationshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConceptRelationshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConceptRelationshipGroupByArgs['orderBy'] }
        : { orderBy?: ConceptRelationshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConceptRelationshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConceptRelationshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConceptRelationship model
   */
  readonly fields: ConceptRelationshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConceptRelationship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConceptRelationshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fromConcept<T extends ConceptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConceptDefaultArgs<ExtArgs>>): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    toConcept<T extends ConceptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConceptDefaultArgs<ExtArgs>>): Prisma__ConceptClient<$Result.GetResult<Prisma.$ConceptPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConceptRelationship model
   */ 
  interface ConceptRelationshipFieldRefs {
    readonly id: FieldRef<"ConceptRelationship", 'String'>
    readonly fromConceptId: FieldRef<"ConceptRelationship", 'String'>
    readonly toConceptId: FieldRef<"ConceptRelationship", 'String'>
    readonly relationship: FieldRef<"ConceptRelationship", 'RelationshipType'>
    readonly strength: FieldRef<"ConceptRelationship", 'Float'>
    readonly createdAt: FieldRef<"ConceptRelationship", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConceptRelationship findUnique
   */
  export type ConceptRelationshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptRelationship
     */
    select?: ConceptRelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which ConceptRelationship to fetch.
     */
    where: ConceptRelationshipWhereUniqueInput
  }

  /**
   * ConceptRelationship findUniqueOrThrow
   */
  export type ConceptRelationshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptRelationship
     */
    select?: ConceptRelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which ConceptRelationship to fetch.
     */
    where: ConceptRelationshipWhereUniqueInput
  }

  /**
   * ConceptRelationship findFirst
   */
  export type ConceptRelationshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptRelationship
     */
    select?: ConceptRelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which ConceptRelationship to fetch.
     */
    where?: ConceptRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptRelationships to fetch.
     */
    orderBy?: ConceptRelationshipOrderByWithRelationInput | ConceptRelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConceptRelationships.
     */
    cursor?: ConceptRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptRelationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConceptRelationships.
     */
    distinct?: ConceptRelationshipScalarFieldEnum | ConceptRelationshipScalarFieldEnum[]
  }

  /**
   * ConceptRelationship findFirstOrThrow
   */
  export type ConceptRelationshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptRelationship
     */
    select?: ConceptRelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which ConceptRelationship to fetch.
     */
    where?: ConceptRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptRelationships to fetch.
     */
    orderBy?: ConceptRelationshipOrderByWithRelationInput | ConceptRelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConceptRelationships.
     */
    cursor?: ConceptRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptRelationships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConceptRelationships.
     */
    distinct?: ConceptRelationshipScalarFieldEnum | ConceptRelationshipScalarFieldEnum[]
  }

  /**
   * ConceptRelationship findMany
   */
  export type ConceptRelationshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptRelationship
     */
    select?: ConceptRelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptRelationshipInclude<ExtArgs> | null
    /**
     * Filter, which ConceptRelationships to fetch.
     */
    where?: ConceptRelationshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConceptRelationships to fetch.
     */
    orderBy?: ConceptRelationshipOrderByWithRelationInput | ConceptRelationshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConceptRelationships.
     */
    cursor?: ConceptRelationshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConceptRelationships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConceptRelationships.
     */
    skip?: number
    distinct?: ConceptRelationshipScalarFieldEnum | ConceptRelationshipScalarFieldEnum[]
  }

  /**
   * ConceptRelationship create
   */
  export type ConceptRelationshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptRelationship
     */
    select?: ConceptRelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptRelationshipInclude<ExtArgs> | null
    /**
     * The data needed to create a ConceptRelationship.
     */
    data: XOR<ConceptRelationshipCreateInput, ConceptRelationshipUncheckedCreateInput>
  }

  /**
   * ConceptRelationship createMany
   */
  export type ConceptRelationshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConceptRelationships.
     */
    data: ConceptRelationshipCreateManyInput | ConceptRelationshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConceptRelationship createManyAndReturn
   */
  export type ConceptRelationshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptRelationship
     */
    select?: ConceptRelationshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ConceptRelationships.
     */
    data: ConceptRelationshipCreateManyInput | ConceptRelationshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptRelationshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConceptRelationship update
   */
  export type ConceptRelationshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptRelationship
     */
    select?: ConceptRelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptRelationshipInclude<ExtArgs> | null
    /**
     * The data needed to update a ConceptRelationship.
     */
    data: XOR<ConceptRelationshipUpdateInput, ConceptRelationshipUncheckedUpdateInput>
    /**
     * Choose, which ConceptRelationship to update.
     */
    where: ConceptRelationshipWhereUniqueInput
  }

  /**
   * ConceptRelationship updateMany
   */
  export type ConceptRelationshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConceptRelationships.
     */
    data: XOR<ConceptRelationshipUpdateManyMutationInput, ConceptRelationshipUncheckedUpdateManyInput>
    /**
     * Filter which ConceptRelationships to update
     */
    where?: ConceptRelationshipWhereInput
  }

  /**
   * ConceptRelationship upsert
   */
  export type ConceptRelationshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptRelationship
     */
    select?: ConceptRelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptRelationshipInclude<ExtArgs> | null
    /**
     * The filter to search for the ConceptRelationship to update in case it exists.
     */
    where: ConceptRelationshipWhereUniqueInput
    /**
     * In case the ConceptRelationship found by the `where` argument doesn't exist, create a new ConceptRelationship with this data.
     */
    create: XOR<ConceptRelationshipCreateInput, ConceptRelationshipUncheckedCreateInput>
    /**
     * In case the ConceptRelationship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConceptRelationshipUpdateInput, ConceptRelationshipUncheckedUpdateInput>
  }

  /**
   * ConceptRelationship delete
   */
  export type ConceptRelationshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptRelationship
     */
    select?: ConceptRelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptRelationshipInclude<ExtArgs> | null
    /**
     * Filter which ConceptRelationship to delete.
     */
    where: ConceptRelationshipWhereUniqueInput
  }

  /**
   * ConceptRelationship deleteMany
   */
  export type ConceptRelationshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConceptRelationships to delete
     */
    where?: ConceptRelationshipWhereInput
  }

  /**
   * ConceptRelationship without action
   */
  export type ConceptRelationshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConceptRelationship
     */
    select?: ConceptRelationshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConceptRelationshipInclude<ExtArgs> | null
  }


  /**
   * Model ValidationPrompt
   */

  export type AggregateValidationPrompt = {
    _count: ValidationPromptCountAggregateOutputType | null
    _min: ValidationPromptMinAggregateOutputType | null
    _max: ValidationPromptMaxAggregateOutputType | null
  }

  export type ValidationPromptMinAggregateOutputType = {
    id: string | null
    promptText: string | null
    promptType: $Enums.PromptType | null
    conceptName: string | null
    createdAt: Date | null
  }

  export type ValidationPromptMaxAggregateOutputType = {
    id: string | null
    promptText: string | null
    promptType: $Enums.PromptType | null
    conceptName: string | null
    createdAt: Date | null
  }

  export type ValidationPromptCountAggregateOutputType = {
    id: number
    promptText: number
    promptType: number
    conceptName: number
    expectedCriteria: number
    createdAt: number
    _all: number
  }


  export type ValidationPromptMinAggregateInputType = {
    id?: true
    promptText?: true
    promptType?: true
    conceptName?: true
    createdAt?: true
  }

  export type ValidationPromptMaxAggregateInputType = {
    id?: true
    promptText?: true
    promptType?: true
    conceptName?: true
    createdAt?: true
  }

  export type ValidationPromptCountAggregateInputType = {
    id?: true
    promptText?: true
    promptType?: true
    conceptName?: true
    expectedCriteria?: true
    createdAt?: true
    _all?: true
  }

  export type ValidationPromptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ValidationPrompt to aggregate.
     */
    where?: ValidationPromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ValidationPrompts to fetch.
     */
    orderBy?: ValidationPromptOrderByWithRelationInput | ValidationPromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ValidationPromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ValidationPrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ValidationPrompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ValidationPrompts
    **/
    _count?: true | ValidationPromptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ValidationPromptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ValidationPromptMaxAggregateInputType
  }

  export type GetValidationPromptAggregateType<T extends ValidationPromptAggregateArgs> = {
        [P in keyof T & keyof AggregateValidationPrompt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateValidationPrompt[P]>
      : GetScalarType<T[P], AggregateValidationPrompt[P]>
  }




  export type ValidationPromptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ValidationPromptWhereInput
    orderBy?: ValidationPromptOrderByWithAggregationInput | ValidationPromptOrderByWithAggregationInput[]
    by: ValidationPromptScalarFieldEnum[] | ValidationPromptScalarFieldEnum
    having?: ValidationPromptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ValidationPromptCountAggregateInputType | true
    _min?: ValidationPromptMinAggregateInputType
    _max?: ValidationPromptMaxAggregateInputType
  }

  export type ValidationPromptGroupByOutputType = {
    id: string
    promptText: string
    promptType: $Enums.PromptType
    conceptName: string
    expectedCriteria: string[]
    createdAt: Date
    _count: ValidationPromptCountAggregateOutputType | null
    _min: ValidationPromptMinAggregateOutputType | null
    _max: ValidationPromptMaxAggregateOutputType | null
  }

  type GetValidationPromptGroupByPayload<T extends ValidationPromptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ValidationPromptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ValidationPromptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ValidationPromptGroupByOutputType[P]>
            : GetScalarType<T[P], ValidationPromptGroupByOutputType[P]>
        }
      >
    >


  export type ValidationPromptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promptText?: boolean
    promptType?: boolean
    conceptName?: boolean
    expectedCriteria?: boolean
    createdAt?: boolean
    responses?: boolean | ValidationPrompt$responsesArgs<ExtArgs>
    _count?: boolean | ValidationPromptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["validationPrompt"]>

  export type ValidationPromptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promptText?: boolean
    promptType?: boolean
    conceptName?: boolean
    expectedCriteria?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["validationPrompt"]>

  export type ValidationPromptSelectScalar = {
    id?: boolean
    promptText?: boolean
    promptType?: boolean
    conceptName?: boolean
    expectedCriteria?: boolean
    createdAt?: boolean
  }

  export type ValidationPromptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | ValidationPrompt$responsesArgs<ExtArgs>
    _count?: boolean | ValidationPromptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ValidationPromptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ValidationPromptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ValidationPrompt"
    objects: {
      responses: Prisma.$ValidationResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      promptText: string
      promptType: $Enums.PromptType
      conceptName: string
      expectedCriteria: string[]
      createdAt: Date
    }, ExtArgs["result"]["validationPrompt"]>
    composites: {}
  }

  type ValidationPromptGetPayload<S extends boolean | null | undefined | ValidationPromptDefaultArgs> = $Result.GetResult<Prisma.$ValidationPromptPayload, S>

  type ValidationPromptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ValidationPromptFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ValidationPromptCountAggregateInputType | true
    }

  export interface ValidationPromptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ValidationPrompt'], meta: { name: 'ValidationPrompt' } }
    /**
     * Find zero or one ValidationPrompt that matches the filter.
     * @param {ValidationPromptFindUniqueArgs} args - Arguments to find a ValidationPrompt
     * @example
     * // Get one ValidationPrompt
     * const validationPrompt = await prisma.validationPrompt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ValidationPromptFindUniqueArgs>(args: SelectSubset<T, ValidationPromptFindUniqueArgs<ExtArgs>>): Prisma__ValidationPromptClient<$Result.GetResult<Prisma.$ValidationPromptPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ValidationPrompt that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ValidationPromptFindUniqueOrThrowArgs} args - Arguments to find a ValidationPrompt
     * @example
     * // Get one ValidationPrompt
     * const validationPrompt = await prisma.validationPrompt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ValidationPromptFindUniqueOrThrowArgs>(args: SelectSubset<T, ValidationPromptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ValidationPromptClient<$Result.GetResult<Prisma.$ValidationPromptPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ValidationPrompt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationPromptFindFirstArgs} args - Arguments to find a ValidationPrompt
     * @example
     * // Get one ValidationPrompt
     * const validationPrompt = await prisma.validationPrompt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ValidationPromptFindFirstArgs>(args?: SelectSubset<T, ValidationPromptFindFirstArgs<ExtArgs>>): Prisma__ValidationPromptClient<$Result.GetResult<Prisma.$ValidationPromptPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ValidationPrompt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationPromptFindFirstOrThrowArgs} args - Arguments to find a ValidationPrompt
     * @example
     * // Get one ValidationPrompt
     * const validationPrompt = await prisma.validationPrompt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ValidationPromptFindFirstOrThrowArgs>(args?: SelectSubset<T, ValidationPromptFindFirstOrThrowArgs<ExtArgs>>): Prisma__ValidationPromptClient<$Result.GetResult<Prisma.$ValidationPromptPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ValidationPrompts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationPromptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ValidationPrompts
     * const validationPrompts = await prisma.validationPrompt.findMany()
     * 
     * // Get first 10 ValidationPrompts
     * const validationPrompts = await prisma.validationPrompt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const validationPromptWithIdOnly = await prisma.validationPrompt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ValidationPromptFindManyArgs>(args?: SelectSubset<T, ValidationPromptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ValidationPromptPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ValidationPrompt.
     * @param {ValidationPromptCreateArgs} args - Arguments to create a ValidationPrompt.
     * @example
     * // Create one ValidationPrompt
     * const ValidationPrompt = await prisma.validationPrompt.create({
     *   data: {
     *     // ... data to create a ValidationPrompt
     *   }
     * })
     * 
     */
    create<T extends ValidationPromptCreateArgs>(args: SelectSubset<T, ValidationPromptCreateArgs<ExtArgs>>): Prisma__ValidationPromptClient<$Result.GetResult<Prisma.$ValidationPromptPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ValidationPrompts.
     * @param {ValidationPromptCreateManyArgs} args - Arguments to create many ValidationPrompts.
     * @example
     * // Create many ValidationPrompts
     * const validationPrompt = await prisma.validationPrompt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ValidationPromptCreateManyArgs>(args?: SelectSubset<T, ValidationPromptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ValidationPrompts and returns the data saved in the database.
     * @param {ValidationPromptCreateManyAndReturnArgs} args - Arguments to create many ValidationPrompts.
     * @example
     * // Create many ValidationPrompts
     * const validationPrompt = await prisma.validationPrompt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ValidationPrompts and only return the `id`
     * const validationPromptWithIdOnly = await prisma.validationPrompt.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ValidationPromptCreateManyAndReturnArgs>(args?: SelectSubset<T, ValidationPromptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ValidationPromptPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ValidationPrompt.
     * @param {ValidationPromptDeleteArgs} args - Arguments to delete one ValidationPrompt.
     * @example
     * // Delete one ValidationPrompt
     * const ValidationPrompt = await prisma.validationPrompt.delete({
     *   where: {
     *     // ... filter to delete one ValidationPrompt
     *   }
     * })
     * 
     */
    delete<T extends ValidationPromptDeleteArgs>(args: SelectSubset<T, ValidationPromptDeleteArgs<ExtArgs>>): Prisma__ValidationPromptClient<$Result.GetResult<Prisma.$ValidationPromptPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ValidationPrompt.
     * @param {ValidationPromptUpdateArgs} args - Arguments to update one ValidationPrompt.
     * @example
     * // Update one ValidationPrompt
     * const validationPrompt = await prisma.validationPrompt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ValidationPromptUpdateArgs>(args: SelectSubset<T, ValidationPromptUpdateArgs<ExtArgs>>): Prisma__ValidationPromptClient<$Result.GetResult<Prisma.$ValidationPromptPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ValidationPrompts.
     * @param {ValidationPromptDeleteManyArgs} args - Arguments to filter ValidationPrompts to delete.
     * @example
     * // Delete a few ValidationPrompts
     * const { count } = await prisma.validationPrompt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ValidationPromptDeleteManyArgs>(args?: SelectSubset<T, ValidationPromptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ValidationPrompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationPromptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ValidationPrompts
     * const validationPrompt = await prisma.validationPrompt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ValidationPromptUpdateManyArgs>(args: SelectSubset<T, ValidationPromptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ValidationPrompt.
     * @param {ValidationPromptUpsertArgs} args - Arguments to update or create a ValidationPrompt.
     * @example
     * // Update or create a ValidationPrompt
     * const validationPrompt = await prisma.validationPrompt.upsert({
     *   create: {
     *     // ... data to create a ValidationPrompt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ValidationPrompt we want to update
     *   }
     * })
     */
    upsert<T extends ValidationPromptUpsertArgs>(args: SelectSubset<T, ValidationPromptUpsertArgs<ExtArgs>>): Prisma__ValidationPromptClient<$Result.GetResult<Prisma.$ValidationPromptPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ValidationPrompts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationPromptCountArgs} args - Arguments to filter ValidationPrompts to count.
     * @example
     * // Count the number of ValidationPrompts
     * const count = await prisma.validationPrompt.count({
     *   where: {
     *     // ... the filter for the ValidationPrompts we want to count
     *   }
     * })
    **/
    count<T extends ValidationPromptCountArgs>(
      args?: Subset<T, ValidationPromptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ValidationPromptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ValidationPrompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationPromptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ValidationPromptAggregateArgs>(args: Subset<T, ValidationPromptAggregateArgs>): Prisma.PrismaPromise<GetValidationPromptAggregateType<T>>

    /**
     * Group by ValidationPrompt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationPromptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ValidationPromptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ValidationPromptGroupByArgs['orderBy'] }
        : { orderBy?: ValidationPromptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ValidationPromptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetValidationPromptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ValidationPrompt model
   */
  readonly fields: ValidationPromptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ValidationPrompt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ValidationPromptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    responses<T extends ValidationPrompt$responsesArgs<ExtArgs> = {}>(args?: Subset<T, ValidationPrompt$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ValidationResponsePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ValidationPrompt model
   */ 
  interface ValidationPromptFieldRefs {
    readonly id: FieldRef<"ValidationPrompt", 'String'>
    readonly promptText: FieldRef<"ValidationPrompt", 'String'>
    readonly promptType: FieldRef<"ValidationPrompt", 'PromptType'>
    readonly conceptName: FieldRef<"ValidationPrompt", 'String'>
    readonly expectedCriteria: FieldRef<"ValidationPrompt", 'String[]'>
    readonly createdAt: FieldRef<"ValidationPrompt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ValidationPrompt findUnique
   */
  export type ValidationPromptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationPrompt
     */
    select?: ValidationPromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationPromptInclude<ExtArgs> | null
    /**
     * Filter, which ValidationPrompt to fetch.
     */
    where: ValidationPromptWhereUniqueInput
  }

  /**
   * ValidationPrompt findUniqueOrThrow
   */
  export type ValidationPromptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationPrompt
     */
    select?: ValidationPromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationPromptInclude<ExtArgs> | null
    /**
     * Filter, which ValidationPrompt to fetch.
     */
    where: ValidationPromptWhereUniqueInput
  }

  /**
   * ValidationPrompt findFirst
   */
  export type ValidationPromptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationPrompt
     */
    select?: ValidationPromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationPromptInclude<ExtArgs> | null
    /**
     * Filter, which ValidationPrompt to fetch.
     */
    where?: ValidationPromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ValidationPrompts to fetch.
     */
    orderBy?: ValidationPromptOrderByWithRelationInput | ValidationPromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ValidationPrompts.
     */
    cursor?: ValidationPromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ValidationPrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ValidationPrompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ValidationPrompts.
     */
    distinct?: ValidationPromptScalarFieldEnum | ValidationPromptScalarFieldEnum[]
  }

  /**
   * ValidationPrompt findFirstOrThrow
   */
  export type ValidationPromptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationPrompt
     */
    select?: ValidationPromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationPromptInclude<ExtArgs> | null
    /**
     * Filter, which ValidationPrompt to fetch.
     */
    where?: ValidationPromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ValidationPrompts to fetch.
     */
    orderBy?: ValidationPromptOrderByWithRelationInput | ValidationPromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ValidationPrompts.
     */
    cursor?: ValidationPromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ValidationPrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ValidationPrompts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ValidationPrompts.
     */
    distinct?: ValidationPromptScalarFieldEnum | ValidationPromptScalarFieldEnum[]
  }

  /**
   * ValidationPrompt findMany
   */
  export type ValidationPromptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationPrompt
     */
    select?: ValidationPromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationPromptInclude<ExtArgs> | null
    /**
     * Filter, which ValidationPrompts to fetch.
     */
    where?: ValidationPromptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ValidationPrompts to fetch.
     */
    orderBy?: ValidationPromptOrderByWithRelationInput | ValidationPromptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ValidationPrompts.
     */
    cursor?: ValidationPromptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ValidationPrompts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ValidationPrompts.
     */
    skip?: number
    distinct?: ValidationPromptScalarFieldEnum | ValidationPromptScalarFieldEnum[]
  }

  /**
   * ValidationPrompt create
   */
  export type ValidationPromptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationPrompt
     */
    select?: ValidationPromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationPromptInclude<ExtArgs> | null
    /**
     * The data needed to create a ValidationPrompt.
     */
    data: XOR<ValidationPromptCreateInput, ValidationPromptUncheckedCreateInput>
  }

  /**
   * ValidationPrompt createMany
   */
  export type ValidationPromptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ValidationPrompts.
     */
    data: ValidationPromptCreateManyInput | ValidationPromptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ValidationPrompt createManyAndReturn
   */
  export type ValidationPromptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationPrompt
     */
    select?: ValidationPromptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ValidationPrompts.
     */
    data: ValidationPromptCreateManyInput | ValidationPromptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ValidationPrompt update
   */
  export type ValidationPromptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationPrompt
     */
    select?: ValidationPromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationPromptInclude<ExtArgs> | null
    /**
     * The data needed to update a ValidationPrompt.
     */
    data: XOR<ValidationPromptUpdateInput, ValidationPromptUncheckedUpdateInput>
    /**
     * Choose, which ValidationPrompt to update.
     */
    where: ValidationPromptWhereUniqueInput
  }

  /**
   * ValidationPrompt updateMany
   */
  export type ValidationPromptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ValidationPrompts.
     */
    data: XOR<ValidationPromptUpdateManyMutationInput, ValidationPromptUncheckedUpdateManyInput>
    /**
     * Filter which ValidationPrompts to update
     */
    where?: ValidationPromptWhereInput
  }

  /**
   * ValidationPrompt upsert
   */
  export type ValidationPromptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationPrompt
     */
    select?: ValidationPromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationPromptInclude<ExtArgs> | null
    /**
     * The filter to search for the ValidationPrompt to update in case it exists.
     */
    where: ValidationPromptWhereUniqueInput
    /**
     * In case the ValidationPrompt found by the `where` argument doesn't exist, create a new ValidationPrompt with this data.
     */
    create: XOR<ValidationPromptCreateInput, ValidationPromptUncheckedCreateInput>
    /**
     * In case the ValidationPrompt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ValidationPromptUpdateInput, ValidationPromptUncheckedUpdateInput>
  }

  /**
   * ValidationPrompt delete
   */
  export type ValidationPromptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationPrompt
     */
    select?: ValidationPromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationPromptInclude<ExtArgs> | null
    /**
     * Filter which ValidationPrompt to delete.
     */
    where: ValidationPromptWhereUniqueInput
  }

  /**
   * ValidationPrompt deleteMany
   */
  export type ValidationPromptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ValidationPrompts to delete
     */
    where?: ValidationPromptWhereInput
  }

  /**
   * ValidationPrompt.responses
   */
  export type ValidationPrompt$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationResponse
     */
    select?: ValidationResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationResponseInclude<ExtArgs> | null
    where?: ValidationResponseWhereInput
    orderBy?: ValidationResponseOrderByWithRelationInput | ValidationResponseOrderByWithRelationInput[]
    cursor?: ValidationResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ValidationResponseScalarFieldEnum | ValidationResponseScalarFieldEnum[]
  }

  /**
   * ValidationPrompt without action
   */
  export type ValidationPromptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationPrompt
     */
    select?: ValidationPromptSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationPromptInclude<ExtArgs> | null
  }


  /**
   * Model ValidationResponse
   */

  export type AggregateValidationResponse = {
    _count: ValidationResponseCountAggregateOutputType | null
    _avg: ValidationResponseAvgAggregateOutputType | null
    _sum: ValidationResponseSumAggregateOutputType | null
    _min: ValidationResponseMinAggregateOutputType | null
    _max: ValidationResponseMaxAggregateOutputType | null
  }

  export type ValidationResponseAvgAggregateOutputType = {
    score: number | null
    confidence: number | null
  }

  export type ValidationResponseSumAggregateOutputType = {
    score: number | null
    confidence: number | null
  }

  export type ValidationResponseMinAggregateOutputType = {
    id: string | null
    promptId: string | null
    sessionId: string | null
    userAnswer: string | null
    aiEvaluation: string | null
    score: number | null
    confidence: number | null
    respondedAt: Date | null
  }

  export type ValidationResponseMaxAggregateOutputType = {
    id: string | null
    promptId: string | null
    sessionId: string | null
    userAnswer: string | null
    aiEvaluation: string | null
    score: number | null
    confidence: number | null
    respondedAt: Date | null
  }

  export type ValidationResponseCountAggregateOutputType = {
    id: number
    promptId: number
    sessionId: number
    userAnswer: number
    aiEvaluation: number
    score: number
    confidence: number
    respondedAt: number
    _all: number
  }


  export type ValidationResponseAvgAggregateInputType = {
    score?: true
    confidence?: true
  }

  export type ValidationResponseSumAggregateInputType = {
    score?: true
    confidence?: true
  }

  export type ValidationResponseMinAggregateInputType = {
    id?: true
    promptId?: true
    sessionId?: true
    userAnswer?: true
    aiEvaluation?: true
    score?: true
    confidence?: true
    respondedAt?: true
  }

  export type ValidationResponseMaxAggregateInputType = {
    id?: true
    promptId?: true
    sessionId?: true
    userAnswer?: true
    aiEvaluation?: true
    score?: true
    confidence?: true
    respondedAt?: true
  }

  export type ValidationResponseCountAggregateInputType = {
    id?: true
    promptId?: true
    sessionId?: true
    userAnswer?: true
    aiEvaluation?: true
    score?: true
    confidence?: true
    respondedAt?: true
    _all?: true
  }

  export type ValidationResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ValidationResponse to aggregate.
     */
    where?: ValidationResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ValidationResponses to fetch.
     */
    orderBy?: ValidationResponseOrderByWithRelationInput | ValidationResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ValidationResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ValidationResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ValidationResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ValidationResponses
    **/
    _count?: true | ValidationResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ValidationResponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ValidationResponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ValidationResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ValidationResponseMaxAggregateInputType
  }

  export type GetValidationResponseAggregateType<T extends ValidationResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateValidationResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateValidationResponse[P]>
      : GetScalarType<T[P], AggregateValidationResponse[P]>
  }




  export type ValidationResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ValidationResponseWhereInput
    orderBy?: ValidationResponseOrderByWithAggregationInput | ValidationResponseOrderByWithAggregationInput[]
    by: ValidationResponseScalarFieldEnum[] | ValidationResponseScalarFieldEnum
    having?: ValidationResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ValidationResponseCountAggregateInputType | true
    _avg?: ValidationResponseAvgAggregateInputType
    _sum?: ValidationResponseSumAggregateInputType
    _min?: ValidationResponseMinAggregateInputType
    _max?: ValidationResponseMaxAggregateInputType
  }

  export type ValidationResponseGroupByOutputType = {
    id: string
    promptId: string
    sessionId: string | null
    userAnswer: string
    aiEvaluation: string
    score: number
    confidence: number | null
    respondedAt: Date
    _count: ValidationResponseCountAggregateOutputType | null
    _avg: ValidationResponseAvgAggregateOutputType | null
    _sum: ValidationResponseSumAggregateOutputType | null
    _min: ValidationResponseMinAggregateOutputType | null
    _max: ValidationResponseMaxAggregateOutputType | null
  }

  type GetValidationResponseGroupByPayload<T extends ValidationResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ValidationResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ValidationResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ValidationResponseGroupByOutputType[P]>
            : GetScalarType<T[P], ValidationResponseGroupByOutputType[P]>
        }
      >
    >


  export type ValidationResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promptId?: boolean
    sessionId?: boolean
    userAnswer?: boolean
    aiEvaluation?: boolean
    score?: boolean
    confidence?: boolean
    respondedAt?: boolean
    prompt?: boolean | ValidationPromptDefaultArgs<ExtArgs>
    session?: boolean | ValidationResponse$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["validationResponse"]>

  export type ValidationResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    promptId?: boolean
    sessionId?: boolean
    userAnswer?: boolean
    aiEvaluation?: boolean
    score?: boolean
    confidence?: boolean
    respondedAt?: boolean
    prompt?: boolean | ValidationPromptDefaultArgs<ExtArgs>
    session?: boolean | ValidationResponse$sessionArgs<ExtArgs>
  }, ExtArgs["result"]["validationResponse"]>

  export type ValidationResponseSelectScalar = {
    id?: boolean
    promptId?: boolean
    sessionId?: boolean
    userAnswer?: boolean
    aiEvaluation?: boolean
    score?: boolean
    confidence?: boolean
    respondedAt?: boolean
  }

  export type ValidationResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prompt?: boolean | ValidationPromptDefaultArgs<ExtArgs>
    session?: boolean | ValidationResponse$sessionArgs<ExtArgs>
  }
  export type ValidationResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prompt?: boolean | ValidationPromptDefaultArgs<ExtArgs>
    session?: boolean | ValidationResponse$sessionArgs<ExtArgs>
  }

  export type $ValidationResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ValidationResponse"
    objects: {
      prompt: Prisma.$ValidationPromptPayload<ExtArgs>
      session: Prisma.$StudySessionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      promptId: string
      sessionId: string | null
      userAnswer: string
      aiEvaluation: string
      score: number
      confidence: number | null
      respondedAt: Date
    }, ExtArgs["result"]["validationResponse"]>
    composites: {}
  }

  type ValidationResponseGetPayload<S extends boolean | null | undefined | ValidationResponseDefaultArgs> = $Result.GetResult<Prisma.$ValidationResponsePayload, S>

  type ValidationResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ValidationResponseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ValidationResponseCountAggregateInputType | true
    }

  export interface ValidationResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ValidationResponse'], meta: { name: 'ValidationResponse' } }
    /**
     * Find zero or one ValidationResponse that matches the filter.
     * @param {ValidationResponseFindUniqueArgs} args - Arguments to find a ValidationResponse
     * @example
     * // Get one ValidationResponse
     * const validationResponse = await prisma.validationResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ValidationResponseFindUniqueArgs>(args: SelectSubset<T, ValidationResponseFindUniqueArgs<ExtArgs>>): Prisma__ValidationResponseClient<$Result.GetResult<Prisma.$ValidationResponsePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ValidationResponse that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ValidationResponseFindUniqueOrThrowArgs} args - Arguments to find a ValidationResponse
     * @example
     * // Get one ValidationResponse
     * const validationResponse = await prisma.validationResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ValidationResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, ValidationResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ValidationResponseClient<$Result.GetResult<Prisma.$ValidationResponsePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ValidationResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationResponseFindFirstArgs} args - Arguments to find a ValidationResponse
     * @example
     * // Get one ValidationResponse
     * const validationResponse = await prisma.validationResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ValidationResponseFindFirstArgs>(args?: SelectSubset<T, ValidationResponseFindFirstArgs<ExtArgs>>): Prisma__ValidationResponseClient<$Result.GetResult<Prisma.$ValidationResponsePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ValidationResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationResponseFindFirstOrThrowArgs} args - Arguments to find a ValidationResponse
     * @example
     * // Get one ValidationResponse
     * const validationResponse = await prisma.validationResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ValidationResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, ValidationResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ValidationResponseClient<$Result.GetResult<Prisma.$ValidationResponsePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ValidationResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ValidationResponses
     * const validationResponses = await prisma.validationResponse.findMany()
     * 
     * // Get first 10 ValidationResponses
     * const validationResponses = await prisma.validationResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const validationResponseWithIdOnly = await prisma.validationResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ValidationResponseFindManyArgs>(args?: SelectSubset<T, ValidationResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ValidationResponsePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ValidationResponse.
     * @param {ValidationResponseCreateArgs} args - Arguments to create a ValidationResponse.
     * @example
     * // Create one ValidationResponse
     * const ValidationResponse = await prisma.validationResponse.create({
     *   data: {
     *     // ... data to create a ValidationResponse
     *   }
     * })
     * 
     */
    create<T extends ValidationResponseCreateArgs>(args: SelectSubset<T, ValidationResponseCreateArgs<ExtArgs>>): Prisma__ValidationResponseClient<$Result.GetResult<Prisma.$ValidationResponsePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ValidationResponses.
     * @param {ValidationResponseCreateManyArgs} args - Arguments to create many ValidationResponses.
     * @example
     * // Create many ValidationResponses
     * const validationResponse = await prisma.validationResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ValidationResponseCreateManyArgs>(args?: SelectSubset<T, ValidationResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ValidationResponses and returns the data saved in the database.
     * @param {ValidationResponseCreateManyAndReturnArgs} args - Arguments to create many ValidationResponses.
     * @example
     * // Create many ValidationResponses
     * const validationResponse = await prisma.validationResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ValidationResponses and only return the `id`
     * const validationResponseWithIdOnly = await prisma.validationResponse.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ValidationResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, ValidationResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ValidationResponsePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ValidationResponse.
     * @param {ValidationResponseDeleteArgs} args - Arguments to delete one ValidationResponse.
     * @example
     * // Delete one ValidationResponse
     * const ValidationResponse = await prisma.validationResponse.delete({
     *   where: {
     *     // ... filter to delete one ValidationResponse
     *   }
     * })
     * 
     */
    delete<T extends ValidationResponseDeleteArgs>(args: SelectSubset<T, ValidationResponseDeleteArgs<ExtArgs>>): Prisma__ValidationResponseClient<$Result.GetResult<Prisma.$ValidationResponsePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ValidationResponse.
     * @param {ValidationResponseUpdateArgs} args - Arguments to update one ValidationResponse.
     * @example
     * // Update one ValidationResponse
     * const validationResponse = await prisma.validationResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ValidationResponseUpdateArgs>(args: SelectSubset<T, ValidationResponseUpdateArgs<ExtArgs>>): Prisma__ValidationResponseClient<$Result.GetResult<Prisma.$ValidationResponsePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ValidationResponses.
     * @param {ValidationResponseDeleteManyArgs} args - Arguments to filter ValidationResponses to delete.
     * @example
     * // Delete a few ValidationResponses
     * const { count } = await prisma.validationResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ValidationResponseDeleteManyArgs>(args?: SelectSubset<T, ValidationResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ValidationResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ValidationResponses
     * const validationResponse = await prisma.validationResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ValidationResponseUpdateManyArgs>(args: SelectSubset<T, ValidationResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ValidationResponse.
     * @param {ValidationResponseUpsertArgs} args - Arguments to update or create a ValidationResponse.
     * @example
     * // Update or create a ValidationResponse
     * const validationResponse = await prisma.validationResponse.upsert({
     *   create: {
     *     // ... data to create a ValidationResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ValidationResponse we want to update
     *   }
     * })
     */
    upsert<T extends ValidationResponseUpsertArgs>(args: SelectSubset<T, ValidationResponseUpsertArgs<ExtArgs>>): Prisma__ValidationResponseClient<$Result.GetResult<Prisma.$ValidationResponsePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ValidationResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationResponseCountArgs} args - Arguments to filter ValidationResponses to count.
     * @example
     * // Count the number of ValidationResponses
     * const count = await prisma.validationResponse.count({
     *   where: {
     *     // ... the filter for the ValidationResponses we want to count
     *   }
     * })
    **/
    count<T extends ValidationResponseCountArgs>(
      args?: Subset<T, ValidationResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ValidationResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ValidationResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ValidationResponseAggregateArgs>(args: Subset<T, ValidationResponseAggregateArgs>): Prisma.PrismaPromise<GetValidationResponseAggregateType<T>>

    /**
     * Group by ValidationResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ValidationResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ValidationResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ValidationResponseGroupByArgs['orderBy'] }
        : { orderBy?: ValidationResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ValidationResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetValidationResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ValidationResponse model
   */
  readonly fields: ValidationResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ValidationResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ValidationResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prompt<T extends ValidationPromptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ValidationPromptDefaultArgs<ExtArgs>>): Prisma__ValidationPromptClient<$Result.GetResult<Prisma.$ValidationPromptPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    session<T extends ValidationResponse$sessionArgs<ExtArgs> = {}>(args?: Subset<T, ValidationResponse$sessionArgs<ExtArgs>>): Prisma__StudySessionClient<$Result.GetResult<Prisma.$StudySessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ValidationResponse model
   */ 
  interface ValidationResponseFieldRefs {
    readonly id: FieldRef<"ValidationResponse", 'String'>
    readonly promptId: FieldRef<"ValidationResponse", 'String'>
    readonly sessionId: FieldRef<"ValidationResponse", 'String'>
    readonly userAnswer: FieldRef<"ValidationResponse", 'String'>
    readonly aiEvaluation: FieldRef<"ValidationResponse", 'String'>
    readonly score: FieldRef<"ValidationResponse", 'Float'>
    readonly confidence: FieldRef<"ValidationResponse", 'Float'>
    readonly respondedAt: FieldRef<"ValidationResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ValidationResponse findUnique
   */
  export type ValidationResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationResponse
     */
    select?: ValidationResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationResponseInclude<ExtArgs> | null
    /**
     * Filter, which ValidationResponse to fetch.
     */
    where: ValidationResponseWhereUniqueInput
  }

  /**
   * ValidationResponse findUniqueOrThrow
   */
  export type ValidationResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationResponse
     */
    select?: ValidationResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationResponseInclude<ExtArgs> | null
    /**
     * Filter, which ValidationResponse to fetch.
     */
    where: ValidationResponseWhereUniqueInput
  }

  /**
   * ValidationResponse findFirst
   */
  export type ValidationResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationResponse
     */
    select?: ValidationResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationResponseInclude<ExtArgs> | null
    /**
     * Filter, which ValidationResponse to fetch.
     */
    where?: ValidationResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ValidationResponses to fetch.
     */
    orderBy?: ValidationResponseOrderByWithRelationInput | ValidationResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ValidationResponses.
     */
    cursor?: ValidationResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ValidationResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ValidationResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ValidationResponses.
     */
    distinct?: ValidationResponseScalarFieldEnum | ValidationResponseScalarFieldEnum[]
  }

  /**
   * ValidationResponse findFirstOrThrow
   */
  export type ValidationResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationResponse
     */
    select?: ValidationResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationResponseInclude<ExtArgs> | null
    /**
     * Filter, which ValidationResponse to fetch.
     */
    where?: ValidationResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ValidationResponses to fetch.
     */
    orderBy?: ValidationResponseOrderByWithRelationInput | ValidationResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ValidationResponses.
     */
    cursor?: ValidationResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ValidationResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ValidationResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ValidationResponses.
     */
    distinct?: ValidationResponseScalarFieldEnum | ValidationResponseScalarFieldEnum[]
  }

  /**
   * ValidationResponse findMany
   */
  export type ValidationResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationResponse
     */
    select?: ValidationResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationResponseInclude<ExtArgs> | null
    /**
     * Filter, which ValidationResponses to fetch.
     */
    where?: ValidationResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ValidationResponses to fetch.
     */
    orderBy?: ValidationResponseOrderByWithRelationInput | ValidationResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ValidationResponses.
     */
    cursor?: ValidationResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ValidationResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ValidationResponses.
     */
    skip?: number
    distinct?: ValidationResponseScalarFieldEnum | ValidationResponseScalarFieldEnum[]
  }

  /**
   * ValidationResponse create
   */
  export type ValidationResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationResponse
     */
    select?: ValidationResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a ValidationResponse.
     */
    data: XOR<ValidationResponseCreateInput, ValidationResponseUncheckedCreateInput>
  }

  /**
   * ValidationResponse createMany
   */
  export type ValidationResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ValidationResponses.
     */
    data: ValidationResponseCreateManyInput | ValidationResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ValidationResponse createManyAndReturn
   */
  export type ValidationResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationResponse
     */
    select?: ValidationResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ValidationResponses.
     */
    data: ValidationResponseCreateManyInput | ValidationResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ValidationResponse update
   */
  export type ValidationResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationResponse
     */
    select?: ValidationResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a ValidationResponse.
     */
    data: XOR<ValidationResponseUpdateInput, ValidationResponseUncheckedUpdateInput>
    /**
     * Choose, which ValidationResponse to update.
     */
    where: ValidationResponseWhereUniqueInput
  }

  /**
   * ValidationResponse updateMany
   */
  export type ValidationResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ValidationResponses.
     */
    data: XOR<ValidationResponseUpdateManyMutationInput, ValidationResponseUncheckedUpdateManyInput>
    /**
     * Filter which ValidationResponses to update
     */
    where?: ValidationResponseWhereInput
  }

  /**
   * ValidationResponse upsert
   */
  export type ValidationResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationResponse
     */
    select?: ValidationResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the ValidationResponse to update in case it exists.
     */
    where: ValidationResponseWhereUniqueInput
    /**
     * In case the ValidationResponse found by the `where` argument doesn't exist, create a new ValidationResponse with this data.
     */
    create: XOR<ValidationResponseCreateInput, ValidationResponseUncheckedCreateInput>
    /**
     * In case the ValidationResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ValidationResponseUpdateInput, ValidationResponseUncheckedUpdateInput>
  }

  /**
   * ValidationResponse delete
   */
  export type ValidationResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationResponse
     */
    select?: ValidationResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationResponseInclude<ExtArgs> | null
    /**
     * Filter which ValidationResponse to delete.
     */
    where: ValidationResponseWhereUniqueInput
  }

  /**
   * ValidationResponse deleteMany
   */
  export type ValidationResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ValidationResponses to delete
     */
    where?: ValidationResponseWhereInput
  }

  /**
   * ValidationResponse.session
   */
  export type ValidationResponse$sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudySession
     */
    select?: StudySessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudySessionInclude<ExtArgs> | null
    where?: StudySessionWhereInput
  }

  /**
   * ValidationResponse without action
   */
  export type ValidationResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ValidationResponse
     */
    select?: ValidationResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ValidationResponseInclude<ExtArgs> | null
  }


  /**
   * Model ComprehensionMetric
   */

  export type AggregateComprehensionMetric = {
    _count: ComprehensionMetricCountAggregateOutputType | null
    _avg: ComprehensionMetricAvgAggregateOutputType | null
    _sum: ComprehensionMetricSumAggregateOutputType | null
    _min: ComprehensionMetricMinAggregateOutputType | null
    _max: ComprehensionMetricMaxAggregateOutputType | null
  }

  export type ComprehensionMetricAvgAggregateOutputType = {
    avgScore: number | null
    sampleSize: number | null
  }

  export type ComprehensionMetricSumAggregateOutputType = {
    avgScore: number | null
    sampleSize: number | null
  }

  export type ComprehensionMetricMinAggregateOutputType = {
    id: string | null
    conceptName: string | null
    date: Date | null
    avgScore: number | null
    sampleSize: number | null
    trend: string | null
  }

  export type ComprehensionMetricMaxAggregateOutputType = {
    id: string | null
    conceptName: string | null
    date: Date | null
    avgScore: number | null
    sampleSize: number | null
    trend: string | null
  }

  export type ComprehensionMetricCountAggregateOutputType = {
    id: number
    conceptName: number
    date: number
    avgScore: number
    sampleSize: number
    trend: number
    _all: number
  }


  export type ComprehensionMetricAvgAggregateInputType = {
    avgScore?: true
    sampleSize?: true
  }

  export type ComprehensionMetricSumAggregateInputType = {
    avgScore?: true
    sampleSize?: true
  }

  export type ComprehensionMetricMinAggregateInputType = {
    id?: true
    conceptName?: true
    date?: true
    avgScore?: true
    sampleSize?: true
    trend?: true
  }

  export type ComprehensionMetricMaxAggregateInputType = {
    id?: true
    conceptName?: true
    date?: true
    avgScore?: true
    sampleSize?: true
    trend?: true
  }

  export type ComprehensionMetricCountAggregateInputType = {
    id?: true
    conceptName?: true
    date?: true
    avgScore?: true
    sampleSize?: true
    trend?: true
    _all?: true
  }

  export type ComprehensionMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComprehensionMetric to aggregate.
     */
    where?: ComprehensionMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComprehensionMetrics to fetch.
     */
    orderBy?: ComprehensionMetricOrderByWithRelationInput | ComprehensionMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComprehensionMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComprehensionMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComprehensionMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComprehensionMetrics
    **/
    _count?: true | ComprehensionMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComprehensionMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComprehensionMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComprehensionMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComprehensionMetricMaxAggregateInputType
  }

  export type GetComprehensionMetricAggregateType<T extends ComprehensionMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateComprehensionMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComprehensionMetric[P]>
      : GetScalarType<T[P], AggregateComprehensionMetric[P]>
  }




  export type ComprehensionMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComprehensionMetricWhereInput
    orderBy?: ComprehensionMetricOrderByWithAggregationInput | ComprehensionMetricOrderByWithAggregationInput[]
    by: ComprehensionMetricScalarFieldEnum[] | ComprehensionMetricScalarFieldEnum
    having?: ComprehensionMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComprehensionMetricCountAggregateInputType | true
    _avg?: ComprehensionMetricAvgAggregateInputType
    _sum?: ComprehensionMetricSumAggregateInputType
    _min?: ComprehensionMetricMinAggregateInputType
    _max?: ComprehensionMetricMaxAggregateInputType
  }

  export type ComprehensionMetricGroupByOutputType = {
    id: string
    conceptName: string
    date: Date
    avgScore: number
    sampleSize: number
    trend: string | null
    _count: ComprehensionMetricCountAggregateOutputType | null
    _avg: ComprehensionMetricAvgAggregateOutputType | null
    _sum: ComprehensionMetricSumAggregateOutputType | null
    _min: ComprehensionMetricMinAggregateOutputType | null
    _max: ComprehensionMetricMaxAggregateOutputType | null
  }

  type GetComprehensionMetricGroupByPayload<T extends ComprehensionMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComprehensionMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComprehensionMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComprehensionMetricGroupByOutputType[P]>
            : GetScalarType<T[P], ComprehensionMetricGroupByOutputType[P]>
        }
      >
    >


  export type ComprehensionMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conceptName?: boolean
    date?: boolean
    avgScore?: boolean
    sampleSize?: boolean
    trend?: boolean
  }, ExtArgs["result"]["comprehensionMetric"]>

  export type ComprehensionMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conceptName?: boolean
    date?: boolean
    avgScore?: boolean
    sampleSize?: boolean
    trend?: boolean
  }, ExtArgs["result"]["comprehensionMetric"]>

  export type ComprehensionMetricSelectScalar = {
    id?: boolean
    conceptName?: boolean
    date?: boolean
    avgScore?: boolean
    sampleSize?: boolean
    trend?: boolean
  }


  export type $ComprehensionMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComprehensionMetric"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conceptName: string
      date: Date
      avgScore: number
      sampleSize: number
      trend: string | null
    }, ExtArgs["result"]["comprehensionMetric"]>
    composites: {}
  }

  type ComprehensionMetricGetPayload<S extends boolean | null | undefined | ComprehensionMetricDefaultArgs> = $Result.GetResult<Prisma.$ComprehensionMetricPayload, S>

  type ComprehensionMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComprehensionMetricFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComprehensionMetricCountAggregateInputType | true
    }

  export interface ComprehensionMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComprehensionMetric'], meta: { name: 'ComprehensionMetric' } }
    /**
     * Find zero or one ComprehensionMetric that matches the filter.
     * @param {ComprehensionMetricFindUniqueArgs} args - Arguments to find a ComprehensionMetric
     * @example
     * // Get one ComprehensionMetric
     * const comprehensionMetric = await prisma.comprehensionMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComprehensionMetricFindUniqueArgs>(args: SelectSubset<T, ComprehensionMetricFindUniqueArgs<ExtArgs>>): Prisma__ComprehensionMetricClient<$Result.GetResult<Prisma.$ComprehensionMetricPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ComprehensionMetric that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComprehensionMetricFindUniqueOrThrowArgs} args - Arguments to find a ComprehensionMetric
     * @example
     * // Get one ComprehensionMetric
     * const comprehensionMetric = await prisma.comprehensionMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComprehensionMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, ComprehensionMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComprehensionMetricClient<$Result.GetResult<Prisma.$ComprehensionMetricPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ComprehensionMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprehensionMetricFindFirstArgs} args - Arguments to find a ComprehensionMetric
     * @example
     * // Get one ComprehensionMetric
     * const comprehensionMetric = await prisma.comprehensionMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComprehensionMetricFindFirstArgs>(args?: SelectSubset<T, ComprehensionMetricFindFirstArgs<ExtArgs>>): Prisma__ComprehensionMetricClient<$Result.GetResult<Prisma.$ComprehensionMetricPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ComprehensionMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprehensionMetricFindFirstOrThrowArgs} args - Arguments to find a ComprehensionMetric
     * @example
     * // Get one ComprehensionMetric
     * const comprehensionMetric = await prisma.comprehensionMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComprehensionMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, ComprehensionMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComprehensionMetricClient<$Result.GetResult<Prisma.$ComprehensionMetricPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ComprehensionMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprehensionMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComprehensionMetrics
     * const comprehensionMetrics = await prisma.comprehensionMetric.findMany()
     * 
     * // Get first 10 ComprehensionMetrics
     * const comprehensionMetrics = await prisma.comprehensionMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comprehensionMetricWithIdOnly = await prisma.comprehensionMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComprehensionMetricFindManyArgs>(args?: SelectSubset<T, ComprehensionMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComprehensionMetricPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ComprehensionMetric.
     * @param {ComprehensionMetricCreateArgs} args - Arguments to create a ComprehensionMetric.
     * @example
     * // Create one ComprehensionMetric
     * const ComprehensionMetric = await prisma.comprehensionMetric.create({
     *   data: {
     *     // ... data to create a ComprehensionMetric
     *   }
     * })
     * 
     */
    create<T extends ComprehensionMetricCreateArgs>(args: SelectSubset<T, ComprehensionMetricCreateArgs<ExtArgs>>): Prisma__ComprehensionMetricClient<$Result.GetResult<Prisma.$ComprehensionMetricPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ComprehensionMetrics.
     * @param {ComprehensionMetricCreateManyArgs} args - Arguments to create many ComprehensionMetrics.
     * @example
     * // Create many ComprehensionMetrics
     * const comprehensionMetric = await prisma.comprehensionMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComprehensionMetricCreateManyArgs>(args?: SelectSubset<T, ComprehensionMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComprehensionMetrics and returns the data saved in the database.
     * @param {ComprehensionMetricCreateManyAndReturnArgs} args - Arguments to create many ComprehensionMetrics.
     * @example
     * // Create many ComprehensionMetrics
     * const comprehensionMetric = await prisma.comprehensionMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComprehensionMetrics and only return the `id`
     * const comprehensionMetricWithIdOnly = await prisma.comprehensionMetric.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComprehensionMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, ComprehensionMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComprehensionMetricPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ComprehensionMetric.
     * @param {ComprehensionMetricDeleteArgs} args - Arguments to delete one ComprehensionMetric.
     * @example
     * // Delete one ComprehensionMetric
     * const ComprehensionMetric = await prisma.comprehensionMetric.delete({
     *   where: {
     *     // ... filter to delete one ComprehensionMetric
     *   }
     * })
     * 
     */
    delete<T extends ComprehensionMetricDeleteArgs>(args: SelectSubset<T, ComprehensionMetricDeleteArgs<ExtArgs>>): Prisma__ComprehensionMetricClient<$Result.GetResult<Prisma.$ComprehensionMetricPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ComprehensionMetric.
     * @param {ComprehensionMetricUpdateArgs} args - Arguments to update one ComprehensionMetric.
     * @example
     * // Update one ComprehensionMetric
     * const comprehensionMetric = await prisma.comprehensionMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComprehensionMetricUpdateArgs>(args: SelectSubset<T, ComprehensionMetricUpdateArgs<ExtArgs>>): Prisma__ComprehensionMetricClient<$Result.GetResult<Prisma.$ComprehensionMetricPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ComprehensionMetrics.
     * @param {ComprehensionMetricDeleteManyArgs} args - Arguments to filter ComprehensionMetrics to delete.
     * @example
     * // Delete a few ComprehensionMetrics
     * const { count } = await prisma.comprehensionMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComprehensionMetricDeleteManyArgs>(args?: SelectSubset<T, ComprehensionMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComprehensionMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprehensionMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComprehensionMetrics
     * const comprehensionMetric = await prisma.comprehensionMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComprehensionMetricUpdateManyArgs>(args: SelectSubset<T, ComprehensionMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ComprehensionMetric.
     * @param {ComprehensionMetricUpsertArgs} args - Arguments to update or create a ComprehensionMetric.
     * @example
     * // Update or create a ComprehensionMetric
     * const comprehensionMetric = await prisma.comprehensionMetric.upsert({
     *   create: {
     *     // ... data to create a ComprehensionMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComprehensionMetric we want to update
     *   }
     * })
     */
    upsert<T extends ComprehensionMetricUpsertArgs>(args: SelectSubset<T, ComprehensionMetricUpsertArgs<ExtArgs>>): Prisma__ComprehensionMetricClient<$Result.GetResult<Prisma.$ComprehensionMetricPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ComprehensionMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprehensionMetricCountArgs} args - Arguments to filter ComprehensionMetrics to count.
     * @example
     * // Count the number of ComprehensionMetrics
     * const count = await prisma.comprehensionMetric.count({
     *   where: {
     *     // ... the filter for the ComprehensionMetrics we want to count
     *   }
     * })
    **/
    count<T extends ComprehensionMetricCountArgs>(
      args?: Subset<T, ComprehensionMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComprehensionMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComprehensionMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprehensionMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComprehensionMetricAggregateArgs>(args: Subset<T, ComprehensionMetricAggregateArgs>): Prisma.PrismaPromise<GetComprehensionMetricAggregateType<T>>

    /**
     * Group by ComprehensionMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprehensionMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComprehensionMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComprehensionMetricGroupByArgs['orderBy'] }
        : { orderBy?: ComprehensionMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComprehensionMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComprehensionMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComprehensionMetric model
   */
  readonly fields: ComprehensionMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComprehensionMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComprehensionMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComprehensionMetric model
   */ 
  interface ComprehensionMetricFieldRefs {
    readonly id: FieldRef<"ComprehensionMetric", 'String'>
    readonly conceptName: FieldRef<"ComprehensionMetric", 'String'>
    readonly date: FieldRef<"ComprehensionMetric", 'DateTime'>
    readonly avgScore: FieldRef<"ComprehensionMetric", 'Float'>
    readonly sampleSize: FieldRef<"ComprehensionMetric", 'Int'>
    readonly trend: FieldRef<"ComprehensionMetric", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ComprehensionMetric findUnique
   */
  export type ComprehensionMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComprehensionMetric
     */
    select?: ComprehensionMetricSelect<ExtArgs> | null
    /**
     * Filter, which ComprehensionMetric to fetch.
     */
    where: ComprehensionMetricWhereUniqueInput
  }

  /**
   * ComprehensionMetric findUniqueOrThrow
   */
  export type ComprehensionMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComprehensionMetric
     */
    select?: ComprehensionMetricSelect<ExtArgs> | null
    /**
     * Filter, which ComprehensionMetric to fetch.
     */
    where: ComprehensionMetricWhereUniqueInput
  }

  /**
   * ComprehensionMetric findFirst
   */
  export type ComprehensionMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComprehensionMetric
     */
    select?: ComprehensionMetricSelect<ExtArgs> | null
    /**
     * Filter, which ComprehensionMetric to fetch.
     */
    where?: ComprehensionMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComprehensionMetrics to fetch.
     */
    orderBy?: ComprehensionMetricOrderByWithRelationInput | ComprehensionMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComprehensionMetrics.
     */
    cursor?: ComprehensionMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComprehensionMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComprehensionMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComprehensionMetrics.
     */
    distinct?: ComprehensionMetricScalarFieldEnum | ComprehensionMetricScalarFieldEnum[]
  }

  /**
   * ComprehensionMetric findFirstOrThrow
   */
  export type ComprehensionMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComprehensionMetric
     */
    select?: ComprehensionMetricSelect<ExtArgs> | null
    /**
     * Filter, which ComprehensionMetric to fetch.
     */
    where?: ComprehensionMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComprehensionMetrics to fetch.
     */
    orderBy?: ComprehensionMetricOrderByWithRelationInput | ComprehensionMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComprehensionMetrics.
     */
    cursor?: ComprehensionMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComprehensionMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComprehensionMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComprehensionMetrics.
     */
    distinct?: ComprehensionMetricScalarFieldEnum | ComprehensionMetricScalarFieldEnum[]
  }

  /**
   * ComprehensionMetric findMany
   */
  export type ComprehensionMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComprehensionMetric
     */
    select?: ComprehensionMetricSelect<ExtArgs> | null
    /**
     * Filter, which ComprehensionMetrics to fetch.
     */
    where?: ComprehensionMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComprehensionMetrics to fetch.
     */
    orderBy?: ComprehensionMetricOrderByWithRelationInput | ComprehensionMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComprehensionMetrics.
     */
    cursor?: ComprehensionMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComprehensionMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComprehensionMetrics.
     */
    skip?: number
    distinct?: ComprehensionMetricScalarFieldEnum | ComprehensionMetricScalarFieldEnum[]
  }

  /**
   * ComprehensionMetric create
   */
  export type ComprehensionMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComprehensionMetric
     */
    select?: ComprehensionMetricSelect<ExtArgs> | null
    /**
     * The data needed to create a ComprehensionMetric.
     */
    data: XOR<ComprehensionMetricCreateInput, ComprehensionMetricUncheckedCreateInput>
  }

  /**
   * ComprehensionMetric createMany
   */
  export type ComprehensionMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComprehensionMetrics.
     */
    data: ComprehensionMetricCreateManyInput | ComprehensionMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComprehensionMetric createManyAndReturn
   */
  export type ComprehensionMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComprehensionMetric
     */
    select?: ComprehensionMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ComprehensionMetrics.
     */
    data: ComprehensionMetricCreateManyInput | ComprehensionMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComprehensionMetric update
   */
  export type ComprehensionMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComprehensionMetric
     */
    select?: ComprehensionMetricSelect<ExtArgs> | null
    /**
     * The data needed to update a ComprehensionMetric.
     */
    data: XOR<ComprehensionMetricUpdateInput, ComprehensionMetricUncheckedUpdateInput>
    /**
     * Choose, which ComprehensionMetric to update.
     */
    where: ComprehensionMetricWhereUniqueInput
  }

  /**
   * ComprehensionMetric updateMany
   */
  export type ComprehensionMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComprehensionMetrics.
     */
    data: XOR<ComprehensionMetricUpdateManyMutationInput, ComprehensionMetricUncheckedUpdateManyInput>
    /**
     * Filter which ComprehensionMetrics to update
     */
    where?: ComprehensionMetricWhereInput
  }

  /**
   * ComprehensionMetric upsert
   */
  export type ComprehensionMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComprehensionMetric
     */
    select?: ComprehensionMetricSelect<ExtArgs> | null
    /**
     * The filter to search for the ComprehensionMetric to update in case it exists.
     */
    where: ComprehensionMetricWhereUniqueInput
    /**
     * In case the ComprehensionMetric found by the `where` argument doesn't exist, create a new ComprehensionMetric with this data.
     */
    create: XOR<ComprehensionMetricCreateInput, ComprehensionMetricUncheckedCreateInput>
    /**
     * In case the ComprehensionMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComprehensionMetricUpdateInput, ComprehensionMetricUncheckedUpdateInput>
  }

  /**
   * ComprehensionMetric delete
   */
  export type ComprehensionMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComprehensionMetric
     */
    select?: ComprehensionMetricSelect<ExtArgs> | null
    /**
     * Filter which ComprehensionMetric to delete.
     */
    where: ComprehensionMetricWhereUniqueInput
  }

  /**
   * ComprehensionMetric deleteMany
   */
  export type ComprehensionMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComprehensionMetrics to delete
     */
    where?: ComprehensionMetricWhereInput
  }

  /**
   * ComprehensionMetric without action
   */
  export type ComprehensionMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComprehensionMetric
     */
    select?: ComprehensionMetricSelect<ExtArgs> | null
  }


  /**
   * Model BehavioralEvent
   */

  export type AggregateBehavioralEvent = {
    _count: BehavioralEventCountAggregateOutputType | null
    _avg: BehavioralEventAvgAggregateOutputType | null
    _sum: BehavioralEventSumAggregateOutputType | null
    _min: BehavioralEventMinAggregateOutputType | null
    _max: BehavioralEventMaxAggregateOutputType | null
  }

  export type BehavioralEventAvgAggregateOutputType = {
    sessionPerformanceScore: number | null
    timeOfDay: number | null
    dayOfWeek: number | null
  }

  export type BehavioralEventSumAggregateOutputType = {
    sessionPerformanceScore: number | null
    timeOfDay: number | null
    dayOfWeek: number | null
  }

  export type BehavioralEventMinAggregateOutputType = {
    id: string | null
    userId: string | null
    eventType: $Enums.EventType | null
    timestamp: Date | null
    sessionPerformanceScore: number | null
    engagementLevel: $Enums.EngagementLevel | null
    completionQuality: $Enums.CompletionQuality | null
    timeOfDay: number | null
    dayOfWeek: number | null
    contentType: string | null
    difficultyLevel: string | null
  }

  export type BehavioralEventMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    eventType: $Enums.EventType | null
    timestamp: Date | null
    sessionPerformanceScore: number | null
    engagementLevel: $Enums.EngagementLevel | null
    completionQuality: $Enums.CompletionQuality | null
    timeOfDay: number | null
    dayOfWeek: number | null
    contentType: string | null
    difficultyLevel: string | null
  }

  export type BehavioralEventCountAggregateOutputType = {
    id: number
    userId: number
    eventType: number
    eventData: number
    timestamp: number
    sessionPerformanceScore: number
    engagementLevel: number
    completionQuality: number
    timeOfDay: number
    dayOfWeek: number
    contentType: number
    difficultyLevel: number
    _all: number
  }


  export type BehavioralEventAvgAggregateInputType = {
    sessionPerformanceScore?: true
    timeOfDay?: true
    dayOfWeek?: true
  }

  export type BehavioralEventSumAggregateInputType = {
    sessionPerformanceScore?: true
    timeOfDay?: true
    dayOfWeek?: true
  }

  export type BehavioralEventMinAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    timestamp?: true
    sessionPerformanceScore?: true
    engagementLevel?: true
    completionQuality?: true
    timeOfDay?: true
    dayOfWeek?: true
    contentType?: true
    difficultyLevel?: true
  }

  export type BehavioralEventMaxAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    timestamp?: true
    sessionPerformanceScore?: true
    engagementLevel?: true
    completionQuality?: true
    timeOfDay?: true
    dayOfWeek?: true
    contentType?: true
    difficultyLevel?: true
  }

  export type BehavioralEventCountAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    eventData?: true
    timestamp?: true
    sessionPerformanceScore?: true
    engagementLevel?: true
    completionQuality?: true
    timeOfDay?: true
    dayOfWeek?: true
    contentType?: true
    difficultyLevel?: true
    _all?: true
  }

  export type BehavioralEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BehavioralEvent to aggregate.
     */
    where?: BehavioralEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehavioralEvents to fetch.
     */
    orderBy?: BehavioralEventOrderByWithRelationInput | BehavioralEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BehavioralEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehavioralEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehavioralEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BehavioralEvents
    **/
    _count?: true | BehavioralEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BehavioralEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BehavioralEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BehavioralEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BehavioralEventMaxAggregateInputType
  }

  export type GetBehavioralEventAggregateType<T extends BehavioralEventAggregateArgs> = {
        [P in keyof T & keyof AggregateBehavioralEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBehavioralEvent[P]>
      : GetScalarType<T[P], AggregateBehavioralEvent[P]>
  }




  export type BehavioralEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BehavioralEventWhereInput
    orderBy?: BehavioralEventOrderByWithAggregationInput | BehavioralEventOrderByWithAggregationInput[]
    by: BehavioralEventScalarFieldEnum[] | BehavioralEventScalarFieldEnum
    having?: BehavioralEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BehavioralEventCountAggregateInputType | true
    _avg?: BehavioralEventAvgAggregateInputType
    _sum?: BehavioralEventSumAggregateInputType
    _min?: BehavioralEventMinAggregateInputType
    _max?: BehavioralEventMaxAggregateInputType
  }

  export type BehavioralEventGroupByOutputType = {
    id: string
    userId: string
    eventType: $Enums.EventType
    eventData: JsonValue
    timestamp: Date
    sessionPerformanceScore: number | null
    engagementLevel: $Enums.EngagementLevel | null
    completionQuality: $Enums.CompletionQuality | null
    timeOfDay: number | null
    dayOfWeek: number | null
    contentType: string | null
    difficultyLevel: string | null
    _count: BehavioralEventCountAggregateOutputType | null
    _avg: BehavioralEventAvgAggregateOutputType | null
    _sum: BehavioralEventSumAggregateOutputType | null
    _min: BehavioralEventMinAggregateOutputType | null
    _max: BehavioralEventMaxAggregateOutputType | null
  }

  type GetBehavioralEventGroupByPayload<T extends BehavioralEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BehavioralEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BehavioralEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BehavioralEventGroupByOutputType[P]>
            : GetScalarType<T[P], BehavioralEventGroupByOutputType[P]>
        }
      >
    >


  export type BehavioralEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    eventData?: boolean
    timestamp?: boolean
    sessionPerformanceScore?: boolean
    engagementLevel?: boolean
    completionQuality?: boolean
    timeOfDay?: boolean
    dayOfWeek?: boolean
    contentType?: boolean
    difficultyLevel?: boolean
  }, ExtArgs["result"]["behavioralEvent"]>

  export type BehavioralEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    eventData?: boolean
    timestamp?: boolean
    sessionPerformanceScore?: boolean
    engagementLevel?: boolean
    completionQuality?: boolean
    timeOfDay?: boolean
    dayOfWeek?: boolean
    contentType?: boolean
    difficultyLevel?: boolean
  }, ExtArgs["result"]["behavioralEvent"]>

  export type BehavioralEventSelectScalar = {
    id?: boolean
    userId?: boolean
    eventType?: boolean
    eventData?: boolean
    timestamp?: boolean
    sessionPerformanceScore?: boolean
    engagementLevel?: boolean
    completionQuality?: boolean
    timeOfDay?: boolean
    dayOfWeek?: boolean
    contentType?: boolean
    difficultyLevel?: boolean
  }


  export type $BehavioralEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BehavioralEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      eventType: $Enums.EventType
      eventData: Prisma.JsonValue
      timestamp: Date
      sessionPerformanceScore: number | null
      engagementLevel: $Enums.EngagementLevel | null
      completionQuality: $Enums.CompletionQuality | null
      timeOfDay: number | null
      dayOfWeek: number | null
      contentType: string | null
      difficultyLevel: string | null
    }, ExtArgs["result"]["behavioralEvent"]>
    composites: {}
  }

  type BehavioralEventGetPayload<S extends boolean | null | undefined | BehavioralEventDefaultArgs> = $Result.GetResult<Prisma.$BehavioralEventPayload, S>

  type BehavioralEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BehavioralEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BehavioralEventCountAggregateInputType | true
    }

  export interface BehavioralEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BehavioralEvent'], meta: { name: 'BehavioralEvent' } }
    /**
     * Find zero or one BehavioralEvent that matches the filter.
     * @param {BehavioralEventFindUniqueArgs} args - Arguments to find a BehavioralEvent
     * @example
     * // Get one BehavioralEvent
     * const behavioralEvent = await prisma.behavioralEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BehavioralEventFindUniqueArgs>(args: SelectSubset<T, BehavioralEventFindUniqueArgs<ExtArgs>>): Prisma__BehavioralEventClient<$Result.GetResult<Prisma.$BehavioralEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BehavioralEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BehavioralEventFindUniqueOrThrowArgs} args - Arguments to find a BehavioralEvent
     * @example
     * // Get one BehavioralEvent
     * const behavioralEvent = await prisma.behavioralEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BehavioralEventFindUniqueOrThrowArgs>(args: SelectSubset<T, BehavioralEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BehavioralEventClient<$Result.GetResult<Prisma.$BehavioralEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BehavioralEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralEventFindFirstArgs} args - Arguments to find a BehavioralEvent
     * @example
     * // Get one BehavioralEvent
     * const behavioralEvent = await prisma.behavioralEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BehavioralEventFindFirstArgs>(args?: SelectSubset<T, BehavioralEventFindFirstArgs<ExtArgs>>): Prisma__BehavioralEventClient<$Result.GetResult<Prisma.$BehavioralEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BehavioralEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralEventFindFirstOrThrowArgs} args - Arguments to find a BehavioralEvent
     * @example
     * // Get one BehavioralEvent
     * const behavioralEvent = await prisma.behavioralEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BehavioralEventFindFirstOrThrowArgs>(args?: SelectSubset<T, BehavioralEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__BehavioralEventClient<$Result.GetResult<Prisma.$BehavioralEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BehavioralEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BehavioralEvents
     * const behavioralEvents = await prisma.behavioralEvent.findMany()
     * 
     * // Get first 10 BehavioralEvents
     * const behavioralEvents = await prisma.behavioralEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const behavioralEventWithIdOnly = await prisma.behavioralEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BehavioralEventFindManyArgs>(args?: SelectSubset<T, BehavioralEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehavioralEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BehavioralEvent.
     * @param {BehavioralEventCreateArgs} args - Arguments to create a BehavioralEvent.
     * @example
     * // Create one BehavioralEvent
     * const BehavioralEvent = await prisma.behavioralEvent.create({
     *   data: {
     *     // ... data to create a BehavioralEvent
     *   }
     * })
     * 
     */
    create<T extends BehavioralEventCreateArgs>(args: SelectSubset<T, BehavioralEventCreateArgs<ExtArgs>>): Prisma__BehavioralEventClient<$Result.GetResult<Prisma.$BehavioralEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BehavioralEvents.
     * @param {BehavioralEventCreateManyArgs} args - Arguments to create many BehavioralEvents.
     * @example
     * // Create many BehavioralEvents
     * const behavioralEvent = await prisma.behavioralEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BehavioralEventCreateManyArgs>(args?: SelectSubset<T, BehavioralEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BehavioralEvents and returns the data saved in the database.
     * @param {BehavioralEventCreateManyAndReturnArgs} args - Arguments to create many BehavioralEvents.
     * @example
     * // Create many BehavioralEvents
     * const behavioralEvent = await prisma.behavioralEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BehavioralEvents and only return the `id`
     * const behavioralEventWithIdOnly = await prisma.behavioralEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BehavioralEventCreateManyAndReturnArgs>(args?: SelectSubset<T, BehavioralEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehavioralEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BehavioralEvent.
     * @param {BehavioralEventDeleteArgs} args - Arguments to delete one BehavioralEvent.
     * @example
     * // Delete one BehavioralEvent
     * const BehavioralEvent = await prisma.behavioralEvent.delete({
     *   where: {
     *     // ... filter to delete one BehavioralEvent
     *   }
     * })
     * 
     */
    delete<T extends BehavioralEventDeleteArgs>(args: SelectSubset<T, BehavioralEventDeleteArgs<ExtArgs>>): Prisma__BehavioralEventClient<$Result.GetResult<Prisma.$BehavioralEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BehavioralEvent.
     * @param {BehavioralEventUpdateArgs} args - Arguments to update one BehavioralEvent.
     * @example
     * // Update one BehavioralEvent
     * const behavioralEvent = await prisma.behavioralEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BehavioralEventUpdateArgs>(args: SelectSubset<T, BehavioralEventUpdateArgs<ExtArgs>>): Prisma__BehavioralEventClient<$Result.GetResult<Prisma.$BehavioralEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BehavioralEvents.
     * @param {BehavioralEventDeleteManyArgs} args - Arguments to filter BehavioralEvents to delete.
     * @example
     * // Delete a few BehavioralEvents
     * const { count } = await prisma.behavioralEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BehavioralEventDeleteManyArgs>(args?: SelectSubset<T, BehavioralEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BehavioralEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BehavioralEvents
     * const behavioralEvent = await prisma.behavioralEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BehavioralEventUpdateManyArgs>(args: SelectSubset<T, BehavioralEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BehavioralEvent.
     * @param {BehavioralEventUpsertArgs} args - Arguments to update or create a BehavioralEvent.
     * @example
     * // Update or create a BehavioralEvent
     * const behavioralEvent = await prisma.behavioralEvent.upsert({
     *   create: {
     *     // ... data to create a BehavioralEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BehavioralEvent we want to update
     *   }
     * })
     */
    upsert<T extends BehavioralEventUpsertArgs>(args: SelectSubset<T, BehavioralEventUpsertArgs<ExtArgs>>): Prisma__BehavioralEventClient<$Result.GetResult<Prisma.$BehavioralEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BehavioralEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralEventCountArgs} args - Arguments to filter BehavioralEvents to count.
     * @example
     * // Count the number of BehavioralEvents
     * const count = await prisma.behavioralEvent.count({
     *   where: {
     *     // ... the filter for the BehavioralEvents we want to count
     *   }
     * })
    **/
    count<T extends BehavioralEventCountArgs>(
      args?: Subset<T, BehavioralEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BehavioralEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BehavioralEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BehavioralEventAggregateArgs>(args: Subset<T, BehavioralEventAggregateArgs>): Prisma.PrismaPromise<GetBehavioralEventAggregateType<T>>

    /**
     * Group by BehavioralEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BehavioralEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BehavioralEventGroupByArgs['orderBy'] }
        : { orderBy?: BehavioralEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BehavioralEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBehavioralEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BehavioralEvent model
   */
  readonly fields: BehavioralEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BehavioralEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BehavioralEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BehavioralEvent model
   */ 
  interface BehavioralEventFieldRefs {
    readonly id: FieldRef<"BehavioralEvent", 'String'>
    readonly userId: FieldRef<"BehavioralEvent", 'String'>
    readonly eventType: FieldRef<"BehavioralEvent", 'EventType'>
    readonly eventData: FieldRef<"BehavioralEvent", 'Json'>
    readonly timestamp: FieldRef<"BehavioralEvent", 'DateTime'>
    readonly sessionPerformanceScore: FieldRef<"BehavioralEvent", 'Int'>
    readonly engagementLevel: FieldRef<"BehavioralEvent", 'EngagementLevel'>
    readonly completionQuality: FieldRef<"BehavioralEvent", 'CompletionQuality'>
    readonly timeOfDay: FieldRef<"BehavioralEvent", 'Int'>
    readonly dayOfWeek: FieldRef<"BehavioralEvent", 'Int'>
    readonly contentType: FieldRef<"BehavioralEvent", 'String'>
    readonly difficultyLevel: FieldRef<"BehavioralEvent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BehavioralEvent findUnique
   */
  export type BehavioralEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralEvent
     */
    select?: BehavioralEventSelect<ExtArgs> | null
    /**
     * Filter, which BehavioralEvent to fetch.
     */
    where: BehavioralEventWhereUniqueInput
  }

  /**
   * BehavioralEvent findUniqueOrThrow
   */
  export type BehavioralEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralEvent
     */
    select?: BehavioralEventSelect<ExtArgs> | null
    /**
     * Filter, which BehavioralEvent to fetch.
     */
    where: BehavioralEventWhereUniqueInput
  }

  /**
   * BehavioralEvent findFirst
   */
  export type BehavioralEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralEvent
     */
    select?: BehavioralEventSelect<ExtArgs> | null
    /**
     * Filter, which BehavioralEvent to fetch.
     */
    where?: BehavioralEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehavioralEvents to fetch.
     */
    orderBy?: BehavioralEventOrderByWithRelationInput | BehavioralEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BehavioralEvents.
     */
    cursor?: BehavioralEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehavioralEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehavioralEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BehavioralEvents.
     */
    distinct?: BehavioralEventScalarFieldEnum | BehavioralEventScalarFieldEnum[]
  }

  /**
   * BehavioralEvent findFirstOrThrow
   */
  export type BehavioralEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralEvent
     */
    select?: BehavioralEventSelect<ExtArgs> | null
    /**
     * Filter, which BehavioralEvent to fetch.
     */
    where?: BehavioralEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehavioralEvents to fetch.
     */
    orderBy?: BehavioralEventOrderByWithRelationInput | BehavioralEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BehavioralEvents.
     */
    cursor?: BehavioralEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehavioralEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehavioralEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BehavioralEvents.
     */
    distinct?: BehavioralEventScalarFieldEnum | BehavioralEventScalarFieldEnum[]
  }

  /**
   * BehavioralEvent findMany
   */
  export type BehavioralEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralEvent
     */
    select?: BehavioralEventSelect<ExtArgs> | null
    /**
     * Filter, which BehavioralEvents to fetch.
     */
    where?: BehavioralEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehavioralEvents to fetch.
     */
    orderBy?: BehavioralEventOrderByWithRelationInput | BehavioralEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BehavioralEvents.
     */
    cursor?: BehavioralEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehavioralEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehavioralEvents.
     */
    skip?: number
    distinct?: BehavioralEventScalarFieldEnum | BehavioralEventScalarFieldEnum[]
  }

  /**
   * BehavioralEvent create
   */
  export type BehavioralEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralEvent
     */
    select?: BehavioralEventSelect<ExtArgs> | null
    /**
     * The data needed to create a BehavioralEvent.
     */
    data: XOR<BehavioralEventCreateInput, BehavioralEventUncheckedCreateInput>
  }

  /**
   * BehavioralEvent createMany
   */
  export type BehavioralEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BehavioralEvents.
     */
    data: BehavioralEventCreateManyInput | BehavioralEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BehavioralEvent createManyAndReturn
   */
  export type BehavioralEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralEvent
     */
    select?: BehavioralEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BehavioralEvents.
     */
    data: BehavioralEventCreateManyInput | BehavioralEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BehavioralEvent update
   */
  export type BehavioralEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralEvent
     */
    select?: BehavioralEventSelect<ExtArgs> | null
    /**
     * The data needed to update a BehavioralEvent.
     */
    data: XOR<BehavioralEventUpdateInput, BehavioralEventUncheckedUpdateInput>
    /**
     * Choose, which BehavioralEvent to update.
     */
    where: BehavioralEventWhereUniqueInput
  }

  /**
   * BehavioralEvent updateMany
   */
  export type BehavioralEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BehavioralEvents.
     */
    data: XOR<BehavioralEventUpdateManyMutationInput, BehavioralEventUncheckedUpdateManyInput>
    /**
     * Filter which BehavioralEvents to update
     */
    where?: BehavioralEventWhereInput
  }

  /**
   * BehavioralEvent upsert
   */
  export type BehavioralEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralEvent
     */
    select?: BehavioralEventSelect<ExtArgs> | null
    /**
     * The filter to search for the BehavioralEvent to update in case it exists.
     */
    where: BehavioralEventWhereUniqueInput
    /**
     * In case the BehavioralEvent found by the `where` argument doesn't exist, create a new BehavioralEvent with this data.
     */
    create: XOR<BehavioralEventCreateInput, BehavioralEventUncheckedCreateInput>
    /**
     * In case the BehavioralEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BehavioralEventUpdateInput, BehavioralEventUncheckedUpdateInput>
  }

  /**
   * BehavioralEvent delete
   */
  export type BehavioralEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralEvent
     */
    select?: BehavioralEventSelect<ExtArgs> | null
    /**
     * Filter which BehavioralEvent to delete.
     */
    where: BehavioralEventWhereUniqueInput
  }

  /**
   * BehavioralEvent deleteMany
   */
  export type BehavioralEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BehavioralEvents to delete
     */
    where?: BehavioralEventWhereInput
  }

  /**
   * BehavioralEvent without action
   */
  export type BehavioralEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralEvent
     */
    select?: BehavioralEventSelect<ExtArgs> | null
  }


  /**
   * Model BehavioralPattern
   */

  export type AggregateBehavioralPattern = {
    _count: BehavioralPatternCountAggregateOutputType | null
    _avg: BehavioralPatternAvgAggregateOutputType | null
    _sum: BehavioralPatternSumAggregateOutputType | null
    _min: BehavioralPatternMinAggregateOutputType | null
    _max: BehavioralPatternMaxAggregateOutputType | null
  }

  export type BehavioralPatternAvgAggregateOutputType = {
    confidence: number | null
    occurrenceCount: number | null
  }

  export type BehavioralPatternSumAggregateOutputType = {
    confidence: number | null
    occurrenceCount: number | null
  }

  export type BehavioralPatternMinAggregateOutputType = {
    id: string | null
    userId: string | null
    patternType: $Enums.BehavioralPatternType | null
    patternName: string | null
    confidence: number | null
    detectedAt: Date | null
    lastSeenAt: Date | null
    occurrenceCount: number | null
  }

  export type BehavioralPatternMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    patternType: $Enums.BehavioralPatternType | null
    patternName: string | null
    confidence: number | null
    detectedAt: Date | null
    lastSeenAt: Date | null
    occurrenceCount: number | null
  }

  export type BehavioralPatternCountAggregateOutputType = {
    id: number
    userId: number
    patternType: number
    patternName: number
    confidence: number
    evidence: number
    detectedAt: number
    lastSeenAt: number
    occurrenceCount: number
    _all: number
  }


  export type BehavioralPatternAvgAggregateInputType = {
    confidence?: true
    occurrenceCount?: true
  }

  export type BehavioralPatternSumAggregateInputType = {
    confidence?: true
    occurrenceCount?: true
  }

  export type BehavioralPatternMinAggregateInputType = {
    id?: true
    userId?: true
    patternType?: true
    patternName?: true
    confidence?: true
    detectedAt?: true
    lastSeenAt?: true
    occurrenceCount?: true
  }

  export type BehavioralPatternMaxAggregateInputType = {
    id?: true
    userId?: true
    patternType?: true
    patternName?: true
    confidence?: true
    detectedAt?: true
    lastSeenAt?: true
    occurrenceCount?: true
  }

  export type BehavioralPatternCountAggregateInputType = {
    id?: true
    userId?: true
    patternType?: true
    patternName?: true
    confidence?: true
    evidence?: true
    detectedAt?: true
    lastSeenAt?: true
    occurrenceCount?: true
    _all?: true
  }

  export type BehavioralPatternAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BehavioralPattern to aggregate.
     */
    where?: BehavioralPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehavioralPatterns to fetch.
     */
    orderBy?: BehavioralPatternOrderByWithRelationInput | BehavioralPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BehavioralPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehavioralPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehavioralPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BehavioralPatterns
    **/
    _count?: true | BehavioralPatternCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BehavioralPatternAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BehavioralPatternSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BehavioralPatternMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BehavioralPatternMaxAggregateInputType
  }

  export type GetBehavioralPatternAggregateType<T extends BehavioralPatternAggregateArgs> = {
        [P in keyof T & keyof AggregateBehavioralPattern]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBehavioralPattern[P]>
      : GetScalarType<T[P], AggregateBehavioralPattern[P]>
  }




  export type BehavioralPatternGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BehavioralPatternWhereInput
    orderBy?: BehavioralPatternOrderByWithAggregationInput | BehavioralPatternOrderByWithAggregationInput[]
    by: BehavioralPatternScalarFieldEnum[] | BehavioralPatternScalarFieldEnum
    having?: BehavioralPatternScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BehavioralPatternCountAggregateInputType | true
    _avg?: BehavioralPatternAvgAggregateInputType
    _sum?: BehavioralPatternSumAggregateInputType
    _min?: BehavioralPatternMinAggregateInputType
    _max?: BehavioralPatternMaxAggregateInputType
  }

  export type BehavioralPatternGroupByOutputType = {
    id: string
    userId: string
    patternType: $Enums.BehavioralPatternType
    patternName: string
    confidence: number
    evidence: JsonValue
    detectedAt: Date
    lastSeenAt: Date
    occurrenceCount: number
    _count: BehavioralPatternCountAggregateOutputType | null
    _avg: BehavioralPatternAvgAggregateOutputType | null
    _sum: BehavioralPatternSumAggregateOutputType | null
    _min: BehavioralPatternMinAggregateOutputType | null
    _max: BehavioralPatternMaxAggregateOutputType | null
  }

  type GetBehavioralPatternGroupByPayload<T extends BehavioralPatternGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BehavioralPatternGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BehavioralPatternGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BehavioralPatternGroupByOutputType[P]>
            : GetScalarType<T[P], BehavioralPatternGroupByOutputType[P]>
        }
      >
    >


  export type BehavioralPatternSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    patternType?: boolean
    patternName?: boolean
    confidence?: boolean
    evidence?: boolean
    detectedAt?: boolean
    lastSeenAt?: boolean
    occurrenceCount?: boolean
    insights?: boolean | BehavioralPattern$insightsArgs<ExtArgs>
    _count?: boolean | BehavioralPatternCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["behavioralPattern"]>

  export type BehavioralPatternSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    patternType?: boolean
    patternName?: boolean
    confidence?: boolean
    evidence?: boolean
    detectedAt?: boolean
    lastSeenAt?: boolean
    occurrenceCount?: boolean
  }, ExtArgs["result"]["behavioralPattern"]>

  export type BehavioralPatternSelectScalar = {
    id?: boolean
    userId?: boolean
    patternType?: boolean
    patternName?: boolean
    confidence?: boolean
    evidence?: boolean
    detectedAt?: boolean
    lastSeenAt?: boolean
    occurrenceCount?: boolean
  }

  export type BehavioralPatternInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insights?: boolean | BehavioralPattern$insightsArgs<ExtArgs>
    _count?: boolean | BehavioralPatternCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BehavioralPatternIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BehavioralPatternPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BehavioralPattern"
    objects: {
      insights: Prisma.$InsightPatternPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      patternType: $Enums.BehavioralPatternType
      patternName: string
      confidence: number
      evidence: Prisma.JsonValue
      detectedAt: Date
      lastSeenAt: Date
      occurrenceCount: number
    }, ExtArgs["result"]["behavioralPattern"]>
    composites: {}
  }

  type BehavioralPatternGetPayload<S extends boolean | null | undefined | BehavioralPatternDefaultArgs> = $Result.GetResult<Prisma.$BehavioralPatternPayload, S>

  type BehavioralPatternCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BehavioralPatternFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BehavioralPatternCountAggregateInputType | true
    }

  export interface BehavioralPatternDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BehavioralPattern'], meta: { name: 'BehavioralPattern' } }
    /**
     * Find zero or one BehavioralPattern that matches the filter.
     * @param {BehavioralPatternFindUniqueArgs} args - Arguments to find a BehavioralPattern
     * @example
     * // Get one BehavioralPattern
     * const behavioralPattern = await prisma.behavioralPattern.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BehavioralPatternFindUniqueArgs>(args: SelectSubset<T, BehavioralPatternFindUniqueArgs<ExtArgs>>): Prisma__BehavioralPatternClient<$Result.GetResult<Prisma.$BehavioralPatternPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BehavioralPattern that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BehavioralPatternFindUniqueOrThrowArgs} args - Arguments to find a BehavioralPattern
     * @example
     * // Get one BehavioralPattern
     * const behavioralPattern = await prisma.behavioralPattern.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BehavioralPatternFindUniqueOrThrowArgs>(args: SelectSubset<T, BehavioralPatternFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BehavioralPatternClient<$Result.GetResult<Prisma.$BehavioralPatternPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BehavioralPattern that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralPatternFindFirstArgs} args - Arguments to find a BehavioralPattern
     * @example
     * // Get one BehavioralPattern
     * const behavioralPattern = await prisma.behavioralPattern.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BehavioralPatternFindFirstArgs>(args?: SelectSubset<T, BehavioralPatternFindFirstArgs<ExtArgs>>): Prisma__BehavioralPatternClient<$Result.GetResult<Prisma.$BehavioralPatternPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BehavioralPattern that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralPatternFindFirstOrThrowArgs} args - Arguments to find a BehavioralPattern
     * @example
     * // Get one BehavioralPattern
     * const behavioralPattern = await prisma.behavioralPattern.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BehavioralPatternFindFirstOrThrowArgs>(args?: SelectSubset<T, BehavioralPatternFindFirstOrThrowArgs<ExtArgs>>): Prisma__BehavioralPatternClient<$Result.GetResult<Prisma.$BehavioralPatternPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BehavioralPatterns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralPatternFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BehavioralPatterns
     * const behavioralPatterns = await prisma.behavioralPattern.findMany()
     * 
     * // Get first 10 BehavioralPatterns
     * const behavioralPatterns = await prisma.behavioralPattern.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const behavioralPatternWithIdOnly = await prisma.behavioralPattern.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BehavioralPatternFindManyArgs>(args?: SelectSubset<T, BehavioralPatternFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehavioralPatternPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BehavioralPattern.
     * @param {BehavioralPatternCreateArgs} args - Arguments to create a BehavioralPattern.
     * @example
     * // Create one BehavioralPattern
     * const BehavioralPattern = await prisma.behavioralPattern.create({
     *   data: {
     *     // ... data to create a BehavioralPattern
     *   }
     * })
     * 
     */
    create<T extends BehavioralPatternCreateArgs>(args: SelectSubset<T, BehavioralPatternCreateArgs<ExtArgs>>): Prisma__BehavioralPatternClient<$Result.GetResult<Prisma.$BehavioralPatternPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BehavioralPatterns.
     * @param {BehavioralPatternCreateManyArgs} args - Arguments to create many BehavioralPatterns.
     * @example
     * // Create many BehavioralPatterns
     * const behavioralPattern = await prisma.behavioralPattern.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BehavioralPatternCreateManyArgs>(args?: SelectSubset<T, BehavioralPatternCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BehavioralPatterns and returns the data saved in the database.
     * @param {BehavioralPatternCreateManyAndReturnArgs} args - Arguments to create many BehavioralPatterns.
     * @example
     * // Create many BehavioralPatterns
     * const behavioralPattern = await prisma.behavioralPattern.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BehavioralPatterns and only return the `id`
     * const behavioralPatternWithIdOnly = await prisma.behavioralPattern.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BehavioralPatternCreateManyAndReturnArgs>(args?: SelectSubset<T, BehavioralPatternCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehavioralPatternPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BehavioralPattern.
     * @param {BehavioralPatternDeleteArgs} args - Arguments to delete one BehavioralPattern.
     * @example
     * // Delete one BehavioralPattern
     * const BehavioralPattern = await prisma.behavioralPattern.delete({
     *   where: {
     *     // ... filter to delete one BehavioralPattern
     *   }
     * })
     * 
     */
    delete<T extends BehavioralPatternDeleteArgs>(args: SelectSubset<T, BehavioralPatternDeleteArgs<ExtArgs>>): Prisma__BehavioralPatternClient<$Result.GetResult<Prisma.$BehavioralPatternPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BehavioralPattern.
     * @param {BehavioralPatternUpdateArgs} args - Arguments to update one BehavioralPattern.
     * @example
     * // Update one BehavioralPattern
     * const behavioralPattern = await prisma.behavioralPattern.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BehavioralPatternUpdateArgs>(args: SelectSubset<T, BehavioralPatternUpdateArgs<ExtArgs>>): Prisma__BehavioralPatternClient<$Result.GetResult<Prisma.$BehavioralPatternPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BehavioralPatterns.
     * @param {BehavioralPatternDeleteManyArgs} args - Arguments to filter BehavioralPatterns to delete.
     * @example
     * // Delete a few BehavioralPatterns
     * const { count } = await prisma.behavioralPattern.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BehavioralPatternDeleteManyArgs>(args?: SelectSubset<T, BehavioralPatternDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BehavioralPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralPatternUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BehavioralPatterns
     * const behavioralPattern = await prisma.behavioralPattern.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BehavioralPatternUpdateManyArgs>(args: SelectSubset<T, BehavioralPatternUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BehavioralPattern.
     * @param {BehavioralPatternUpsertArgs} args - Arguments to update or create a BehavioralPattern.
     * @example
     * // Update or create a BehavioralPattern
     * const behavioralPattern = await prisma.behavioralPattern.upsert({
     *   create: {
     *     // ... data to create a BehavioralPattern
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BehavioralPattern we want to update
     *   }
     * })
     */
    upsert<T extends BehavioralPatternUpsertArgs>(args: SelectSubset<T, BehavioralPatternUpsertArgs<ExtArgs>>): Prisma__BehavioralPatternClient<$Result.GetResult<Prisma.$BehavioralPatternPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BehavioralPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralPatternCountArgs} args - Arguments to filter BehavioralPatterns to count.
     * @example
     * // Count the number of BehavioralPatterns
     * const count = await prisma.behavioralPattern.count({
     *   where: {
     *     // ... the filter for the BehavioralPatterns we want to count
     *   }
     * })
    **/
    count<T extends BehavioralPatternCountArgs>(
      args?: Subset<T, BehavioralPatternCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BehavioralPatternCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BehavioralPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralPatternAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BehavioralPatternAggregateArgs>(args: Subset<T, BehavioralPatternAggregateArgs>): Prisma.PrismaPromise<GetBehavioralPatternAggregateType<T>>

    /**
     * Group by BehavioralPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralPatternGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BehavioralPatternGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BehavioralPatternGroupByArgs['orderBy'] }
        : { orderBy?: BehavioralPatternGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BehavioralPatternGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBehavioralPatternGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BehavioralPattern model
   */
  readonly fields: BehavioralPatternFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BehavioralPattern.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BehavioralPatternClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insights<T extends BehavioralPattern$insightsArgs<ExtArgs> = {}>(args?: Subset<T, BehavioralPattern$insightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BehavioralPattern model
   */ 
  interface BehavioralPatternFieldRefs {
    readonly id: FieldRef<"BehavioralPattern", 'String'>
    readonly userId: FieldRef<"BehavioralPattern", 'String'>
    readonly patternType: FieldRef<"BehavioralPattern", 'BehavioralPatternType'>
    readonly patternName: FieldRef<"BehavioralPattern", 'String'>
    readonly confidence: FieldRef<"BehavioralPattern", 'Float'>
    readonly evidence: FieldRef<"BehavioralPattern", 'Json'>
    readonly detectedAt: FieldRef<"BehavioralPattern", 'DateTime'>
    readonly lastSeenAt: FieldRef<"BehavioralPattern", 'DateTime'>
    readonly occurrenceCount: FieldRef<"BehavioralPattern", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BehavioralPattern findUnique
   */
  export type BehavioralPatternFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralPattern
     */
    select?: BehavioralPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralPatternInclude<ExtArgs> | null
    /**
     * Filter, which BehavioralPattern to fetch.
     */
    where: BehavioralPatternWhereUniqueInput
  }

  /**
   * BehavioralPattern findUniqueOrThrow
   */
  export type BehavioralPatternFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralPattern
     */
    select?: BehavioralPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralPatternInclude<ExtArgs> | null
    /**
     * Filter, which BehavioralPattern to fetch.
     */
    where: BehavioralPatternWhereUniqueInput
  }

  /**
   * BehavioralPattern findFirst
   */
  export type BehavioralPatternFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralPattern
     */
    select?: BehavioralPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralPatternInclude<ExtArgs> | null
    /**
     * Filter, which BehavioralPattern to fetch.
     */
    where?: BehavioralPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehavioralPatterns to fetch.
     */
    orderBy?: BehavioralPatternOrderByWithRelationInput | BehavioralPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BehavioralPatterns.
     */
    cursor?: BehavioralPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehavioralPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehavioralPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BehavioralPatterns.
     */
    distinct?: BehavioralPatternScalarFieldEnum | BehavioralPatternScalarFieldEnum[]
  }

  /**
   * BehavioralPattern findFirstOrThrow
   */
  export type BehavioralPatternFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralPattern
     */
    select?: BehavioralPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralPatternInclude<ExtArgs> | null
    /**
     * Filter, which BehavioralPattern to fetch.
     */
    where?: BehavioralPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehavioralPatterns to fetch.
     */
    orderBy?: BehavioralPatternOrderByWithRelationInput | BehavioralPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BehavioralPatterns.
     */
    cursor?: BehavioralPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehavioralPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehavioralPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BehavioralPatterns.
     */
    distinct?: BehavioralPatternScalarFieldEnum | BehavioralPatternScalarFieldEnum[]
  }

  /**
   * BehavioralPattern findMany
   */
  export type BehavioralPatternFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralPattern
     */
    select?: BehavioralPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralPatternInclude<ExtArgs> | null
    /**
     * Filter, which BehavioralPatterns to fetch.
     */
    where?: BehavioralPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehavioralPatterns to fetch.
     */
    orderBy?: BehavioralPatternOrderByWithRelationInput | BehavioralPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BehavioralPatterns.
     */
    cursor?: BehavioralPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehavioralPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehavioralPatterns.
     */
    skip?: number
    distinct?: BehavioralPatternScalarFieldEnum | BehavioralPatternScalarFieldEnum[]
  }

  /**
   * BehavioralPattern create
   */
  export type BehavioralPatternCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralPattern
     */
    select?: BehavioralPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralPatternInclude<ExtArgs> | null
    /**
     * The data needed to create a BehavioralPattern.
     */
    data: XOR<BehavioralPatternCreateInput, BehavioralPatternUncheckedCreateInput>
  }

  /**
   * BehavioralPattern createMany
   */
  export type BehavioralPatternCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BehavioralPatterns.
     */
    data: BehavioralPatternCreateManyInput | BehavioralPatternCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BehavioralPattern createManyAndReturn
   */
  export type BehavioralPatternCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralPattern
     */
    select?: BehavioralPatternSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BehavioralPatterns.
     */
    data: BehavioralPatternCreateManyInput | BehavioralPatternCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BehavioralPattern update
   */
  export type BehavioralPatternUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralPattern
     */
    select?: BehavioralPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralPatternInclude<ExtArgs> | null
    /**
     * The data needed to update a BehavioralPattern.
     */
    data: XOR<BehavioralPatternUpdateInput, BehavioralPatternUncheckedUpdateInput>
    /**
     * Choose, which BehavioralPattern to update.
     */
    where: BehavioralPatternWhereUniqueInput
  }

  /**
   * BehavioralPattern updateMany
   */
  export type BehavioralPatternUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BehavioralPatterns.
     */
    data: XOR<BehavioralPatternUpdateManyMutationInput, BehavioralPatternUncheckedUpdateManyInput>
    /**
     * Filter which BehavioralPatterns to update
     */
    where?: BehavioralPatternWhereInput
  }

  /**
   * BehavioralPattern upsert
   */
  export type BehavioralPatternUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralPattern
     */
    select?: BehavioralPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralPatternInclude<ExtArgs> | null
    /**
     * The filter to search for the BehavioralPattern to update in case it exists.
     */
    where: BehavioralPatternWhereUniqueInput
    /**
     * In case the BehavioralPattern found by the `where` argument doesn't exist, create a new BehavioralPattern with this data.
     */
    create: XOR<BehavioralPatternCreateInput, BehavioralPatternUncheckedCreateInput>
    /**
     * In case the BehavioralPattern was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BehavioralPatternUpdateInput, BehavioralPatternUncheckedUpdateInput>
  }

  /**
   * BehavioralPattern delete
   */
  export type BehavioralPatternDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralPattern
     */
    select?: BehavioralPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralPatternInclude<ExtArgs> | null
    /**
     * Filter which BehavioralPattern to delete.
     */
    where: BehavioralPatternWhereUniqueInput
  }

  /**
   * BehavioralPattern deleteMany
   */
  export type BehavioralPatternDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BehavioralPatterns to delete
     */
    where?: BehavioralPatternWhereInput
  }

  /**
   * BehavioralPattern.insights
   */
  export type BehavioralPattern$insightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternInclude<ExtArgs> | null
    where?: InsightPatternWhereInput
    orderBy?: InsightPatternOrderByWithRelationInput | InsightPatternOrderByWithRelationInput[]
    cursor?: InsightPatternWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsightPatternScalarFieldEnum | InsightPatternScalarFieldEnum[]
  }

  /**
   * BehavioralPattern without action
   */
  export type BehavioralPatternDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralPattern
     */
    select?: BehavioralPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralPatternInclude<ExtArgs> | null
  }


  /**
   * Model BehavioralInsight
   */

  export type AggregateBehavioralInsight = {
    _count: BehavioralInsightCountAggregateOutputType | null
    _avg: BehavioralInsightAvgAggregateOutputType | null
    _sum: BehavioralInsightSumAggregateOutputType | null
    _min: BehavioralInsightMinAggregateOutputType | null
    _max: BehavioralInsightMaxAggregateOutputType | null
  }

  export type BehavioralInsightAvgAggregateOutputType = {
    confidence: number | null
  }

  export type BehavioralInsightSumAggregateOutputType = {
    confidence: number | null
  }

  export type BehavioralInsightMinAggregateOutputType = {
    id: string | null
    userId: string | null
    insightType: $Enums.InsightType | null
    title: string | null
    description: string | null
    actionableRecommendation: string | null
    confidence: number | null
    createdAt: Date | null
    acknowledgedAt: Date | null
    applied: boolean | null
  }

  export type BehavioralInsightMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    insightType: $Enums.InsightType | null
    title: string | null
    description: string | null
    actionableRecommendation: string | null
    confidence: number | null
    createdAt: Date | null
    acknowledgedAt: Date | null
    applied: boolean | null
  }

  export type BehavioralInsightCountAggregateOutputType = {
    id: number
    userId: number
    insightType: number
    title: number
    description: number
    actionableRecommendation: number
    confidence: number
    createdAt: number
    acknowledgedAt: number
    applied: number
    _all: number
  }


  export type BehavioralInsightAvgAggregateInputType = {
    confidence?: true
  }

  export type BehavioralInsightSumAggregateInputType = {
    confidence?: true
  }

  export type BehavioralInsightMinAggregateInputType = {
    id?: true
    userId?: true
    insightType?: true
    title?: true
    description?: true
    actionableRecommendation?: true
    confidence?: true
    createdAt?: true
    acknowledgedAt?: true
    applied?: true
  }

  export type BehavioralInsightMaxAggregateInputType = {
    id?: true
    userId?: true
    insightType?: true
    title?: true
    description?: true
    actionableRecommendation?: true
    confidence?: true
    createdAt?: true
    acknowledgedAt?: true
    applied?: true
  }

  export type BehavioralInsightCountAggregateInputType = {
    id?: true
    userId?: true
    insightType?: true
    title?: true
    description?: true
    actionableRecommendation?: true
    confidence?: true
    createdAt?: true
    acknowledgedAt?: true
    applied?: true
    _all?: true
  }

  export type BehavioralInsightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BehavioralInsight to aggregate.
     */
    where?: BehavioralInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehavioralInsights to fetch.
     */
    orderBy?: BehavioralInsightOrderByWithRelationInput | BehavioralInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BehavioralInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehavioralInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehavioralInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BehavioralInsights
    **/
    _count?: true | BehavioralInsightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BehavioralInsightAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BehavioralInsightSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BehavioralInsightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BehavioralInsightMaxAggregateInputType
  }

  export type GetBehavioralInsightAggregateType<T extends BehavioralInsightAggregateArgs> = {
        [P in keyof T & keyof AggregateBehavioralInsight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBehavioralInsight[P]>
      : GetScalarType<T[P], AggregateBehavioralInsight[P]>
  }




  export type BehavioralInsightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BehavioralInsightWhereInput
    orderBy?: BehavioralInsightOrderByWithAggregationInput | BehavioralInsightOrderByWithAggregationInput[]
    by: BehavioralInsightScalarFieldEnum[] | BehavioralInsightScalarFieldEnum
    having?: BehavioralInsightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BehavioralInsightCountAggregateInputType | true
    _avg?: BehavioralInsightAvgAggregateInputType
    _sum?: BehavioralInsightSumAggregateInputType
    _min?: BehavioralInsightMinAggregateInputType
    _max?: BehavioralInsightMaxAggregateInputType
  }

  export type BehavioralInsightGroupByOutputType = {
    id: string
    userId: string
    insightType: $Enums.InsightType
    title: string
    description: string
    actionableRecommendation: string
    confidence: number
    createdAt: Date
    acknowledgedAt: Date | null
    applied: boolean
    _count: BehavioralInsightCountAggregateOutputType | null
    _avg: BehavioralInsightAvgAggregateOutputType | null
    _sum: BehavioralInsightSumAggregateOutputType | null
    _min: BehavioralInsightMinAggregateOutputType | null
    _max: BehavioralInsightMaxAggregateOutputType | null
  }

  type GetBehavioralInsightGroupByPayload<T extends BehavioralInsightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BehavioralInsightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BehavioralInsightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BehavioralInsightGroupByOutputType[P]>
            : GetScalarType<T[P], BehavioralInsightGroupByOutputType[P]>
        }
      >
    >


  export type BehavioralInsightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    insightType?: boolean
    title?: boolean
    description?: boolean
    actionableRecommendation?: boolean
    confidence?: boolean
    createdAt?: boolean
    acknowledgedAt?: boolean
    applied?: boolean
    patterns?: boolean | BehavioralInsight$patternsArgs<ExtArgs>
    _count?: boolean | BehavioralInsightCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["behavioralInsight"]>

  export type BehavioralInsightSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    insightType?: boolean
    title?: boolean
    description?: boolean
    actionableRecommendation?: boolean
    confidence?: boolean
    createdAt?: boolean
    acknowledgedAt?: boolean
    applied?: boolean
  }, ExtArgs["result"]["behavioralInsight"]>

  export type BehavioralInsightSelectScalar = {
    id?: boolean
    userId?: boolean
    insightType?: boolean
    title?: boolean
    description?: boolean
    actionableRecommendation?: boolean
    confidence?: boolean
    createdAt?: boolean
    acknowledgedAt?: boolean
    applied?: boolean
  }

  export type BehavioralInsightInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patterns?: boolean | BehavioralInsight$patternsArgs<ExtArgs>
    _count?: boolean | BehavioralInsightCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BehavioralInsightIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BehavioralInsightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BehavioralInsight"
    objects: {
      patterns: Prisma.$InsightPatternPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      insightType: $Enums.InsightType
      title: string
      description: string
      actionableRecommendation: string
      confidence: number
      createdAt: Date
      acknowledgedAt: Date | null
      applied: boolean
    }, ExtArgs["result"]["behavioralInsight"]>
    composites: {}
  }

  type BehavioralInsightGetPayload<S extends boolean | null | undefined | BehavioralInsightDefaultArgs> = $Result.GetResult<Prisma.$BehavioralInsightPayload, S>

  type BehavioralInsightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BehavioralInsightFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BehavioralInsightCountAggregateInputType | true
    }

  export interface BehavioralInsightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BehavioralInsight'], meta: { name: 'BehavioralInsight' } }
    /**
     * Find zero or one BehavioralInsight that matches the filter.
     * @param {BehavioralInsightFindUniqueArgs} args - Arguments to find a BehavioralInsight
     * @example
     * // Get one BehavioralInsight
     * const behavioralInsight = await prisma.behavioralInsight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BehavioralInsightFindUniqueArgs>(args: SelectSubset<T, BehavioralInsightFindUniqueArgs<ExtArgs>>): Prisma__BehavioralInsightClient<$Result.GetResult<Prisma.$BehavioralInsightPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BehavioralInsight that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BehavioralInsightFindUniqueOrThrowArgs} args - Arguments to find a BehavioralInsight
     * @example
     * // Get one BehavioralInsight
     * const behavioralInsight = await prisma.behavioralInsight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BehavioralInsightFindUniqueOrThrowArgs>(args: SelectSubset<T, BehavioralInsightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BehavioralInsightClient<$Result.GetResult<Prisma.$BehavioralInsightPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BehavioralInsight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralInsightFindFirstArgs} args - Arguments to find a BehavioralInsight
     * @example
     * // Get one BehavioralInsight
     * const behavioralInsight = await prisma.behavioralInsight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BehavioralInsightFindFirstArgs>(args?: SelectSubset<T, BehavioralInsightFindFirstArgs<ExtArgs>>): Prisma__BehavioralInsightClient<$Result.GetResult<Prisma.$BehavioralInsightPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BehavioralInsight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralInsightFindFirstOrThrowArgs} args - Arguments to find a BehavioralInsight
     * @example
     * // Get one BehavioralInsight
     * const behavioralInsight = await prisma.behavioralInsight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BehavioralInsightFindFirstOrThrowArgs>(args?: SelectSubset<T, BehavioralInsightFindFirstOrThrowArgs<ExtArgs>>): Prisma__BehavioralInsightClient<$Result.GetResult<Prisma.$BehavioralInsightPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BehavioralInsights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralInsightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BehavioralInsights
     * const behavioralInsights = await prisma.behavioralInsight.findMany()
     * 
     * // Get first 10 BehavioralInsights
     * const behavioralInsights = await prisma.behavioralInsight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const behavioralInsightWithIdOnly = await prisma.behavioralInsight.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BehavioralInsightFindManyArgs>(args?: SelectSubset<T, BehavioralInsightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehavioralInsightPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BehavioralInsight.
     * @param {BehavioralInsightCreateArgs} args - Arguments to create a BehavioralInsight.
     * @example
     * // Create one BehavioralInsight
     * const BehavioralInsight = await prisma.behavioralInsight.create({
     *   data: {
     *     // ... data to create a BehavioralInsight
     *   }
     * })
     * 
     */
    create<T extends BehavioralInsightCreateArgs>(args: SelectSubset<T, BehavioralInsightCreateArgs<ExtArgs>>): Prisma__BehavioralInsightClient<$Result.GetResult<Prisma.$BehavioralInsightPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BehavioralInsights.
     * @param {BehavioralInsightCreateManyArgs} args - Arguments to create many BehavioralInsights.
     * @example
     * // Create many BehavioralInsights
     * const behavioralInsight = await prisma.behavioralInsight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BehavioralInsightCreateManyArgs>(args?: SelectSubset<T, BehavioralInsightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BehavioralInsights and returns the data saved in the database.
     * @param {BehavioralInsightCreateManyAndReturnArgs} args - Arguments to create many BehavioralInsights.
     * @example
     * // Create many BehavioralInsights
     * const behavioralInsight = await prisma.behavioralInsight.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BehavioralInsights and only return the `id`
     * const behavioralInsightWithIdOnly = await prisma.behavioralInsight.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BehavioralInsightCreateManyAndReturnArgs>(args?: SelectSubset<T, BehavioralInsightCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehavioralInsightPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BehavioralInsight.
     * @param {BehavioralInsightDeleteArgs} args - Arguments to delete one BehavioralInsight.
     * @example
     * // Delete one BehavioralInsight
     * const BehavioralInsight = await prisma.behavioralInsight.delete({
     *   where: {
     *     // ... filter to delete one BehavioralInsight
     *   }
     * })
     * 
     */
    delete<T extends BehavioralInsightDeleteArgs>(args: SelectSubset<T, BehavioralInsightDeleteArgs<ExtArgs>>): Prisma__BehavioralInsightClient<$Result.GetResult<Prisma.$BehavioralInsightPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BehavioralInsight.
     * @param {BehavioralInsightUpdateArgs} args - Arguments to update one BehavioralInsight.
     * @example
     * // Update one BehavioralInsight
     * const behavioralInsight = await prisma.behavioralInsight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BehavioralInsightUpdateArgs>(args: SelectSubset<T, BehavioralInsightUpdateArgs<ExtArgs>>): Prisma__BehavioralInsightClient<$Result.GetResult<Prisma.$BehavioralInsightPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BehavioralInsights.
     * @param {BehavioralInsightDeleteManyArgs} args - Arguments to filter BehavioralInsights to delete.
     * @example
     * // Delete a few BehavioralInsights
     * const { count } = await prisma.behavioralInsight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BehavioralInsightDeleteManyArgs>(args?: SelectSubset<T, BehavioralInsightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BehavioralInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralInsightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BehavioralInsights
     * const behavioralInsight = await prisma.behavioralInsight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BehavioralInsightUpdateManyArgs>(args: SelectSubset<T, BehavioralInsightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BehavioralInsight.
     * @param {BehavioralInsightUpsertArgs} args - Arguments to update or create a BehavioralInsight.
     * @example
     * // Update or create a BehavioralInsight
     * const behavioralInsight = await prisma.behavioralInsight.upsert({
     *   create: {
     *     // ... data to create a BehavioralInsight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BehavioralInsight we want to update
     *   }
     * })
     */
    upsert<T extends BehavioralInsightUpsertArgs>(args: SelectSubset<T, BehavioralInsightUpsertArgs<ExtArgs>>): Prisma__BehavioralInsightClient<$Result.GetResult<Prisma.$BehavioralInsightPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BehavioralInsights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralInsightCountArgs} args - Arguments to filter BehavioralInsights to count.
     * @example
     * // Count the number of BehavioralInsights
     * const count = await prisma.behavioralInsight.count({
     *   where: {
     *     // ... the filter for the BehavioralInsights we want to count
     *   }
     * })
    **/
    count<T extends BehavioralInsightCountArgs>(
      args?: Subset<T, BehavioralInsightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BehavioralInsightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BehavioralInsight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralInsightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BehavioralInsightAggregateArgs>(args: Subset<T, BehavioralInsightAggregateArgs>): Prisma.PrismaPromise<GetBehavioralInsightAggregateType<T>>

    /**
     * Group by BehavioralInsight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehavioralInsightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BehavioralInsightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BehavioralInsightGroupByArgs['orderBy'] }
        : { orderBy?: BehavioralInsightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BehavioralInsightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBehavioralInsightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BehavioralInsight model
   */
  readonly fields: BehavioralInsightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BehavioralInsight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BehavioralInsightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patterns<T extends BehavioralInsight$patternsArgs<ExtArgs> = {}>(args?: Subset<T, BehavioralInsight$patternsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BehavioralInsight model
   */ 
  interface BehavioralInsightFieldRefs {
    readonly id: FieldRef<"BehavioralInsight", 'String'>
    readonly userId: FieldRef<"BehavioralInsight", 'String'>
    readonly insightType: FieldRef<"BehavioralInsight", 'InsightType'>
    readonly title: FieldRef<"BehavioralInsight", 'String'>
    readonly description: FieldRef<"BehavioralInsight", 'String'>
    readonly actionableRecommendation: FieldRef<"BehavioralInsight", 'String'>
    readonly confidence: FieldRef<"BehavioralInsight", 'Float'>
    readonly createdAt: FieldRef<"BehavioralInsight", 'DateTime'>
    readonly acknowledgedAt: FieldRef<"BehavioralInsight", 'DateTime'>
    readonly applied: FieldRef<"BehavioralInsight", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * BehavioralInsight findUnique
   */
  export type BehavioralInsightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInsight
     */
    select?: BehavioralInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralInsightInclude<ExtArgs> | null
    /**
     * Filter, which BehavioralInsight to fetch.
     */
    where: BehavioralInsightWhereUniqueInput
  }

  /**
   * BehavioralInsight findUniqueOrThrow
   */
  export type BehavioralInsightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInsight
     */
    select?: BehavioralInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralInsightInclude<ExtArgs> | null
    /**
     * Filter, which BehavioralInsight to fetch.
     */
    where: BehavioralInsightWhereUniqueInput
  }

  /**
   * BehavioralInsight findFirst
   */
  export type BehavioralInsightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInsight
     */
    select?: BehavioralInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralInsightInclude<ExtArgs> | null
    /**
     * Filter, which BehavioralInsight to fetch.
     */
    where?: BehavioralInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehavioralInsights to fetch.
     */
    orderBy?: BehavioralInsightOrderByWithRelationInput | BehavioralInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BehavioralInsights.
     */
    cursor?: BehavioralInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehavioralInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehavioralInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BehavioralInsights.
     */
    distinct?: BehavioralInsightScalarFieldEnum | BehavioralInsightScalarFieldEnum[]
  }

  /**
   * BehavioralInsight findFirstOrThrow
   */
  export type BehavioralInsightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInsight
     */
    select?: BehavioralInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralInsightInclude<ExtArgs> | null
    /**
     * Filter, which BehavioralInsight to fetch.
     */
    where?: BehavioralInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehavioralInsights to fetch.
     */
    orderBy?: BehavioralInsightOrderByWithRelationInput | BehavioralInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BehavioralInsights.
     */
    cursor?: BehavioralInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehavioralInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehavioralInsights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BehavioralInsights.
     */
    distinct?: BehavioralInsightScalarFieldEnum | BehavioralInsightScalarFieldEnum[]
  }

  /**
   * BehavioralInsight findMany
   */
  export type BehavioralInsightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInsight
     */
    select?: BehavioralInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralInsightInclude<ExtArgs> | null
    /**
     * Filter, which BehavioralInsights to fetch.
     */
    where?: BehavioralInsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehavioralInsights to fetch.
     */
    orderBy?: BehavioralInsightOrderByWithRelationInput | BehavioralInsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BehavioralInsights.
     */
    cursor?: BehavioralInsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehavioralInsights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehavioralInsights.
     */
    skip?: number
    distinct?: BehavioralInsightScalarFieldEnum | BehavioralInsightScalarFieldEnum[]
  }

  /**
   * BehavioralInsight create
   */
  export type BehavioralInsightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInsight
     */
    select?: BehavioralInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralInsightInclude<ExtArgs> | null
    /**
     * The data needed to create a BehavioralInsight.
     */
    data: XOR<BehavioralInsightCreateInput, BehavioralInsightUncheckedCreateInput>
  }

  /**
   * BehavioralInsight createMany
   */
  export type BehavioralInsightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BehavioralInsights.
     */
    data: BehavioralInsightCreateManyInput | BehavioralInsightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BehavioralInsight createManyAndReturn
   */
  export type BehavioralInsightCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInsight
     */
    select?: BehavioralInsightSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BehavioralInsights.
     */
    data: BehavioralInsightCreateManyInput | BehavioralInsightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BehavioralInsight update
   */
  export type BehavioralInsightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInsight
     */
    select?: BehavioralInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralInsightInclude<ExtArgs> | null
    /**
     * The data needed to update a BehavioralInsight.
     */
    data: XOR<BehavioralInsightUpdateInput, BehavioralInsightUncheckedUpdateInput>
    /**
     * Choose, which BehavioralInsight to update.
     */
    where: BehavioralInsightWhereUniqueInput
  }

  /**
   * BehavioralInsight updateMany
   */
  export type BehavioralInsightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BehavioralInsights.
     */
    data: XOR<BehavioralInsightUpdateManyMutationInput, BehavioralInsightUncheckedUpdateManyInput>
    /**
     * Filter which BehavioralInsights to update
     */
    where?: BehavioralInsightWhereInput
  }

  /**
   * BehavioralInsight upsert
   */
  export type BehavioralInsightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInsight
     */
    select?: BehavioralInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralInsightInclude<ExtArgs> | null
    /**
     * The filter to search for the BehavioralInsight to update in case it exists.
     */
    where: BehavioralInsightWhereUniqueInput
    /**
     * In case the BehavioralInsight found by the `where` argument doesn't exist, create a new BehavioralInsight with this data.
     */
    create: XOR<BehavioralInsightCreateInput, BehavioralInsightUncheckedCreateInput>
    /**
     * In case the BehavioralInsight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BehavioralInsightUpdateInput, BehavioralInsightUncheckedUpdateInput>
  }

  /**
   * BehavioralInsight delete
   */
  export type BehavioralInsightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInsight
     */
    select?: BehavioralInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralInsightInclude<ExtArgs> | null
    /**
     * Filter which BehavioralInsight to delete.
     */
    where: BehavioralInsightWhereUniqueInput
  }

  /**
   * BehavioralInsight deleteMany
   */
  export type BehavioralInsightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BehavioralInsights to delete
     */
    where?: BehavioralInsightWhereInput
  }

  /**
   * BehavioralInsight.patterns
   */
  export type BehavioralInsight$patternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternInclude<ExtArgs> | null
    where?: InsightPatternWhereInput
    orderBy?: InsightPatternOrderByWithRelationInput | InsightPatternOrderByWithRelationInput[]
    cursor?: InsightPatternWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsightPatternScalarFieldEnum | InsightPatternScalarFieldEnum[]
  }

  /**
   * BehavioralInsight without action
   */
  export type BehavioralInsightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehavioralInsight
     */
    select?: BehavioralInsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehavioralInsightInclude<ExtArgs> | null
  }


  /**
   * Model InsightPattern
   */

  export type AggregateInsightPattern = {
    _count: InsightPatternCountAggregateOutputType | null
    _min: InsightPatternMinAggregateOutputType | null
    _max: InsightPatternMaxAggregateOutputType | null
  }

  export type InsightPatternMinAggregateOutputType = {
    id: string | null
    insightId: string | null
    patternId: string | null
  }

  export type InsightPatternMaxAggregateOutputType = {
    id: string | null
    insightId: string | null
    patternId: string | null
  }

  export type InsightPatternCountAggregateOutputType = {
    id: number
    insightId: number
    patternId: number
    _all: number
  }


  export type InsightPatternMinAggregateInputType = {
    id?: true
    insightId?: true
    patternId?: true
  }

  export type InsightPatternMaxAggregateInputType = {
    id?: true
    insightId?: true
    patternId?: true
  }

  export type InsightPatternCountAggregateInputType = {
    id?: true
    insightId?: true
    patternId?: true
    _all?: true
  }

  export type InsightPatternAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsightPattern to aggregate.
     */
    where?: InsightPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightPatterns to fetch.
     */
    orderBy?: InsightPatternOrderByWithRelationInput | InsightPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsightPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InsightPatterns
    **/
    _count?: true | InsightPatternCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsightPatternMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsightPatternMaxAggregateInputType
  }

  export type GetInsightPatternAggregateType<T extends InsightPatternAggregateArgs> = {
        [P in keyof T & keyof AggregateInsightPattern]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsightPattern[P]>
      : GetScalarType<T[P], AggregateInsightPattern[P]>
  }




  export type InsightPatternGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightPatternWhereInput
    orderBy?: InsightPatternOrderByWithAggregationInput | InsightPatternOrderByWithAggregationInput[]
    by: InsightPatternScalarFieldEnum[] | InsightPatternScalarFieldEnum
    having?: InsightPatternScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsightPatternCountAggregateInputType | true
    _min?: InsightPatternMinAggregateInputType
    _max?: InsightPatternMaxAggregateInputType
  }

  export type InsightPatternGroupByOutputType = {
    id: string
    insightId: string
    patternId: string
    _count: InsightPatternCountAggregateOutputType | null
    _min: InsightPatternMinAggregateOutputType | null
    _max: InsightPatternMaxAggregateOutputType | null
  }

  type GetInsightPatternGroupByPayload<T extends InsightPatternGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InsightPatternGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsightPatternGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsightPatternGroupByOutputType[P]>
            : GetScalarType<T[P], InsightPatternGroupByOutputType[P]>
        }
      >
    >


  export type InsightPatternSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insightId?: boolean
    patternId?: boolean
    insight?: boolean | BehavioralInsightDefaultArgs<ExtArgs>
    pattern?: boolean | BehavioralPatternDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insightPattern"]>

  export type InsightPatternSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insightId?: boolean
    patternId?: boolean
    insight?: boolean | BehavioralInsightDefaultArgs<ExtArgs>
    pattern?: boolean | BehavioralPatternDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insightPattern"]>

  export type InsightPatternSelectScalar = {
    id?: boolean
    insightId?: boolean
    patternId?: boolean
  }

  export type InsightPatternInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insight?: boolean | BehavioralInsightDefaultArgs<ExtArgs>
    pattern?: boolean | BehavioralPatternDefaultArgs<ExtArgs>
  }
  export type InsightPatternIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insight?: boolean | BehavioralInsightDefaultArgs<ExtArgs>
    pattern?: boolean | BehavioralPatternDefaultArgs<ExtArgs>
  }

  export type $InsightPatternPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InsightPattern"
    objects: {
      insight: Prisma.$BehavioralInsightPayload<ExtArgs>
      pattern: Prisma.$BehavioralPatternPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      insightId: string
      patternId: string
    }, ExtArgs["result"]["insightPattern"]>
    composites: {}
  }

  type InsightPatternGetPayload<S extends boolean | null | undefined | InsightPatternDefaultArgs> = $Result.GetResult<Prisma.$InsightPatternPayload, S>

  type InsightPatternCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InsightPatternFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InsightPatternCountAggregateInputType | true
    }

  export interface InsightPatternDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InsightPattern'], meta: { name: 'InsightPattern' } }
    /**
     * Find zero or one InsightPattern that matches the filter.
     * @param {InsightPatternFindUniqueArgs} args - Arguments to find a InsightPattern
     * @example
     * // Get one InsightPattern
     * const insightPattern = await prisma.insightPattern.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InsightPatternFindUniqueArgs>(args: SelectSubset<T, InsightPatternFindUniqueArgs<ExtArgs>>): Prisma__InsightPatternClient<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InsightPattern that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InsightPatternFindUniqueOrThrowArgs} args - Arguments to find a InsightPattern
     * @example
     * // Get one InsightPattern
     * const insightPattern = await prisma.insightPattern.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InsightPatternFindUniqueOrThrowArgs>(args: SelectSubset<T, InsightPatternFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InsightPatternClient<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InsightPattern that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightPatternFindFirstArgs} args - Arguments to find a InsightPattern
     * @example
     * // Get one InsightPattern
     * const insightPattern = await prisma.insightPattern.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InsightPatternFindFirstArgs>(args?: SelectSubset<T, InsightPatternFindFirstArgs<ExtArgs>>): Prisma__InsightPatternClient<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InsightPattern that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightPatternFindFirstOrThrowArgs} args - Arguments to find a InsightPattern
     * @example
     * // Get one InsightPattern
     * const insightPattern = await prisma.insightPattern.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InsightPatternFindFirstOrThrowArgs>(args?: SelectSubset<T, InsightPatternFindFirstOrThrowArgs<ExtArgs>>): Prisma__InsightPatternClient<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InsightPatterns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightPatternFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InsightPatterns
     * const insightPatterns = await prisma.insightPattern.findMany()
     * 
     * // Get first 10 InsightPatterns
     * const insightPatterns = await prisma.insightPattern.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const insightPatternWithIdOnly = await prisma.insightPattern.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InsightPatternFindManyArgs>(args?: SelectSubset<T, InsightPatternFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InsightPattern.
     * @param {InsightPatternCreateArgs} args - Arguments to create a InsightPattern.
     * @example
     * // Create one InsightPattern
     * const InsightPattern = await prisma.insightPattern.create({
     *   data: {
     *     // ... data to create a InsightPattern
     *   }
     * })
     * 
     */
    create<T extends InsightPatternCreateArgs>(args: SelectSubset<T, InsightPatternCreateArgs<ExtArgs>>): Prisma__InsightPatternClient<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InsightPatterns.
     * @param {InsightPatternCreateManyArgs} args - Arguments to create many InsightPatterns.
     * @example
     * // Create many InsightPatterns
     * const insightPattern = await prisma.insightPattern.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InsightPatternCreateManyArgs>(args?: SelectSubset<T, InsightPatternCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InsightPatterns and returns the data saved in the database.
     * @param {InsightPatternCreateManyAndReturnArgs} args - Arguments to create many InsightPatterns.
     * @example
     * // Create many InsightPatterns
     * const insightPattern = await prisma.insightPattern.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InsightPatterns and only return the `id`
     * const insightPatternWithIdOnly = await prisma.insightPattern.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InsightPatternCreateManyAndReturnArgs>(args?: SelectSubset<T, InsightPatternCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InsightPattern.
     * @param {InsightPatternDeleteArgs} args - Arguments to delete one InsightPattern.
     * @example
     * // Delete one InsightPattern
     * const InsightPattern = await prisma.insightPattern.delete({
     *   where: {
     *     // ... filter to delete one InsightPattern
     *   }
     * })
     * 
     */
    delete<T extends InsightPatternDeleteArgs>(args: SelectSubset<T, InsightPatternDeleteArgs<ExtArgs>>): Prisma__InsightPatternClient<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InsightPattern.
     * @param {InsightPatternUpdateArgs} args - Arguments to update one InsightPattern.
     * @example
     * // Update one InsightPattern
     * const insightPattern = await prisma.insightPattern.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InsightPatternUpdateArgs>(args: SelectSubset<T, InsightPatternUpdateArgs<ExtArgs>>): Prisma__InsightPatternClient<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InsightPatterns.
     * @param {InsightPatternDeleteManyArgs} args - Arguments to filter InsightPatterns to delete.
     * @example
     * // Delete a few InsightPatterns
     * const { count } = await prisma.insightPattern.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InsightPatternDeleteManyArgs>(args?: SelectSubset<T, InsightPatternDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsightPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightPatternUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InsightPatterns
     * const insightPattern = await prisma.insightPattern.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InsightPatternUpdateManyArgs>(args: SelectSubset<T, InsightPatternUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InsightPattern.
     * @param {InsightPatternUpsertArgs} args - Arguments to update or create a InsightPattern.
     * @example
     * // Update or create a InsightPattern
     * const insightPattern = await prisma.insightPattern.upsert({
     *   create: {
     *     // ... data to create a InsightPattern
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InsightPattern we want to update
     *   }
     * })
     */
    upsert<T extends InsightPatternUpsertArgs>(args: SelectSubset<T, InsightPatternUpsertArgs<ExtArgs>>): Prisma__InsightPatternClient<$Result.GetResult<Prisma.$InsightPatternPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InsightPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightPatternCountArgs} args - Arguments to filter InsightPatterns to count.
     * @example
     * // Count the number of InsightPatterns
     * const count = await prisma.insightPattern.count({
     *   where: {
     *     // ... the filter for the InsightPatterns we want to count
     *   }
     * })
    **/
    count<T extends InsightPatternCountArgs>(
      args?: Subset<T, InsightPatternCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsightPatternCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InsightPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightPatternAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsightPatternAggregateArgs>(args: Subset<T, InsightPatternAggregateArgs>): Prisma.PrismaPromise<GetInsightPatternAggregateType<T>>

    /**
     * Group by InsightPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightPatternGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsightPatternGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsightPatternGroupByArgs['orderBy'] }
        : { orderBy?: InsightPatternGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsightPatternGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsightPatternGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InsightPattern model
   */
  readonly fields: InsightPatternFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InsightPattern.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InsightPatternClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insight<T extends BehavioralInsightDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BehavioralInsightDefaultArgs<ExtArgs>>): Prisma__BehavioralInsightClient<$Result.GetResult<Prisma.$BehavioralInsightPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    pattern<T extends BehavioralPatternDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BehavioralPatternDefaultArgs<ExtArgs>>): Prisma__BehavioralPatternClient<$Result.GetResult<Prisma.$BehavioralPatternPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InsightPattern model
   */ 
  interface InsightPatternFieldRefs {
    readonly id: FieldRef<"InsightPattern", 'String'>
    readonly insightId: FieldRef<"InsightPattern", 'String'>
    readonly patternId: FieldRef<"InsightPattern", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InsightPattern findUnique
   */
  export type InsightPatternFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternInclude<ExtArgs> | null
    /**
     * Filter, which InsightPattern to fetch.
     */
    where: InsightPatternWhereUniqueInput
  }

  /**
   * InsightPattern findUniqueOrThrow
   */
  export type InsightPatternFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternInclude<ExtArgs> | null
    /**
     * Filter, which InsightPattern to fetch.
     */
    where: InsightPatternWhereUniqueInput
  }

  /**
   * InsightPattern findFirst
   */
  export type InsightPatternFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternInclude<ExtArgs> | null
    /**
     * Filter, which InsightPattern to fetch.
     */
    where?: InsightPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightPatterns to fetch.
     */
    orderBy?: InsightPatternOrderByWithRelationInput | InsightPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsightPatterns.
     */
    cursor?: InsightPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsightPatterns.
     */
    distinct?: InsightPatternScalarFieldEnum | InsightPatternScalarFieldEnum[]
  }

  /**
   * InsightPattern findFirstOrThrow
   */
  export type InsightPatternFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternInclude<ExtArgs> | null
    /**
     * Filter, which InsightPattern to fetch.
     */
    where?: InsightPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightPatterns to fetch.
     */
    orderBy?: InsightPatternOrderByWithRelationInput | InsightPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsightPatterns.
     */
    cursor?: InsightPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsightPatterns.
     */
    distinct?: InsightPatternScalarFieldEnum | InsightPatternScalarFieldEnum[]
  }

  /**
   * InsightPattern findMany
   */
  export type InsightPatternFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternInclude<ExtArgs> | null
    /**
     * Filter, which InsightPatterns to fetch.
     */
    where?: InsightPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightPatterns to fetch.
     */
    orderBy?: InsightPatternOrderByWithRelationInput | InsightPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InsightPatterns.
     */
    cursor?: InsightPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightPatterns.
     */
    skip?: number
    distinct?: InsightPatternScalarFieldEnum | InsightPatternScalarFieldEnum[]
  }

  /**
   * InsightPattern create
   */
  export type InsightPatternCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternInclude<ExtArgs> | null
    /**
     * The data needed to create a InsightPattern.
     */
    data: XOR<InsightPatternCreateInput, InsightPatternUncheckedCreateInput>
  }

  /**
   * InsightPattern createMany
   */
  export type InsightPatternCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InsightPatterns.
     */
    data: InsightPatternCreateManyInput | InsightPatternCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InsightPattern createManyAndReturn
   */
  export type InsightPatternCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InsightPatterns.
     */
    data: InsightPatternCreateManyInput | InsightPatternCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InsightPattern update
   */
  export type InsightPatternUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternInclude<ExtArgs> | null
    /**
     * The data needed to update a InsightPattern.
     */
    data: XOR<InsightPatternUpdateInput, InsightPatternUncheckedUpdateInput>
    /**
     * Choose, which InsightPattern to update.
     */
    where: InsightPatternWhereUniqueInput
  }

  /**
   * InsightPattern updateMany
   */
  export type InsightPatternUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InsightPatterns.
     */
    data: XOR<InsightPatternUpdateManyMutationInput, InsightPatternUncheckedUpdateManyInput>
    /**
     * Filter which InsightPatterns to update
     */
    where?: InsightPatternWhereInput
  }

  /**
   * InsightPattern upsert
   */
  export type InsightPatternUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternInclude<ExtArgs> | null
    /**
     * The filter to search for the InsightPattern to update in case it exists.
     */
    where: InsightPatternWhereUniqueInput
    /**
     * In case the InsightPattern found by the `where` argument doesn't exist, create a new InsightPattern with this data.
     */
    create: XOR<InsightPatternCreateInput, InsightPatternUncheckedCreateInput>
    /**
     * In case the InsightPattern was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsightPatternUpdateInput, InsightPatternUncheckedUpdateInput>
  }

  /**
   * InsightPattern delete
   */
  export type InsightPatternDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternInclude<ExtArgs> | null
    /**
     * Filter which InsightPattern to delete.
     */
    where: InsightPatternWhereUniqueInput
  }

  /**
   * InsightPattern deleteMany
   */
  export type InsightPatternDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsightPatterns to delete
     */
    where?: InsightPatternWhereInput
  }

  /**
   * InsightPattern without action
   */
  export type InsightPatternDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightPattern
     */
    select?: InsightPatternSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightPatternInclude<ExtArgs> | null
  }


  /**
   * Model UserLearningProfile
   */

  export type AggregateUserLearningProfile = {
    _count: UserLearningProfileCountAggregateOutputType | null
    _avg: UserLearningProfileAvgAggregateOutputType | null
    _sum: UserLearningProfileSumAggregateOutputType | null
    _min: UserLearningProfileMinAggregateOutputType | null
    _max: UserLearningProfileMaxAggregateOutputType | null
  }

  export type UserLearningProfileAvgAggregateOutputType = {
    averageSessionDuration: number | null
    optimalSessionDuration: number | null
    dataQualityScore: number | null
  }

  export type UserLearningProfileSumAggregateOutputType = {
    averageSessionDuration: number | null
    optimalSessionDuration: number | null
    dataQualityScore: number | null
  }

  export type UserLearningProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    averageSessionDuration: number | null
    optimalSessionDuration: number | null
    lastAnalyzedAt: Date | null
    dataQualityScore: number | null
  }

  export type UserLearningProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    averageSessionDuration: number | null
    optimalSessionDuration: number | null
    lastAnalyzedAt: Date | null
    dataQualityScore: number | null
  }

  export type UserLearningProfileCountAggregateOutputType = {
    id: number
    userId: number
    preferredStudyTimes: number
    averageSessionDuration: number
    optimalSessionDuration: number
    contentPreferences: number
    learningStyleProfile: number
    personalizedForgettingCurve: number
    lastAnalyzedAt: number
    dataQualityScore: number
    _all: number
  }


  export type UserLearningProfileAvgAggregateInputType = {
    averageSessionDuration?: true
    optimalSessionDuration?: true
    dataQualityScore?: true
  }

  export type UserLearningProfileSumAggregateInputType = {
    averageSessionDuration?: true
    optimalSessionDuration?: true
    dataQualityScore?: true
  }

  export type UserLearningProfileMinAggregateInputType = {
    id?: true
    userId?: true
    averageSessionDuration?: true
    optimalSessionDuration?: true
    lastAnalyzedAt?: true
    dataQualityScore?: true
  }

  export type UserLearningProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    averageSessionDuration?: true
    optimalSessionDuration?: true
    lastAnalyzedAt?: true
    dataQualityScore?: true
  }

  export type UserLearningProfileCountAggregateInputType = {
    id?: true
    userId?: true
    preferredStudyTimes?: true
    averageSessionDuration?: true
    optimalSessionDuration?: true
    contentPreferences?: true
    learningStyleProfile?: true
    personalizedForgettingCurve?: true
    lastAnalyzedAt?: true
    dataQualityScore?: true
    _all?: true
  }

  export type UserLearningProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLearningProfile to aggregate.
     */
    where?: UserLearningProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLearningProfiles to fetch.
     */
    orderBy?: UserLearningProfileOrderByWithRelationInput | UserLearningProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserLearningProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLearningProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLearningProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserLearningProfiles
    **/
    _count?: true | UserLearningProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserLearningProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserLearningProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserLearningProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserLearningProfileMaxAggregateInputType
  }

  export type GetUserLearningProfileAggregateType<T extends UserLearningProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserLearningProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserLearningProfile[P]>
      : GetScalarType<T[P], AggregateUserLearningProfile[P]>
  }




  export type UserLearningProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserLearningProfileWhereInput
    orderBy?: UserLearningProfileOrderByWithAggregationInput | UserLearningProfileOrderByWithAggregationInput[]
    by: UserLearningProfileScalarFieldEnum[] | UserLearningProfileScalarFieldEnum
    having?: UserLearningProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserLearningProfileCountAggregateInputType | true
    _avg?: UserLearningProfileAvgAggregateInputType
    _sum?: UserLearningProfileSumAggregateInputType
    _min?: UserLearningProfileMinAggregateInputType
    _max?: UserLearningProfileMaxAggregateInputType
  }

  export type UserLearningProfileGroupByOutputType = {
    id: string
    userId: string
    preferredStudyTimes: JsonValue
    averageSessionDuration: number
    optimalSessionDuration: number
    contentPreferences: JsonValue
    learningStyleProfile: JsonValue
    personalizedForgettingCurve: JsonValue
    lastAnalyzedAt: Date
    dataQualityScore: number
    _count: UserLearningProfileCountAggregateOutputType | null
    _avg: UserLearningProfileAvgAggregateOutputType | null
    _sum: UserLearningProfileSumAggregateOutputType | null
    _min: UserLearningProfileMinAggregateOutputType | null
    _max: UserLearningProfileMaxAggregateOutputType | null
  }

  type GetUserLearningProfileGroupByPayload<T extends UserLearningProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserLearningProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserLearningProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserLearningProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserLearningProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserLearningProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    preferredStudyTimes?: boolean
    averageSessionDuration?: boolean
    optimalSessionDuration?: boolean
    contentPreferences?: boolean
    learningStyleProfile?: boolean
    personalizedForgettingCurve?: boolean
    lastAnalyzedAt?: boolean
    dataQualityScore?: boolean
  }, ExtArgs["result"]["userLearningProfile"]>

  export type UserLearningProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    preferredStudyTimes?: boolean
    averageSessionDuration?: boolean
    optimalSessionDuration?: boolean
    contentPreferences?: boolean
    learningStyleProfile?: boolean
    personalizedForgettingCurve?: boolean
    lastAnalyzedAt?: boolean
    dataQualityScore?: boolean
  }, ExtArgs["result"]["userLearningProfile"]>

  export type UserLearningProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    preferredStudyTimes?: boolean
    averageSessionDuration?: boolean
    optimalSessionDuration?: boolean
    contentPreferences?: boolean
    learningStyleProfile?: boolean
    personalizedForgettingCurve?: boolean
    lastAnalyzedAt?: boolean
    dataQualityScore?: boolean
  }


  export type $UserLearningProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserLearningProfile"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      preferredStudyTimes: Prisma.JsonValue
      averageSessionDuration: number
      optimalSessionDuration: number
      contentPreferences: Prisma.JsonValue
      learningStyleProfile: Prisma.JsonValue
      personalizedForgettingCurve: Prisma.JsonValue
      lastAnalyzedAt: Date
      dataQualityScore: number
    }, ExtArgs["result"]["userLearningProfile"]>
    composites: {}
  }

  type UserLearningProfileGetPayload<S extends boolean | null | undefined | UserLearningProfileDefaultArgs> = $Result.GetResult<Prisma.$UserLearningProfilePayload, S>

  type UserLearningProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserLearningProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserLearningProfileCountAggregateInputType | true
    }

  export interface UserLearningProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserLearningProfile'], meta: { name: 'UserLearningProfile' } }
    /**
     * Find zero or one UserLearningProfile that matches the filter.
     * @param {UserLearningProfileFindUniqueArgs} args - Arguments to find a UserLearningProfile
     * @example
     * // Get one UserLearningProfile
     * const userLearningProfile = await prisma.userLearningProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserLearningProfileFindUniqueArgs>(args: SelectSubset<T, UserLearningProfileFindUniqueArgs<ExtArgs>>): Prisma__UserLearningProfileClient<$Result.GetResult<Prisma.$UserLearningProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserLearningProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserLearningProfileFindUniqueOrThrowArgs} args - Arguments to find a UserLearningProfile
     * @example
     * // Get one UserLearningProfile
     * const userLearningProfile = await prisma.userLearningProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserLearningProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserLearningProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserLearningProfileClient<$Result.GetResult<Prisma.$UserLearningProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserLearningProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLearningProfileFindFirstArgs} args - Arguments to find a UserLearningProfile
     * @example
     * // Get one UserLearningProfile
     * const userLearningProfile = await prisma.userLearningProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserLearningProfileFindFirstArgs>(args?: SelectSubset<T, UserLearningProfileFindFirstArgs<ExtArgs>>): Prisma__UserLearningProfileClient<$Result.GetResult<Prisma.$UserLearningProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserLearningProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLearningProfileFindFirstOrThrowArgs} args - Arguments to find a UserLearningProfile
     * @example
     * // Get one UserLearningProfile
     * const userLearningProfile = await prisma.userLearningProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserLearningProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserLearningProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserLearningProfileClient<$Result.GetResult<Prisma.$UserLearningProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserLearningProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLearningProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserLearningProfiles
     * const userLearningProfiles = await prisma.userLearningProfile.findMany()
     * 
     * // Get first 10 UserLearningProfiles
     * const userLearningProfiles = await prisma.userLearningProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userLearningProfileWithIdOnly = await prisma.userLearningProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserLearningProfileFindManyArgs>(args?: SelectSubset<T, UserLearningProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLearningProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserLearningProfile.
     * @param {UserLearningProfileCreateArgs} args - Arguments to create a UserLearningProfile.
     * @example
     * // Create one UserLearningProfile
     * const UserLearningProfile = await prisma.userLearningProfile.create({
     *   data: {
     *     // ... data to create a UserLearningProfile
     *   }
     * })
     * 
     */
    create<T extends UserLearningProfileCreateArgs>(args: SelectSubset<T, UserLearningProfileCreateArgs<ExtArgs>>): Prisma__UserLearningProfileClient<$Result.GetResult<Prisma.$UserLearningProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserLearningProfiles.
     * @param {UserLearningProfileCreateManyArgs} args - Arguments to create many UserLearningProfiles.
     * @example
     * // Create many UserLearningProfiles
     * const userLearningProfile = await prisma.userLearningProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserLearningProfileCreateManyArgs>(args?: SelectSubset<T, UserLearningProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserLearningProfiles and returns the data saved in the database.
     * @param {UserLearningProfileCreateManyAndReturnArgs} args - Arguments to create many UserLearningProfiles.
     * @example
     * // Create many UserLearningProfiles
     * const userLearningProfile = await prisma.userLearningProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserLearningProfiles and only return the `id`
     * const userLearningProfileWithIdOnly = await prisma.userLearningProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserLearningProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, UserLearningProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserLearningProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserLearningProfile.
     * @param {UserLearningProfileDeleteArgs} args - Arguments to delete one UserLearningProfile.
     * @example
     * // Delete one UserLearningProfile
     * const UserLearningProfile = await prisma.userLearningProfile.delete({
     *   where: {
     *     // ... filter to delete one UserLearningProfile
     *   }
     * })
     * 
     */
    delete<T extends UserLearningProfileDeleteArgs>(args: SelectSubset<T, UserLearningProfileDeleteArgs<ExtArgs>>): Prisma__UserLearningProfileClient<$Result.GetResult<Prisma.$UserLearningProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserLearningProfile.
     * @param {UserLearningProfileUpdateArgs} args - Arguments to update one UserLearningProfile.
     * @example
     * // Update one UserLearningProfile
     * const userLearningProfile = await prisma.userLearningProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserLearningProfileUpdateArgs>(args: SelectSubset<T, UserLearningProfileUpdateArgs<ExtArgs>>): Prisma__UserLearningProfileClient<$Result.GetResult<Prisma.$UserLearningProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserLearningProfiles.
     * @param {UserLearningProfileDeleteManyArgs} args - Arguments to filter UserLearningProfiles to delete.
     * @example
     * // Delete a few UserLearningProfiles
     * const { count } = await prisma.userLearningProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserLearningProfileDeleteManyArgs>(args?: SelectSubset<T, UserLearningProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserLearningProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLearningProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserLearningProfiles
     * const userLearningProfile = await prisma.userLearningProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserLearningProfileUpdateManyArgs>(args: SelectSubset<T, UserLearningProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserLearningProfile.
     * @param {UserLearningProfileUpsertArgs} args - Arguments to update or create a UserLearningProfile.
     * @example
     * // Update or create a UserLearningProfile
     * const userLearningProfile = await prisma.userLearningProfile.upsert({
     *   create: {
     *     // ... data to create a UserLearningProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserLearningProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserLearningProfileUpsertArgs>(args: SelectSubset<T, UserLearningProfileUpsertArgs<ExtArgs>>): Prisma__UserLearningProfileClient<$Result.GetResult<Prisma.$UserLearningProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserLearningProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLearningProfileCountArgs} args - Arguments to filter UserLearningProfiles to count.
     * @example
     * // Count the number of UserLearningProfiles
     * const count = await prisma.userLearningProfile.count({
     *   where: {
     *     // ... the filter for the UserLearningProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserLearningProfileCountArgs>(
      args?: Subset<T, UserLearningProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserLearningProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserLearningProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLearningProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserLearningProfileAggregateArgs>(args: Subset<T, UserLearningProfileAggregateArgs>): Prisma.PrismaPromise<GetUserLearningProfileAggregateType<T>>

    /**
     * Group by UserLearningProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserLearningProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserLearningProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserLearningProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserLearningProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserLearningProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserLearningProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserLearningProfile model
   */
  readonly fields: UserLearningProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserLearningProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserLearningProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserLearningProfile model
   */ 
  interface UserLearningProfileFieldRefs {
    readonly id: FieldRef<"UserLearningProfile", 'String'>
    readonly userId: FieldRef<"UserLearningProfile", 'String'>
    readonly preferredStudyTimes: FieldRef<"UserLearningProfile", 'Json'>
    readonly averageSessionDuration: FieldRef<"UserLearningProfile", 'Int'>
    readonly optimalSessionDuration: FieldRef<"UserLearningProfile", 'Int'>
    readonly contentPreferences: FieldRef<"UserLearningProfile", 'Json'>
    readonly learningStyleProfile: FieldRef<"UserLearningProfile", 'Json'>
    readonly personalizedForgettingCurve: FieldRef<"UserLearningProfile", 'Json'>
    readonly lastAnalyzedAt: FieldRef<"UserLearningProfile", 'DateTime'>
    readonly dataQualityScore: FieldRef<"UserLearningProfile", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * UserLearningProfile findUnique
   */
  export type UserLearningProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningProfile
     */
    select?: UserLearningProfileSelect<ExtArgs> | null
    /**
     * Filter, which UserLearningProfile to fetch.
     */
    where: UserLearningProfileWhereUniqueInput
  }

  /**
   * UserLearningProfile findUniqueOrThrow
   */
  export type UserLearningProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningProfile
     */
    select?: UserLearningProfileSelect<ExtArgs> | null
    /**
     * Filter, which UserLearningProfile to fetch.
     */
    where: UserLearningProfileWhereUniqueInput
  }

  /**
   * UserLearningProfile findFirst
   */
  export type UserLearningProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningProfile
     */
    select?: UserLearningProfileSelect<ExtArgs> | null
    /**
     * Filter, which UserLearningProfile to fetch.
     */
    where?: UserLearningProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLearningProfiles to fetch.
     */
    orderBy?: UserLearningProfileOrderByWithRelationInput | UserLearningProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLearningProfiles.
     */
    cursor?: UserLearningProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLearningProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLearningProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLearningProfiles.
     */
    distinct?: UserLearningProfileScalarFieldEnum | UserLearningProfileScalarFieldEnum[]
  }

  /**
   * UserLearningProfile findFirstOrThrow
   */
  export type UserLearningProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningProfile
     */
    select?: UserLearningProfileSelect<ExtArgs> | null
    /**
     * Filter, which UserLearningProfile to fetch.
     */
    where?: UserLearningProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLearningProfiles to fetch.
     */
    orderBy?: UserLearningProfileOrderByWithRelationInput | UserLearningProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserLearningProfiles.
     */
    cursor?: UserLearningProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLearningProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLearningProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserLearningProfiles.
     */
    distinct?: UserLearningProfileScalarFieldEnum | UserLearningProfileScalarFieldEnum[]
  }

  /**
   * UserLearningProfile findMany
   */
  export type UserLearningProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningProfile
     */
    select?: UserLearningProfileSelect<ExtArgs> | null
    /**
     * Filter, which UserLearningProfiles to fetch.
     */
    where?: UserLearningProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserLearningProfiles to fetch.
     */
    orderBy?: UserLearningProfileOrderByWithRelationInput | UserLearningProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserLearningProfiles.
     */
    cursor?: UserLearningProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserLearningProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserLearningProfiles.
     */
    skip?: number
    distinct?: UserLearningProfileScalarFieldEnum | UserLearningProfileScalarFieldEnum[]
  }

  /**
   * UserLearningProfile create
   */
  export type UserLearningProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningProfile
     */
    select?: UserLearningProfileSelect<ExtArgs> | null
    /**
     * The data needed to create a UserLearningProfile.
     */
    data: XOR<UserLearningProfileCreateInput, UserLearningProfileUncheckedCreateInput>
  }

  /**
   * UserLearningProfile createMany
   */
  export type UserLearningProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserLearningProfiles.
     */
    data: UserLearningProfileCreateManyInput | UserLearningProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserLearningProfile createManyAndReturn
   */
  export type UserLearningProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningProfile
     */
    select?: UserLearningProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserLearningProfiles.
     */
    data: UserLearningProfileCreateManyInput | UserLearningProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserLearningProfile update
   */
  export type UserLearningProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningProfile
     */
    select?: UserLearningProfileSelect<ExtArgs> | null
    /**
     * The data needed to update a UserLearningProfile.
     */
    data: XOR<UserLearningProfileUpdateInput, UserLearningProfileUncheckedUpdateInput>
    /**
     * Choose, which UserLearningProfile to update.
     */
    where: UserLearningProfileWhereUniqueInput
  }

  /**
   * UserLearningProfile updateMany
   */
  export type UserLearningProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserLearningProfiles.
     */
    data: XOR<UserLearningProfileUpdateManyMutationInput, UserLearningProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserLearningProfiles to update
     */
    where?: UserLearningProfileWhereInput
  }

  /**
   * UserLearningProfile upsert
   */
  export type UserLearningProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningProfile
     */
    select?: UserLearningProfileSelect<ExtArgs> | null
    /**
     * The filter to search for the UserLearningProfile to update in case it exists.
     */
    where: UserLearningProfileWhereUniqueInput
    /**
     * In case the UserLearningProfile found by the `where` argument doesn't exist, create a new UserLearningProfile with this data.
     */
    create: XOR<UserLearningProfileCreateInput, UserLearningProfileUncheckedCreateInput>
    /**
     * In case the UserLearningProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserLearningProfileUpdateInput, UserLearningProfileUncheckedUpdateInput>
  }

  /**
   * UserLearningProfile delete
   */
  export type UserLearningProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningProfile
     */
    select?: UserLearningProfileSelect<ExtArgs> | null
    /**
     * Filter which UserLearningProfile to delete.
     */
    where: UserLearningProfileWhereUniqueInput
  }

  /**
   * UserLearningProfile deleteMany
   */
  export type UserLearningProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserLearningProfiles to delete
     */
    where?: UserLearningProfileWhereInput
  }

  /**
   * UserLearningProfile without action
   */
  export type UserLearningProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserLearningProfile
     */
    select?: UserLearningProfileSelect<ExtArgs> | null
  }


  /**
   * Model LearningPattern
   */

  export type AggregateLearningPattern = {
    _count: LearningPatternCountAggregateOutputType | null
    _avg: LearningPatternAvgAggregateOutputType | null
    _sum: LearningPatternSumAggregateOutputType | null
    _min: LearningPatternMinAggregateOutputType | null
    _max: LearningPatternMaxAggregateOutputType | null
  }

  export type LearningPatternAvgAggregateOutputType = {
    confidence: number | null
  }

  export type LearningPatternSumAggregateOutputType = {
    confidence: number | null
  }

  export type LearningPatternMinAggregateOutputType = {
    id: string | null
    userId: string | null
    patternType: $Enums.PatternType | null
    confidence: number | null
    detectedAt: Date | null
    lastSeenAt: Date | null
  }

  export type LearningPatternMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    patternType: $Enums.PatternType | null
    confidence: number | null
    detectedAt: Date | null
    lastSeenAt: Date | null
  }

  export type LearningPatternCountAggregateOutputType = {
    id: number
    userId: number
    patternType: number
    patternData: number
    confidence: number
    detectedAt: number
    lastSeenAt: number
    _all: number
  }


  export type LearningPatternAvgAggregateInputType = {
    confidence?: true
  }

  export type LearningPatternSumAggregateInputType = {
    confidence?: true
  }

  export type LearningPatternMinAggregateInputType = {
    id?: true
    userId?: true
    patternType?: true
    confidence?: true
    detectedAt?: true
    lastSeenAt?: true
  }

  export type LearningPatternMaxAggregateInputType = {
    id?: true
    userId?: true
    patternType?: true
    confidence?: true
    detectedAt?: true
    lastSeenAt?: true
  }

  export type LearningPatternCountAggregateInputType = {
    id?: true
    userId?: true
    patternType?: true
    patternData?: true
    confidence?: true
    detectedAt?: true
    lastSeenAt?: true
    _all?: true
  }

  export type LearningPatternAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningPattern to aggregate.
     */
    where?: LearningPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPatterns to fetch.
     */
    orderBy?: LearningPatternOrderByWithRelationInput | LearningPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearningPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearningPatterns
    **/
    _count?: true | LearningPatternCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LearningPatternAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LearningPatternSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearningPatternMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearningPatternMaxAggregateInputType
  }

  export type GetLearningPatternAggregateType<T extends LearningPatternAggregateArgs> = {
        [P in keyof T & keyof AggregateLearningPattern]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearningPattern[P]>
      : GetScalarType<T[P], AggregateLearningPattern[P]>
  }




  export type LearningPatternGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearningPatternWhereInput
    orderBy?: LearningPatternOrderByWithAggregationInput | LearningPatternOrderByWithAggregationInput[]
    by: LearningPatternScalarFieldEnum[] | LearningPatternScalarFieldEnum
    having?: LearningPatternScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearningPatternCountAggregateInputType | true
    _avg?: LearningPatternAvgAggregateInputType
    _sum?: LearningPatternSumAggregateInputType
    _min?: LearningPatternMinAggregateInputType
    _max?: LearningPatternMaxAggregateInputType
  }

  export type LearningPatternGroupByOutputType = {
    id: string
    userId: string
    patternType: $Enums.PatternType
    patternData: JsonValue
    confidence: number
    detectedAt: Date
    lastSeenAt: Date
    _count: LearningPatternCountAggregateOutputType | null
    _avg: LearningPatternAvgAggregateOutputType | null
    _sum: LearningPatternSumAggregateOutputType | null
    _min: LearningPatternMinAggregateOutputType | null
    _max: LearningPatternMaxAggregateOutputType | null
  }

  type GetLearningPatternGroupByPayload<T extends LearningPatternGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearningPatternGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearningPatternGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearningPatternGroupByOutputType[P]>
            : GetScalarType<T[P], LearningPatternGroupByOutputType[P]>
        }
      >
    >


  export type LearningPatternSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    patternType?: boolean
    patternData?: boolean
    confidence?: boolean
    detectedAt?: boolean
    lastSeenAt?: boolean
  }, ExtArgs["result"]["learningPattern"]>

  export type LearningPatternSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    patternType?: boolean
    patternData?: boolean
    confidence?: boolean
    detectedAt?: boolean
    lastSeenAt?: boolean
  }, ExtArgs["result"]["learningPattern"]>

  export type LearningPatternSelectScalar = {
    id?: boolean
    userId?: boolean
    patternType?: boolean
    patternData?: boolean
    confidence?: boolean
    detectedAt?: boolean
    lastSeenAt?: boolean
  }


  export type $LearningPatternPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearningPattern"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      patternType: $Enums.PatternType
      patternData: Prisma.JsonValue
      confidence: number
      detectedAt: Date
      lastSeenAt: Date
    }, ExtArgs["result"]["learningPattern"]>
    composites: {}
  }

  type LearningPatternGetPayload<S extends boolean | null | undefined | LearningPatternDefaultArgs> = $Result.GetResult<Prisma.$LearningPatternPayload, S>

  type LearningPatternCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LearningPatternFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LearningPatternCountAggregateInputType | true
    }

  export interface LearningPatternDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearningPattern'], meta: { name: 'LearningPattern' } }
    /**
     * Find zero or one LearningPattern that matches the filter.
     * @param {LearningPatternFindUniqueArgs} args - Arguments to find a LearningPattern
     * @example
     * // Get one LearningPattern
     * const learningPattern = await prisma.learningPattern.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearningPatternFindUniqueArgs>(args: SelectSubset<T, LearningPatternFindUniqueArgs<ExtArgs>>): Prisma__LearningPatternClient<$Result.GetResult<Prisma.$LearningPatternPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LearningPattern that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LearningPatternFindUniqueOrThrowArgs} args - Arguments to find a LearningPattern
     * @example
     * // Get one LearningPattern
     * const learningPattern = await prisma.learningPattern.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearningPatternFindUniqueOrThrowArgs>(args: SelectSubset<T, LearningPatternFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearningPatternClient<$Result.GetResult<Prisma.$LearningPatternPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LearningPattern that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPatternFindFirstArgs} args - Arguments to find a LearningPattern
     * @example
     * // Get one LearningPattern
     * const learningPattern = await prisma.learningPattern.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearningPatternFindFirstArgs>(args?: SelectSubset<T, LearningPatternFindFirstArgs<ExtArgs>>): Prisma__LearningPatternClient<$Result.GetResult<Prisma.$LearningPatternPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LearningPattern that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPatternFindFirstOrThrowArgs} args - Arguments to find a LearningPattern
     * @example
     * // Get one LearningPattern
     * const learningPattern = await prisma.learningPattern.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearningPatternFindFirstOrThrowArgs>(args?: SelectSubset<T, LearningPatternFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearningPatternClient<$Result.GetResult<Prisma.$LearningPatternPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LearningPatterns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPatternFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearningPatterns
     * const learningPatterns = await prisma.learningPattern.findMany()
     * 
     * // Get first 10 LearningPatterns
     * const learningPatterns = await prisma.learningPattern.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learningPatternWithIdOnly = await prisma.learningPattern.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LearningPatternFindManyArgs>(args?: SelectSubset<T, LearningPatternFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPatternPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LearningPattern.
     * @param {LearningPatternCreateArgs} args - Arguments to create a LearningPattern.
     * @example
     * // Create one LearningPattern
     * const LearningPattern = await prisma.learningPattern.create({
     *   data: {
     *     // ... data to create a LearningPattern
     *   }
     * })
     * 
     */
    create<T extends LearningPatternCreateArgs>(args: SelectSubset<T, LearningPatternCreateArgs<ExtArgs>>): Prisma__LearningPatternClient<$Result.GetResult<Prisma.$LearningPatternPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LearningPatterns.
     * @param {LearningPatternCreateManyArgs} args - Arguments to create many LearningPatterns.
     * @example
     * // Create many LearningPatterns
     * const learningPattern = await prisma.learningPattern.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearningPatternCreateManyArgs>(args?: SelectSubset<T, LearningPatternCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearningPatterns and returns the data saved in the database.
     * @param {LearningPatternCreateManyAndReturnArgs} args - Arguments to create many LearningPatterns.
     * @example
     * // Create many LearningPatterns
     * const learningPattern = await prisma.learningPattern.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearningPatterns and only return the `id`
     * const learningPatternWithIdOnly = await prisma.learningPattern.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearningPatternCreateManyAndReturnArgs>(args?: SelectSubset<T, LearningPatternCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearningPatternPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LearningPattern.
     * @param {LearningPatternDeleteArgs} args - Arguments to delete one LearningPattern.
     * @example
     * // Delete one LearningPattern
     * const LearningPattern = await prisma.learningPattern.delete({
     *   where: {
     *     // ... filter to delete one LearningPattern
     *   }
     * })
     * 
     */
    delete<T extends LearningPatternDeleteArgs>(args: SelectSubset<T, LearningPatternDeleteArgs<ExtArgs>>): Prisma__LearningPatternClient<$Result.GetResult<Prisma.$LearningPatternPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LearningPattern.
     * @param {LearningPatternUpdateArgs} args - Arguments to update one LearningPattern.
     * @example
     * // Update one LearningPattern
     * const learningPattern = await prisma.learningPattern.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearningPatternUpdateArgs>(args: SelectSubset<T, LearningPatternUpdateArgs<ExtArgs>>): Prisma__LearningPatternClient<$Result.GetResult<Prisma.$LearningPatternPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LearningPatterns.
     * @param {LearningPatternDeleteManyArgs} args - Arguments to filter LearningPatterns to delete.
     * @example
     * // Delete a few LearningPatterns
     * const { count } = await prisma.learningPattern.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearningPatternDeleteManyArgs>(args?: SelectSubset<T, LearningPatternDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearningPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPatternUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearningPatterns
     * const learningPattern = await prisma.learningPattern.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearningPatternUpdateManyArgs>(args: SelectSubset<T, LearningPatternUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LearningPattern.
     * @param {LearningPatternUpsertArgs} args - Arguments to update or create a LearningPattern.
     * @example
     * // Update or create a LearningPattern
     * const learningPattern = await prisma.learningPattern.upsert({
     *   create: {
     *     // ... data to create a LearningPattern
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearningPattern we want to update
     *   }
     * })
     */
    upsert<T extends LearningPatternUpsertArgs>(args: SelectSubset<T, LearningPatternUpsertArgs<ExtArgs>>): Prisma__LearningPatternClient<$Result.GetResult<Prisma.$LearningPatternPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LearningPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPatternCountArgs} args - Arguments to filter LearningPatterns to count.
     * @example
     * // Count the number of LearningPatterns
     * const count = await prisma.learningPattern.count({
     *   where: {
     *     // ... the filter for the LearningPatterns we want to count
     *   }
     * })
    **/
    count<T extends LearningPatternCountArgs>(
      args?: Subset<T, LearningPatternCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearningPatternCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearningPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPatternAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearningPatternAggregateArgs>(args: Subset<T, LearningPatternAggregateArgs>): Prisma.PrismaPromise<GetLearningPatternAggregateType<T>>

    /**
     * Group by LearningPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearningPatternGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearningPatternGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearningPatternGroupByArgs['orderBy'] }
        : { orderBy?: LearningPatternGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearningPatternGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearningPatternGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearningPattern model
   */
  readonly fields: LearningPatternFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearningPattern.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearningPatternClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearningPattern model
   */ 
  interface LearningPatternFieldRefs {
    readonly id: FieldRef<"LearningPattern", 'String'>
    readonly userId: FieldRef<"LearningPattern", 'String'>
    readonly patternType: FieldRef<"LearningPattern", 'PatternType'>
    readonly patternData: FieldRef<"LearningPattern", 'Json'>
    readonly confidence: FieldRef<"LearningPattern", 'Float'>
    readonly detectedAt: FieldRef<"LearningPattern", 'DateTime'>
    readonly lastSeenAt: FieldRef<"LearningPattern", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LearningPattern findUnique
   */
  export type LearningPatternFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPattern
     */
    select?: LearningPatternSelect<ExtArgs> | null
    /**
     * Filter, which LearningPattern to fetch.
     */
    where: LearningPatternWhereUniqueInput
  }

  /**
   * LearningPattern findUniqueOrThrow
   */
  export type LearningPatternFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPattern
     */
    select?: LearningPatternSelect<ExtArgs> | null
    /**
     * Filter, which LearningPattern to fetch.
     */
    where: LearningPatternWhereUniqueInput
  }

  /**
   * LearningPattern findFirst
   */
  export type LearningPatternFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPattern
     */
    select?: LearningPatternSelect<ExtArgs> | null
    /**
     * Filter, which LearningPattern to fetch.
     */
    where?: LearningPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPatterns to fetch.
     */
    orderBy?: LearningPatternOrderByWithRelationInput | LearningPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningPatterns.
     */
    cursor?: LearningPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningPatterns.
     */
    distinct?: LearningPatternScalarFieldEnum | LearningPatternScalarFieldEnum[]
  }

  /**
   * LearningPattern findFirstOrThrow
   */
  export type LearningPatternFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPattern
     */
    select?: LearningPatternSelect<ExtArgs> | null
    /**
     * Filter, which LearningPattern to fetch.
     */
    where?: LearningPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPatterns to fetch.
     */
    orderBy?: LearningPatternOrderByWithRelationInput | LearningPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearningPatterns.
     */
    cursor?: LearningPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearningPatterns.
     */
    distinct?: LearningPatternScalarFieldEnum | LearningPatternScalarFieldEnum[]
  }

  /**
   * LearningPattern findMany
   */
  export type LearningPatternFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPattern
     */
    select?: LearningPatternSelect<ExtArgs> | null
    /**
     * Filter, which LearningPatterns to fetch.
     */
    where?: LearningPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearningPatterns to fetch.
     */
    orderBy?: LearningPatternOrderByWithRelationInput | LearningPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearningPatterns.
     */
    cursor?: LearningPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearningPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearningPatterns.
     */
    skip?: number
    distinct?: LearningPatternScalarFieldEnum | LearningPatternScalarFieldEnum[]
  }

  /**
   * LearningPattern create
   */
  export type LearningPatternCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPattern
     */
    select?: LearningPatternSelect<ExtArgs> | null
    /**
     * The data needed to create a LearningPattern.
     */
    data: XOR<LearningPatternCreateInput, LearningPatternUncheckedCreateInput>
  }

  /**
   * LearningPattern createMany
   */
  export type LearningPatternCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearningPatterns.
     */
    data: LearningPatternCreateManyInput | LearningPatternCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearningPattern createManyAndReturn
   */
  export type LearningPatternCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPattern
     */
    select?: LearningPatternSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LearningPatterns.
     */
    data: LearningPatternCreateManyInput | LearningPatternCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearningPattern update
   */
  export type LearningPatternUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPattern
     */
    select?: LearningPatternSelect<ExtArgs> | null
    /**
     * The data needed to update a LearningPattern.
     */
    data: XOR<LearningPatternUpdateInput, LearningPatternUncheckedUpdateInput>
    /**
     * Choose, which LearningPattern to update.
     */
    where: LearningPatternWhereUniqueInput
  }

  /**
   * LearningPattern updateMany
   */
  export type LearningPatternUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearningPatterns.
     */
    data: XOR<LearningPatternUpdateManyMutationInput, LearningPatternUncheckedUpdateManyInput>
    /**
     * Filter which LearningPatterns to update
     */
    where?: LearningPatternWhereInput
  }

  /**
   * LearningPattern upsert
   */
  export type LearningPatternUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPattern
     */
    select?: LearningPatternSelect<ExtArgs> | null
    /**
     * The filter to search for the LearningPattern to update in case it exists.
     */
    where: LearningPatternWhereUniqueInput
    /**
     * In case the LearningPattern found by the `where` argument doesn't exist, create a new LearningPattern with this data.
     */
    create: XOR<LearningPatternCreateInput, LearningPatternUncheckedCreateInput>
    /**
     * In case the LearningPattern was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearningPatternUpdateInput, LearningPatternUncheckedUpdateInput>
  }

  /**
   * LearningPattern delete
   */
  export type LearningPatternDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPattern
     */
    select?: LearningPatternSelect<ExtArgs> | null
    /**
     * Filter which LearningPattern to delete.
     */
    where: LearningPatternWhereUniqueInput
  }

  /**
   * LearningPattern deleteMany
   */
  export type LearningPatternDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearningPatterns to delete
     */
    where?: LearningPatternWhereInput
  }

  /**
   * LearningPattern without action
   */
  export type LearningPatternDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningPattern
     */
    select?: LearningPatternSelect<ExtArgs> | null
  }


  /**
   * Model PerformancePrediction
   */

  export type AggregatePerformancePrediction = {
    _count: PerformancePredictionCountAggregateOutputType | null
    _avg: PerformancePredictionAvgAggregateOutputType | null
    _sum: PerformancePredictionSumAggregateOutputType | null
    _min: PerformancePredictionMinAggregateOutputType | null
    _max: PerformancePredictionMaxAggregateOutputType | null
  }

  export type PerformancePredictionAvgAggregateOutputType = {
    confidence: number | null
  }

  export type PerformancePredictionSumAggregateOutputType = {
    confidence: number | null
  }

  export type PerformancePredictionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    predictedFor: Date | null
    predictionType: string | null
    confidence: number | null
    createdAt: Date | null
  }

  export type PerformancePredictionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    predictedFor: Date | null
    predictionType: string | null
    confidence: number | null
    createdAt: Date | null
  }

  export type PerformancePredictionCountAggregateOutputType = {
    id: number
    userId: number
    predictedFor: number
    predictionType: number
    prediction: number
    confidence: number
    createdAt: number
    _all: number
  }


  export type PerformancePredictionAvgAggregateInputType = {
    confidence?: true
  }

  export type PerformancePredictionSumAggregateInputType = {
    confidence?: true
  }

  export type PerformancePredictionMinAggregateInputType = {
    id?: true
    userId?: true
    predictedFor?: true
    predictionType?: true
    confidence?: true
    createdAt?: true
  }

  export type PerformancePredictionMaxAggregateInputType = {
    id?: true
    userId?: true
    predictedFor?: true
    predictionType?: true
    confidence?: true
    createdAt?: true
  }

  export type PerformancePredictionCountAggregateInputType = {
    id?: true
    userId?: true
    predictedFor?: true
    predictionType?: true
    prediction?: true
    confidence?: true
    createdAt?: true
    _all?: true
  }

  export type PerformancePredictionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformancePrediction to aggregate.
     */
    where?: PerformancePredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformancePredictions to fetch.
     */
    orderBy?: PerformancePredictionOrderByWithRelationInput | PerformancePredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerformancePredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformancePredictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformancePredictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerformancePredictions
    **/
    _count?: true | PerformancePredictionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformancePredictionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformancePredictionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformancePredictionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformancePredictionMaxAggregateInputType
  }

  export type GetPerformancePredictionAggregateType<T extends PerformancePredictionAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformancePrediction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformancePrediction[P]>
      : GetScalarType<T[P], AggregatePerformancePrediction[P]>
  }




  export type PerformancePredictionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformancePredictionWhereInput
    orderBy?: PerformancePredictionOrderByWithAggregationInput | PerformancePredictionOrderByWithAggregationInput[]
    by: PerformancePredictionScalarFieldEnum[] | PerformancePredictionScalarFieldEnum
    having?: PerformancePredictionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformancePredictionCountAggregateInputType | true
    _avg?: PerformancePredictionAvgAggregateInputType
    _sum?: PerformancePredictionSumAggregateInputType
    _min?: PerformancePredictionMinAggregateInputType
    _max?: PerformancePredictionMaxAggregateInputType
  }

  export type PerformancePredictionGroupByOutputType = {
    id: string
    userId: string
    predictedFor: Date
    predictionType: string
    prediction: JsonValue
    confidence: number
    createdAt: Date
    _count: PerformancePredictionCountAggregateOutputType | null
    _avg: PerformancePredictionAvgAggregateOutputType | null
    _sum: PerformancePredictionSumAggregateOutputType | null
    _min: PerformancePredictionMinAggregateOutputType | null
    _max: PerformancePredictionMaxAggregateOutputType | null
  }

  type GetPerformancePredictionGroupByPayload<T extends PerformancePredictionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformancePredictionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformancePredictionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformancePredictionGroupByOutputType[P]>
            : GetScalarType<T[P], PerformancePredictionGroupByOutputType[P]>
        }
      >
    >


  export type PerformancePredictionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    predictedFor?: boolean
    predictionType?: boolean
    prediction?: boolean
    confidence?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["performancePrediction"]>

  export type PerformancePredictionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    predictedFor?: boolean
    predictionType?: boolean
    prediction?: boolean
    confidence?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["performancePrediction"]>

  export type PerformancePredictionSelectScalar = {
    id?: boolean
    userId?: boolean
    predictedFor?: boolean
    predictionType?: boolean
    prediction?: boolean
    confidence?: boolean
    createdAt?: boolean
  }


  export type $PerformancePredictionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerformancePrediction"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      predictedFor: Date
      predictionType: string
      prediction: Prisma.JsonValue
      confidence: number
      createdAt: Date
    }, ExtArgs["result"]["performancePrediction"]>
    composites: {}
  }

  type PerformancePredictionGetPayload<S extends boolean | null | undefined | PerformancePredictionDefaultArgs> = $Result.GetResult<Prisma.$PerformancePredictionPayload, S>

  type PerformancePredictionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PerformancePredictionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PerformancePredictionCountAggregateInputType | true
    }

  export interface PerformancePredictionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerformancePrediction'], meta: { name: 'PerformancePrediction' } }
    /**
     * Find zero or one PerformancePrediction that matches the filter.
     * @param {PerformancePredictionFindUniqueArgs} args - Arguments to find a PerformancePrediction
     * @example
     * // Get one PerformancePrediction
     * const performancePrediction = await prisma.performancePrediction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerformancePredictionFindUniqueArgs>(args: SelectSubset<T, PerformancePredictionFindUniqueArgs<ExtArgs>>): Prisma__PerformancePredictionClient<$Result.GetResult<Prisma.$PerformancePredictionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PerformancePrediction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PerformancePredictionFindUniqueOrThrowArgs} args - Arguments to find a PerformancePrediction
     * @example
     * // Get one PerformancePrediction
     * const performancePrediction = await prisma.performancePrediction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerformancePredictionFindUniqueOrThrowArgs>(args: SelectSubset<T, PerformancePredictionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerformancePredictionClient<$Result.GetResult<Prisma.$PerformancePredictionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PerformancePrediction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformancePredictionFindFirstArgs} args - Arguments to find a PerformancePrediction
     * @example
     * // Get one PerformancePrediction
     * const performancePrediction = await prisma.performancePrediction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerformancePredictionFindFirstArgs>(args?: SelectSubset<T, PerformancePredictionFindFirstArgs<ExtArgs>>): Prisma__PerformancePredictionClient<$Result.GetResult<Prisma.$PerformancePredictionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PerformancePrediction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformancePredictionFindFirstOrThrowArgs} args - Arguments to find a PerformancePrediction
     * @example
     * // Get one PerformancePrediction
     * const performancePrediction = await prisma.performancePrediction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerformancePredictionFindFirstOrThrowArgs>(args?: SelectSubset<T, PerformancePredictionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerformancePredictionClient<$Result.GetResult<Prisma.$PerformancePredictionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PerformancePredictions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformancePredictionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerformancePredictions
     * const performancePredictions = await prisma.performancePrediction.findMany()
     * 
     * // Get first 10 PerformancePredictions
     * const performancePredictions = await prisma.performancePrediction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performancePredictionWithIdOnly = await prisma.performancePrediction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerformancePredictionFindManyArgs>(args?: SelectSubset<T, PerformancePredictionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformancePredictionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PerformancePrediction.
     * @param {PerformancePredictionCreateArgs} args - Arguments to create a PerformancePrediction.
     * @example
     * // Create one PerformancePrediction
     * const PerformancePrediction = await prisma.performancePrediction.create({
     *   data: {
     *     // ... data to create a PerformancePrediction
     *   }
     * })
     * 
     */
    create<T extends PerformancePredictionCreateArgs>(args: SelectSubset<T, PerformancePredictionCreateArgs<ExtArgs>>): Prisma__PerformancePredictionClient<$Result.GetResult<Prisma.$PerformancePredictionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PerformancePredictions.
     * @param {PerformancePredictionCreateManyArgs} args - Arguments to create many PerformancePredictions.
     * @example
     * // Create many PerformancePredictions
     * const performancePrediction = await prisma.performancePrediction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerformancePredictionCreateManyArgs>(args?: SelectSubset<T, PerformancePredictionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PerformancePredictions and returns the data saved in the database.
     * @param {PerformancePredictionCreateManyAndReturnArgs} args - Arguments to create many PerformancePredictions.
     * @example
     * // Create many PerformancePredictions
     * const performancePrediction = await prisma.performancePrediction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PerformancePredictions and only return the `id`
     * const performancePredictionWithIdOnly = await prisma.performancePrediction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PerformancePredictionCreateManyAndReturnArgs>(args?: SelectSubset<T, PerformancePredictionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformancePredictionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PerformancePrediction.
     * @param {PerformancePredictionDeleteArgs} args - Arguments to delete one PerformancePrediction.
     * @example
     * // Delete one PerformancePrediction
     * const PerformancePrediction = await prisma.performancePrediction.delete({
     *   where: {
     *     // ... filter to delete one PerformancePrediction
     *   }
     * })
     * 
     */
    delete<T extends PerformancePredictionDeleteArgs>(args: SelectSubset<T, PerformancePredictionDeleteArgs<ExtArgs>>): Prisma__PerformancePredictionClient<$Result.GetResult<Prisma.$PerformancePredictionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PerformancePrediction.
     * @param {PerformancePredictionUpdateArgs} args - Arguments to update one PerformancePrediction.
     * @example
     * // Update one PerformancePrediction
     * const performancePrediction = await prisma.performancePrediction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerformancePredictionUpdateArgs>(args: SelectSubset<T, PerformancePredictionUpdateArgs<ExtArgs>>): Prisma__PerformancePredictionClient<$Result.GetResult<Prisma.$PerformancePredictionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PerformancePredictions.
     * @param {PerformancePredictionDeleteManyArgs} args - Arguments to filter PerformancePredictions to delete.
     * @example
     * // Delete a few PerformancePredictions
     * const { count } = await prisma.performancePrediction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerformancePredictionDeleteManyArgs>(args?: SelectSubset<T, PerformancePredictionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformancePredictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformancePredictionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerformancePredictions
     * const performancePrediction = await prisma.performancePrediction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerformancePredictionUpdateManyArgs>(args: SelectSubset<T, PerformancePredictionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PerformancePrediction.
     * @param {PerformancePredictionUpsertArgs} args - Arguments to update or create a PerformancePrediction.
     * @example
     * // Update or create a PerformancePrediction
     * const performancePrediction = await prisma.performancePrediction.upsert({
     *   create: {
     *     // ... data to create a PerformancePrediction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerformancePrediction we want to update
     *   }
     * })
     */
    upsert<T extends PerformancePredictionUpsertArgs>(args: SelectSubset<T, PerformancePredictionUpsertArgs<ExtArgs>>): Prisma__PerformancePredictionClient<$Result.GetResult<Prisma.$PerformancePredictionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PerformancePredictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformancePredictionCountArgs} args - Arguments to filter PerformancePredictions to count.
     * @example
     * // Count the number of PerformancePredictions
     * const count = await prisma.performancePrediction.count({
     *   where: {
     *     // ... the filter for the PerformancePredictions we want to count
     *   }
     * })
    **/
    count<T extends PerformancePredictionCountArgs>(
      args?: Subset<T, PerformancePredictionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformancePredictionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerformancePrediction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformancePredictionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformancePredictionAggregateArgs>(args: Subset<T, PerformancePredictionAggregateArgs>): Prisma.PrismaPromise<GetPerformancePredictionAggregateType<T>>

    /**
     * Group by PerformancePrediction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformancePredictionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerformancePredictionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerformancePredictionGroupByArgs['orderBy'] }
        : { orderBy?: PerformancePredictionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerformancePredictionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformancePredictionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerformancePrediction model
   */
  readonly fields: PerformancePredictionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerformancePrediction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerformancePredictionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerformancePrediction model
   */ 
  interface PerformancePredictionFieldRefs {
    readonly id: FieldRef<"PerformancePrediction", 'String'>
    readonly userId: FieldRef<"PerformancePrediction", 'String'>
    readonly predictedFor: FieldRef<"PerformancePrediction", 'DateTime'>
    readonly predictionType: FieldRef<"PerformancePrediction", 'String'>
    readonly prediction: FieldRef<"PerformancePrediction", 'Json'>
    readonly confidence: FieldRef<"PerformancePrediction", 'Float'>
    readonly createdAt: FieldRef<"PerformancePrediction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PerformancePrediction findUnique
   */
  export type PerformancePredictionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformancePrediction
     */
    select?: PerformancePredictionSelect<ExtArgs> | null
    /**
     * Filter, which PerformancePrediction to fetch.
     */
    where: PerformancePredictionWhereUniqueInput
  }

  /**
   * PerformancePrediction findUniqueOrThrow
   */
  export type PerformancePredictionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformancePrediction
     */
    select?: PerformancePredictionSelect<ExtArgs> | null
    /**
     * Filter, which PerformancePrediction to fetch.
     */
    where: PerformancePredictionWhereUniqueInput
  }

  /**
   * PerformancePrediction findFirst
   */
  export type PerformancePredictionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformancePrediction
     */
    select?: PerformancePredictionSelect<ExtArgs> | null
    /**
     * Filter, which PerformancePrediction to fetch.
     */
    where?: PerformancePredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformancePredictions to fetch.
     */
    orderBy?: PerformancePredictionOrderByWithRelationInput | PerformancePredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformancePredictions.
     */
    cursor?: PerformancePredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformancePredictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformancePredictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformancePredictions.
     */
    distinct?: PerformancePredictionScalarFieldEnum | PerformancePredictionScalarFieldEnum[]
  }

  /**
   * PerformancePrediction findFirstOrThrow
   */
  export type PerformancePredictionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformancePrediction
     */
    select?: PerformancePredictionSelect<ExtArgs> | null
    /**
     * Filter, which PerformancePrediction to fetch.
     */
    where?: PerformancePredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformancePredictions to fetch.
     */
    orderBy?: PerformancePredictionOrderByWithRelationInput | PerformancePredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformancePredictions.
     */
    cursor?: PerformancePredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformancePredictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformancePredictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformancePredictions.
     */
    distinct?: PerformancePredictionScalarFieldEnum | PerformancePredictionScalarFieldEnum[]
  }

  /**
   * PerformancePrediction findMany
   */
  export type PerformancePredictionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformancePrediction
     */
    select?: PerformancePredictionSelect<ExtArgs> | null
    /**
     * Filter, which PerformancePredictions to fetch.
     */
    where?: PerformancePredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformancePredictions to fetch.
     */
    orderBy?: PerformancePredictionOrderByWithRelationInput | PerformancePredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerformancePredictions.
     */
    cursor?: PerformancePredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformancePredictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformancePredictions.
     */
    skip?: number
    distinct?: PerformancePredictionScalarFieldEnum | PerformancePredictionScalarFieldEnum[]
  }

  /**
   * PerformancePrediction create
   */
  export type PerformancePredictionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformancePrediction
     */
    select?: PerformancePredictionSelect<ExtArgs> | null
    /**
     * The data needed to create a PerformancePrediction.
     */
    data: XOR<PerformancePredictionCreateInput, PerformancePredictionUncheckedCreateInput>
  }

  /**
   * PerformancePrediction createMany
   */
  export type PerformancePredictionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerformancePredictions.
     */
    data: PerformancePredictionCreateManyInput | PerformancePredictionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerformancePrediction createManyAndReturn
   */
  export type PerformancePredictionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformancePrediction
     */
    select?: PerformancePredictionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PerformancePredictions.
     */
    data: PerformancePredictionCreateManyInput | PerformancePredictionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerformancePrediction update
   */
  export type PerformancePredictionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformancePrediction
     */
    select?: PerformancePredictionSelect<ExtArgs> | null
    /**
     * The data needed to update a PerformancePrediction.
     */
    data: XOR<PerformancePredictionUpdateInput, PerformancePredictionUncheckedUpdateInput>
    /**
     * Choose, which PerformancePrediction to update.
     */
    where: PerformancePredictionWhereUniqueInput
  }

  /**
   * PerformancePrediction updateMany
   */
  export type PerformancePredictionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerformancePredictions.
     */
    data: XOR<PerformancePredictionUpdateManyMutationInput, PerformancePredictionUncheckedUpdateManyInput>
    /**
     * Filter which PerformancePredictions to update
     */
    where?: PerformancePredictionWhereInput
  }

  /**
   * PerformancePrediction upsert
   */
  export type PerformancePredictionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformancePrediction
     */
    select?: PerformancePredictionSelect<ExtArgs> | null
    /**
     * The filter to search for the PerformancePrediction to update in case it exists.
     */
    where: PerformancePredictionWhereUniqueInput
    /**
     * In case the PerformancePrediction found by the `where` argument doesn't exist, create a new PerformancePrediction with this data.
     */
    create: XOR<PerformancePredictionCreateInput, PerformancePredictionUncheckedCreateInput>
    /**
     * In case the PerformancePrediction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerformancePredictionUpdateInput, PerformancePredictionUncheckedUpdateInput>
  }

  /**
   * PerformancePrediction delete
   */
  export type PerformancePredictionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformancePrediction
     */
    select?: PerformancePredictionSelect<ExtArgs> | null
    /**
     * Filter which PerformancePrediction to delete.
     */
    where: PerformancePredictionWhereUniqueInput
  }

  /**
   * PerformancePrediction deleteMany
   */
  export type PerformancePredictionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformancePredictions to delete
     */
    where?: PerformancePredictionWhereInput
  }

  /**
   * PerformancePrediction without action
   */
  export type PerformancePredictionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformancePrediction
     */
    select?: PerformancePredictionSelect<ExtArgs> | null
  }


  /**
   * Model StrugglePrediction
   */

  export type AggregateStrugglePrediction = {
    _count: StrugglePredictionCountAggregateOutputType | null
    _avg: StrugglePredictionAvgAggregateOutputType | null
    _sum: StrugglePredictionSumAggregateOutputType | null
    _min: StrugglePredictionMinAggregateOutputType | null
    _max: StrugglePredictionMaxAggregateOutputType | null
  }

  export type StrugglePredictionAvgAggregateOutputType = {
    predictedStruggleProbability: number | null
    predictionConfidence: number | null
  }

  export type StrugglePredictionSumAggregateOutputType = {
    predictedStruggleProbability: number | null
    predictionConfidence: number | null
  }

  export type StrugglePredictionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    learningObjectiveId: string | null
    topicId: string | null
    predictionDate: Date | null
    predictedStruggleProbability: number | null
    predictionConfidence: number | null
    predictionStatus: $Enums.PredictionStatus | null
    actualOutcome: boolean | null
    outcomeRecordedAt: Date | null
  }

  export type StrugglePredictionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    learningObjectiveId: string | null
    topicId: string | null
    predictionDate: Date | null
    predictedStruggleProbability: number | null
    predictionConfidence: number | null
    predictionStatus: $Enums.PredictionStatus | null
    actualOutcome: boolean | null
    outcomeRecordedAt: Date | null
  }

  export type StrugglePredictionCountAggregateOutputType = {
    id: number
    userId: number
    learningObjectiveId: number
    topicId: number
    predictionDate: number
    predictedStruggleProbability: number
    predictionConfidence: number
    predictionStatus: number
    actualOutcome: number
    outcomeRecordedAt: number
    featureVector: number
    _all: number
  }


  export type StrugglePredictionAvgAggregateInputType = {
    predictedStruggleProbability?: true
    predictionConfidence?: true
  }

  export type StrugglePredictionSumAggregateInputType = {
    predictedStruggleProbability?: true
    predictionConfidence?: true
  }

  export type StrugglePredictionMinAggregateInputType = {
    id?: true
    userId?: true
    learningObjectiveId?: true
    topicId?: true
    predictionDate?: true
    predictedStruggleProbability?: true
    predictionConfidence?: true
    predictionStatus?: true
    actualOutcome?: true
    outcomeRecordedAt?: true
  }

  export type StrugglePredictionMaxAggregateInputType = {
    id?: true
    userId?: true
    learningObjectiveId?: true
    topicId?: true
    predictionDate?: true
    predictedStruggleProbability?: true
    predictionConfidence?: true
    predictionStatus?: true
    actualOutcome?: true
    outcomeRecordedAt?: true
  }

  export type StrugglePredictionCountAggregateInputType = {
    id?: true
    userId?: true
    learningObjectiveId?: true
    topicId?: true
    predictionDate?: true
    predictedStruggleProbability?: true
    predictionConfidence?: true
    predictionStatus?: true
    actualOutcome?: true
    outcomeRecordedAt?: true
    featureVector?: true
    _all?: true
  }

  export type StrugglePredictionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StrugglePrediction to aggregate.
     */
    where?: StrugglePredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrugglePredictions to fetch.
     */
    orderBy?: StrugglePredictionOrderByWithRelationInput | StrugglePredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StrugglePredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrugglePredictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrugglePredictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StrugglePredictions
    **/
    _count?: true | StrugglePredictionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StrugglePredictionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StrugglePredictionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StrugglePredictionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StrugglePredictionMaxAggregateInputType
  }

  export type GetStrugglePredictionAggregateType<T extends StrugglePredictionAggregateArgs> = {
        [P in keyof T & keyof AggregateStrugglePrediction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStrugglePrediction[P]>
      : GetScalarType<T[P], AggregateStrugglePrediction[P]>
  }




  export type StrugglePredictionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StrugglePredictionWhereInput
    orderBy?: StrugglePredictionOrderByWithAggregationInput | StrugglePredictionOrderByWithAggregationInput[]
    by: StrugglePredictionScalarFieldEnum[] | StrugglePredictionScalarFieldEnum
    having?: StrugglePredictionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StrugglePredictionCountAggregateInputType | true
    _avg?: StrugglePredictionAvgAggregateInputType
    _sum?: StrugglePredictionSumAggregateInputType
    _min?: StrugglePredictionMinAggregateInputType
    _max?: StrugglePredictionMaxAggregateInputType
  }

  export type StrugglePredictionGroupByOutputType = {
    id: string
    userId: string
    learningObjectiveId: string | null
    topicId: string | null
    predictionDate: Date
    predictedStruggleProbability: number
    predictionConfidence: number
    predictionStatus: $Enums.PredictionStatus
    actualOutcome: boolean | null
    outcomeRecordedAt: Date | null
    featureVector: JsonValue
    _count: StrugglePredictionCountAggregateOutputType | null
    _avg: StrugglePredictionAvgAggregateOutputType | null
    _sum: StrugglePredictionSumAggregateOutputType | null
    _min: StrugglePredictionMinAggregateOutputType | null
    _max: StrugglePredictionMaxAggregateOutputType | null
  }

  type GetStrugglePredictionGroupByPayload<T extends StrugglePredictionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StrugglePredictionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StrugglePredictionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StrugglePredictionGroupByOutputType[P]>
            : GetScalarType<T[P], StrugglePredictionGroupByOutputType[P]>
        }
      >
    >


  export type StrugglePredictionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    learningObjectiveId?: boolean
    topicId?: boolean
    predictionDate?: boolean
    predictedStruggleProbability?: boolean
    predictionConfidence?: boolean
    predictionStatus?: boolean
    actualOutcome?: boolean
    outcomeRecordedAt?: boolean
    featureVector?: boolean
    learningObjective?: boolean | StrugglePrediction$learningObjectiveArgs<ExtArgs>
    indicators?: boolean | StrugglePrediction$indicatorsArgs<ExtArgs>
    interventions?: boolean | StrugglePrediction$interventionsArgs<ExtArgs>
    feedbacks?: boolean | StrugglePrediction$feedbacksArgs<ExtArgs>
    _count?: boolean | StrugglePredictionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["strugglePrediction"]>

  export type StrugglePredictionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    learningObjectiveId?: boolean
    topicId?: boolean
    predictionDate?: boolean
    predictedStruggleProbability?: boolean
    predictionConfidence?: boolean
    predictionStatus?: boolean
    actualOutcome?: boolean
    outcomeRecordedAt?: boolean
    featureVector?: boolean
    learningObjective?: boolean | StrugglePrediction$learningObjectiveArgs<ExtArgs>
  }, ExtArgs["result"]["strugglePrediction"]>

  export type StrugglePredictionSelectScalar = {
    id?: boolean
    userId?: boolean
    learningObjectiveId?: boolean
    topicId?: boolean
    predictionDate?: boolean
    predictedStruggleProbability?: boolean
    predictionConfidence?: boolean
    predictionStatus?: boolean
    actualOutcome?: boolean
    outcomeRecordedAt?: boolean
    featureVector?: boolean
  }

  export type StrugglePredictionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningObjective?: boolean | StrugglePrediction$learningObjectiveArgs<ExtArgs>
    indicators?: boolean | StrugglePrediction$indicatorsArgs<ExtArgs>
    interventions?: boolean | StrugglePrediction$interventionsArgs<ExtArgs>
    feedbacks?: boolean | StrugglePrediction$feedbacksArgs<ExtArgs>
    _count?: boolean | StrugglePredictionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StrugglePredictionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningObjective?: boolean | StrugglePrediction$learningObjectiveArgs<ExtArgs>
  }

  export type $StrugglePredictionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StrugglePrediction"
    objects: {
      learningObjective: Prisma.$LearningObjectivePayload<ExtArgs> | null
      indicators: Prisma.$StruggleIndicatorPayload<ExtArgs>[]
      interventions: Prisma.$InterventionRecommendationPayload<ExtArgs>[]
      feedbacks: Prisma.$PredictionFeedbackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      learningObjectiveId: string | null
      topicId: string | null
      predictionDate: Date
      predictedStruggleProbability: number
      predictionConfidence: number
      predictionStatus: $Enums.PredictionStatus
      actualOutcome: boolean | null
      outcomeRecordedAt: Date | null
      featureVector: Prisma.JsonValue
    }, ExtArgs["result"]["strugglePrediction"]>
    composites: {}
  }

  type StrugglePredictionGetPayload<S extends boolean | null | undefined | StrugglePredictionDefaultArgs> = $Result.GetResult<Prisma.$StrugglePredictionPayload, S>

  type StrugglePredictionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StrugglePredictionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StrugglePredictionCountAggregateInputType | true
    }

  export interface StrugglePredictionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StrugglePrediction'], meta: { name: 'StrugglePrediction' } }
    /**
     * Find zero or one StrugglePrediction that matches the filter.
     * @param {StrugglePredictionFindUniqueArgs} args - Arguments to find a StrugglePrediction
     * @example
     * // Get one StrugglePrediction
     * const strugglePrediction = await prisma.strugglePrediction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StrugglePredictionFindUniqueArgs>(args: SelectSubset<T, StrugglePredictionFindUniqueArgs<ExtArgs>>): Prisma__StrugglePredictionClient<$Result.GetResult<Prisma.$StrugglePredictionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StrugglePrediction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StrugglePredictionFindUniqueOrThrowArgs} args - Arguments to find a StrugglePrediction
     * @example
     * // Get one StrugglePrediction
     * const strugglePrediction = await prisma.strugglePrediction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StrugglePredictionFindUniqueOrThrowArgs>(args: SelectSubset<T, StrugglePredictionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StrugglePredictionClient<$Result.GetResult<Prisma.$StrugglePredictionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StrugglePrediction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrugglePredictionFindFirstArgs} args - Arguments to find a StrugglePrediction
     * @example
     * // Get one StrugglePrediction
     * const strugglePrediction = await prisma.strugglePrediction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StrugglePredictionFindFirstArgs>(args?: SelectSubset<T, StrugglePredictionFindFirstArgs<ExtArgs>>): Prisma__StrugglePredictionClient<$Result.GetResult<Prisma.$StrugglePredictionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StrugglePrediction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrugglePredictionFindFirstOrThrowArgs} args - Arguments to find a StrugglePrediction
     * @example
     * // Get one StrugglePrediction
     * const strugglePrediction = await prisma.strugglePrediction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StrugglePredictionFindFirstOrThrowArgs>(args?: SelectSubset<T, StrugglePredictionFindFirstOrThrowArgs<ExtArgs>>): Prisma__StrugglePredictionClient<$Result.GetResult<Prisma.$StrugglePredictionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StrugglePredictions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrugglePredictionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StrugglePredictions
     * const strugglePredictions = await prisma.strugglePrediction.findMany()
     * 
     * // Get first 10 StrugglePredictions
     * const strugglePredictions = await prisma.strugglePrediction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const strugglePredictionWithIdOnly = await prisma.strugglePrediction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StrugglePredictionFindManyArgs>(args?: SelectSubset<T, StrugglePredictionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrugglePredictionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StrugglePrediction.
     * @param {StrugglePredictionCreateArgs} args - Arguments to create a StrugglePrediction.
     * @example
     * // Create one StrugglePrediction
     * const StrugglePrediction = await prisma.strugglePrediction.create({
     *   data: {
     *     // ... data to create a StrugglePrediction
     *   }
     * })
     * 
     */
    create<T extends StrugglePredictionCreateArgs>(args: SelectSubset<T, StrugglePredictionCreateArgs<ExtArgs>>): Prisma__StrugglePredictionClient<$Result.GetResult<Prisma.$StrugglePredictionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StrugglePredictions.
     * @param {StrugglePredictionCreateManyArgs} args - Arguments to create many StrugglePredictions.
     * @example
     * // Create many StrugglePredictions
     * const strugglePrediction = await prisma.strugglePrediction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StrugglePredictionCreateManyArgs>(args?: SelectSubset<T, StrugglePredictionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StrugglePredictions and returns the data saved in the database.
     * @param {StrugglePredictionCreateManyAndReturnArgs} args - Arguments to create many StrugglePredictions.
     * @example
     * // Create many StrugglePredictions
     * const strugglePrediction = await prisma.strugglePrediction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StrugglePredictions and only return the `id`
     * const strugglePredictionWithIdOnly = await prisma.strugglePrediction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StrugglePredictionCreateManyAndReturnArgs>(args?: SelectSubset<T, StrugglePredictionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StrugglePredictionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StrugglePrediction.
     * @param {StrugglePredictionDeleteArgs} args - Arguments to delete one StrugglePrediction.
     * @example
     * // Delete one StrugglePrediction
     * const StrugglePrediction = await prisma.strugglePrediction.delete({
     *   where: {
     *     // ... filter to delete one StrugglePrediction
     *   }
     * })
     * 
     */
    delete<T extends StrugglePredictionDeleteArgs>(args: SelectSubset<T, StrugglePredictionDeleteArgs<ExtArgs>>): Prisma__StrugglePredictionClient<$Result.GetResult<Prisma.$StrugglePredictionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StrugglePrediction.
     * @param {StrugglePredictionUpdateArgs} args - Arguments to update one StrugglePrediction.
     * @example
     * // Update one StrugglePrediction
     * const strugglePrediction = await prisma.strugglePrediction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StrugglePredictionUpdateArgs>(args: SelectSubset<T, StrugglePredictionUpdateArgs<ExtArgs>>): Prisma__StrugglePredictionClient<$Result.GetResult<Prisma.$StrugglePredictionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StrugglePredictions.
     * @param {StrugglePredictionDeleteManyArgs} args - Arguments to filter StrugglePredictions to delete.
     * @example
     * // Delete a few StrugglePredictions
     * const { count } = await prisma.strugglePrediction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StrugglePredictionDeleteManyArgs>(args?: SelectSubset<T, StrugglePredictionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StrugglePredictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrugglePredictionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StrugglePredictions
     * const strugglePrediction = await prisma.strugglePrediction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StrugglePredictionUpdateManyArgs>(args: SelectSubset<T, StrugglePredictionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StrugglePrediction.
     * @param {StrugglePredictionUpsertArgs} args - Arguments to update or create a StrugglePrediction.
     * @example
     * // Update or create a StrugglePrediction
     * const strugglePrediction = await prisma.strugglePrediction.upsert({
     *   create: {
     *     // ... data to create a StrugglePrediction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StrugglePrediction we want to update
     *   }
     * })
     */
    upsert<T extends StrugglePredictionUpsertArgs>(args: SelectSubset<T, StrugglePredictionUpsertArgs<ExtArgs>>): Prisma__StrugglePredictionClient<$Result.GetResult<Prisma.$StrugglePredictionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StrugglePredictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrugglePredictionCountArgs} args - Arguments to filter StrugglePredictions to count.
     * @example
     * // Count the number of StrugglePredictions
     * const count = await prisma.strugglePrediction.count({
     *   where: {
     *     // ... the filter for the StrugglePredictions we want to count
     *   }
     * })
    **/
    count<T extends StrugglePredictionCountArgs>(
      args?: Subset<T, StrugglePredictionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StrugglePredictionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StrugglePrediction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrugglePredictionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StrugglePredictionAggregateArgs>(args: Subset<T, StrugglePredictionAggregateArgs>): Prisma.PrismaPromise<GetStrugglePredictionAggregateType<T>>

    /**
     * Group by StrugglePrediction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StrugglePredictionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StrugglePredictionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StrugglePredictionGroupByArgs['orderBy'] }
        : { orderBy?: StrugglePredictionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StrugglePredictionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStrugglePredictionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StrugglePrediction model
   */
  readonly fields: StrugglePredictionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StrugglePrediction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StrugglePredictionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    learningObjective<T extends StrugglePrediction$learningObjectiveArgs<ExtArgs> = {}>(args?: Subset<T, StrugglePrediction$learningObjectiveArgs<ExtArgs>>): Prisma__LearningObjectiveClient<$Result.GetResult<Prisma.$LearningObjectivePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    indicators<T extends StrugglePrediction$indicatorsArgs<ExtArgs> = {}>(args?: Subset<T, StrugglePrediction$indicatorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StruggleIndicatorPayload<ExtArgs>, T, "findMany"> | Null>
    interventions<T extends StrugglePrediction$interventionsArgs<ExtArgs> = {}>(args?: Subset<T, StrugglePrediction$interventionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionRecommendationPayload<ExtArgs>, T, "findMany"> | Null>
    feedbacks<T extends StrugglePrediction$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, StrugglePrediction$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PredictionFeedbackPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StrugglePrediction model
   */ 
  interface StrugglePredictionFieldRefs {
    readonly id: FieldRef<"StrugglePrediction", 'String'>
    readonly userId: FieldRef<"StrugglePrediction", 'String'>
    readonly learningObjectiveId: FieldRef<"StrugglePrediction", 'String'>
    readonly topicId: FieldRef<"StrugglePrediction", 'String'>
    readonly predictionDate: FieldRef<"StrugglePrediction", 'DateTime'>
    readonly predictedStruggleProbability: FieldRef<"StrugglePrediction", 'Float'>
    readonly predictionConfidence: FieldRef<"StrugglePrediction", 'Float'>
    readonly predictionStatus: FieldRef<"StrugglePrediction", 'PredictionStatus'>
    readonly actualOutcome: FieldRef<"StrugglePrediction", 'Boolean'>
    readonly outcomeRecordedAt: FieldRef<"StrugglePrediction", 'DateTime'>
    readonly featureVector: FieldRef<"StrugglePrediction", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * StrugglePrediction findUnique
   */
  export type StrugglePredictionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrugglePrediction
     */
    select?: StrugglePredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrugglePredictionInclude<ExtArgs> | null
    /**
     * Filter, which StrugglePrediction to fetch.
     */
    where: StrugglePredictionWhereUniqueInput
  }

  /**
   * StrugglePrediction findUniqueOrThrow
   */
  export type StrugglePredictionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrugglePrediction
     */
    select?: StrugglePredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrugglePredictionInclude<ExtArgs> | null
    /**
     * Filter, which StrugglePrediction to fetch.
     */
    where: StrugglePredictionWhereUniqueInput
  }

  /**
   * StrugglePrediction findFirst
   */
  export type StrugglePredictionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrugglePrediction
     */
    select?: StrugglePredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrugglePredictionInclude<ExtArgs> | null
    /**
     * Filter, which StrugglePrediction to fetch.
     */
    where?: StrugglePredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrugglePredictions to fetch.
     */
    orderBy?: StrugglePredictionOrderByWithRelationInput | StrugglePredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StrugglePredictions.
     */
    cursor?: StrugglePredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrugglePredictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrugglePredictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StrugglePredictions.
     */
    distinct?: StrugglePredictionScalarFieldEnum | StrugglePredictionScalarFieldEnum[]
  }

  /**
   * StrugglePrediction findFirstOrThrow
   */
  export type StrugglePredictionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrugglePrediction
     */
    select?: StrugglePredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrugglePredictionInclude<ExtArgs> | null
    /**
     * Filter, which StrugglePrediction to fetch.
     */
    where?: StrugglePredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrugglePredictions to fetch.
     */
    orderBy?: StrugglePredictionOrderByWithRelationInput | StrugglePredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StrugglePredictions.
     */
    cursor?: StrugglePredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrugglePredictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrugglePredictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StrugglePredictions.
     */
    distinct?: StrugglePredictionScalarFieldEnum | StrugglePredictionScalarFieldEnum[]
  }

  /**
   * StrugglePrediction findMany
   */
  export type StrugglePredictionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrugglePrediction
     */
    select?: StrugglePredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrugglePredictionInclude<ExtArgs> | null
    /**
     * Filter, which StrugglePredictions to fetch.
     */
    where?: StrugglePredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StrugglePredictions to fetch.
     */
    orderBy?: StrugglePredictionOrderByWithRelationInput | StrugglePredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StrugglePredictions.
     */
    cursor?: StrugglePredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StrugglePredictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StrugglePredictions.
     */
    skip?: number
    distinct?: StrugglePredictionScalarFieldEnum | StrugglePredictionScalarFieldEnum[]
  }

  /**
   * StrugglePrediction create
   */
  export type StrugglePredictionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrugglePrediction
     */
    select?: StrugglePredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrugglePredictionInclude<ExtArgs> | null
    /**
     * The data needed to create a StrugglePrediction.
     */
    data: XOR<StrugglePredictionCreateInput, StrugglePredictionUncheckedCreateInput>
  }

  /**
   * StrugglePrediction createMany
   */
  export type StrugglePredictionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StrugglePredictions.
     */
    data: StrugglePredictionCreateManyInput | StrugglePredictionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StrugglePrediction createManyAndReturn
   */
  export type StrugglePredictionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrugglePrediction
     */
    select?: StrugglePredictionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StrugglePredictions.
     */
    data: StrugglePredictionCreateManyInput | StrugglePredictionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrugglePredictionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StrugglePrediction update
   */
  export type StrugglePredictionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrugglePrediction
     */
    select?: StrugglePredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrugglePredictionInclude<ExtArgs> | null
    /**
     * The data needed to update a StrugglePrediction.
     */
    data: XOR<StrugglePredictionUpdateInput, StrugglePredictionUncheckedUpdateInput>
    /**
     * Choose, which StrugglePrediction to update.
     */
    where: StrugglePredictionWhereUniqueInput
  }

  /**
   * StrugglePrediction updateMany
   */
  export type StrugglePredictionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StrugglePredictions.
     */
    data: XOR<StrugglePredictionUpdateManyMutationInput, StrugglePredictionUncheckedUpdateManyInput>
    /**
     * Filter which StrugglePredictions to update
     */
    where?: StrugglePredictionWhereInput
  }

  /**
   * StrugglePrediction upsert
   */
  export type StrugglePredictionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrugglePrediction
     */
    select?: StrugglePredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrugglePredictionInclude<ExtArgs> | null
    /**
     * The filter to search for the StrugglePrediction to update in case it exists.
     */
    where: StrugglePredictionWhereUniqueInput
    /**
     * In case the StrugglePrediction found by the `where` argument doesn't exist, create a new StrugglePrediction with this data.
     */
    create: XOR<StrugglePredictionCreateInput, StrugglePredictionUncheckedCreateInput>
    /**
     * In case the StrugglePrediction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StrugglePredictionUpdateInput, StrugglePredictionUncheckedUpdateInput>
  }

  /**
   * StrugglePrediction delete
   */
  export type StrugglePredictionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrugglePrediction
     */
    select?: StrugglePredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrugglePredictionInclude<ExtArgs> | null
    /**
     * Filter which StrugglePrediction to delete.
     */
    where: StrugglePredictionWhereUniqueInput
  }

  /**
   * StrugglePrediction deleteMany
   */
  export type StrugglePredictionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StrugglePredictions to delete
     */
    where?: StrugglePredictionWhereInput
  }

  /**
   * StrugglePrediction.learningObjective
   */
  export type StrugglePrediction$learningObjectiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearningObjective
     */
    select?: LearningObjectiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearningObjectiveInclude<ExtArgs> | null
    where?: LearningObjectiveWhereInput
  }

  /**
   * StrugglePrediction.indicators
   */
  export type StrugglePrediction$indicatorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StruggleIndicator
     */
    select?: StruggleIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StruggleIndicatorInclude<ExtArgs> | null
    where?: StruggleIndicatorWhereInput
    orderBy?: StruggleIndicatorOrderByWithRelationInput | StruggleIndicatorOrderByWithRelationInput[]
    cursor?: StruggleIndicatorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StruggleIndicatorScalarFieldEnum | StruggleIndicatorScalarFieldEnum[]
  }

  /**
   * StrugglePrediction.interventions
   */
  export type StrugglePrediction$interventionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionRecommendation
     */
    select?: InterventionRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionRecommendationInclude<ExtArgs> | null
    where?: InterventionRecommendationWhereInput
    orderBy?: InterventionRecommendationOrderByWithRelationInput | InterventionRecommendationOrderByWithRelationInput[]
    cursor?: InterventionRecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterventionRecommendationScalarFieldEnum | InterventionRecommendationScalarFieldEnum[]
  }

  /**
   * StrugglePrediction.feedbacks
   */
  export type StrugglePrediction$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionFeedback
     */
    select?: PredictionFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionFeedbackInclude<ExtArgs> | null
    where?: PredictionFeedbackWhereInput
    orderBy?: PredictionFeedbackOrderByWithRelationInput | PredictionFeedbackOrderByWithRelationInput[]
    cursor?: PredictionFeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PredictionFeedbackScalarFieldEnum | PredictionFeedbackScalarFieldEnum[]
  }

  /**
   * StrugglePrediction without action
   */
  export type StrugglePredictionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrugglePrediction
     */
    select?: StrugglePredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrugglePredictionInclude<ExtArgs> | null
  }


  /**
   * Model StruggleIndicator
   */

  export type AggregateStruggleIndicator = {
    _count: StruggleIndicatorCountAggregateOutputType | null
    _min: StruggleIndicatorMinAggregateOutputType | null
    _max: StruggleIndicatorMaxAggregateOutputType | null
  }

  export type StruggleIndicatorMinAggregateOutputType = {
    id: string | null
    userId: string | null
    predictionId: string | null
    learningObjectiveId: string | null
    indicatorType: $Enums.IndicatorType | null
    severity: $Enums.Severity | null
    detectedAt: Date | null
  }

  export type StruggleIndicatorMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    predictionId: string | null
    learningObjectiveId: string | null
    indicatorType: $Enums.IndicatorType | null
    severity: $Enums.Severity | null
    detectedAt: Date | null
  }

  export type StruggleIndicatorCountAggregateOutputType = {
    id: number
    userId: number
    predictionId: number
    learningObjectiveId: number
    indicatorType: number
    severity: number
    detectedAt: number
    context: number
    _all: number
  }


  export type StruggleIndicatorMinAggregateInputType = {
    id?: true
    userId?: true
    predictionId?: true
    learningObjectiveId?: true
    indicatorType?: true
    severity?: true
    detectedAt?: true
  }

  export type StruggleIndicatorMaxAggregateInputType = {
    id?: true
    userId?: true
    predictionId?: true
    learningObjectiveId?: true
    indicatorType?: true
    severity?: true
    detectedAt?: true
  }

  export type StruggleIndicatorCountAggregateInputType = {
    id?: true
    userId?: true
    predictionId?: true
    learningObjectiveId?: true
    indicatorType?: true
    severity?: true
    detectedAt?: true
    context?: true
    _all?: true
  }

  export type StruggleIndicatorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StruggleIndicator to aggregate.
     */
    where?: StruggleIndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StruggleIndicators to fetch.
     */
    orderBy?: StruggleIndicatorOrderByWithRelationInput | StruggleIndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StruggleIndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StruggleIndicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StruggleIndicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StruggleIndicators
    **/
    _count?: true | StruggleIndicatorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StruggleIndicatorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StruggleIndicatorMaxAggregateInputType
  }

  export type GetStruggleIndicatorAggregateType<T extends StruggleIndicatorAggregateArgs> = {
        [P in keyof T & keyof AggregateStruggleIndicator]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStruggleIndicator[P]>
      : GetScalarType<T[P], AggregateStruggleIndicator[P]>
  }




  export type StruggleIndicatorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StruggleIndicatorWhereInput
    orderBy?: StruggleIndicatorOrderByWithAggregationInput | StruggleIndicatorOrderByWithAggregationInput[]
    by: StruggleIndicatorScalarFieldEnum[] | StruggleIndicatorScalarFieldEnum
    having?: StruggleIndicatorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StruggleIndicatorCountAggregateInputType | true
    _min?: StruggleIndicatorMinAggregateInputType
    _max?: StruggleIndicatorMaxAggregateInputType
  }

  export type StruggleIndicatorGroupByOutputType = {
    id: string
    userId: string
    predictionId: string | null
    learningObjectiveId: string
    indicatorType: $Enums.IndicatorType
    severity: $Enums.Severity
    detectedAt: Date
    context: JsonValue
    _count: StruggleIndicatorCountAggregateOutputType | null
    _min: StruggleIndicatorMinAggregateOutputType | null
    _max: StruggleIndicatorMaxAggregateOutputType | null
  }

  type GetStruggleIndicatorGroupByPayload<T extends StruggleIndicatorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StruggleIndicatorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StruggleIndicatorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StruggleIndicatorGroupByOutputType[P]>
            : GetScalarType<T[P], StruggleIndicatorGroupByOutputType[P]>
        }
      >
    >


  export type StruggleIndicatorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    predictionId?: boolean
    learningObjectiveId?: boolean
    indicatorType?: boolean
    severity?: boolean
    detectedAt?: boolean
    context?: boolean
    prediction?: boolean | StruggleIndicator$predictionArgs<ExtArgs>
    learningObjective?: boolean | LearningObjectiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["struggleIndicator"]>

  export type StruggleIndicatorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    predictionId?: boolean
    learningObjectiveId?: boolean
    indicatorType?: boolean
    severity?: boolean
    detectedAt?: boolean
    context?: boolean
    prediction?: boolean | StruggleIndicator$predictionArgs<ExtArgs>
    learningObjective?: boolean | LearningObjectiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["struggleIndicator"]>

  export type StruggleIndicatorSelectScalar = {
    id?: boolean
    userId?: boolean
    predictionId?: boolean
    learningObjectiveId?: boolean
    indicatorType?: boolean
    severity?: boolean
    detectedAt?: boolean
    context?: boolean
  }

  export type StruggleIndicatorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prediction?: boolean | StruggleIndicator$predictionArgs<ExtArgs>
    learningObjective?: boolean | LearningObjectiveDefaultArgs<ExtArgs>
  }
  export type StruggleIndicatorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prediction?: boolean | StruggleIndicator$predictionArgs<ExtArgs>
    learningObjective?: boolean | LearningObjectiveDefaultArgs<ExtArgs>
  }

  export type $StruggleIndicatorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StruggleIndicator"
    objects: {
      prediction: Prisma.$StrugglePredictionPayload<ExtArgs> | null
      learningObjective: Prisma.$LearningObjectivePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      predictionId: string | null
      learningObjectiveId: string
      indicatorType: $Enums.IndicatorType
      severity: $Enums.Severity
      detectedAt: Date
      context: Prisma.JsonValue
    }, ExtArgs["result"]["struggleIndicator"]>
    composites: {}
  }

  type StruggleIndicatorGetPayload<S extends boolean | null | undefined | StruggleIndicatorDefaultArgs> = $Result.GetResult<Prisma.$StruggleIndicatorPayload, S>

  type StruggleIndicatorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StruggleIndicatorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StruggleIndicatorCountAggregateInputType | true
    }

  export interface StruggleIndicatorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StruggleIndicator'], meta: { name: 'StruggleIndicator' } }
    /**
     * Find zero or one StruggleIndicator that matches the filter.
     * @param {StruggleIndicatorFindUniqueArgs} args - Arguments to find a StruggleIndicator
     * @example
     * // Get one StruggleIndicator
     * const struggleIndicator = await prisma.struggleIndicator.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StruggleIndicatorFindUniqueArgs>(args: SelectSubset<T, StruggleIndicatorFindUniqueArgs<ExtArgs>>): Prisma__StruggleIndicatorClient<$Result.GetResult<Prisma.$StruggleIndicatorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StruggleIndicator that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StruggleIndicatorFindUniqueOrThrowArgs} args - Arguments to find a StruggleIndicator
     * @example
     * // Get one StruggleIndicator
     * const struggleIndicator = await prisma.struggleIndicator.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StruggleIndicatorFindUniqueOrThrowArgs>(args: SelectSubset<T, StruggleIndicatorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StruggleIndicatorClient<$Result.GetResult<Prisma.$StruggleIndicatorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StruggleIndicator that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StruggleIndicatorFindFirstArgs} args - Arguments to find a StruggleIndicator
     * @example
     * // Get one StruggleIndicator
     * const struggleIndicator = await prisma.struggleIndicator.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StruggleIndicatorFindFirstArgs>(args?: SelectSubset<T, StruggleIndicatorFindFirstArgs<ExtArgs>>): Prisma__StruggleIndicatorClient<$Result.GetResult<Prisma.$StruggleIndicatorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StruggleIndicator that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StruggleIndicatorFindFirstOrThrowArgs} args - Arguments to find a StruggleIndicator
     * @example
     * // Get one StruggleIndicator
     * const struggleIndicator = await prisma.struggleIndicator.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StruggleIndicatorFindFirstOrThrowArgs>(args?: SelectSubset<T, StruggleIndicatorFindFirstOrThrowArgs<ExtArgs>>): Prisma__StruggleIndicatorClient<$Result.GetResult<Prisma.$StruggleIndicatorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StruggleIndicators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StruggleIndicatorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StruggleIndicators
     * const struggleIndicators = await prisma.struggleIndicator.findMany()
     * 
     * // Get first 10 StruggleIndicators
     * const struggleIndicators = await prisma.struggleIndicator.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const struggleIndicatorWithIdOnly = await prisma.struggleIndicator.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StruggleIndicatorFindManyArgs>(args?: SelectSubset<T, StruggleIndicatorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StruggleIndicatorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StruggleIndicator.
     * @param {StruggleIndicatorCreateArgs} args - Arguments to create a StruggleIndicator.
     * @example
     * // Create one StruggleIndicator
     * const StruggleIndicator = await prisma.struggleIndicator.create({
     *   data: {
     *     // ... data to create a StruggleIndicator
     *   }
     * })
     * 
     */
    create<T extends StruggleIndicatorCreateArgs>(args: SelectSubset<T, StruggleIndicatorCreateArgs<ExtArgs>>): Prisma__StruggleIndicatorClient<$Result.GetResult<Prisma.$StruggleIndicatorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StruggleIndicators.
     * @param {StruggleIndicatorCreateManyArgs} args - Arguments to create many StruggleIndicators.
     * @example
     * // Create many StruggleIndicators
     * const struggleIndicator = await prisma.struggleIndicator.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StruggleIndicatorCreateManyArgs>(args?: SelectSubset<T, StruggleIndicatorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StruggleIndicators and returns the data saved in the database.
     * @param {StruggleIndicatorCreateManyAndReturnArgs} args - Arguments to create many StruggleIndicators.
     * @example
     * // Create many StruggleIndicators
     * const struggleIndicator = await prisma.struggleIndicator.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StruggleIndicators and only return the `id`
     * const struggleIndicatorWithIdOnly = await prisma.struggleIndicator.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StruggleIndicatorCreateManyAndReturnArgs>(args?: SelectSubset<T, StruggleIndicatorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StruggleIndicatorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StruggleIndicator.
     * @param {StruggleIndicatorDeleteArgs} args - Arguments to delete one StruggleIndicator.
     * @example
     * // Delete one StruggleIndicator
     * const StruggleIndicator = await prisma.struggleIndicator.delete({
     *   where: {
     *     // ... filter to delete one StruggleIndicator
     *   }
     * })
     * 
     */
    delete<T extends StruggleIndicatorDeleteArgs>(args: SelectSubset<T, StruggleIndicatorDeleteArgs<ExtArgs>>): Prisma__StruggleIndicatorClient<$Result.GetResult<Prisma.$StruggleIndicatorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StruggleIndicator.
     * @param {StruggleIndicatorUpdateArgs} args - Arguments to update one StruggleIndicator.
     * @example
     * // Update one StruggleIndicator
     * const struggleIndicator = await prisma.struggleIndicator.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StruggleIndicatorUpdateArgs>(args: SelectSubset<T, StruggleIndicatorUpdateArgs<ExtArgs>>): Prisma__StruggleIndicatorClient<$Result.GetResult<Prisma.$StruggleIndicatorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StruggleIndicators.
     * @param {StruggleIndicatorDeleteManyArgs} args - Arguments to filter StruggleIndicators to delete.
     * @example
     * // Delete a few StruggleIndicators
     * const { count } = await prisma.struggleIndicator.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StruggleIndicatorDeleteManyArgs>(args?: SelectSubset<T, StruggleIndicatorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StruggleIndicators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StruggleIndicatorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StruggleIndicators
     * const struggleIndicator = await prisma.struggleIndicator.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StruggleIndicatorUpdateManyArgs>(args: SelectSubset<T, StruggleIndicatorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StruggleIndicator.
     * @param {StruggleIndicatorUpsertArgs} args - Arguments to update or create a StruggleIndicator.
     * @example
     * // Update or create a StruggleIndicator
     * const struggleIndicator = await prisma.struggleIndicator.upsert({
     *   create: {
     *     // ... data to create a StruggleIndicator
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StruggleIndicator we want to update
     *   }
     * })
     */
    upsert<T extends StruggleIndicatorUpsertArgs>(args: SelectSubset<T, StruggleIndicatorUpsertArgs<ExtArgs>>): Prisma__StruggleIndicatorClient<$Result.GetResult<Prisma.$StruggleIndicatorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StruggleIndicators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StruggleIndicatorCountArgs} args - Arguments to filter StruggleIndicators to count.
     * @example
     * // Count the number of StruggleIndicators
     * const count = await prisma.struggleIndicator.count({
     *   where: {
     *     // ... the filter for the StruggleIndicators we want to count
     *   }
     * })
    **/
    count<T extends StruggleIndicatorCountArgs>(
      args?: Subset<T, StruggleIndicatorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StruggleIndicatorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StruggleIndicator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StruggleIndicatorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StruggleIndicatorAggregateArgs>(args: Subset<T, StruggleIndicatorAggregateArgs>): Prisma.PrismaPromise<GetStruggleIndicatorAggregateType<T>>

    /**
     * Group by StruggleIndicator.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StruggleIndicatorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StruggleIndicatorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StruggleIndicatorGroupByArgs['orderBy'] }
        : { orderBy?: StruggleIndicatorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StruggleIndicatorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStruggleIndicatorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StruggleIndicator model
   */
  readonly fields: StruggleIndicatorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StruggleIndicator.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StruggleIndicatorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prediction<T extends StruggleIndicator$predictionArgs<ExtArgs> = {}>(args?: Subset<T, StruggleIndicator$predictionArgs<ExtArgs>>): Prisma__StrugglePredictionClient<$Result.GetResult<Prisma.$StrugglePredictionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    learningObjective<T extends LearningObjectiveDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearningObjectiveDefaultArgs<ExtArgs>>): Prisma__LearningObjectiveClient<$Result.GetResult<Prisma.$LearningObjectivePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StruggleIndicator model
   */ 
  interface StruggleIndicatorFieldRefs {
    readonly id: FieldRef<"StruggleIndicator", 'String'>
    readonly userId: FieldRef<"StruggleIndicator", 'String'>
    readonly predictionId: FieldRef<"StruggleIndicator", 'String'>
    readonly learningObjectiveId: FieldRef<"StruggleIndicator", 'String'>
    readonly indicatorType: FieldRef<"StruggleIndicator", 'IndicatorType'>
    readonly severity: FieldRef<"StruggleIndicator", 'Severity'>
    readonly detectedAt: FieldRef<"StruggleIndicator", 'DateTime'>
    readonly context: FieldRef<"StruggleIndicator", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * StruggleIndicator findUnique
   */
  export type StruggleIndicatorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StruggleIndicator
     */
    select?: StruggleIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StruggleIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which StruggleIndicator to fetch.
     */
    where: StruggleIndicatorWhereUniqueInput
  }

  /**
   * StruggleIndicator findUniqueOrThrow
   */
  export type StruggleIndicatorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StruggleIndicator
     */
    select?: StruggleIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StruggleIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which StruggleIndicator to fetch.
     */
    where: StruggleIndicatorWhereUniqueInput
  }

  /**
   * StruggleIndicator findFirst
   */
  export type StruggleIndicatorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StruggleIndicator
     */
    select?: StruggleIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StruggleIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which StruggleIndicator to fetch.
     */
    where?: StruggleIndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StruggleIndicators to fetch.
     */
    orderBy?: StruggleIndicatorOrderByWithRelationInput | StruggleIndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StruggleIndicators.
     */
    cursor?: StruggleIndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StruggleIndicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StruggleIndicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StruggleIndicators.
     */
    distinct?: StruggleIndicatorScalarFieldEnum | StruggleIndicatorScalarFieldEnum[]
  }

  /**
   * StruggleIndicator findFirstOrThrow
   */
  export type StruggleIndicatorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StruggleIndicator
     */
    select?: StruggleIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StruggleIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which StruggleIndicator to fetch.
     */
    where?: StruggleIndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StruggleIndicators to fetch.
     */
    orderBy?: StruggleIndicatorOrderByWithRelationInput | StruggleIndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StruggleIndicators.
     */
    cursor?: StruggleIndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StruggleIndicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StruggleIndicators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StruggleIndicators.
     */
    distinct?: StruggleIndicatorScalarFieldEnum | StruggleIndicatorScalarFieldEnum[]
  }

  /**
   * StruggleIndicator findMany
   */
  export type StruggleIndicatorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StruggleIndicator
     */
    select?: StruggleIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StruggleIndicatorInclude<ExtArgs> | null
    /**
     * Filter, which StruggleIndicators to fetch.
     */
    where?: StruggleIndicatorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StruggleIndicators to fetch.
     */
    orderBy?: StruggleIndicatorOrderByWithRelationInput | StruggleIndicatorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StruggleIndicators.
     */
    cursor?: StruggleIndicatorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StruggleIndicators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StruggleIndicators.
     */
    skip?: number
    distinct?: StruggleIndicatorScalarFieldEnum | StruggleIndicatorScalarFieldEnum[]
  }

  /**
   * StruggleIndicator create
   */
  export type StruggleIndicatorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StruggleIndicator
     */
    select?: StruggleIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StruggleIndicatorInclude<ExtArgs> | null
    /**
     * The data needed to create a StruggleIndicator.
     */
    data: XOR<StruggleIndicatorCreateInput, StruggleIndicatorUncheckedCreateInput>
  }

  /**
   * StruggleIndicator createMany
   */
  export type StruggleIndicatorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StruggleIndicators.
     */
    data: StruggleIndicatorCreateManyInput | StruggleIndicatorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StruggleIndicator createManyAndReturn
   */
  export type StruggleIndicatorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StruggleIndicator
     */
    select?: StruggleIndicatorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StruggleIndicators.
     */
    data: StruggleIndicatorCreateManyInput | StruggleIndicatorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StruggleIndicatorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StruggleIndicator update
   */
  export type StruggleIndicatorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StruggleIndicator
     */
    select?: StruggleIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StruggleIndicatorInclude<ExtArgs> | null
    /**
     * The data needed to update a StruggleIndicator.
     */
    data: XOR<StruggleIndicatorUpdateInput, StruggleIndicatorUncheckedUpdateInput>
    /**
     * Choose, which StruggleIndicator to update.
     */
    where: StruggleIndicatorWhereUniqueInput
  }

  /**
   * StruggleIndicator updateMany
   */
  export type StruggleIndicatorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StruggleIndicators.
     */
    data: XOR<StruggleIndicatorUpdateManyMutationInput, StruggleIndicatorUncheckedUpdateManyInput>
    /**
     * Filter which StruggleIndicators to update
     */
    where?: StruggleIndicatorWhereInput
  }

  /**
   * StruggleIndicator upsert
   */
  export type StruggleIndicatorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StruggleIndicator
     */
    select?: StruggleIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StruggleIndicatorInclude<ExtArgs> | null
    /**
     * The filter to search for the StruggleIndicator to update in case it exists.
     */
    where: StruggleIndicatorWhereUniqueInput
    /**
     * In case the StruggleIndicator found by the `where` argument doesn't exist, create a new StruggleIndicator with this data.
     */
    create: XOR<StruggleIndicatorCreateInput, StruggleIndicatorUncheckedCreateInput>
    /**
     * In case the StruggleIndicator was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StruggleIndicatorUpdateInput, StruggleIndicatorUncheckedUpdateInput>
  }

  /**
   * StruggleIndicator delete
   */
  export type StruggleIndicatorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StruggleIndicator
     */
    select?: StruggleIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StruggleIndicatorInclude<ExtArgs> | null
    /**
     * Filter which StruggleIndicator to delete.
     */
    where: StruggleIndicatorWhereUniqueInput
  }

  /**
   * StruggleIndicator deleteMany
   */
  export type StruggleIndicatorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StruggleIndicators to delete
     */
    where?: StruggleIndicatorWhereInput
  }

  /**
   * StruggleIndicator.prediction
   */
  export type StruggleIndicator$predictionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StrugglePrediction
     */
    select?: StrugglePredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StrugglePredictionInclude<ExtArgs> | null
    where?: StrugglePredictionWhereInput
  }

  /**
   * StruggleIndicator without action
   */
  export type StruggleIndicatorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StruggleIndicator
     */
    select?: StruggleIndicatorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StruggleIndicatorInclude<ExtArgs> | null
  }


  /**
   * Model InterventionRecommendation
   */

  export type AggregateInterventionRecommendation = {
    _count: InterventionRecommendationCountAggregateOutputType | null
    _avg: InterventionRecommendationAvgAggregateOutputType | null
    _sum: InterventionRecommendationSumAggregateOutputType | null
    _min: InterventionRecommendationMinAggregateOutputType | null
    _max: InterventionRecommendationMaxAggregateOutputType | null
  }

  export type InterventionRecommendationAvgAggregateOutputType = {
    priority: number | null
    effectiveness: number | null
  }

  export type InterventionRecommendationSumAggregateOutputType = {
    priority: number | null
    effectiveness: number | null
  }

  export type InterventionRecommendationMinAggregateOutputType = {
    id: string | null
    predictionId: string | null
    userId: string | null
    interventionType: $Enums.InterventionType | null
    description: string | null
    reasoning: string | null
    priority: number | null
    status: $Enums.InterventionStatus | null
    appliedAt: Date | null
    appliedToMissionId: string | null
    effectiveness: number | null
    createdAt: Date | null
  }

  export type InterventionRecommendationMaxAggregateOutputType = {
    id: string | null
    predictionId: string | null
    userId: string | null
    interventionType: $Enums.InterventionType | null
    description: string | null
    reasoning: string | null
    priority: number | null
    status: $Enums.InterventionStatus | null
    appliedAt: Date | null
    appliedToMissionId: string | null
    effectiveness: number | null
    createdAt: Date | null
  }

  export type InterventionRecommendationCountAggregateOutputType = {
    id: number
    predictionId: number
    userId: number
    interventionType: number
    description: number
    reasoning: number
    priority: number
    status: number
    appliedAt: number
    appliedToMissionId: number
    effectiveness: number
    createdAt: number
    _all: number
  }


  export type InterventionRecommendationAvgAggregateInputType = {
    priority?: true
    effectiveness?: true
  }

  export type InterventionRecommendationSumAggregateInputType = {
    priority?: true
    effectiveness?: true
  }

  export type InterventionRecommendationMinAggregateInputType = {
    id?: true
    predictionId?: true
    userId?: true
    interventionType?: true
    description?: true
    reasoning?: true
    priority?: true
    status?: true
    appliedAt?: true
    appliedToMissionId?: true
    effectiveness?: true
    createdAt?: true
  }

  export type InterventionRecommendationMaxAggregateInputType = {
    id?: true
    predictionId?: true
    userId?: true
    interventionType?: true
    description?: true
    reasoning?: true
    priority?: true
    status?: true
    appliedAt?: true
    appliedToMissionId?: true
    effectiveness?: true
    createdAt?: true
  }

  export type InterventionRecommendationCountAggregateInputType = {
    id?: true
    predictionId?: true
    userId?: true
    interventionType?: true
    description?: true
    reasoning?: true
    priority?: true
    status?: true
    appliedAt?: true
    appliedToMissionId?: true
    effectiveness?: true
    createdAt?: true
    _all?: true
  }

  export type InterventionRecommendationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterventionRecommendation to aggregate.
     */
    where?: InterventionRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterventionRecommendations to fetch.
     */
    orderBy?: InterventionRecommendationOrderByWithRelationInput | InterventionRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterventionRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterventionRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterventionRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InterventionRecommendations
    **/
    _count?: true | InterventionRecommendationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterventionRecommendationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterventionRecommendationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterventionRecommendationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterventionRecommendationMaxAggregateInputType
  }

  export type GetInterventionRecommendationAggregateType<T extends InterventionRecommendationAggregateArgs> = {
        [P in keyof T & keyof AggregateInterventionRecommendation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterventionRecommendation[P]>
      : GetScalarType<T[P], AggregateInterventionRecommendation[P]>
  }




  export type InterventionRecommendationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterventionRecommendationWhereInput
    orderBy?: InterventionRecommendationOrderByWithAggregationInput | InterventionRecommendationOrderByWithAggregationInput[]
    by: InterventionRecommendationScalarFieldEnum[] | InterventionRecommendationScalarFieldEnum
    having?: InterventionRecommendationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterventionRecommendationCountAggregateInputType | true
    _avg?: InterventionRecommendationAvgAggregateInputType
    _sum?: InterventionRecommendationSumAggregateInputType
    _min?: InterventionRecommendationMinAggregateInputType
    _max?: InterventionRecommendationMaxAggregateInputType
  }

  export type InterventionRecommendationGroupByOutputType = {
    id: string
    predictionId: string
    userId: string
    interventionType: $Enums.InterventionType
    description: string
    reasoning: string
    priority: number
    status: $Enums.InterventionStatus
    appliedAt: Date | null
    appliedToMissionId: string | null
    effectiveness: number | null
    createdAt: Date
    _count: InterventionRecommendationCountAggregateOutputType | null
    _avg: InterventionRecommendationAvgAggregateOutputType | null
    _sum: InterventionRecommendationSumAggregateOutputType | null
    _min: InterventionRecommendationMinAggregateOutputType | null
    _max: InterventionRecommendationMaxAggregateOutputType | null
  }

  type GetInterventionRecommendationGroupByPayload<T extends InterventionRecommendationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterventionRecommendationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterventionRecommendationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterventionRecommendationGroupByOutputType[P]>
            : GetScalarType<T[P], InterventionRecommendationGroupByOutputType[P]>
        }
      >
    >


  export type InterventionRecommendationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    predictionId?: boolean
    userId?: boolean
    interventionType?: boolean
    description?: boolean
    reasoning?: boolean
    priority?: boolean
    status?: boolean
    appliedAt?: boolean
    appliedToMissionId?: boolean
    effectiveness?: boolean
    createdAt?: boolean
    prediction?: boolean | StrugglePredictionDefaultArgs<ExtArgs>
    mission?: boolean | InterventionRecommendation$missionArgs<ExtArgs>
  }, ExtArgs["result"]["interventionRecommendation"]>

  export type InterventionRecommendationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    predictionId?: boolean
    userId?: boolean
    interventionType?: boolean
    description?: boolean
    reasoning?: boolean
    priority?: boolean
    status?: boolean
    appliedAt?: boolean
    appliedToMissionId?: boolean
    effectiveness?: boolean
    createdAt?: boolean
    prediction?: boolean | StrugglePredictionDefaultArgs<ExtArgs>
    mission?: boolean | InterventionRecommendation$missionArgs<ExtArgs>
  }, ExtArgs["result"]["interventionRecommendation"]>

  export type InterventionRecommendationSelectScalar = {
    id?: boolean
    predictionId?: boolean
    userId?: boolean
    interventionType?: boolean
    description?: boolean
    reasoning?: boolean
    priority?: boolean
    status?: boolean
    appliedAt?: boolean
    appliedToMissionId?: boolean
    effectiveness?: boolean
    createdAt?: boolean
  }

  export type InterventionRecommendationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prediction?: boolean | StrugglePredictionDefaultArgs<ExtArgs>
    mission?: boolean | InterventionRecommendation$missionArgs<ExtArgs>
  }
  export type InterventionRecommendationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prediction?: boolean | StrugglePredictionDefaultArgs<ExtArgs>
    mission?: boolean | InterventionRecommendation$missionArgs<ExtArgs>
  }

  export type $InterventionRecommendationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InterventionRecommendation"
    objects: {
      prediction: Prisma.$StrugglePredictionPayload<ExtArgs>
      mission: Prisma.$MissionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      predictionId: string
      userId: string
      interventionType: $Enums.InterventionType
      description: string
      reasoning: string
      priority: number
      status: $Enums.InterventionStatus
      appliedAt: Date | null
      appliedToMissionId: string | null
      effectiveness: number | null
      createdAt: Date
    }, ExtArgs["result"]["interventionRecommendation"]>
    composites: {}
  }

  type InterventionRecommendationGetPayload<S extends boolean | null | undefined | InterventionRecommendationDefaultArgs> = $Result.GetResult<Prisma.$InterventionRecommendationPayload, S>

  type InterventionRecommendationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InterventionRecommendationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InterventionRecommendationCountAggregateInputType | true
    }

  export interface InterventionRecommendationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InterventionRecommendation'], meta: { name: 'InterventionRecommendation' } }
    /**
     * Find zero or one InterventionRecommendation that matches the filter.
     * @param {InterventionRecommendationFindUniqueArgs} args - Arguments to find a InterventionRecommendation
     * @example
     * // Get one InterventionRecommendation
     * const interventionRecommendation = await prisma.interventionRecommendation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterventionRecommendationFindUniqueArgs>(args: SelectSubset<T, InterventionRecommendationFindUniqueArgs<ExtArgs>>): Prisma__InterventionRecommendationClient<$Result.GetResult<Prisma.$InterventionRecommendationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InterventionRecommendation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InterventionRecommendationFindUniqueOrThrowArgs} args - Arguments to find a InterventionRecommendation
     * @example
     * // Get one InterventionRecommendation
     * const interventionRecommendation = await prisma.interventionRecommendation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterventionRecommendationFindUniqueOrThrowArgs>(args: SelectSubset<T, InterventionRecommendationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterventionRecommendationClient<$Result.GetResult<Prisma.$InterventionRecommendationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InterventionRecommendation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionRecommendationFindFirstArgs} args - Arguments to find a InterventionRecommendation
     * @example
     * // Get one InterventionRecommendation
     * const interventionRecommendation = await prisma.interventionRecommendation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterventionRecommendationFindFirstArgs>(args?: SelectSubset<T, InterventionRecommendationFindFirstArgs<ExtArgs>>): Prisma__InterventionRecommendationClient<$Result.GetResult<Prisma.$InterventionRecommendationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InterventionRecommendation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionRecommendationFindFirstOrThrowArgs} args - Arguments to find a InterventionRecommendation
     * @example
     * // Get one InterventionRecommendation
     * const interventionRecommendation = await prisma.interventionRecommendation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterventionRecommendationFindFirstOrThrowArgs>(args?: SelectSubset<T, InterventionRecommendationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterventionRecommendationClient<$Result.GetResult<Prisma.$InterventionRecommendationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InterventionRecommendations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionRecommendationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InterventionRecommendations
     * const interventionRecommendations = await prisma.interventionRecommendation.findMany()
     * 
     * // Get first 10 InterventionRecommendations
     * const interventionRecommendations = await prisma.interventionRecommendation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interventionRecommendationWithIdOnly = await prisma.interventionRecommendation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterventionRecommendationFindManyArgs>(args?: SelectSubset<T, InterventionRecommendationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionRecommendationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InterventionRecommendation.
     * @param {InterventionRecommendationCreateArgs} args - Arguments to create a InterventionRecommendation.
     * @example
     * // Create one InterventionRecommendation
     * const InterventionRecommendation = await prisma.interventionRecommendation.create({
     *   data: {
     *     // ... data to create a InterventionRecommendation
     *   }
     * })
     * 
     */
    create<T extends InterventionRecommendationCreateArgs>(args: SelectSubset<T, InterventionRecommendationCreateArgs<ExtArgs>>): Prisma__InterventionRecommendationClient<$Result.GetResult<Prisma.$InterventionRecommendationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InterventionRecommendations.
     * @param {InterventionRecommendationCreateManyArgs} args - Arguments to create many InterventionRecommendations.
     * @example
     * // Create many InterventionRecommendations
     * const interventionRecommendation = await prisma.interventionRecommendation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterventionRecommendationCreateManyArgs>(args?: SelectSubset<T, InterventionRecommendationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InterventionRecommendations and returns the data saved in the database.
     * @param {InterventionRecommendationCreateManyAndReturnArgs} args - Arguments to create many InterventionRecommendations.
     * @example
     * // Create many InterventionRecommendations
     * const interventionRecommendation = await prisma.interventionRecommendation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InterventionRecommendations and only return the `id`
     * const interventionRecommendationWithIdOnly = await prisma.interventionRecommendation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterventionRecommendationCreateManyAndReturnArgs>(args?: SelectSubset<T, InterventionRecommendationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterventionRecommendationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InterventionRecommendation.
     * @param {InterventionRecommendationDeleteArgs} args - Arguments to delete one InterventionRecommendation.
     * @example
     * // Delete one InterventionRecommendation
     * const InterventionRecommendation = await prisma.interventionRecommendation.delete({
     *   where: {
     *     // ... filter to delete one InterventionRecommendation
     *   }
     * })
     * 
     */
    delete<T extends InterventionRecommendationDeleteArgs>(args: SelectSubset<T, InterventionRecommendationDeleteArgs<ExtArgs>>): Prisma__InterventionRecommendationClient<$Result.GetResult<Prisma.$InterventionRecommendationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InterventionRecommendation.
     * @param {InterventionRecommendationUpdateArgs} args - Arguments to update one InterventionRecommendation.
     * @example
     * // Update one InterventionRecommendation
     * const interventionRecommendation = await prisma.interventionRecommendation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterventionRecommendationUpdateArgs>(args: SelectSubset<T, InterventionRecommendationUpdateArgs<ExtArgs>>): Prisma__InterventionRecommendationClient<$Result.GetResult<Prisma.$InterventionRecommendationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InterventionRecommendations.
     * @param {InterventionRecommendationDeleteManyArgs} args - Arguments to filter InterventionRecommendations to delete.
     * @example
     * // Delete a few InterventionRecommendations
     * const { count } = await prisma.interventionRecommendation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterventionRecommendationDeleteManyArgs>(args?: SelectSubset<T, InterventionRecommendationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterventionRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionRecommendationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InterventionRecommendations
     * const interventionRecommendation = await prisma.interventionRecommendation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterventionRecommendationUpdateManyArgs>(args: SelectSubset<T, InterventionRecommendationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InterventionRecommendation.
     * @param {InterventionRecommendationUpsertArgs} args - Arguments to update or create a InterventionRecommendation.
     * @example
     * // Update or create a InterventionRecommendation
     * const interventionRecommendation = await prisma.interventionRecommendation.upsert({
     *   create: {
     *     // ... data to create a InterventionRecommendation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InterventionRecommendation we want to update
     *   }
     * })
     */
    upsert<T extends InterventionRecommendationUpsertArgs>(args: SelectSubset<T, InterventionRecommendationUpsertArgs<ExtArgs>>): Prisma__InterventionRecommendationClient<$Result.GetResult<Prisma.$InterventionRecommendationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InterventionRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionRecommendationCountArgs} args - Arguments to filter InterventionRecommendations to count.
     * @example
     * // Count the number of InterventionRecommendations
     * const count = await prisma.interventionRecommendation.count({
     *   where: {
     *     // ... the filter for the InterventionRecommendations we want to count
     *   }
     * })
    **/
    count<T extends InterventionRecommendationCountArgs>(
      args?: Subset<T, InterventionRecommendationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterventionRecommendationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InterventionRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionRecommendationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterventionRecommendationAggregateArgs>(args: Subset<T, InterventionRecommendationAggregateArgs>): Prisma.PrismaPromise<GetInterventionRecommendationAggregateType<T>>

    /**
     * Group by InterventionRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterventionRecommendationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterventionRecommendationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterventionRecommendationGroupByArgs['orderBy'] }
        : { orderBy?: InterventionRecommendationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterventionRecommendationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterventionRecommendationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InterventionRecommendation model
   */
  readonly fields: InterventionRecommendationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InterventionRecommendation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterventionRecommendationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prediction<T extends StrugglePredictionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StrugglePredictionDefaultArgs<ExtArgs>>): Prisma__StrugglePredictionClient<$Result.GetResult<Prisma.$StrugglePredictionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    mission<T extends InterventionRecommendation$missionArgs<ExtArgs> = {}>(args?: Subset<T, InterventionRecommendation$missionArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InterventionRecommendation model
   */ 
  interface InterventionRecommendationFieldRefs {
    readonly id: FieldRef<"InterventionRecommendation", 'String'>
    readonly predictionId: FieldRef<"InterventionRecommendation", 'String'>
    readonly userId: FieldRef<"InterventionRecommendation", 'String'>
    readonly interventionType: FieldRef<"InterventionRecommendation", 'InterventionType'>
    readonly description: FieldRef<"InterventionRecommendation", 'String'>
    readonly reasoning: FieldRef<"InterventionRecommendation", 'String'>
    readonly priority: FieldRef<"InterventionRecommendation", 'Int'>
    readonly status: FieldRef<"InterventionRecommendation", 'InterventionStatus'>
    readonly appliedAt: FieldRef<"InterventionRecommendation", 'DateTime'>
    readonly appliedToMissionId: FieldRef<"InterventionRecommendation", 'String'>
    readonly effectiveness: FieldRef<"InterventionRecommendation", 'Float'>
    readonly createdAt: FieldRef<"InterventionRecommendation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InterventionRecommendation findUnique
   */
  export type InterventionRecommendationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionRecommendation
     */
    select?: InterventionRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which InterventionRecommendation to fetch.
     */
    where: InterventionRecommendationWhereUniqueInput
  }

  /**
   * InterventionRecommendation findUniqueOrThrow
   */
  export type InterventionRecommendationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionRecommendation
     */
    select?: InterventionRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which InterventionRecommendation to fetch.
     */
    where: InterventionRecommendationWhereUniqueInput
  }

  /**
   * InterventionRecommendation findFirst
   */
  export type InterventionRecommendationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionRecommendation
     */
    select?: InterventionRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which InterventionRecommendation to fetch.
     */
    where?: InterventionRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterventionRecommendations to fetch.
     */
    orderBy?: InterventionRecommendationOrderByWithRelationInput | InterventionRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterventionRecommendations.
     */
    cursor?: InterventionRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterventionRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterventionRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterventionRecommendations.
     */
    distinct?: InterventionRecommendationScalarFieldEnum | InterventionRecommendationScalarFieldEnum[]
  }

  /**
   * InterventionRecommendation findFirstOrThrow
   */
  export type InterventionRecommendationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionRecommendation
     */
    select?: InterventionRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which InterventionRecommendation to fetch.
     */
    where?: InterventionRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterventionRecommendations to fetch.
     */
    orderBy?: InterventionRecommendationOrderByWithRelationInput | InterventionRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterventionRecommendations.
     */
    cursor?: InterventionRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterventionRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterventionRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterventionRecommendations.
     */
    distinct?: InterventionRecommendationScalarFieldEnum | InterventionRecommendationScalarFieldEnum[]
  }

  /**
   * InterventionRecommendation findMany
   */
  export type InterventionRecommendationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionRecommendation
     */
    select?: InterventionRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which InterventionRecommendations to fetch.
     */
    where?: InterventionRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterventionRecommendations to fetch.
     */
    orderBy?: InterventionRecommendationOrderByWithRelationInput | InterventionRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InterventionRecommendations.
     */
    cursor?: InterventionRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterventionRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterventionRecommendations.
     */
    skip?: number
    distinct?: InterventionRecommendationScalarFieldEnum | InterventionRecommendationScalarFieldEnum[]
  }

  /**
   * InterventionRecommendation create
   */
  export type InterventionRecommendationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionRecommendation
     */
    select?: InterventionRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to create a InterventionRecommendation.
     */
    data: XOR<InterventionRecommendationCreateInput, InterventionRecommendationUncheckedCreateInput>
  }

  /**
   * InterventionRecommendation createMany
   */
  export type InterventionRecommendationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InterventionRecommendations.
     */
    data: InterventionRecommendationCreateManyInput | InterventionRecommendationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterventionRecommendation createManyAndReturn
   */
  export type InterventionRecommendationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionRecommendation
     */
    select?: InterventionRecommendationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InterventionRecommendations.
     */
    data: InterventionRecommendationCreateManyInput | InterventionRecommendationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionRecommendationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterventionRecommendation update
   */
  export type InterventionRecommendationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionRecommendation
     */
    select?: InterventionRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to update a InterventionRecommendation.
     */
    data: XOR<InterventionRecommendationUpdateInput, InterventionRecommendationUncheckedUpdateInput>
    /**
     * Choose, which InterventionRecommendation to update.
     */
    where: InterventionRecommendationWhereUniqueInput
  }

  /**
   * InterventionRecommendation updateMany
   */
  export type InterventionRecommendationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InterventionRecommendations.
     */
    data: XOR<InterventionRecommendationUpdateManyMutationInput, InterventionRecommendationUncheckedUpdateManyInput>
    /**
     * Filter which InterventionRecommendations to update
     */
    where?: InterventionRecommendationWhereInput
  }

  /**
   * InterventionRecommendation upsert
   */
  export type InterventionRecommendationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionRecommendation
     */
    select?: InterventionRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionRecommendationInclude<ExtArgs> | null
    /**
     * The filter to search for the InterventionRecommendation to update in case it exists.
     */
    where: InterventionRecommendationWhereUniqueInput
    /**
     * In case the InterventionRecommendation found by the `where` argument doesn't exist, create a new InterventionRecommendation with this data.
     */
    create: XOR<InterventionRecommendationCreateInput, InterventionRecommendationUncheckedCreateInput>
    /**
     * In case the InterventionRecommendation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterventionRecommendationUpdateInput, InterventionRecommendationUncheckedUpdateInput>
  }

  /**
   * InterventionRecommendation delete
   */
  export type InterventionRecommendationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionRecommendation
     */
    select?: InterventionRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionRecommendationInclude<ExtArgs> | null
    /**
     * Filter which InterventionRecommendation to delete.
     */
    where: InterventionRecommendationWhereUniqueInput
  }

  /**
   * InterventionRecommendation deleteMany
   */
  export type InterventionRecommendationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterventionRecommendations to delete
     */
    where?: InterventionRecommendationWhereInput
  }

  /**
   * InterventionRecommendation.mission
   */
  export type InterventionRecommendation$missionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mission
     */
    select?: MissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionInclude<ExtArgs> | null
    where?: MissionWhereInput
  }

  /**
   * InterventionRecommendation without action
   */
  export type InterventionRecommendationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterventionRecommendation
     */
    select?: InterventionRecommendationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterventionRecommendationInclude<ExtArgs> | null
  }


  /**
   * Model PredictionFeedback
   */

  export type AggregatePredictionFeedback = {
    _count: PredictionFeedbackCountAggregateOutputType | null
    _avg: PredictionFeedbackAvgAggregateOutputType | null
    _sum: PredictionFeedbackSumAggregateOutputType | null
    _min: PredictionFeedbackMinAggregateOutputType | null
    _max: PredictionFeedbackMaxAggregateOutputType | null
  }

  export type PredictionFeedbackAvgAggregateOutputType = {
    helpfulness: number | null
  }

  export type PredictionFeedbackSumAggregateOutputType = {
    helpfulness: number | null
  }

  export type PredictionFeedbackMinAggregateOutputType = {
    id: string | null
    predictionId: string | null
    userId: string | null
    feedbackType: $Enums.FeedbackType | null
    actualStruggle: boolean | null
    helpfulness: number | null
    comments: string | null
    submittedAt: Date | null
  }

  export type PredictionFeedbackMaxAggregateOutputType = {
    id: string | null
    predictionId: string | null
    userId: string | null
    feedbackType: $Enums.FeedbackType | null
    actualStruggle: boolean | null
    helpfulness: number | null
    comments: string | null
    submittedAt: Date | null
  }

  export type PredictionFeedbackCountAggregateOutputType = {
    id: number
    predictionId: number
    userId: number
    feedbackType: number
    actualStruggle: number
    helpfulness: number
    comments: number
    submittedAt: number
    _all: number
  }


  export type PredictionFeedbackAvgAggregateInputType = {
    helpfulness?: true
  }

  export type PredictionFeedbackSumAggregateInputType = {
    helpfulness?: true
  }

  export type PredictionFeedbackMinAggregateInputType = {
    id?: true
    predictionId?: true
    userId?: true
    feedbackType?: true
    actualStruggle?: true
    helpfulness?: true
    comments?: true
    submittedAt?: true
  }

  export type PredictionFeedbackMaxAggregateInputType = {
    id?: true
    predictionId?: true
    userId?: true
    feedbackType?: true
    actualStruggle?: true
    helpfulness?: true
    comments?: true
    submittedAt?: true
  }

  export type PredictionFeedbackCountAggregateInputType = {
    id?: true
    predictionId?: true
    userId?: true
    feedbackType?: true
    actualStruggle?: true
    helpfulness?: true
    comments?: true
    submittedAt?: true
    _all?: true
  }

  export type PredictionFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PredictionFeedback to aggregate.
     */
    where?: PredictionFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PredictionFeedbacks to fetch.
     */
    orderBy?: PredictionFeedbackOrderByWithRelationInput | PredictionFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PredictionFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PredictionFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PredictionFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PredictionFeedbacks
    **/
    _count?: true | PredictionFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PredictionFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PredictionFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PredictionFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PredictionFeedbackMaxAggregateInputType
  }

  export type GetPredictionFeedbackAggregateType<T extends PredictionFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregatePredictionFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePredictionFeedback[P]>
      : GetScalarType<T[P], AggregatePredictionFeedback[P]>
  }




  export type PredictionFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PredictionFeedbackWhereInput
    orderBy?: PredictionFeedbackOrderByWithAggregationInput | PredictionFeedbackOrderByWithAggregationInput[]
    by: PredictionFeedbackScalarFieldEnum[] | PredictionFeedbackScalarFieldEnum
    having?: PredictionFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PredictionFeedbackCountAggregateInputType | true
    _avg?: PredictionFeedbackAvgAggregateInputType
    _sum?: PredictionFeedbackSumAggregateInputType
    _min?: PredictionFeedbackMinAggregateInputType
    _max?: PredictionFeedbackMaxAggregateInputType
  }

  export type PredictionFeedbackGroupByOutputType = {
    id: string
    predictionId: string
    userId: string
    feedbackType: $Enums.FeedbackType
    actualStruggle: boolean
    helpfulness: number | null
    comments: string | null
    submittedAt: Date
    _count: PredictionFeedbackCountAggregateOutputType | null
    _avg: PredictionFeedbackAvgAggregateOutputType | null
    _sum: PredictionFeedbackSumAggregateOutputType | null
    _min: PredictionFeedbackMinAggregateOutputType | null
    _max: PredictionFeedbackMaxAggregateOutputType | null
  }

  type GetPredictionFeedbackGroupByPayload<T extends PredictionFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PredictionFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PredictionFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PredictionFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], PredictionFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type PredictionFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    predictionId?: boolean
    userId?: boolean
    feedbackType?: boolean
    actualStruggle?: boolean
    helpfulness?: boolean
    comments?: boolean
    submittedAt?: boolean
    prediction?: boolean | StrugglePredictionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["predictionFeedback"]>

  export type PredictionFeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    predictionId?: boolean
    userId?: boolean
    feedbackType?: boolean
    actualStruggle?: boolean
    helpfulness?: boolean
    comments?: boolean
    submittedAt?: boolean
    prediction?: boolean | StrugglePredictionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["predictionFeedback"]>

  export type PredictionFeedbackSelectScalar = {
    id?: boolean
    predictionId?: boolean
    userId?: boolean
    feedbackType?: boolean
    actualStruggle?: boolean
    helpfulness?: boolean
    comments?: boolean
    submittedAt?: boolean
  }

  export type PredictionFeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prediction?: boolean | StrugglePredictionDefaultArgs<ExtArgs>
  }
  export type PredictionFeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prediction?: boolean | StrugglePredictionDefaultArgs<ExtArgs>
  }

  export type $PredictionFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PredictionFeedback"
    objects: {
      prediction: Prisma.$StrugglePredictionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      predictionId: string
      userId: string
      feedbackType: $Enums.FeedbackType
      actualStruggle: boolean
      helpfulness: number | null
      comments: string | null
      submittedAt: Date
    }, ExtArgs["result"]["predictionFeedback"]>
    composites: {}
  }

  type PredictionFeedbackGetPayload<S extends boolean | null | undefined | PredictionFeedbackDefaultArgs> = $Result.GetResult<Prisma.$PredictionFeedbackPayload, S>

  type PredictionFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PredictionFeedbackFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PredictionFeedbackCountAggregateInputType | true
    }

  export interface PredictionFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PredictionFeedback'], meta: { name: 'PredictionFeedback' } }
    /**
     * Find zero or one PredictionFeedback that matches the filter.
     * @param {PredictionFeedbackFindUniqueArgs} args - Arguments to find a PredictionFeedback
     * @example
     * // Get one PredictionFeedback
     * const predictionFeedback = await prisma.predictionFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PredictionFeedbackFindUniqueArgs>(args: SelectSubset<T, PredictionFeedbackFindUniqueArgs<ExtArgs>>): Prisma__PredictionFeedbackClient<$Result.GetResult<Prisma.$PredictionFeedbackPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PredictionFeedback that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PredictionFeedbackFindUniqueOrThrowArgs} args - Arguments to find a PredictionFeedback
     * @example
     * // Get one PredictionFeedback
     * const predictionFeedback = await prisma.predictionFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PredictionFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, PredictionFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PredictionFeedbackClient<$Result.GetResult<Prisma.$PredictionFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PredictionFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionFeedbackFindFirstArgs} args - Arguments to find a PredictionFeedback
     * @example
     * // Get one PredictionFeedback
     * const predictionFeedback = await prisma.predictionFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PredictionFeedbackFindFirstArgs>(args?: SelectSubset<T, PredictionFeedbackFindFirstArgs<ExtArgs>>): Prisma__PredictionFeedbackClient<$Result.GetResult<Prisma.$PredictionFeedbackPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PredictionFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionFeedbackFindFirstOrThrowArgs} args - Arguments to find a PredictionFeedback
     * @example
     * // Get one PredictionFeedback
     * const predictionFeedback = await prisma.predictionFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PredictionFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, PredictionFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__PredictionFeedbackClient<$Result.GetResult<Prisma.$PredictionFeedbackPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PredictionFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PredictionFeedbacks
     * const predictionFeedbacks = await prisma.predictionFeedback.findMany()
     * 
     * // Get first 10 PredictionFeedbacks
     * const predictionFeedbacks = await prisma.predictionFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const predictionFeedbackWithIdOnly = await prisma.predictionFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PredictionFeedbackFindManyArgs>(args?: SelectSubset<T, PredictionFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PredictionFeedbackPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PredictionFeedback.
     * @param {PredictionFeedbackCreateArgs} args - Arguments to create a PredictionFeedback.
     * @example
     * // Create one PredictionFeedback
     * const PredictionFeedback = await prisma.predictionFeedback.create({
     *   data: {
     *     // ... data to create a PredictionFeedback
     *   }
     * })
     * 
     */
    create<T extends PredictionFeedbackCreateArgs>(args: SelectSubset<T, PredictionFeedbackCreateArgs<ExtArgs>>): Prisma__PredictionFeedbackClient<$Result.GetResult<Prisma.$PredictionFeedbackPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PredictionFeedbacks.
     * @param {PredictionFeedbackCreateManyArgs} args - Arguments to create many PredictionFeedbacks.
     * @example
     * // Create many PredictionFeedbacks
     * const predictionFeedback = await prisma.predictionFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PredictionFeedbackCreateManyArgs>(args?: SelectSubset<T, PredictionFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PredictionFeedbacks and returns the data saved in the database.
     * @param {PredictionFeedbackCreateManyAndReturnArgs} args - Arguments to create many PredictionFeedbacks.
     * @example
     * // Create many PredictionFeedbacks
     * const predictionFeedback = await prisma.predictionFeedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PredictionFeedbacks and only return the `id`
     * const predictionFeedbackWithIdOnly = await prisma.predictionFeedback.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PredictionFeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, PredictionFeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PredictionFeedbackPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PredictionFeedback.
     * @param {PredictionFeedbackDeleteArgs} args - Arguments to delete one PredictionFeedback.
     * @example
     * // Delete one PredictionFeedback
     * const PredictionFeedback = await prisma.predictionFeedback.delete({
     *   where: {
     *     // ... filter to delete one PredictionFeedback
     *   }
     * })
     * 
     */
    delete<T extends PredictionFeedbackDeleteArgs>(args: SelectSubset<T, PredictionFeedbackDeleteArgs<ExtArgs>>): Prisma__PredictionFeedbackClient<$Result.GetResult<Prisma.$PredictionFeedbackPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PredictionFeedback.
     * @param {PredictionFeedbackUpdateArgs} args - Arguments to update one PredictionFeedback.
     * @example
     * // Update one PredictionFeedback
     * const predictionFeedback = await prisma.predictionFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PredictionFeedbackUpdateArgs>(args: SelectSubset<T, PredictionFeedbackUpdateArgs<ExtArgs>>): Prisma__PredictionFeedbackClient<$Result.GetResult<Prisma.$PredictionFeedbackPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PredictionFeedbacks.
     * @param {PredictionFeedbackDeleteManyArgs} args - Arguments to filter PredictionFeedbacks to delete.
     * @example
     * // Delete a few PredictionFeedbacks
     * const { count } = await prisma.predictionFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PredictionFeedbackDeleteManyArgs>(args?: SelectSubset<T, PredictionFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PredictionFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PredictionFeedbacks
     * const predictionFeedback = await prisma.predictionFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PredictionFeedbackUpdateManyArgs>(args: SelectSubset<T, PredictionFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PredictionFeedback.
     * @param {PredictionFeedbackUpsertArgs} args - Arguments to update or create a PredictionFeedback.
     * @example
     * // Update or create a PredictionFeedback
     * const predictionFeedback = await prisma.predictionFeedback.upsert({
     *   create: {
     *     // ... data to create a PredictionFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PredictionFeedback we want to update
     *   }
     * })
     */
    upsert<T extends PredictionFeedbackUpsertArgs>(args: SelectSubset<T, PredictionFeedbackUpsertArgs<ExtArgs>>): Prisma__PredictionFeedbackClient<$Result.GetResult<Prisma.$PredictionFeedbackPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PredictionFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionFeedbackCountArgs} args - Arguments to filter PredictionFeedbacks to count.
     * @example
     * // Count the number of PredictionFeedbacks
     * const count = await prisma.predictionFeedback.count({
     *   where: {
     *     // ... the filter for the PredictionFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends PredictionFeedbackCountArgs>(
      args?: Subset<T, PredictionFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PredictionFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PredictionFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PredictionFeedbackAggregateArgs>(args: Subset<T, PredictionFeedbackAggregateArgs>): Prisma.PrismaPromise<GetPredictionFeedbackAggregateType<T>>

    /**
     * Group by PredictionFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PredictionFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PredictionFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: PredictionFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PredictionFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPredictionFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PredictionFeedback model
   */
  readonly fields: PredictionFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PredictionFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PredictionFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prediction<T extends StrugglePredictionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StrugglePredictionDefaultArgs<ExtArgs>>): Prisma__StrugglePredictionClient<$Result.GetResult<Prisma.$StrugglePredictionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PredictionFeedback model
   */ 
  interface PredictionFeedbackFieldRefs {
    readonly id: FieldRef<"PredictionFeedback", 'String'>
    readonly predictionId: FieldRef<"PredictionFeedback", 'String'>
    readonly userId: FieldRef<"PredictionFeedback", 'String'>
    readonly feedbackType: FieldRef<"PredictionFeedback", 'FeedbackType'>
    readonly actualStruggle: FieldRef<"PredictionFeedback", 'Boolean'>
    readonly helpfulness: FieldRef<"PredictionFeedback", 'Int'>
    readonly comments: FieldRef<"PredictionFeedback", 'String'>
    readonly submittedAt: FieldRef<"PredictionFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PredictionFeedback findUnique
   */
  export type PredictionFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionFeedback
     */
    select?: PredictionFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which PredictionFeedback to fetch.
     */
    where: PredictionFeedbackWhereUniqueInput
  }

  /**
   * PredictionFeedback findUniqueOrThrow
   */
  export type PredictionFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionFeedback
     */
    select?: PredictionFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which PredictionFeedback to fetch.
     */
    where: PredictionFeedbackWhereUniqueInput
  }

  /**
   * PredictionFeedback findFirst
   */
  export type PredictionFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionFeedback
     */
    select?: PredictionFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which PredictionFeedback to fetch.
     */
    where?: PredictionFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PredictionFeedbacks to fetch.
     */
    orderBy?: PredictionFeedbackOrderByWithRelationInput | PredictionFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PredictionFeedbacks.
     */
    cursor?: PredictionFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PredictionFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PredictionFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PredictionFeedbacks.
     */
    distinct?: PredictionFeedbackScalarFieldEnum | PredictionFeedbackScalarFieldEnum[]
  }

  /**
   * PredictionFeedback findFirstOrThrow
   */
  export type PredictionFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionFeedback
     */
    select?: PredictionFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which PredictionFeedback to fetch.
     */
    where?: PredictionFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PredictionFeedbacks to fetch.
     */
    orderBy?: PredictionFeedbackOrderByWithRelationInput | PredictionFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PredictionFeedbacks.
     */
    cursor?: PredictionFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PredictionFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PredictionFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PredictionFeedbacks.
     */
    distinct?: PredictionFeedbackScalarFieldEnum | PredictionFeedbackScalarFieldEnum[]
  }

  /**
   * PredictionFeedback findMany
   */
  export type PredictionFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionFeedback
     */
    select?: PredictionFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which PredictionFeedbacks to fetch.
     */
    where?: PredictionFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PredictionFeedbacks to fetch.
     */
    orderBy?: PredictionFeedbackOrderByWithRelationInput | PredictionFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PredictionFeedbacks.
     */
    cursor?: PredictionFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PredictionFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PredictionFeedbacks.
     */
    skip?: number
    distinct?: PredictionFeedbackScalarFieldEnum | PredictionFeedbackScalarFieldEnum[]
  }

  /**
   * PredictionFeedback create
   */
  export type PredictionFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionFeedback
     */
    select?: PredictionFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a PredictionFeedback.
     */
    data: XOR<PredictionFeedbackCreateInput, PredictionFeedbackUncheckedCreateInput>
  }

  /**
   * PredictionFeedback createMany
   */
  export type PredictionFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PredictionFeedbacks.
     */
    data: PredictionFeedbackCreateManyInput | PredictionFeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PredictionFeedback createManyAndReturn
   */
  export type PredictionFeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionFeedback
     */
    select?: PredictionFeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PredictionFeedbacks.
     */
    data: PredictionFeedbackCreateManyInput | PredictionFeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionFeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PredictionFeedback update
   */
  export type PredictionFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionFeedback
     */
    select?: PredictionFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a PredictionFeedback.
     */
    data: XOR<PredictionFeedbackUpdateInput, PredictionFeedbackUncheckedUpdateInput>
    /**
     * Choose, which PredictionFeedback to update.
     */
    where: PredictionFeedbackWhereUniqueInput
  }

  /**
   * PredictionFeedback updateMany
   */
  export type PredictionFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PredictionFeedbacks.
     */
    data: XOR<PredictionFeedbackUpdateManyMutationInput, PredictionFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which PredictionFeedbacks to update
     */
    where?: PredictionFeedbackWhereInput
  }

  /**
   * PredictionFeedback upsert
   */
  export type PredictionFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionFeedback
     */
    select?: PredictionFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionFeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the PredictionFeedback to update in case it exists.
     */
    where: PredictionFeedbackWhereUniqueInput
    /**
     * In case the PredictionFeedback found by the `where` argument doesn't exist, create a new PredictionFeedback with this data.
     */
    create: XOR<PredictionFeedbackCreateInput, PredictionFeedbackUncheckedCreateInput>
    /**
     * In case the PredictionFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PredictionFeedbackUpdateInput, PredictionFeedbackUncheckedUpdateInput>
  }

  /**
   * PredictionFeedback delete
   */
  export type PredictionFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionFeedback
     */
    select?: PredictionFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionFeedbackInclude<ExtArgs> | null
    /**
     * Filter which PredictionFeedback to delete.
     */
    where: PredictionFeedbackWhereUniqueInput
  }

  /**
   * PredictionFeedback deleteMany
   */
  export type PredictionFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PredictionFeedbacks to delete
     */
    where?: PredictionFeedbackWhereInput
  }

  /**
   * PredictionFeedback without action
   */
  export type PredictionFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PredictionFeedback
     */
    select?: PredictionFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionFeedbackInclude<ExtArgs> | null
  }


  /**
   * Model PerformanceMetric
   */

  export type AggregatePerformanceMetric = {
    _count: PerformanceMetricCountAggregateOutputType | null
    _avg: PerformanceMetricAvgAggregateOutputType | null
    _sum: PerformanceMetricSumAggregateOutputType | null
    _min: PerformanceMetricMinAggregateOutputType | null
    _max: PerformanceMetricMaxAggregateOutputType | null
  }

  export type PerformanceMetricAvgAggregateOutputType = {
    retentionScore: number | null
    studyTimeMs: number | null
    reviewCount: number | null
    correctReviews: number | null
    incorrectReviews: number | null
  }

  export type PerformanceMetricSumAggregateOutputType = {
    retentionScore: number | null
    studyTimeMs: number | null
    reviewCount: number | null
    correctReviews: number | null
    incorrectReviews: number | null
  }

  export type PerformanceMetricMinAggregateOutputType = {
    id: string | null
    userId: string | null
    learningObjectiveId: string | null
    date: Date | null
    retentionScore: number | null
    studyTimeMs: number | null
    reviewCount: number | null
    correctReviews: number | null
    incorrectReviews: number | null
    createdAt: Date | null
  }

  export type PerformanceMetricMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    learningObjectiveId: string | null
    date: Date | null
    retentionScore: number | null
    studyTimeMs: number | null
    reviewCount: number | null
    correctReviews: number | null
    incorrectReviews: number | null
    createdAt: Date | null
  }

  export type PerformanceMetricCountAggregateOutputType = {
    id: number
    userId: number
    learningObjectiveId: number
    date: number
    retentionScore: number
    studyTimeMs: number
    reviewCount: number
    correctReviews: number
    incorrectReviews: number
    createdAt: number
    _all: number
  }


  export type PerformanceMetricAvgAggregateInputType = {
    retentionScore?: true
    studyTimeMs?: true
    reviewCount?: true
    correctReviews?: true
    incorrectReviews?: true
  }

  export type PerformanceMetricSumAggregateInputType = {
    retentionScore?: true
    studyTimeMs?: true
    reviewCount?: true
    correctReviews?: true
    incorrectReviews?: true
  }

  export type PerformanceMetricMinAggregateInputType = {
    id?: true
    userId?: true
    learningObjectiveId?: true
    date?: true
    retentionScore?: true
    studyTimeMs?: true
    reviewCount?: true
    correctReviews?: true
    incorrectReviews?: true
    createdAt?: true
  }

  export type PerformanceMetricMaxAggregateInputType = {
    id?: true
    userId?: true
    learningObjectiveId?: true
    date?: true
    retentionScore?: true
    studyTimeMs?: true
    reviewCount?: true
    correctReviews?: true
    incorrectReviews?: true
    createdAt?: true
  }

  export type PerformanceMetricCountAggregateInputType = {
    id?: true
    userId?: true
    learningObjectiveId?: true
    date?: true
    retentionScore?: true
    studyTimeMs?: true
    reviewCount?: true
    correctReviews?: true
    incorrectReviews?: true
    createdAt?: true
    _all?: true
  }

  export type PerformanceMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceMetric to aggregate.
     */
    where?: PerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetrics to fetch.
     */
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerformanceMetrics
    **/
    _count?: true | PerformanceMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformanceMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformanceMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformanceMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformanceMetricMaxAggregateInputType
  }

  export type GetPerformanceMetricAggregateType<T extends PerformanceMetricAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformanceMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformanceMetric[P]>
      : GetScalarType<T[P], AggregatePerformanceMetric[P]>
  }




  export type PerformanceMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceMetricWhereInput
    orderBy?: PerformanceMetricOrderByWithAggregationInput | PerformanceMetricOrderByWithAggregationInput[]
    by: PerformanceMetricScalarFieldEnum[] | PerformanceMetricScalarFieldEnum
    having?: PerformanceMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformanceMetricCountAggregateInputType | true
    _avg?: PerformanceMetricAvgAggregateInputType
    _sum?: PerformanceMetricSumAggregateInputType
    _min?: PerformanceMetricMinAggregateInputType
    _max?: PerformanceMetricMaxAggregateInputType
  }

  export type PerformanceMetricGroupByOutputType = {
    id: string
    userId: string
    learningObjectiveId: string
    date: Date
    retentionScore: number
    studyTimeMs: number
    reviewCount: number
    correctReviews: number
    incorrectReviews: number
    createdAt: Date
    _count: PerformanceMetricCountAggregateOutputType | null
    _avg: PerformanceMetricAvgAggregateOutputType | null
    _sum: PerformanceMetricSumAggregateOutputType | null
    _min: PerformanceMetricMinAggregateOutputType | null
    _max: PerformanceMetricMaxAggregateOutputType | null
  }

  type GetPerformanceMetricGroupByPayload<T extends PerformanceMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformanceMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformanceMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformanceMetricGroupByOutputType[P]>
            : GetScalarType<T[P], PerformanceMetricGroupByOutputType[P]>
        }
      >
    >


  export type PerformanceMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    learningObjectiveId?: boolean
    date?: boolean
    retentionScore?: boolean
    studyTimeMs?: boolean
    reviewCount?: boolean
    correctReviews?: boolean
    incorrectReviews?: boolean
    createdAt?: boolean
    learningObjective?: boolean | LearningObjectiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceMetric"]>

  export type PerformanceMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    learningObjectiveId?: boolean
    date?: boolean
    retentionScore?: boolean
    studyTimeMs?: boolean
    reviewCount?: boolean
    correctReviews?: boolean
    incorrectReviews?: boolean
    createdAt?: boolean
    learningObjective?: boolean | LearningObjectiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceMetric"]>

  export type PerformanceMetricSelectScalar = {
    id?: boolean
    userId?: boolean
    learningObjectiveId?: boolean
    date?: boolean
    retentionScore?: boolean
    studyTimeMs?: boolean
    reviewCount?: boolean
    correctReviews?: boolean
    incorrectReviews?: boolean
    createdAt?: boolean
  }

  export type PerformanceMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningObjective?: boolean | LearningObjectiveDefaultArgs<ExtArgs>
  }
  export type PerformanceMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningObjective?: boolean | LearningObjectiveDefaultArgs<ExtArgs>
  }

  export type $PerformanceMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerformanceMetric"
    objects: {
      learningObjective: Prisma.$LearningObjectivePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      learningObjectiveId: string
      date: Date
      retentionScore: number
      studyTimeMs: number
      reviewCount: number
      correctReviews: number
      incorrectReviews: number
      createdAt: Date
    }, ExtArgs["result"]["performanceMetric"]>
    composites: {}
  }

  type PerformanceMetricGetPayload<S extends boolean | null | undefined | PerformanceMetricDefaultArgs> = $Result.GetResult<Prisma.$PerformanceMetricPayload, S>

  type PerformanceMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PerformanceMetricFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PerformanceMetricCountAggregateInputType | true
    }

  export interface PerformanceMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerformanceMetric'], meta: { name: 'PerformanceMetric' } }
    /**
     * Find zero or one PerformanceMetric that matches the filter.
     * @param {PerformanceMetricFindUniqueArgs} args - Arguments to find a PerformanceMetric
     * @example
     * // Get one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerformanceMetricFindUniqueArgs>(args: SelectSubset<T, PerformanceMetricFindUniqueArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PerformanceMetric that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PerformanceMetricFindUniqueOrThrowArgs} args - Arguments to find a PerformanceMetric
     * @example
     * // Get one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerformanceMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, PerformanceMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PerformanceMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricFindFirstArgs} args - Arguments to find a PerformanceMetric
     * @example
     * // Get one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerformanceMetricFindFirstArgs>(args?: SelectSubset<T, PerformanceMetricFindFirstArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PerformanceMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricFindFirstOrThrowArgs} args - Arguments to find a PerformanceMetric
     * @example
     * // Get one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerformanceMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, PerformanceMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PerformanceMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerformanceMetrics
     * const performanceMetrics = await prisma.performanceMetric.findMany()
     * 
     * // Get first 10 PerformanceMetrics
     * const performanceMetrics = await prisma.performanceMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performanceMetricWithIdOnly = await prisma.performanceMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerformanceMetricFindManyArgs>(args?: SelectSubset<T, PerformanceMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PerformanceMetric.
     * @param {PerformanceMetricCreateArgs} args - Arguments to create a PerformanceMetric.
     * @example
     * // Create one PerformanceMetric
     * const PerformanceMetric = await prisma.performanceMetric.create({
     *   data: {
     *     // ... data to create a PerformanceMetric
     *   }
     * })
     * 
     */
    create<T extends PerformanceMetricCreateArgs>(args: SelectSubset<T, PerformanceMetricCreateArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PerformanceMetrics.
     * @param {PerformanceMetricCreateManyArgs} args - Arguments to create many PerformanceMetrics.
     * @example
     * // Create many PerformanceMetrics
     * const performanceMetric = await prisma.performanceMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerformanceMetricCreateManyArgs>(args?: SelectSubset<T, PerformanceMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PerformanceMetrics and returns the data saved in the database.
     * @param {PerformanceMetricCreateManyAndReturnArgs} args - Arguments to create many PerformanceMetrics.
     * @example
     * // Create many PerformanceMetrics
     * const performanceMetric = await prisma.performanceMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PerformanceMetrics and only return the `id`
     * const performanceMetricWithIdOnly = await prisma.performanceMetric.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PerformanceMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, PerformanceMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PerformanceMetric.
     * @param {PerformanceMetricDeleteArgs} args - Arguments to delete one PerformanceMetric.
     * @example
     * // Delete one PerformanceMetric
     * const PerformanceMetric = await prisma.performanceMetric.delete({
     *   where: {
     *     // ... filter to delete one PerformanceMetric
     *   }
     * })
     * 
     */
    delete<T extends PerformanceMetricDeleteArgs>(args: SelectSubset<T, PerformanceMetricDeleteArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PerformanceMetric.
     * @param {PerformanceMetricUpdateArgs} args - Arguments to update one PerformanceMetric.
     * @example
     * // Update one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerformanceMetricUpdateArgs>(args: SelectSubset<T, PerformanceMetricUpdateArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PerformanceMetrics.
     * @param {PerformanceMetricDeleteManyArgs} args - Arguments to filter PerformanceMetrics to delete.
     * @example
     * // Delete a few PerformanceMetrics
     * const { count } = await prisma.performanceMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerformanceMetricDeleteManyArgs>(args?: SelectSubset<T, PerformanceMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerformanceMetrics
     * const performanceMetric = await prisma.performanceMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerformanceMetricUpdateManyArgs>(args: SelectSubset<T, PerformanceMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PerformanceMetric.
     * @param {PerformanceMetricUpsertArgs} args - Arguments to update or create a PerformanceMetric.
     * @example
     * // Update or create a PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.upsert({
     *   create: {
     *     // ... data to create a PerformanceMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerformanceMetric we want to update
     *   }
     * })
     */
    upsert<T extends PerformanceMetricUpsertArgs>(args: SelectSubset<T, PerformanceMetricUpsertArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PerformanceMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricCountArgs} args - Arguments to filter PerformanceMetrics to count.
     * @example
     * // Count the number of PerformanceMetrics
     * const count = await prisma.performanceMetric.count({
     *   where: {
     *     // ... the filter for the PerformanceMetrics we want to count
     *   }
     * })
    **/
    count<T extends PerformanceMetricCountArgs>(
      args?: Subset<T, PerformanceMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformanceMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerformanceMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformanceMetricAggregateArgs>(args: Subset<T, PerformanceMetricAggregateArgs>): Prisma.PrismaPromise<GetPerformanceMetricAggregateType<T>>

    /**
     * Group by PerformanceMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerformanceMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerformanceMetricGroupByArgs['orderBy'] }
        : { orderBy?: PerformanceMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerformanceMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformanceMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerformanceMetric model
   */
  readonly fields: PerformanceMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerformanceMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerformanceMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    learningObjective<T extends LearningObjectiveDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearningObjectiveDefaultArgs<ExtArgs>>): Prisma__LearningObjectiveClient<$Result.GetResult<Prisma.$LearningObjectivePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerformanceMetric model
   */ 
  interface PerformanceMetricFieldRefs {
    readonly id: FieldRef<"PerformanceMetric", 'String'>
    readonly userId: FieldRef<"PerformanceMetric", 'String'>
    readonly learningObjectiveId: FieldRef<"PerformanceMetric", 'String'>
    readonly date: FieldRef<"PerformanceMetric", 'DateTime'>
    readonly retentionScore: FieldRef<"PerformanceMetric", 'Float'>
    readonly studyTimeMs: FieldRef<"PerformanceMetric", 'Int'>
    readonly reviewCount: FieldRef<"PerformanceMetric", 'Int'>
    readonly correctReviews: FieldRef<"PerformanceMetric", 'Int'>
    readonly incorrectReviews: FieldRef<"PerformanceMetric", 'Int'>
    readonly createdAt: FieldRef<"PerformanceMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PerformanceMetric findUnique
   */
  export type PerformanceMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceMetric to fetch.
     */
    where: PerformanceMetricWhereUniqueInput
  }

  /**
   * PerformanceMetric findUniqueOrThrow
   */
  export type PerformanceMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceMetric to fetch.
     */
    where: PerformanceMetricWhereUniqueInput
  }

  /**
   * PerformanceMetric findFirst
   */
  export type PerformanceMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceMetric to fetch.
     */
    where?: PerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetrics to fetch.
     */
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceMetrics.
     */
    cursor?: PerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceMetrics.
     */
    distinct?: PerformanceMetricScalarFieldEnum | PerformanceMetricScalarFieldEnum[]
  }

  /**
   * PerformanceMetric findFirstOrThrow
   */
  export type PerformanceMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceMetric to fetch.
     */
    where?: PerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetrics to fetch.
     */
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceMetrics.
     */
    cursor?: PerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceMetrics.
     */
    distinct?: PerformanceMetricScalarFieldEnum | PerformanceMetricScalarFieldEnum[]
  }

  /**
   * PerformanceMetric findMany
   */
  export type PerformanceMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceMetrics to fetch.
     */
    where?: PerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetrics to fetch.
     */
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerformanceMetrics.
     */
    cursor?: PerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetrics.
     */
    skip?: number
    distinct?: PerformanceMetricScalarFieldEnum | PerformanceMetricScalarFieldEnum[]
  }

  /**
   * PerformanceMetric create
   */
  export type PerformanceMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a PerformanceMetric.
     */
    data: XOR<PerformanceMetricCreateInput, PerformanceMetricUncheckedCreateInput>
  }

  /**
   * PerformanceMetric createMany
   */
  export type PerformanceMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerformanceMetrics.
     */
    data: PerformanceMetricCreateManyInput | PerformanceMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerformanceMetric createManyAndReturn
   */
  export type PerformanceMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PerformanceMetrics.
     */
    data: PerformanceMetricCreateManyInput | PerformanceMetricCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerformanceMetric update
   */
  export type PerformanceMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a PerformanceMetric.
     */
    data: XOR<PerformanceMetricUpdateInput, PerformanceMetricUncheckedUpdateInput>
    /**
     * Choose, which PerformanceMetric to update.
     */
    where: PerformanceMetricWhereUniqueInput
  }

  /**
   * PerformanceMetric updateMany
   */
  export type PerformanceMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerformanceMetrics.
     */
    data: XOR<PerformanceMetricUpdateManyMutationInput, PerformanceMetricUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceMetrics to update
     */
    where?: PerformanceMetricWhereInput
  }

  /**
   * PerformanceMetric upsert
   */
  export type PerformanceMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the PerformanceMetric to update in case it exists.
     */
    where: PerformanceMetricWhereUniqueInput
    /**
     * In case the PerformanceMetric found by the `where` argument doesn't exist, create a new PerformanceMetric with this data.
     */
    create: XOR<PerformanceMetricCreateInput, PerformanceMetricUncheckedCreateInput>
    /**
     * In case the PerformanceMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerformanceMetricUpdateInput, PerformanceMetricUncheckedUpdateInput>
  }

  /**
   * PerformanceMetric delete
   */
  export type PerformanceMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * Filter which PerformanceMetric to delete.
     */
    where: PerformanceMetricWhereUniqueInput
  }

  /**
   * PerformanceMetric deleteMany
   */
  export type PerformanceMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceMetrics to delete
     */
    where?: PerformanceMetricWhereInput
  }

  /**
   * PerformanceMetric without action
   */
  export type PerformanceMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
  }


  /**
   * Model Exam
   */

  export type AggregateExam = {
    _count: ExamCountAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  export type ExamMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    date: Date | null
    courseId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    date: Date | null
    courseId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    date: number
    courseId: number
    coverageTopics: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    date?: true
    courseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    date?: true
    courseId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    date?: true
    courseId?: true
    coverageTopics?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exam to aggregate.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exams
    **/
    _count?: true | ExamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamMaxAggregateInputType
  }

  export type GetExamAggregateType<T extends ExamAggregateArgs> = {
        [P in keyof T & keyof AggregateExam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExam[P]>
      : GetScalarType<T[P], AggregateExam[P]>
  }




  export type ExamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithAggregationInput | ExamOrderByWithAggregationInput[]
    by: ExamScalarFieldEnum[] | ExamScalarFieldEnum
    having?: ExamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamCountAggregateInputType | true
    _min?: ExamMinAggregateInputType
    _max?: ExamMaxAggregateInputType
  }

  export type ExamGroupByOutputType = {
    id: string
    userId: string
    name: string
    date: Date
    courseId: string
    coverageTopics: string[]
    createdAt: Date
    updatedAt: Date
    _count: ExamCountAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  type GetExamGroupByPayload<T extends ExamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamGroupByOutputType[P]>
            : GetScalarType<T[P], ExamGroupByOutputType[P]>
        }
      >
    >


  export type ExamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    date?: boolean
    courseId?: boolean
    coverageTopics?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    date?: boolean
    courseId?: boolean
    coverageTopics?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    date?: boolean
    courseId?: boolean
    coverageTopics?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type ExamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $ExamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exam"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      date: Date
      courseId: string
      coverageTopics: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["exam"]>
    composites: {}
  }

  type ExamGetPayload<S extends boolean | null | undefined | ExamDefaultArgs> = $Result.GetResult<Prisma.$ExamPayload, S>

  type ExamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExamCountAggregateInputType | true
    }

  export interface ExamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exam'], meta: { name: 'Exam' } }
    /**
     * Find zero or one Exam that matches the filter.
     * @param {ExamFindUniqueArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamFindUniqueArgs>(args: SelectSubset<T, ExamFindUniqueArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Exam that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExamFindUniqueOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Exam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamFindFirstArgs>(args?: SelectSubset<T, ExamFindFirstArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Exam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exams
     * const exams = await prisma.exam.findMany()
     * 
     * // Get first 10 Exams
     * const exams = await prisma.exam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examWithIdOnly = await prisma.exam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamFindManyArgs>(args?: SelectSubset<T, ExamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Exam.
     * @param {ExamCreateArgs} args - Arguments to create a Exam.
     * @example
     * // Create one Exam
     * const Exam = await prisma.exam.create({
     *   data: {
     *     // ... data to create a Exam
     *   }
     * })
     * 
     */
    create<T extends ExamCreateArgs>(args: SelectSubset<T, ExamCreateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Exams.
     * @param {ExamCreateManyArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamCreateManyArgs>(args?: SelectSubset<T, ExamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exams and returns the data saved in the database.
     * @param {ExamCreateManyAndReturnArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exams and only return the `id`
     * const examWithIdOnly = await prisma.exam.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Exam.
     * @param {ExamDeleteArgs} args - Arguments to delete one Exam.
     * @example
     * // Delete one Exam
     * const Exam = await prisma.exam.delete({
     *   where: {
     *     // ... filter to delete one Exam
     *   }
     * })
     * 
     */
    delete<T extends ExamDeleteArgs>(args: SelectSubset<T, ExamDeleteArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Exam.
     * @param {ExamUpdateArgs} args - Arguments to update one Exam.
     * @example
     * // Update one Exam
     * const exam = await prisma.exam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamUpdateArgs>(args: SelectSubset<T, ExamUpdateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Exams.
     * @param {ExamDeleteManyArgs} args - Arguments to filter Exams to delete.
     * @example
     * // Delete a few Exams
     * const { count } = await prisma.exam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamDeleteManyArgs>(args?: SelectSubset<T, ExamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamUpdateManyArgs>(args: SelectSubset<T, ExamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Exam.
     * @param {ExamUpsertArgs} args - Arguments to update or create a Exam.
     * @example
     * // Update or create a Exam
     * const exam = await prisma.exam.upsert({
     *   create: {
     *     // ... data to create a Exam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exam we want to update
     *   }
     * })
     */
    upsert<T extends ExamUpsertArgs>(args: SelectSubset<T, ExamUpsertArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCountArgs} args - Arguments to filter Exams to count.
     * @example
     * // Count the number of Exams
     * const count = await prisma.exam.count({
     *   where: {
     *     // ... the filter for the Exams we want to count
     *   }
     * })
    **/
    count<T extends ExamCountArgs>(
      args?: Subset<T, ExamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamAggregateArgs>(args: Subset<T, ExamAggregateArgs>): Prisma.PrismaPromise<GetExamAggregateType<T>>

    /**
     * Group by Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamGroupByArgs['orderBy'] }
        : { orderBy?: ExamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exam model
   */
  readonly fields: ExamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exam model
   */ 
  interface ExamFieldRefs {
    readonly id: FieldRef<"Exam", 'String'>
    readonly userId: FieldRef<"Exam", 'String'>
    readonly name: FieldRef<"Exam", 'String'>
    readonly date: FieldRef<"Exam", 'DateTime'>
    readonly courseId: FieldRef<"Exam", 'String'>
    readonly coverageTopics: FieldRef<"Exam", 'String[]'>
    readonly createdAt: FieldRef<"Exam", 'DateTime'>
    readonly updatedAt: FieldRef<"Exam", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Exam findUnique
   */
  export type ExamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findUniqueOrThrow
   */
  export type ExamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findFirst
   */
  export type ExamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findFirstOrThrow
   */
  export type ExamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findMany
   */
  export type ExamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exams to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam create
   */
  export type ExamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to create a Exam.
     */
    data: XOR<ExamCreateInput, ExamUncheckedCreateInput>
  }

  /**
   * Exam createMany
   */
  export type ExamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exam createManyAndReturn
   */
  export type ExamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exam update
   */
  export type ExamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to update a Exam.
     */
    data: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
    /**
     * Choose, which Exam to update.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam updateMany
   */
  export type ExamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput
  }

  /**
   * Exam upsert
   */
  export type ExamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The filter to search for the Exam to update in case it exists.
     */
    where: ExamWhereUniqueInput
    /**
     * In case the Exam found by the `where` argument doesn't exist, create a new Exam with this data.
     */
    create: XOR<ExamCreateInput, ExamUncheckedCreateInput>
    /**
     * In case the Exam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
  }

  /**
   * Exam delete
   */
  export type ExamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter which Exam to delete.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam deleteMany
   */
  export type ExamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exams to delete
     */
    where?: ExamWhereInput
  }

  /**
   * Exam without action
   */
  export type ExamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
  }


  /**
   * Model CoursePriority
   */

  export type AggregateCoursePriority = {
    _count: CoursePriorityCountAggregateOutputType | null
    _min: CoursePriorityMinAggregateOutputType | null
    _max: CoursePriorityMaxAggregateOutputType | null
  }

  export type CoursePriorityMinAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    priorityLevel: $Enums.PriorityLevel | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoursePriorityMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    courseId: string | null
    priorityLevel: $Enums.PriorityLevel | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoursePriorityCountAggregateOutputType = {
    id: number
    userId: number
    courseId: number
    priorityLevel: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CoursePriorityMinAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    priorityLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoursePriorityMaxAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    priorityLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoursePriorityCountAggregateInputType = {
    id?: true
    userId?: true
    courseId?: true
    priorityLevel?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CoursePriorityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoursePriority to aggregate.
     */
    where?: CoursePriorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoursePriorities to fetch.
     */
    orderBy?: CoursePriorityOrderByWithRelationInput | CoursePriorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoursePriorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoursePriorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoursePriorities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoursePriorities
    **/
    _count?: true | CoursePriorityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoursePriorityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoursePriorityMaxAggregateInputType
  }

  export type GetCoursePriorityAggregateType<T extends CoursePriorityAggregateArgs> = {
        [P in keyof T & keyof AggregateCoursePriority]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoursePriority[P]>
      : GetScalarType<T[P], AggregateCoursePriority[P]>
  }




  export type CoursePriorityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoursePriorityWhereInput
    orderBy?: CoursePriorityOrderByWithAggregationInput | CoursePriorityOrderByWithAggregationInput[]
    by: CoursePriorityScalarFieldEnum[] | CoursePriorityScalarFieldEnum
    having?: CoursePriorityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoursePriorityCountAggregateInputType | true
    _min?: CoursePriorityMinAggregateInputType
    _max?: CoursePriorityMaxAggregateInputType
  }

  export type CoursePriorityGroupByOutputType = {
    id: string
    userId: string
    courseId: string
    priorityLevel: $Enums.PriorityLevel
    createdAt: Date
    updatedAt: Date
    _count: CoursePriorityCountAggregateOutputType | null
    _min: CoursePriorityMinAggregateOutputType | null
    _max: CoursePriorityMaxAggregateOutputType | null
  }

  type GetCoursePriorityGroupByPayload<T extends CoursePriorityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoursePriorityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoursePriorityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoursePriorityGroupByOutputType[P]>
            : GetScalarType<T[P], CoursePriorityGroupByOutputType[P]>
        }
      >
    >


  export type CoursePrioritySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    priorityLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coursePriority"]>

  export type CoursePrioritySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    courseId?: boolean
    priorityLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coursePriority"]>

  export type CoursePrioritySelectScalar = {
    id?: boolean
    userId?: boolean
    courseId?: boolean
    priorityLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CoursePriorityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CoursePriorityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $CoursePriorityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CoursePriority"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      courseId: string
      priorityLevel: $Enums.PriorityLevel
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["coursePriority"]>
    composites: {}
  }

  type CoursePriorityGetPayload<S extends boolean | null | undefined | CoursePriorityDefaultArgs> = $Result.GetResult<Prisma.$CoursePriorityPayload, S>

  type CoursePriorityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CoursePriorityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CoursePriorityCountAggregateInputType | true
    }

  export interface CoursePriorityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoursePriority'], meta: { name: 'CoursePriority' } }
    /**
     * Find zero or one CoursePriority that matches the filter.
     * @param {CoursePriorityFindUniqueArgs} args - Arguments to find a CoursePriority
     * @example
     * // Get one CoursePriority
     * const coursePriority = await prisma.coursePriority.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoursePriorityFindUniqueArgs>(args: SelectSubset<T, CoursePriorityFindUniqueArgs<ExtArgs>>): Prisma__CoursePriorityClient<$Result.GetResult<Prisma.$CoursePriorityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CoursePriority that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CoursePriorityFindUniqueOrThrowArgs} args - Arguments to find a CoursePriority
     * @example
     * // Get one CoursePriority
     * const coursePriority = await prisma.coursePriority.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoursePriorityFindUniqueOrThrowArgs>(args: SelectSubset<T, CoursePriorityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoursePriorityClient<$Result.GetResult<Prisma.$CoursePriorityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CoursePriority that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePriorityFindFirstArgs} args - Arguments to find a CoursePriority
     * @example
     * // Get one CoursePriority
     * const coursePriority = await prisma.coursePriority.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoursePriorityFindFirstArgs>(args?: SelectSubset<T, CoursePriorityFindFirstArgs<ExtArgs>>): Prisma__CoursePriorityClient<$Result.GetResult<Prisma.$CoursePriorityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CoursePriority that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePriorityFindFirstOrThrowArgs} args - Arguments to find a CoursePriority
     * @example
     * // Get one CoursePriority
     * const coursePriority = await prisma.coursePriority.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoursePriorityFindFirstOrThrowArgs>(args?: SelectSubset<T, CoursePriorityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoursePriorityClient<$Result.GetResult<Prisma.$CoursePriorityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CoursePriorities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePriorityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoursePriorities
     * const coursePriorities = await prisma.coursePriority.findMany()
     * 
     * // Get first 10 CoursePriorities
     * const coursePriorities = await prisma.coursePriority.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coursePriorityWithIdOnly = await prisma.coursePriority.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CoursePriorityFindManyArgs>(args?: SelectSubset<T, CoursePriorityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePriorityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CoursePriority.
     * @param {CoursePriorityCreateArgs} args - Arguments to create a CoursePriority.
     * @example
     * // Create one CoursePriority
     * const CoursePriority = await prisma.coursePriority.create({
     *   data: {
     *     // ... data to create a CoursePriority
     *   }
     * })
     * 
     */
    create<T extends CoursePriorityCreateArgs>(args: SelectSubset<T, CoursePriorityCreateArgs<ExtArgs>>): Prisma__CoursePriorityClient<$Result.GetResult<Prisma.$CoursePriorityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CoursePriorities.
     * @param {CoursePriorityCreateManyArgs} args - Arguments to create many CoursePriorities.
     * @example
     * // Create many CoursePriorities
     * const coursePriority = await prisma.coursePriority.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoursePriorityCreateManyArgs>(args?: SelectSubset<T, CoursePriorityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CoursePriorities and returns the data saved in the database.
     * @param {CoursePriorityCreateManyAndReturnArgs} args - Arguments to create many CoursePriorities.
     * @example
     * // Create many CoursePriorities
     * const coursePriority = await prisma.coursePriority.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CoursePriorities and only return the `id`
     * const coursePriorityWithIdOnly = await prisma.coursePriority.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoursePriorityCreateManyAndReturnArgs>(args?: SelectSubset<T, CoursePriorityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePriorityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CoursePriority.
     * @param {CoursePriorityDeleteArgs} args - Arguments to delete one CoursePriority.
     * @example
     * // Delete one CoursePriority
     * const CoursePriority = await prisma.coursePriority.delete({
     *   where: {
     *     // ... filter to delete one CoursePriority
     *   }
     * })
     * 
     */
    delete<T extends CoursePriorityDeleteArgs>(args: SelectSubset<T, CoursePriorityDeleteArgs<ExtArgs>>): Prisma__CoursePriorityClient<$Result.GetResult<Prisma.$CoursePriorityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CoursePriority.
     * @param {CoursePriorityUpdateArgs} args - Arguments to update one CoursePriority.
     * @example
     * // Update one CoursePriority
     * const coursePriority = await prisma.coursePriority.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoursePriorityUpdateArgs>(args: SelectSubset<T, CoursePriorityUpdateArgs<ExtArgs>>): Prisma__CoursePriorityClient<$Result.GetResult<Prisma.$CoursePriorityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CoursePriorities.
     * @param {CoursePriorityDeleteManyArgs} args - Arguments to filter CoursePriorities to delete.
     * @example
     * // Delete a few CoursePriorities
     * const { count } = await prisma.coursePriority.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoursePriorityDeleteManyArgs>(args?: SelectSubset<T, CoursePriorityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoursePriorities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePriorityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoursePriorities
     * const coursePriority = await prisma.coursePriority.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoursePriorityUpdateManyArgs>(args: SelectSubset<T, CoursePriorityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CoursePriority.
     * @param {CoursePriorityUpsertArgs} args - Arguments to update or create a CoursePriority.
     * @example
     * // Update or create a CoursePriority
     * const coursePriority = await prisma.coursePriority.upsert({
     *   create: {
     *     // ... data to create a CoursePriority
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoursePriority we want to update
     *   }
     * })
     */
    upsert<T extends CoursePriorityUpsertArgs>(args: SelectSubset<T, CoursePriorityUpsertArgs<ExtArgs>>): Prisma__CoursePriorityClient<$Result.GetResult<Prisma.$CoursePriorityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CoursePriorities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePriorityCountArgs} args - Arguments to filter CoursePriorities to count.
     * @example
     * // Count the number of CoursePriorities
     * const count = await prisma.coursePriority.count({
     *   where: {
     *     // ... the filter for the CoursePriorities we want to count
     *   }
     * })
    **/
    count<T extends CoursePriorityCountArgs>(
      args?: Subset<T, CoursePriorityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoursePriorityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoursePriority.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePriorityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoursePriorityAggregateArgs>(args: Subset<T, CoursePriorityAggregateArgs>): Prisma.PrismaPromise<GetCoursePriorityAggregateType<T>>

    /**
     * Group by CoursePriority.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursePriorityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoursePriorityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoursePriorityGroupByArgs['orderBy'] }
        : { orderBy?: CoursePriorityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoursePriorityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoursePriorityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoursePriority model
   */
  readonly fields: CoursePriorityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoursePriority.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoursePriorityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CoursePriority model
   */ 
  interface CoursePriorityFieldRefs {
    readonly id: FieldRef<"CoursePriority", 'String'>
    readonly userId: FieldRef<"CoursePriority", 'String'>
    readonly courseId: FieldRef<"CoursePriority", 'String'>
    readonly priorityLevel: FieldRef<"CoursePriority", 'PriorityLevel'>
    readonly createdAt: FieldRef<"CoursePriority", 'DateTime'>
    readonly updatedAt: FieldRef<"CoursePriority", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CoursePriority findUnique
   */
  export type CoursePriorityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePriority
     */
    select?: CoursePrioritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePriorityInclude<ExtArgs> | null
    /**
     * Filter, which CoursePriority to fetch.
     */
    where: CoursePriorityWhereUniqueInput
  }

  /**
   * CoursePriority findUniqueOrThrow
   */
  export type CoursePriorityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePriority
     */
    select?: CoursePrioritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePriorityInclude<ExtArgs> | null
    /**
     * Filter, which CoursePriority to fetch.
     */
    where: CoursePriorityWhereUniqueInput
  }

  /**
   * CoursePriority findFirst
   */
  export type CoursePriorityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePriority
     */
    select?: CoursePrioritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePriorityInclude<ExtArgs> | null
    /**
     * Filter, which CoursePriority to fetch.
     */
    where?: CoursePriorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoursePriorities to fetch.
     */
    orderBy?: CoursePriorityOrderByWithRelationInput | CoursePriorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoursePriorities.
     */
    cursor?: CoursePriorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoursePriorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoursePriorities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoursePriorities.
     */
    distinct?: CoursePriorityScalarFieldEnum | CoursePriorityScalarFieldEnum[]
  }

  /**
   * CoursePriority findFirstOrThrow
   */
  export type CoursePriorityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePriority
     */
    select?: CoursePrioritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePriorityInclude<ExtArgs> | null
    /**
     * Filter, which CoursePriority to fetch.
     */
    where?: CoursePriorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoursePriorities to fetch.
     */
    orderBy?: CoursePriorityOrderByWithRelationInput | CoursePriorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoursePriorities.
     */
    cursor?: CoursePriorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoursePriorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoursePriorities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoursePriorities.
     */
    distinct?: CoursePriorityScalarFieldEnum | CoursePriorityScalarFieldEnum[]
  }

  /**
   * CoursePriority findMany
   */
  export type CoursePriorityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePriority
     */
    select?: CoursePrioritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePriorityInclude<ExtArgs> | null
    /**
     * Filter, which CoursePriorities to fetch.
     */
    where?: CoursePriorityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoursePriorities to fetch.
     */
    orderBy?: CoursePriorityOrderByWithRelationInput | CoursePriorityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoursePriorities.
     */
    cursor?: CoursePriorityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoursePriorities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoursePriorities.
     */
    skip?: number
    distinct?: CoursePriorityScalarFieldEnum | CoursePriorityScalarFieldEnum[]
  }

  /**
   * CoursePriority create
   */
  export type CoursePriorityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePriority
     */
    select?: CoursePrioritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePriorityInclude<ExtArgs> | null
    /**
     * The data needed to create a CoursePriority.
     */
    data: XOR<CoursePriorityCreateInput, CoursePriorityUncheckedCreateInput>
  }

  /**
   * CoursePriority createMany
   */
  export type CoursePriorityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoursePriorities.
     */
    data: CoursePriorityCreateManyInput | CoursePriorityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CoursePriority createManyAndReturn
   */
  export type CoursePriorityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePriority
     */
    select?: CoursePrioritySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CoursePriorities.
     */
    data: CoursePriorityCreateManyInput | CoursePriorityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePriorityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoursePriority update
   */
  export type CoursePriorityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePriority
     */
    select?: CoursePrioritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePriorityInclude<ExtArgs> | null
    /**
     * The data needed to update a CoursePriority.
     */
    data: XOR<CoursePriorityUpdateInput, CoursePriorityUncheckedUpdateInput>
    /**
     * Choose, which CoursePriority to update.
     */
    where: CoursePriorityWhereUniqueInput
  }

  /**
   * CoursePriority updateMany
   */
  export type CoursePriorityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoursePriorities.
     */
    data: XOR<CoursePriorityUpdateManyMutationInput, CoursePriorityUncheckedUpdateManyInput>
    /**
     * Filter which CoursePriorities to update
     */
    where?: CoursePriorityWhereInput
  }

  /**
   * CoursePriority upsert
   */
  export type CoursePriorityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePriority
     */
    select?: CoursePrioritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePriorityInclude<ExtArgs> | null
    /**
     * The filter to search for the CoursePriority to update in case it exists.
     */
    where: CoursePriorityWhereUniqueInput
    /**
     * In case the CoursePriority found by the `where` argument doesn't exist, create a new CoursePriority with this data.
     */
    create: XOR<CoursePriorityCreateInput, CoursePriorityUncheckedCreateInput>
    /**
     * In case the CoursePriority was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoursePriorityUpdateInput, CoursePriorityUncheckedUpdateInput>
  }

  /**
   * CoursePriority delete
   */
  export type CoursePriorityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePriority
     */
    select?: CoursePrioritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePriorityInclude<ExtArgs> | null
    /**
     * Filter which CoursePriority to delete.
     */
    where: CoursePriorityWhereUniqueInput
  }

  /**
   * CoursePriority deleteMany
   */
  export type CoursePriorityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoursePriorities to delete
     */
    where?: CoursePriorityWhereInput
  }

  /**
   * CoursePriority without action
   */
  export type CoursePriorityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursePriority
     */
    select?: CoursePrioritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoursePriorityInclude<ExtArgs> | null
  }


  /**
   * Model PriorityFeedback
   */

  export type AggregatePriorityFeedback = {
    _count: PriorityFeedbackCountAggregateOutputType | null
    _avg: PriorityFeedbackAvgAggregateOutputType | null
    _sum: PriorityFeedbackSumAggregateOutputType | null
    _min: PriorityFeedbackMinAggregateOutputType | null
    _max: PriorityFeedbackMaxAggregateOutputType | null
  }

  export type PriorityFeedbackAvgAggregateOutputType = {
    suggestedPriority: number | null
  }

  export type PriorityFeedbackSumAggregateOutputType = {
    suggestedPriority: number | null
  }

  export type PriorityFeedbackMinAggregateOutputType = {
    id: string | null
    userId: string | null
    objectiveId: string | null
    suggestedPriority: number | null
    userFeedback: $Enums.FeedbackRating | null
    notes: string | null
    createdAt: Date | null
  }

  export type PriorityFeedbackMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    objectiveId: string | null
    suggestedPriority: number | null
    userFeedback: $Enums.FeedbackRating | null
    notes: string | null
    createdAt: Date | null
  }

  export type PriorityFeedbackCountAggregateOutputType = {
    id: number
    userId: number
    objectiveId: number
    suggestedPriority: number
    userFeedback: number
    notes: number
    createdAt: number
    _all: number
  }


  export type PriorityFeedbackAvgAggregateInputType = {
    suggestedPriority?: true
  }

  export type PriorityFeedbackSumAggregateInputType = {
    suggestedPriority?: true
  }

  export type PriorityFeedbackMinAggregateInputType = {
    id?: true
    userId?: true
    objectiveId?: true
    suggestedPriority?: true
    userFeedback?: true
    notes?: true
    createdAt?: true
  }

  export type PriorityFeedbackMaxAggregateInputType = {
    id?: true
    userId?: true
    objectiveId?: true
    suggestedPriority?: true
    userFeedback?: true
    notes?: true
    createdAt?: true
  }

  export type PriorityFeedbackCountAggregateInputType = {
    id?: true
    userId?: true
    objectiveId?: true
    suggestedPriority?: true
    userFeedback?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type PriorityFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriorityFeedback to aggregate.
     */
    where?: PriorityFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriorityFeedbacks to fetch.
     */
    orderBy?: PriorityFeedbackOrderByWithRelationInput | PriorityFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriorityFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriorityFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriorityFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PriorityFeedbacks
    **/
    _count?: true | PriorityFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriorityFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriorityFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriorityFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriorityFeedbackMaxAggregateInputType
  }

  export type GetPriorityFeedbackAggregateType<T extends PriorityFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregatePriorityFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriorityFeedback[P]>
      : GetScalarType<T[P], AggregatePriorityFeedback[P]>
  }




  export type PriorityFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriorityFeedbackWhereInput
    orderBy?: PriorityFeedbackOrderByWithAggregationInput | PriorityFeedbackOrderByWithAggregationInput[]
    by: PriorityFeedbackScalarFieldEnum[] | PriorityFeedbackScalarFieldEnum
    having?: PriorityFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriorityFeedbackCountAggregateInputType | true
    _avg?: PriorityFeedbackAvgAggregateInputType
    _sum?: PriorityFeedbackSumAggregateInputType
    _min?: PriorityFeedbackMinAggregateInputType
    _max?: PriorityFeedbackMaxAggregateInputType
  }

  export type PriorityFeedbackGroupByOutputType = {
    id: string
    userId: string
    objectiveId: string
    suggestedPriority: number
    userFeedback: $Enums.FeedbackRating
    notes: string | null
    createdAt: Date
    _count: PriorityFeedbackCountAggregateOutputType | null
    _avg: PriorityFeedbackAvgAggregateOutputType | null
    _sum: PriorityFeedbackSumAggregateOutputType | null
    _min: PriorityFeedbackMinAggregateOutputType | null
    _max: PriorityFeedbackMaxAggregateOutputType | null
  }

  type GetPriorityFeedbackGroupByPayload<T extends PriorityFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriorityFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriorityFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriorityFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], PriorityFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type PriorityFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    objectiveId?: boolean
    suggestedPriority?: boolean
    userFeedback?: boolean
    notes?: boolean
    createdAt?: boolean
    learningObjective?: boolean | LearningObjectiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priorityFeedback"]>

  export type PriorityFeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    objectiveId?: boolean
    suggestedPriority?: boolean
    userFeedback?: boolean
    notes?: boolean
    createdAt?: boolean
    learningObjective?: boolean | LearningObjectiveDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priorityFeedback"]>

  export type PriorityFeedbackSelectScalar = {
    id?: boolean
    userId?: boolean
    objectiveId?: boolean
    suggestedPriority?: boolean
    userFeedback?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type PriorityFeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningObjective?: boolean | LearningObjectiveDefaultArgs<ExtArgs>
  }
  export type PriorityFeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    learningObjective?: boolean | LearningObjectiveDefaultArgs<ExtArgs>
  }

  export type $PriorityFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PriorityFeedback"
    objects: {
      learningObjective: Prisma.$LearningObjectivePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      objectiveId: string
      suggestedPriority: number
      userFeedback: $Enums.FeedbackRating
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["priorityFeedback"]>
    composites: {}
  }

  type PriorityFeedbackGetPayload<S extends boolean | null | undefined | PriorityFeedbackDefaultArgs> = $Result.GetResult<Prisma.$PriorityFeedbackPayload, S>

  type PriorityFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PriorityFeedbackFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PriorityFeedbackCountAggregateInputType | true
    }

  export interface PriorityFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PriorityFeedback'], meta: { name: 'PriorityFeedback' } }
    /**
     * Find zero or one PriorityFeedback that matches the filter.
     * @param {PriorityFeedbackFindUniqueArgs} args - Arguments to find a PriorityFeedback
     * @example
     * // Get one PriorityFeedback
     * const priorityFeedback = await prisma.priorityFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PriorityFeedbackFindUniqueArgs>(args: SelectSubset<T, PriorityFeedbackFindUniqueArgs<ExtArgs>>): Prisma__PriorityFeedbackClient<$Result.GetResult<Prisma.$PriorityFeedbackPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PriorityFeedback that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PriorityFeedbackFindUniqueOrThrowArgs} args - Arguments to find a PriorityFeedback
     * @example
     * // Get one PriorityFeedback
     * const priorityFeedback = await prisma.priorityFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PriorityFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, PriorityFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PriorityFeedbackClient<$Result.GetResult<Prisma.$PriorityFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PriorityFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriorityFeedbackFindFirstArgs} args - Arguments to find a PriorityFeedback
     * @example
     * // Get one PriorityFeedback
     * const priorityFeedback = await prisma.priorityFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PriorityFeedbackFindFirstArgs>(args?: SelectSubset<T, PriorityFeedbackFindFirstArgs<ExtArgs>>): Prisma__PriorityFeedbackClient<$Result.GetResult<Prisma.$PriorityFeedbackPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PriorityFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriorityFeedbackFindFirstOrThrowArgs} args - Arguments to find a PriorityFeedback
     * @example
     * // Get one PriorityFeedback
     * const priorityFeedback = await prisma.priorityFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PriorityFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, PriorityFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__PriorityFeedbackClient<$Result.GetResult<Prisma.$PriorityFeedbackPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PriorityFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriorityFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PriorityFeedbacks
     * const priorityFeedbacks = await prisma.priorityFeedback.findMany()
     * 
     * // Get first 10 PriorityFeedbacks
     * const priorityFeedbacks = await prisma.priorityFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priorityFeedbackWithIdOnly = await prisma.priorityFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PriorityFeedbackFindManyArgs>(args?: SelectSubset<T, PriorityFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriorityFeedbackPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PriorityFeedback.
     * @param {PriorityFeedbackCreateArgs} args - Arguments to create a PriorityFeedback.
     * @example
     * // Create one PriorityFeedback
     * const PriorityFeedback = await prisma.priorityFeedback.create({
     *   data: {
     *     // ... data to create a PriorityFeedback
     *   }
     * })
     * 
     */
    create<T extends PriorityFeedbackCreateArgs>(args: SelectSubset<T, PriorityFeedbackCreateArgs<ExtArgs>>): Prisma__PriorityFeedbackClient<$Result.GetResult<Prisma.$PriorityFeedbackPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PriorityFeedbacks.
     * @param {PriorityFeedbackCreateManyArgs} args - Arguments to create many PriorityFeedbacks.
     * @example
     * // Create many PriorityFeedbacks
     * const priorityFeedback = await prisma.priorityFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PriorityFeedbackCreateManyArgs>(args?: SelectSubset<T, PriorityFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PriorityFeedbacks and returns the data saved in the database.
     * @param {PriorityFeedbackCreateManyAndReturnArgs} args - Arguments to create many PriorityFeedbacks.
     * @example
     * // Create many PriorityFeedbacks
     * const priorityFeedback = await prisma.priorityFeedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PriorityFeedbacks and only return the `id`
     * const priorityFeedbackWithIdOnly = await prisma.priorityFeedback.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PriorityFeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, PriorityFeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriorityFeedbackPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PriorityFeedback.
     * @param {PriorityFeedbackDeleteArgs} args - Arguments to delete one PriorityFeedback.
     * @example
     * // Delete one PriorityFeedback
     * const PriorityFeedback = await prisma.priorityFeedback.delete({
     *   where: {
     *     // ... filter to delete one PriorityFeedback
     *   }
     * })
     * 
     */
    delete<T extends PriorityFeedbackDeleteArgs>(args: SelectSubset<T, PriorityFeedbackDeleteArgs<ExtArgs>>): Prisma__PriorityFeedbackClient<$Result.GetResult<Prisma.$PriorityFeedbackPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PriorityFeedback.
     * @param {PriorityFeedbackUpdateArgs} args - Arguments to update one PriorityFeedback.
     * @example
     * // Update one PriorityFeedback
     * const priorityFeedback = await prisma.priorityFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PriorityFeedbackUpdateArgs>(args: SelectSubset<T, PriorityFeedbackUpdateArgs<ExtArgs>>): Prisma__PriorityFeedbackClient<$Result.GetResult<Prisma.$PriorityFeedbackPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PriorityFeedbacks.
     * @param {PriorityFeedbackDeleteManyArgs} args - Arguments to filter PriorityFeedbacks to delete.
     * @example
     * // Delete a few PriorityFeedbacks
     * const { count } = await prisma.priorityFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PriorityFeedbackDeleteManyArgs>(args?: SelectSubset<T, PriorityFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriorityFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriorityFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PriorityFeedbacks
     * const priorityFeedback = await prisma.priorityFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PriorityFeedbackUpdateManyArgs>(args: SelectSubset<T, PriorityFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PriorityFeedback.
     * @param {PriorityFeedbackUpsertArgs} args - Arguments to update or create a PriorityFeedback.
     * @example
     * // Update or create a PriorityFeedback
     * const priorityFeedback = await prisma.priorityFeedback.upsert({
     *   create: {
     *     // ... data to create a PriorityFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PriorityFeedback we want to update
     *   }
     * })
     */
    upsert<T extends PriorityFeedbackUpsertArgs>(args: SelectSubset<T, PriorityFeedbackUpsertArgs<ExtArgs>>): Prisma__PriorityFeedbackClient<$Result.GetResult<Prisma.$PriorityFeedbackPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PriorityFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriorityFeedbackCountArgs} args - Arguments to filter PriorityFeedbacks to count.
     * @example
     * // Count the number of PriorityFeedbacks
     * const count = await prisma.priorityFeedback.count({
     *   where: {
     *     // ... the filter for the PriorityFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends PriorityFeedbackCountArgs>(
      args?: Subset<T, PriorityFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriorityFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PriorityFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriorityFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriorityFeedbackAggregateArgs>(args: Subset<T, PriorityFeedbackAggregateArgs>): Prisma.PrismaPromise<GetPriorityFeedbackAggregateType<T>>

    /**
     * Group by PriorityFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriorityFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriorityFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriorityFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: PriorityFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriorityFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriorityFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PriorityFeedback model
   */
  readonly fields: PriorityFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PriorityFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PriorityFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    learningObjective<T extends LearningObjectiveDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearningObjectiveDefaultArgs<ExtArgs>>): Prisma__LearningObjectiveClient<$Result.GetResult<Prisma.$LearningObjectivePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PriorityFeedback model
   */ 
  interface PriorityFeedbackFieldRefs {
    readonly id: FieldRef<"PriorityFeedback", 'String'>
    readonly userId: FieldRef<"PriorityFeedback", 'String'>
    readonly objectiveId: FieldRef<"PriorityFeedback", 'String'>
    readonly suggestedPriority: FieldRef<"PriorityFeedback", 'Float'>
    readonly userFeedback: FieldRef<"PriorityFeedback", 'FeedbackRating'>
    readonly notes: FieldRef<"PriorityFeedback", 'String'>
    readonly createdAt: FieldRef<"PriorityFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PriorityFeedback findUnique
   */
  export type PriorityFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriorityFeedback
     */
    select?: PriorityFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriorityFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which PriorityFeedback to fetch.
     */
    where: PriorityFeedbackWhereUniqueInput
  }

  /**
   * PriorityFeedback findUniqueOrThrow
   */
  export type PriorityFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriorityFeedback
     */
    select?: PriorityFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriorityFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which PriorityFeedback to fetch.
     */
    where: PriorityFeedbackWhereUniqueInput
  }

  /**
   * PriorityFeedback findFirst
   */
  export type PriorityFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriorityFeedback
     */
    select?: PriorityFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriorityFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which PriorityFeedback to fetch.
     */
    where?: PriorityFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriorityFeedbacks to fetch.
     */
    orderBy?: PriorityFeedbackOrderByWithRelationInput | PriorityFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriorityFeedbacks.
     */
    cursor?: PriorityFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriorityFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriorityFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriorityFeedbacks.
     */
    distinct?: PriorityFeedbackScalarFieldEnum | PriorityFeedbackScalarFieldEnum[]
  }

  /**
   * PriorityFeedback findFirstOrThrow
   */
  export type PriorityFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriorityFeedback
     */
    select?: PriorityFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriorityFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which PriorityFeedback to fetch.
     */
    where?: PriorityFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriorityFeedbacks to fetch.
     */
    orderBy?: PriorityFeedbackOrderByWithRelationInput | PriorityFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriorityFeedbacks.
     */
    cursor?: PriorityFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriorityFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriorityFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriorityFeedbacks.
     */
    distinct?: PriorityFeedbackScalarFieldEnum | PriorityFeedbackScalarFieldEnum[]
  }

  /**
   * PriorityFeedback findMany
   */
  export type PriorityFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriorityFeedback
     */
    select?: PriorityFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriorityFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which PriorityFeedbacks to fetch.
     */
    where?: PriorityFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriorityFeedbacks to fetch.
     */
    orderBy?: PriorityFeedbackOrderByWithRelationInput | PriorityFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PriorityFeedbacks.
     */
    cursor?: PriorityFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriorityFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriorityFeedbacks.
     */
    skip?: number
    distinct?: PriorityFeedbackScalarFieldEnum | PriorityFeedbackScalarFieldEnum[]
  }

  /**
   * PriorityFeedback create
   */
  export type PriorityFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriorityFeedback
     */
    select?: PriorityFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriorityFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a PriorityFeedback.
     */
    data: XOR<PriorityFeedbackCreateInput, PriorityFeedbackUncheckedCreateInput>
  }

  /**
   * PriorityFeedback createMany
   */
  export type PriorityFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PriorityFeedbacks.
     */
    data: PriorityFeedbackCreateManyInput | PriorityFeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PriorityFeedback createManyAndReturn
   */
  export type PriorityFeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriorityFeedback
     */
    select?: PriorityFeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PriorityFeedbacks.
     */
    data: PriorityFeedbackCreateManyInput | PriorityFeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriorityFeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PriorityFeedback update
   */
  export type PriorityFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriorityFeedback
     */
    select?: PriorityFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriorityFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a PriorityFeedback.
     */
    data: XOR<PriorityFeedbackUpdateInput, PriorityFeedbackUncheckedUpdateInput>
    /**
     * Choose, which PriorityFeedback to update.
     */
    where: PriorityFeedbackWhereUniqueInput
  }

  /**
   * PriorityFeedback updateMany
   */
  export type PriorityFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PriorityFeedbacks.
     */
    data: XOR<PriorityFeedbackUpdateManyMutationInput, PriorityFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which PriorityFeedbacks to update
     */
    where?: PriorityFeedbackWhereInput
  }

  /**
   * PriorityFeedback upsert
   */
  export type PriorityFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriorityFeedback
     */
    select?: PriorityFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriorityFeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the PriorityFeedback to update in case it exists.
     */
    where: PriorityFeedbackWhereUniqueInput
    /**
     * In case the PriorityFeedback found by the `where` argument doesn't exist, create a new PriorityFeedback with this data.
     */
    create: XOR<PriorityFeedbackCreateInput, PriorityFeedbackUncheckedCreateInput>
    /**
     * In case the PriorityFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriorityFeedbackUpdateInput, PriorityFeedbackUncheckedUpdateInput>
  }

  /**
   * PriorityFeedback delete
   */
  export type PriorityFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriorityFeedback
     */
    select?: PriorityFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriorityFeedbackInclude<ExtArgs> | null
    /**
     * Filter which PriorityFeedback to delete.
     */
    where: PriorityFeedbackWhereUniqueInput
  }

  /**
   * PriorityFeedback deleteMany
   */
  export type PriorityFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriorityFeedbacks to delete
     */
    where?: PriorityFeedbackWhereInput
  }

  /**
   * PriorityFeedback without action
   */
  export type PriorityFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriorityFeedback
     */
    select?: PriorityFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriorityFeedbackInclude<ExtArgs> | null
  }


  /**
   * Model Streak
   */

  export type AggregateStreak = {
    _count: StreakCountAggregateOutputType | null
    _avg: StreakAvgAggregateOutputType | null
    _sum: StreakSumAggregateOutputType | null
    _min: StreakMinAggregateOutputType | null
    _max: StreakMaxAggregateOutputType | null
  }

  export type StreakAvgAggregateOutputType = {
    currentStreak: number | null
    longestStreak: number | null
    freezesRemaining: number | null
  }

  export type StreakSumAggregateOutputType = {
    currentStreak: number | null
    longestStreak: number | null
    freezesRemaining: number | null
  }

  export type StreakMinAggregateOutputType = {
    id: string | null
    userId: string | null
    currentStreak: number | null
    longestStreak: number | null
    lastStudyDate: Date | null
    freezesRemaining: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StreakMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    currentStreak: number | null
    longestStreak: number | null
    lastStudyDate: Date | null
    freezesRemaining: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StreakCountAggregateOutputType = {
    id: number
    userId: number
    currentStreak: number
    longestStreak: number
    lastStudyDate: number
    freezesRemaining: number
    freezeUsedDates: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StreakAvgAggregateInputType = {
    currentStreak?: true
    longestStreak?: true
    freezesRemaining?: true
  }

  export type StreakSumAggregateInputType = {
    currentStreak?: true
    longestStreak?: true
    freezesRemaining?: true
  }

  export type StreakMinAggregateInputType = {
    id?: true
    userId?: true
    currentStreak?: true
    longestStreak?: true
    lastStudyDate?: true
    freezesRemaining?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StreakMaxAggregateInputType = {
    id?: true
    userId?: true
    currentStreak?: true
    longestStreak?: true
    lastStudyDate?: true
    freezesRemaining?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StreakCountAggregateInputType = {
    id?: true
    userId?: true
    currentStreak?: true
    longestStreak?: true
    lastStudyDate?: true
    freezesRemaining?: true
    freezeUsedDates?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StreakAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Streak to aggregate.
     */
    where?: StreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Streaks to fetch.
     */
    orderBy?: StreakOrderByWithRelationInput | StreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Streaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Streaks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Streaks
    **/
    _count?: true | StreakCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StreakAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StreakSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StreakMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StreakMaxAggregateInputType
  }

  export type GetStreakAggregateType<T extends StreakAggregateArgs> = {
        [P in keyof T & keyof AggregateStreak]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStreak[P]>
      : GetScalarType<T[P], AggregateStreak[P]>
  }




  export type StreakGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StreakWhereInput
    orderBy?: StreakOrderByWithAggregationInput | StreakOrderByWithAggregationInput[]
    by: StreakScalarFieldEnum[] | StreakScalarFieldEnum
    having?: StreakScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StreakCountAggregateInputType | true
    _avg?: StreakAvgAggregateInputType
    _sum?: StreakSumAggregateInputType
    _min?: StreakMinAggregateInputType
    _max?: StreakMaxAggregateInputType
  }

  export type StreakGroupByOutputType = {
    id: string
    userId: string
    currentStreak: number
    longestStreak: number
    lastStudyDate: Date | null
    freezesRemaining: number
    freezeUsedDates: string[]
    createdAt: Date
    updatedAt: Date
    _count: StreakCountAggregateOutputType | null
    _avg: StreakAvgAggregateOutputType | null
    _sum: StreakSumAggregateOutputType | null
    _min: StreakMinAggregateOutputType | null
    _max: StreakMaxAggregateOutputType | null
  }

  type GetStreakGroupByPayload<T extends StreakGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StreakGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StreakGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StreakGroupByOutputType[P]>
            : GetScalarType<T[P], StreakGroupByOutputType[P]>
        }
      >
    >


  export type StreakSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    lastStudyDate?: boolean
    freezesRemaining?: boolean
    freezeUsedDates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["streak"]>

  export type StreakSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    lastStudyDate?: boolean
    freezesRemaining?: boolean
    freezeUsedDates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["streak"]>

  export type StreakSelectScalar = {
    id?: boolean
    userId?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    lastStudyDate?: boolean
    freezesRemaining?: boolean
    freezeUsedDates?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StreakInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StreakIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StreakPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Streak"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      currentStreak: number
      longestStreak: number
      lastStudyDate: Date | null
      freezesRemaining: number
      freezeUsedDates: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["streak"]>
    composites: {}
  }

  type StreakGetPayload<S extends boolean | null | undefined | StreakDefaultArgs> = $Result.GetResult<Prisma.$StreakPayload, S>

  type StreakCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StreakFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StreakCountAggregateInputType | true
    }

  export interface StreakDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Streak'], meta: { name: 'Streak' } }
    /**
     * Find zero or one Streak that matches the filter.
     * @param {StreakFindUniqueArgs} args - Arguments to find a Streak
     * @example
     * // Get one Streak
     * const streak = await prisma.streak.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StreakFindUniqueArgs>(args: SelectSubset<T, StreakFindUniqueArgs<ExtArgs>>): Prisma__StreakClient<$Result.GetResult<Prisma.$StreakPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Streak that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StreakFindUniqueOrThrowArgs} args - Arguments to find a Streak
     * @example
     * // Get one Streak
     * const streak = await prisma.streak.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StreakFindUniqueOrThrowArgs>(args: SelectSubset<T, StreakFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StreakClient<$Result.GetResult<Prisma.$StreakPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Streak that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakFindFirstArgs} args - Arguments to find a Streak
     * @example
     * // Get one Streak
     * const streak = await prisma.streak.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StreakFindFirstArgs>(args?: SelectSubset<T, StreakFindFirstArgs<ExtArgs>>): Prisma__StreakClient<$Result.GetResult<Prisma.$StreakPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Streak that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakFindFirstOrThrowArgs} args - Arguments to find a Streak
     * @example
     * // Get one Streak
     * const streak = await prisma.streak.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StreakFindFirstOrThrowArgs>(args?: SelectSubset<T, StreakFindFirstOrThrowArgs<ExtArgs>>): Prisma__StreakClient<$Result.GetResult<Prisma.$StreakPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Streaks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Streaks
     * const streaks = await prisma.streak.findMany()
     * 
     * // Get first 10 Streaks
     * const streaks = await prisma.streak.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const streakWithIdOnly = await prisma.streak.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StreakFindManyArgs>(args?: SelectSubset<T, StreakFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreakPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Streak.
     * @param {StreakCreateArgs} args - Arguments to create a Streak.
     * @example
     * // Create one Streak
     * const Streak = await prisma.streak.create({
     *   data: {
     *     // ... data to create a Streak
     *   }
     * })
     * 
     */
    create<T extends StreakCreateArgs>(args: SelectSubset<T, StreakCreateArgs<ExtArgs>>): Prisma__StreakClient<$Result.GetResult<Prisma.$StreakPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Streaks.
     * @param {StreakCreateManyArgs} args - Arguments to create many Streaks.
     * @example
     * // Create many Streaks
     * const streak = await prisma.streak.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StreakCreateManyArgs>(args?: SelectSubset<T, StreakCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Streaks and returns the data saved in the database.
     * @param {StreakCreateManyAndReturnArgs} args - Arguments to create many Streaks.
     * @example
     * // Create many Streaks
     * const streak = await prisma.streak.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Streaks and only return the `id`
     * const streakWithIdOnly = await prisma.streak.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StreakCreateManyAndReturnArgs>(args?: SelectSubset<T, StreakCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StreakPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Streak.
     * @param {StreakDeleteArgs} args - Arguments to delete one Streak.
     * @example
     * // Delete one Streak
     * const Streak = await prisma.streak.delete({
     *   where: {
     *     // ... filter to delete one Streak
     *   }
     * })
     * 
     */
    delete<T extends StreakDeleteArgs>(args: SelectSubset<T, StreakDeleteArgs<ExtArgs>>): Prisma__StreakClient<$Result.GetResult<Prisma.$StreakPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Streak.
     * @param {StreakUpdateArgs} args - Arguments to update one Streak.
     * @example
     * // Update one Streak
     * const streak = await prisma.streak.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StreakUpdateArgs>(args: SelectSubset<T, StreakUpdateArgs<ExtArgs>>): Prisma__StreakClient<$Result.GetResult<Prisma.$StreakPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Streaks.
     * @param {StreakDeleteManyArgs} args - Arguments to filter Streaks to delete.
     * @example
     * // Delete a few Streaks
     * const { count } = await prisma.streak.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StreakDeleteManyArgs>(args?: SelectSubset<T, StreakDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Streaks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Streaks
     * const streak = await prisma.streak.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StreakUpdateManyArgs>(args: SelectSubset<T, StreakUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Streak.
     * @param {StreakUpsertArgs} args - Arguments to update or create a Streak.
     * @example
     * // Update or create a Streak
     * const streak = await prisma.streak.upsert({
     *   create: {
     *     // ... data to create a Streak
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Streak we want to update
     *   }
     * })
     */
    upsert<T extends StreakUpsertArgs>(args: SelectSubset<T, StreakUpsertArgs<ExtArgs>>): Prisma__StreakClient<$Result.GetResult<Prisma.$StreakPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Streaks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakCountArgs} args - Arguments to filter Streaks to count.
     * @example
     * // Count the number of Streaks
     * const count = await prisma.streak.count({
     *   where: {
     *     // ... the filter for the Streaks we want to count
     *   }
     * })
    **/
    count<T extends StreakCountArgs>(
      args?: Subset<T, StreakCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StreakCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Streak.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StreakAggregateArgs>(args: Subset<T, StreakAggregateArgs>): Prisma.PrismaPromise<GetStreakAggregateType<T>>

    /**
     * Group by Streak.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StreakGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StreakGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StreakGroupByArgs['orderBy'] }
        : { orderBy?: StreakGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StreakGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStreakGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Streak model
   */
  readonly fields: StreakFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Streak.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StreakClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Streak model
   */ 
  interface StreakFieldRefs {
    readonly id: FieldRef<"Streak", 'String'>
    readonly userId: FieldRef<"Streak", 'String'>
    readonly currentStreak: FieldRef<"Streak", 'Int'>
    readonly longestStreak: FieldRef<"Streak", 'Int'>
    readonly lastStudyDate: FieldRef<"Streak", 'DateTime'>
    readonly freezesRemaining: FieldRef<"Streak", 'Int'>
    readonly freezeUsedDates: FieldRef<"Streak", 'String[]'>
    readonly createdAt: FieldRef<"Streak", 'DateTime'>
    readonly updatedAt: FieldRef<"Streak", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Streak findUnique
   */
  export type StreakFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Streak
     */
    select?: StreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakInclude<ExtArgs> | null
    /**
     * Filter, which Streak to fetch.
     */
    where: StreakWhereUniqueInput
  }

  /**
   * Streak findUniqueOrThrow
   */
  export type StreakFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Streak
     */
    select?: StreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakInclude<ExtArgs> | null
    /**
     * Filter, which Streak to fetch.
     */
    where: StreakWhereUniqueInput
  }

  /**
   * Streak findFirst
   */
  export type StreakFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Streak
     */
    select?: StreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakInclude<ExtArgs> | null
    /**
     * Filter, which Streak to fetch.
     */
    where?: StreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Streaks to fetch.
     */
    orderBy?: StreakOrderByWithRelationInput | StreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Streaks.
     */
    cursor?: StreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Streaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Streaks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Streaks.
     */
    distinct?: StreakScalarFieldEnum | StreakScalarFieldEnum[]
  }

  /**
   * Streak findFirstOrThrow
   */
  export type StreakFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Streak
     */
    select?: StreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakInclude<ExtArgs> | null
    /**
     * Filter, which Streak to fetch.
     */
    where?: StreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Streaks to fetch.
     */
    orderBy?: StreakOrderByWithRelationInput | StreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Streaks.
     */
    cursor?: StreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Streaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Streaks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Streaks.
     */
    distinct?: StreakScalarFieldEnum | StreakScalarFieldEnum[]
  }

  /**
   * Streak findMany
   */
  export type StreakFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Streak
     */
    select?: StreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakInclude<ExtArgs> | null
    /**
     * Filter, which Streaks to fetch.
     */
    where?: StreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Streaks to fetch.
     */
    orderBy?: StreakOrderByWithRelationInput | StreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Streaks.
     */
    cursor?: StreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Streaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Streaks.
     */
    skip?: number
    distinct?: StreakScalarFieldEnum | StreakScalarFieldEnum[]
  }

  /**
   * Streak create
   */
  export type StreakCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Streak
     */
    select?: StreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakInclude<ExtArgs> | null
    /**
     * The data needed to create a Streak.
     */
    data: XOR<StreakCreateInput, StreakUncheckedCreateInput>
  }

  /**
   * Streak createMany
   */
  export type StreakCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Streaks.
     */
    data: StreakCreateManyInput | StreakCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Streak createManyAndReturn
   */
  export type StreakCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Streak
     */
    select?: StreakSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Streaks.
     */
    data: StreakCreateManyInput | StreakCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Streak update
   */
  export type StreakUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Streak
     */
    select?: StreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakInclude<ExtArgs> | null
    /**
     * The data needed to update a Streak.
     */
    data: XOR<StreakUpdateInput, StreakUncheckedUpdateInput>
    /**
     * Choose, which Streak to update.
     */
    where: StreakWhereUniqueInput
  }

  /**
   * Streak updateMany
   */
  export type StreakUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Streaks.
     */
    data: XOR<StreakUpdateManyMutationInput, StreakUncheckedUpdateManyInput>
    /**
     * Filter which Streaks to update
     */
    where?: StreakWhereInput
  }

  /**
   * Streak upsert
   */
  export type StreakUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Streak
     */
    select?: StreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakInclude<ExtArgs> | null
    /**
     * The filter to search for the Streak to update in case it exists.
     */
    where: StreakWhereUniqueInput
    /**
     * In case the Streak found by the `where` argument doesn't exist, create a new Streak with this data.
     */
    create: XOR<StreakCreateInput, StreakUncheckedCreateInput>
    /**
     * In case the Streak was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StreakUpdateInput, StreakUncheckedUpdateInput>
  }

  /**
   * Streak delete
   */
  export type StreakDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Streak
     */
    select?: StreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakInclude<ExtArgs> | null
    /**
     * Filter which Streak to delete.
     */
    where: StreakWhereUniqueInput
  }

  /**
   * Streak deleteMany
   */
  export type StreakDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Streaks to delete
     */
    where?: StreakWhereInput
  }

  /**
   * Streak without action
   */
  export type StreakDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Streak
     */
    select?: StreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StreakInclude<ExtArgs> | null
  }


  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.AchievementType | null
    name: string | null
    description: string | null
    tier: $Enums.AchievementTier | null
    earnedAt: Date | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.AchievementType | null
    name: string | null
    description: string | null
    tier: $Enums.AchievementTier | null
    earnedAt: Date | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    name: number
    description: number
    tier: number
    earnedAt: number
    metadata: number
    _all: number
  }


  export type AchievementMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    name?: true
    description?: true
    tier?: true
    earnedAt?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    name?: true
    description?: true
    tier?: true
    earnedAt?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    name?: true
    description?: true
    tier?: true
    earnedAt?: true
    metadata?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.AchievementType
    name: string
    description: string
    tier: $Enums.AchievementTier
    earnedAt: Date
    metadata: JsonValue | null
    _count: AchievementCountAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    tier?: boolean
    earnedAt?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    tier?: boolean
    earnedAt?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    tier?: boolean
    earnedAt?: boolean
    metadata?: boolean
  }

  export type AchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.AchievementType
      name: string
      description: string
      tier: $Enums.AchievementTier
      earnedAt: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {AchievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */ 
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'String'>
    readonly userId: FieldRef<"Achievement", 'String'>
    readonly type: FieldRef<"Achievement", 'AchievementType'>
    readonly name: FieldRef<"Achievement", 'String'>
    readonly description: FieldRef<"Achievement", 'String'>
    readonly tier: FieldRef<"Achievement", 'AchievementTier'>
    readonly earnedAt: FieldRef<"Achievement", 'DateTime'>
    readonly metadata: FieldRef<"Achievement", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement createManyAndReturn
   */
  export type AchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
  }


  /**
   * Model StudyGoal
   */

  export type AggregateStudyGoal = {
    _count: StudyGoalCountAggregateOutputType | null
    _avg: StudyGoalAvgAggregateOutputType | null
    _sum: StudyGoalSumAggregateOutputType | null
    _min: StudyGoalMinAggregateOutputType | null
    _max: StudyGoalMaxAggregateOutputType | null
  }

  export type StudyGoalAvgAggregateOutputType = {
    targetValue: number | null
    currentProgress: number | null
  }

  export type StudyGoalSumAggregateOutputType = {
    targetValue: number | null
    currentProgress: number | null
  }

  export type StudyGoalMinAggregateOutputType = {
    id: string | null
    userId: string | null
    goalType: $Enums.GoalType | null
    targetValue: number | null
    currentProgress: number | null
    period: $Enums.GoalPeriod | null
    startDate: Date | null
    endDate: Date | null
    isCompleted: boolean | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type StudyGoalMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    goalType: $Enums.GoalType | null
    targetValue: number | null
    currentProgress: number | null
    period: $Enums.GoalPeriod | null
    startDate: Date | null
    endDate: Date | null
    isCompleted: boolean | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type StudyGoalCountAggregateOutputType = {
    id: number
    userId: number
    goalType: number
    targetValue: number
    currentProgress: number
    period: number
    startDate: number
    endDate: number
    isCompleted: number
    completedAt: number
    createdAt: number
    _all: number
  }


  export type StudyGoalAvgAggregateInputType = {
    targetValue?: true
    currentProgress?: true
  }

  export type StudyGoalSumAggregateInputType = {
    targetValue?: true
    currentProgress?: true
  }

  export type StudyGoalMinAggregateInputType = {
    id?: true
    userId?: true
    goalType?: true
    targetValue?: true
    currentProgress?: true
    period?: true
    startDate?: true
    endDate?: true
    isCompleted?: true
    completedAt?: true
    createdAt?: true
  }

  export type StudyGoalMaxAggregateInputType = {
    id?: true
    userId?: true
    goalType?: true
    targetValue?: true
    currentProgress?: true
    period?: true
    startDate?: true
    endDate?: true
    isCompleted?: true
    completedAt?: true
    createdAt?: true
  }

  export type StudyGoalCountAggregateInputType = {
    id?: true
    userId?: true
    goalType?: true
    targetValue?: true
    currentProgress?: true
    period?: true
    startDate?: true
    endDate?: true
    isCompleted?: true
    completedAt?: true
    createdAt?: true
    _all?: true
  }

  export type StudyGoalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudyGoal to aggregate.
     */
    where?: StudyGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyGoals to fetch.
     */
    orderBy?: StudyGoalOrderByWithRelationInput | StudyGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudyGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudyGoals
    **/
    _count?: true | StudyGoalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudyGoalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudyGoalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudyGoalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudyGoalMaxAggregateInputType
  }

  export type GetStudyGoalAggregateType<T extends StudyGoalAggregateArgs> = {
        [P in keyof T & keyof AggregateStudyGoal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudyGoal[P]>
      : GetScalarType<T[P], AggregateStudyGoal[P]>
  }




  export type StudyGoalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyGoalWhereInput
    orderBy?: StudyGoalOrderByWithAggregationInput | StudyGoalOrderByWithAggregationInput[]
    by: StudyGoalScalarFieldEnum[] | StudyGoalScalarFieldEnum
    having?: StudyGoalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudyGoalCountAggregateInputType | true
    _avg?: StudyGoalAvgAggregateInputType
    _sum?: StudyGoalSumAggregateInputType
    _min?: StudyGoalMinAggregateInputType
    _max?: StudyGoalMaxAggregateInputType
  }

  export type StudyGoalGroupByOutputType = {
    id: string
    userId: string
    goalType: $Enums.GoalType
    targetValue: number
    currentProgress: number
    period: $Enums.GoalPeriod
    startDate: Date
    endDate: Date
    isCompleted: boolean
    completedAt: Date | null
    createdAt: Date
    _count: StudyGoalCountAggregateOutputType | null
    _avg: StudyGoalAvgAggregateOutputType | null
    _sum: StudyGoalSumAggregateOutputType | null
    _min: StudyGoalMinAggregateOutputType | null
    _max: StudyGoalMaxAggregateOutputType | null
  }

  type GetStudyGoalGroupByPayload<T extends StudyGoalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudyGoalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudyGoalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudyGoalGroupByOutputType[P]>
            : GetScalarType<T[P], StudyGoalGroupByOutputType[P]>
        }
      >
    >


  export type StudyGoalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    goalType?: boolean
    targetValue?: boolean
    currentProgress?: boolean
    period?: boolean
    startDate?: boolean
    endDate?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studyGoal"]>

  export type StudyGoalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    goalType?: boolean
    targetValue?: boolean
    currentProgress?: boolean
    period?: boolean
    startDate?: boolean
    endDate?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studyGoal"]>

  export type StudyGoalSelectScalar = {
    id?: boolean
    userId?: boolean
    goalType?: boolean
    targetValue?: boolean
    currentProgress?: boolean
    period?: boolean
    startDate?: boolean
    endDate?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    createdAt?: boolean
  }

  export type StudyGoalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StudyGoalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StudyGoalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudyGoal"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      goalType: $Enums.GoalType
      targetValue: number
      currentProgress: number
      period: $Enums.GoalPeriod
      startDate: Date
      endDate: Date
      isCompleted: boolean
      completedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["studyGoal"]>
    composites: {}
  }

  type StudyGoalGetPayload<S extends boolean | null | undefined | StudyGoalDefaultArgs> = $Result.GetResult<Prisma.$StudyGoalPayload, S>

  type StudyGoalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudyGoalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudyGoalCountAggregateInputType | true
    }

  export interface StudyGoalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudyGoal'], meta: { name: 'StudyGoal' } }
    /**
     * Find zero or one StudyGoal that matches the filter.
     * @param {StudyGoalFindUniqueArgs} args - Arguments to find a StudyGoal
     * @example
     * // Get one StudyGoal
     * const studyGoal = await prisma.studyGoal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudyGoalFindUniqueArgs>(args: SelectSubset<T, StudyGoalFindUniqueArgs<ExtArgs>>): Prisma__StudyGoalClient<$Result.GetResult<Prisma.$StudyGoalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudyGoal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudyGoalFindUniqueOrThrowArgs} args - Arguments to find a StudyGoal
     * @example
     * // Get one StudyGoal
     * const studyGoal = await prisma.studyGoal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudyGoalFindUniqueOrThrowArgs>(args: SelectSubset<T, StudyGoalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudyGoalClient<$Result.GetResult<Prisma.$StudyGoalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudyGoal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyGoalFindFirstArgs} args - Arguments to find a StudyGoal
     * @example
     * // Get one StudyGoal
     * const studyGoal = await prisma.studyGoal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudyGoalFindFirstArgs>(args?: SelectSubset<T, StudyGoalFindFirstArgs<ExtArgs>>): Prisma__StudyGoalClient<$Result.GetResult<Prisma.$StudyGoalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudyGoal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyGoalFindFirstOrThrowArgs} args - Arguments to find a StudyGoal
     * @example
     * // Get one StudyGoal
     * const studyGoal = await prisma.studyGoal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudyGoalFindFirstOrThrowArgs>(args?: SelectSubset<T, StudyGoalFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudyGoalClient<$Result.GetResult<Prisma.$StudyGoalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudyGoals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyGoalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudyGoals
     * const studyGoals = await prisma.studyGoal.findMany()
     * 
     * // Get first 10 StudyGoals
     * const studyGoals = await prisma.studyGoal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studyGoalWithIdOnly = await prisma.studyGoal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudyGoalFindManyArgs>(args?: SelectSubset<T, StudyGoalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyGoalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudyGoal.
     * @param {StudyGoalCreateArgs} args - Arguments to create a StudyGoal.
     * @example
     * // Create one StudyGoal
     * const StudyGoal = await prisma.studyGoal.create({
     *   data: {
     *     // ... data to create a StudyGoal
     *   }
     * })
     * 
     */
    create<T extends StudyGoalCreateArgs>(args: SelectSubset<T, StudyGoalCreateArgs<ExtArgs>>): Prisma__StudyGoalClient<$Result.GetResult<Prisma.$StudyGoalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudyGoals.
     * @param {StudyGoalCreateManyArgs} args - Arguments to create many StudyGoals.
     * @example
     * // Create many StudyGoals
     * const studyGoal = await prisma.studyGoal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudyGoalCreateManyArgs>(args?: SelectSubset<T, StudyGoalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudyGoals and returns the data saved in the database.
     * @param {StudyGoalCreateManyAndReturnArgs} args - Arguments to create many StudyGoals.
     * @example
     * // Create many StudyGoals
     * const studyGoal = await prisma.studyGoal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudyGoals and only return the `id`
     * const studyGoalWithIdOnly = await prisma.studyGoal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudyGoalCreateManyAndReturnArgs>(args?: SelectSubset<T, StudyGoalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyGoalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudyGoal.
     * @param {StudyGoalDeleteArgs} args - Arguments to delete one StudyGoal.
     * @example
     * // Delete one StudyGoal
     * const StudyGoal = await prisma.studyGoal.delete({
     *   where: {
     *     // ... filter to delete one StudyGoal
     *   }
     * })
     * 
     */
    delete<T extends StudyGoalDeleteArgs>(args: SelectSubset<T, StudyGoalDeleteArgs<ExtArgs>>): Prisma__StudyGoalClient<$Result.GetResult<Prisma.$StudyGoalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudyGoal.
     * @param {StudyGoalUpdateArgs} args - Arguments to update one StudyGoal.
     * @example
     * // Update one StudyGoal
     * const studyGoal = await prisma.studyGoal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudyGoalUpdateArgs>(args: SelectSubset<T, StudyGoalUpdateArgs<ExtArgs>>): Prisma__StudyGoalClient<$Result.GetResult<Prisma.$StudyGoalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudyGoals.
     * @param {StudyGoalDeleteManyArgs} args - Arguments to filter StudyGoals to delete.
     * @example
     * // Delete a few StudyGoals
     * const { count } = await prisma.studyGoal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudyGoalDeleteManyArgs>(args?: SelectSubset<T, StudyGoalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudyGoals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyGoalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudyGoals
     * const studyGoal = await prisma.studyGoal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudyGoalUpdateManyArgs>(args: SelectSubset<T, StudyGoalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudyGoal.
     * @param {StudyGoalUpsertArgs} args - Arguments to update or create a StudyGoal.
     * @example
     * // Update or create a StudyGoal
     * const studyGoal = await prisma.studyGoal.upsert({
     *   create: {
     *     // ... data to create a StudyGoal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudyGoal we want to update
     *   }
     * })
     */
    upsert<T extends StudyGoalUpsertArgs>(args: SelectSubset<T, StudyGoalUpsertArgs<ExtArgs>>): Prisma__StudyGoalClient<$Result.GetResult<Prisma.$StudyGoalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudyGoals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyGoalCountArgs} args - Arguments to filter StudyGoals to count.
     * @example
     * // Count the number of StudyGoals
     * const count = await prisma.studyGoal.count({
     *   where: {
     *     // ... the filter for the StudyGoals we want to count
     *   }
     * })
    **/
    count<T extends StudyGoalCountArgs>(
      args?: Subset<T, StudyGoalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudyGoalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudyGoal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyGoalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudyGoalAggregateArgs>(args: Subset<T, StudyGoalAggregateArgs>): Prisma.PrismaPromise<GetStudyGoalAggregateType<T>>

    /**
     * Group by StudyGoal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyGoalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudyGoalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudyGoalGroupByArgs['orderBy'] }
        : { orderBy?: StudyGoalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudyGoalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudyGoalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudyGoal model
   */
  readonly fields: StudyGoalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudyGoal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudyGoalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudyGoal model
   */ 
  interface StudyGoalFieldRefs {
    readonly id: FieldRef<"StudyGoal", 'String'>
    readonly userId: FieldRef<"StudyGoal", 'String'>
    readonly goalType: FieldRef<"StudyGoal", 'GoalType'>
    readonly targetValue: FieldRef<"StudyGoal", 'Int'>
    readonly currentProgress: FieldRef<"StudyGoal", 'Int'>
    readonly period: FieldRef<"StudyGoal", 'GoalPeriod'>
    readonly startDate: FieldRef<"StudyGoal", 'DateTime'>
    readonly endDate: FieldRef<"StudyGoal", 'DateTime'>
    readonly isCompleted: FieldRef<"StudyGoal", 'Boolean'>
    readonly completedAt: FieldRef<"StudyGoal", 'DateTime'>
    readonly createdAt: FieldRef<"StudyGoal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudyGoal findUnique
   */
  export type StudyGoalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGoal
     */
    select?: StudyGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGoalInclude<ExtArgs> | null
    /**
     * Filter, which StudyGoal to fetch.
     */
    where: StudyGoalWhereUniqueInput
  }

  /**
   * StudyGoal findUniqueOrThrow
   */
  export type StudyGoalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGoal
     */
    select?: StudyGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGoalInclude<ExtArgs> | null
    /**
     * Filter, which StudyGoal to fetch.
     */
    where: StudyGoalWhereUniqueInput
  }

  /**
   * StudyGoal findFirst
   */
  export type StudyGoalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGoal
     */
    select?: StudyGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGoalInclude<ExtArgs> | null
    /**
     * Filter, which StudyGoal to fetch.
     */
    where?: StudyGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyGoals to fetch.
     */
    orderBy?: StudyGoalOrderByWithRelationInput | StudyGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudyGoals.
     */
    cursor?: StudyGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudyGoals.
     */
    distinct?: StudyGoalScalarFieldEnum | StudyGoalScalarFieldEnum[]
  }

  /**
   * StudyGoal findFirstOrThrow
   */
  export type StudyGoalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGoal
     */
    select?: StudyGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGoalInclude<ExtArgs> | null
    /**
     * Filter, which StudyGoal to fetch.
     */
    where?: StudyGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyGoals to fetch.
     */
    orderBy?: StudyGoalOrderByWithRelationInput | StudyGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudyGoals.
     */
    cursor?: StudyGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyGoals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudyGoals.
     */
    distinct?: StudyGoalScalarFieldEnum | StudyGoalScalarFieldEnum[]
  }

  /**
   * StudyGoal findMany
   */
  export type StudyGoalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGoal
     */
    select?: StudyGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGoalInclude<ExtArgs> | null
    /**
     * Filter, which StudyGoals to fetch.
     */
    where?: StudyGoalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyGoals to fetch.
     */
    orderBy?: StudyGoalOrderByWithRelationInput | StudyGoalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudyGoals.
     */
    cursor?: StudyGoalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyGoals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyGoals.
     */
    skip?: number
    distinct?: StudyGoalScalarFieldEnum | StudyGoalScalarFieldEnum[]
  }

  /**
   * StudyGoal create
   */
  export type StudyGoalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGoal
     */
    select?: StudyGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGoalInclude<ExtArgs> | null
    /**
     * The data needed to create a StudyGoal.
     */
    data: XOR<StudyGoalCreateInput, StudyGoalUncheckedCreateInput>
  }

  /**
   * StudyGoal createMany
   */
  export type StudyGoalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudyGoals.
     */
    data: StudyGoalCreateManyInput | StudyGoalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudyGoal createManyAndReturn
   */
  export type StudyGoalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGoal
     */
    select?: StudyGoalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudyGoals.
     */
    data: StudyGoalCreateManyInput | StudyGoalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGoalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudyGoal update
   */
  export type StudyGoalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGoal
     */
    select?: StudyGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGoalInclude<ExtArgs> | null
    /**
     * The data needed to update a StudyGoal.
     */
    data: XOR<StudyGoalUpdateInput, StudyGoalUncheckedUpdateInput>
    /**
     * Choose, which StudyGoal to update.
     */
    where: StudyGoalWhereUniqueInput
  }

  /**
   * StudyGoal updateMany
   */
  export type StudyGoalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudyGoals.
     */
    data: XOR<StudyGoalUpdateManyMutationInput, StudyGoalUncheckedUpdateManyInput>
    /**
     * Filter which StudyGoals to update
     */
    where?: StudyGoalWhereInput
  }

  /**
   * StudyGoal upsert
   */
  export type StudyGoalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGoal
     */
    select?: StudyGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGoalInclude<ExtArgs> | null
    /**
     * The filter to search for the StudyGoal to update in case it exists.
     */
    where: StudyGoalWhereUniqueInput
    /**
     * In case the StudyGoal found by the `where` argument doesn't exist, create a new StudyGoal with this data.
     */
    create: XOR<StudyGoalCreateInput, StudyGoalUncheckedCreateInput>
    /**
     * In case the StudyGoal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudyGoalUpdateInput, StudyGoalUncheckedUpdateInput>
  }

  /**
   * StudyGoal delete
   */
  export type StudyGoalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGoal
     */
    select?: StudyGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGoalInclude<ExtArgs> | null
    /**
     * Filter which StudyGoal to delete.
     */
    where: StudyGoalWhereUniqueInput
  }

  /**
   * StudyGoal deleteMany
   */
  export type StudyGoalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudyGoals to delete
     */
    where?: StudyGoalWhereInput
  }

  /**
   * StudyGoal without action
   */
  export type StudyGoalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGoal
     */
    select?: StudyGoalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGoalInclude<ExtArgs> | null
  }


  /**
   * Model MissionAnalytics
   */

  export type AggregateMissionAnalytics = {
    _count: MissionAnalyticsCountAggregateOutputType | null
    _avg: MissionAnalyticsAvgAggregateOutputType | null
    _sum: MissionAnalyticsSumAggregateOutputType | null
    _min: MissionAnalyticsMinAggregateOutputType | null
    _max: MissionAnalyticsMaxAggregateOutputType | null
  }

  export type MissionAnalyticsAvgAggregateOutputType = {
    missionsGenerated: number | null
    missionsCompleted: number | null
    missionsSkipped: number | null
    avgCompletionRate: number | null
    avgTimeAccuracy: number | null
    avgDifficultyRating: number | null
    avgSuccessScore: number | null
  }

  export type MissionAnalyticsSumAggregateOutputType = {
    missionsGenerated: number | null
    missionsCompleted: number | null
    missionsSkipped: number | null
    avgCompletionRate: number | null
    avgTimeAccuracy: number | null
    avgDifficultyRating: number | null
    avgSuccessScore: number | null
  }

  export type MissionAnalyticsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    period: $Enums.AnalyticsPeriod | null
    missionsGenerated: number | null
    missionsCompleted: number | null
    missionsSkipped: number | null
    avgCompletionRate: number | null
    avgTimeAccuracy: number | null
    avgDifficultyRating: number | null
    avgSuccessScore: number | null
    createdAt: Date | null
  }

  export type MissionAnalyticsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    date: Date | null
    period: $Enums.AnalyticsPeriod | null
    missionsGenerated: number | null
    missionsCompleted: number | null
    missionsSkipped: number | null
    avgCompletionRate: number | null
    avgTimeAccuracy: number | null
    avgDifficultyRating: number | null
    avgSuccessScore: number | null
    createdAt: Date | null
  }

  export type MissionAnalyticsCountAggregateOutputType = {
    id: number
    userId: number
    date: number
    period: number
    missionsGenerated: number
    missionsCompleted: number
    missionsSkipped: number
    avgCompletionRate: number
    avgTimeAccuracy: number
    avgDifficultyRating: number
    avgSuccessScore: number
    createdAt: number
    _all: number
  }


  export type MissionAnalyticsAvgAggregateInputType = {
    missionsGenerated?: true
    missionsCompleted?: true
    missionsSkipped?: true
    avgCompletionRate?: true
    avgTimeAccuracy?: true
    avgDifficultyRating?: true
    avgSuccessScore?: true
  }

  export type MissionAnalyticsSumAggregateInputType = {
    missionsGenerated?: true
    missionsCompleted?: true
    missionsSkipped?: true
    avgCompletionRate?: true
    avgTimeAccuracy?: true
    avgDifficultyRating?: true
    avgSuccessScore?: true
  }

  export type MissionAnalyticsMinAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    period?: true
    missionsGenerated?: true
    missionsCompleted?: true
    missionsSkipped?: true
    avgCompletionRate?: true
    avgTimeAccuracy?: true
    avgDifficultyRating?: true
    avgSuccessScore?: true
    createdAt?: true
  }

  export type MissionAnalyticsMaxAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    period?: true
    missionsGenerated?: true
    missionsCompleted?: true
    missionsSkipped?: true
    avgCompletionRate?: true
    avgTimeAccuracy?: true
    avgDifficultyRating?: true
    avgSuccessScore?: true
    createdAt?: true
  }

  export type MissionAnalyticsCountAggregateInputType = {
    id?: true
    userId?: true
    date?: true
    period?: true
    missionsGenerated?: true
    missionsCompleted?: true
    missionsSkipped?: true
    avgCompletionRate?: true
    avgTimeAccuracy?: true
    avgDifficultyRating?: true
    avgSuccessScore?: true
    createdAt?: true
    _all?: true
  }

  export type MissionAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MissionAnalytics to aggregate.
     */
    where?: MissionAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MissionAnalytics to fetch.
     */
    orderBy?: MissionAnalyticsOrderByWithRelationInput | MissionAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MissionAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MissionAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MissionAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MissionAnalytics
    **/
    _count?: true | MissionAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MissionAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MissionAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MissionAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MissionAnalyticsMaxAggregateInputType
  }

  export type GetMissionAnalyticsAggregateType<T extends MissionAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateMissionAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMissionAnalytics[P]>
      : GetScalarType<T[P], AggregateMissionAnalytics[P]>
  }




  export type MissionAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MissionAnalyticsWhereInput
    orderBy?: MissionAnalyticsOrderByWithAggregationInput | MissionAnalyticsOrderByWithAggregationInput[]
    by: MissionAnalyticsScalarFieldEnum[] | MissionAnalyticsScalarFieldEnum
    having?: MissionAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MissionAnalyticsCountAggregateInputType | true
    _avg?: MissionAnalyticsAvgAggregateInputType
    _sum?: MissionAnalyticsSumAggregateInputType
    _min?: MissionAnalyticsMinAggregateInputType
    _max?: MissionAnalyticsMaxAggregateInputType
  }

  export type MissionAnalyticsGroupByOutputType = {
    id: string
    userId: string
    date: Date
    period: $Enums.AnalyticsPeriod
    missionsGenerated: number
    missionsCompleted: number
    missionsSkipped: number
    avgCompletionRate: number
    avgTimeAccuracy: number
    avgDifficultyRating: number
    avgSuccessScore: number
    createdAt: Date
    _count: MissionAnalyticsCountAggregateOutputType | null
    _avg: MissionAnalyticsAvgAggregateOutputType | null
    _sum: MissionAnalyticsSumAggregateOutputType | null
    _min: MissionAnalyticsMinAggregateOutputType | null
    _max: MissionAnalyticsMaxAggregateOutputType | null
  }

  type GetMissionAnalyticsGroupByPayload<T extends MissionAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MissionAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MissionAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MissionAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], MissionAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type MissionAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    period?: boolean
    missionsGenerated?: boolean
    missionsCompleted?: boolean
    missionsSkipped?: boolean
    avgCompletionRate?: boolean
    avgTimeAccuracy?: boolean
    avgDifficultyRating?: boolean
    avgSuccessScore?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["missionAnalytics"]>

  export type MissionAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    date?: boolean
    period?: boolean
    missionsGenerated?: boolean
    missionsCompleted?: boolean
    missionsSkipped?: boolean
    avgCompletionRate?: boolean
    avgTimeAccuracy?: boolean
    avgDifficultyRating?: boolean
    avgSuccessScore?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["missionAnalytics"]>

  export type MissionAnalyticsSelectScalar = {
    id?: boolean
    userId?: boolean
    date?: boolean
    period?: boolean
    missionsGenerated?: boolean
    missionsCompleted?: boolean
    missionsSkipped?: boolean
    avgCompletionRate?: boolean
    avgTimeAccuracy?: boolean
    avgDifficultyRating?: boolean
    avgSuccessScore?: boolean
    createdAt?: boolean
  }


  export type $MissionAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MissionAnalytics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      date: Date
      period: $Enums.AnalyticsPeriod
      missionsGenerated: number
      missionsCompleted: number
      missionsSkipped: number
      avgCompletionRate: number
      avgTimeAccuracy: number
      avgDifficultyRating: number
      avgSuccessScore: number
      createdAt: Date
    }, ExtArgs["result"]["missionAnalytics"]>
    composites: {}
  }

  type MissionAnalyticsGetPayload<S extends boolean | null | undefined | MissionAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$MissionAnalyticsPayload, S>

  type MissionAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MissionAnalyticsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MissionAnalyticsCountAggregateInputType | true
    }

  export interface MissionAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MissionAnalytics'], meta: { name: 'MissionAnalytics' } }
    /**
     * Find zero or one MissionAnalytics that matches the filter.
     * @param {MissionAnalyticsFindUniqueArgs} args - Arguments to find a MissionAnalytics
     * @example
     * // Get one MissionAnalytics
     * const missionAnalytics = await prisma.missionAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MissionAnalyticsFindUniqueArgs>(args: SelectSubset<T, MissionAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__MissionAnalyticsClient<$Result.GetResult<Prisma.$MissionAnalyticsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MissionAnalytics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MissionAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a MissionAnalytics
     * @example
     * // Get one MissionAnalytics
     * const missionAnalytics = await prisma.missionAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MissionAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, MissionAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MissionAnalyticsClient<$Result.GetResult<Prisma.$MissionAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MissionAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionAnalyticsFindFirstArgs} args - Arguments to find a MissionAnalytics
     * @example
     * // Get one MissionAnalytics
     * const missionAnalytics = await prisma.missionAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MissionAnalyticsFindFirstArgs>(args?: SelectSubset<T, MissionAnalyticsFindFirstArgs<ExtArgs>>): Prisma__MissionAnalyticsClient<$Result.GetResult<Prisma.$MissionAnalyticsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MissionAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionAnalyticsFindFirstOrThrowArgs} args - Arguments to find a MissionAnalytics
     * @example
     * // Get one MissionAnalytics
     * const missionAnalytics = await prisma.missionAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MissionAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, MissionAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__MissionAnalyticsClient<$Result.GetResult<Prisma.$MissionAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MissionAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MissionAnalytics
     * const missionAnalytics = await prisma.missionAnalytics.findMany()
     * 
     * // Get first 10 MissionAnalytics
     * const missionAnalytics = await prisma.missionAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const missionAnalyticsWithIdOnly = await prisma.missionAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MissionAnalyticsFindManyArgs>(args?: SelectSubset<T, MissionAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionAnalyticsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MissionAnalytics.
     * @param {MissionAnalyticsCreateArgs} args - Arguments to create a MissionAnalytics.
     * @example
     * // Create one MissionAnalytics
     * const MissionAnalytics = await prisma.missionAnalytics.create({
     *   data: {
     *     // ... data to create a MissionAnalytics
     *   }
     * })
     * 
     */
    create<T extends MissionAnalyticsCreateArgs>(args: SelectSubset<T, MissionAnalyticsCreateArgs<ExtArgs>>): Prisma__MissionAnalyticsClient<$Result.GetResult<Prisma.$MissionAnalyticsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MissionAnalytics.
     * @param {MissionAnalyticsCreateManyArgs} args - Arguments to create many MissionAnalytics.
     * @example
     * // Create many MissionAnalytics
     * const missionAnalytics = await prisma.missionAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MissionAnalyticsCreateManyArgs>(args?: SelectSubset<T, MissionAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MissionAnalytics and returns the data saved in the database.
     * @param {MissionAnalyticsCreateManyAndReturnArgs} args - Arguments to create many MissionAnalytics.
     * @example
     * // Create many MissionAnalytics
     * const missionAnalytics = await prisma.missionAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MissionAnalytics and only return the `id`
     * const missionAnalyticsWithIdOnly = await prisma.missionAnalytics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MissionAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, MissionAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionAnalyticsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MissionAnalytics.
     * @param {MissionAnalyticsDeleteArgs} args - Arguments to delete one MissionAnalytics.
     * @example
     * // Delete one MissionAnalytics
     * const MissionAnalytics = await prisma.missionAnalytics.delete({
     *   where: {
     *     // ... filter to delete one MissionAnalytics
     *   }
     * })
     * 
     */
    delete<T extends MissionAnalyticsDeleteArgs>(args: SelectSubset<T, MissionAnalyticsDeleteArgs<ExtArgs>>): Prisma__MissionAnalyticsClient<$Result.GetResult<Prisma.$MissionAnalyticsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MissionAnalytics.
     * @param {MissionAnalyticsUpdateArgs} args - Arguments to update one MissionAnalytics.
     * @example
     * // Update one MissionAnalytics
     * const missionAnalytics = await prisma.missionAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MissionAnalyticsUpdateArgs>(args: SelectSubset<T, MissionAnalyticsUpdateArgs<ExtArgs>>): Prisma__MissionAnalyticsClient<$Result.GetResult<Prisma.$MissionAnalyticsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MissionAnalytics.
     * @param {MissionAnalyticsDeleteManyArgs} args - Arguments to filter MissionAnalytics to delete.
     * @example
     * // Delete a few MissionAnalytics
     * const { count } = await prisma.missionAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MissionAnalyticsDeleteManyArgs>(args?: SelectSubset<T, MissionAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MissionAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MissionAnalytics
     * const missionAnalytics = await prisma.missionAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MissionAnalyticsUpdateManyArgs>(args: SelectSubset<T, MissionAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MissionAnalytics.
     * @param {MissionAnalyticsUpsertArgs} args - Arguments to update or create a MissionAnalytics.
     * @example
     * // Update or create a MissionAnalytics
     * const missionAnalytics = await prisma.missionAnalytics.upsert({
     *   create: {
     *     // ... data to create a MissionAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MissionAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends MissionAnalyticsUpsertArgs>(args: SelectSubset<T, MissionAnalyticsUpsertArgs<ExtArgs>>): Prisma__MissionAnalyticsClient<$Result.GetResult<Prisma.$MissionAnalyticsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MissionAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionAnalyticsCountArgs} args - Arguments to filter MissionAnalytics to count.
     * @example
     * // Count the number of MissionAnalytics
     * const count = await prisma.missionAnalytics.count({
     *   where: {
     *     // ... the filter for the MissionAnalytics we want to count
     *   }
     * })
    **/
    count<T extends MissionAnalyticsCountArgs>(
      args?: Subset<T, MissionAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MissionAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MissionAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MissionAnalyticsAggregateArgs>(args: Subset<T, MissionAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetMissionAnalyticsAggregateType<T>>

    /**
     * Group by MissionAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MissionAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MissionAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: MissionAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MissionAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMissionAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MissionAnalytics model
   */
  readonly fields: MissionAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MissionAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MissionAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MissionAnalytics model
   */ 
  interface MissionAnalyticsFieldRefs {
    readonly id: FieldRef<"MissionAnalytics", 'String'>
    readonly userId: FieldRef<"MissionAnalytics", 'String'>
    readonly date: FieldRef<"MissionAnalytics", 'DateTime'>
    readonly period: FieldRef<"MissionAnalytics", 'AnalyticsPeriod'>
    readonly missionsGenerated: FieldRef<"MissionAnalytics", 'Int'>
    readonly missionsCompleted: FieldRef<"MissionAnalytics", 'Int'>
    readonly missionsSkipped: FieldRef<"MissionAnalytics", 'Int'>
    readonly avgCompletionRate: FieldRef<"MissionAnalytics", 'Float'>
    readonly avgTimeAccuracy: FieldRef<"MissionAnalytics", 'Float'>
    readonly avgDifficultyRating: FieldRef<"MissionAnalytics", 'Float'>
    readonly avgSuccessScore: FieldRef<"MissionAnalytics", 'Float'>
    readonly createdAt: FieldRef<"MissionAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MissionAnalytics findUnique
   */
  export type MissionAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionAnalytics
     */
    select?: MissionAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which MissionAnalytics to fetch.
     */
    where: MissionAnalyticsWhereUniqueInput
  }

  /**
   * MissionAnalytics findUniqueOrThrow
   */
  export type MissionAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionAnalytics
     */
    select?: MissionAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which MissionAnalytics to fetch.
     */
    where: MissionAnalyticsWhereUniqueInput
  }

  /**
   * MissionAnalytics findFirst
   */
  export type MissionAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionAnalytics
     */
    select?: MissionAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which MissionAnalytics to fetch.
     */
    where?: MissionAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MissionAnalytics to fetch.
     */
    orderBy?: MissionAnalyticsOrderByWithRelationInput | MissionAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MissionAnalytics.
     */
    cursor?: MissionAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MissionAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MissionAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MissionAnalytics.
     */
    distinct?: MissionAnalyticsScalarFieldEnum | MissionAnalyticsScalarFieldEnum[]
  }

  /**
   * MissionAnalytics findFirstOrThrow
   */
  export type MissionAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionAnalytics
     */
    select?: MissionAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which MissionAnalytics to fetch.
     */
    where?: MissionAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MissionAnalytics to fetch.
     */
    orderBy?: MissionAnalyticsOrderByWithRelationInput | MissionAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MissionAnalytics.
     */
    cursor?: MissionAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MissionAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MissionAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MissionAnalytics.
     */
    distinct?: MissionAnalyticsScalarFieldEnum | MissionAnalyticsScalarFieldEnum[]
  }

  /**
   * MissionAnalytics findMany
   */
  export type MissionAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionAnalytics
     */
    select?: MissionAnalyticsSelect<ExtArgs> | null
    /**
     * Filter, which MissionAnalytics to fetch.
     */
    where?: MissionAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MissionAnalytics to fetch.
     */
    orderBy?: MissionAnalyticsOrderByWithRelationInput | MissionAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MissionAnalytics.
     */
    cursor?: MissionAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MissionAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MissionAnalytics.
     */
    skip?: number
    distinct?: MissionAnalyticsScalarFieldEnum | MissionAnalyticsScalarFieldEnum[]
  }

  /**
   * MissionAnalytics create
   */
  export type MissionAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionAnalytics
     */
    select?: MissionAnalyticsSelect<ExtArgs> | null
    /**
     * The data needed to create a MissionAnalytics.
     */
    data: XOR<MissionAnalyticsCreateInput, MissionAnalyticsUncheckedCreateInput>
  }

  /**
   * MissionAnalytics createMany
   */
  export type MissionAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MissionAnalytics.
     */
    data: MissionAnalyticsCreateManyInput | MissionAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MissionAnalytics createManyAndReturn
   */
  export type MissionAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionAnalytics
     */
    select?: MissionAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MissionAnalytics.
     */
    data: MissionAnalyticsCreateManyInput | MissionAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MissionAnalytics update
   */
  export type MissionAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionAnalytics
     */
    select?: MissionAnalyticsSelect<ExtArgs> | null
    /**
     * The data needed to update a MissionAnalytics.
     */
    data: XOR<MissionAnalyticsUpdateInput, MissionAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which MissionAnalytics to update.
     */
    where: MissionAnalyticsWhereUniqueInput
  }

  /**
   * MissionAnalytics updateMany
   */
  export type MissionAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MissionAnalytics.
     */
    data: XOR<MissionAnalyticsUpdateManyMutationInput, MissionAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which MissionAnalytics to update
     */
    where?: MissionAnalyticsWhereInput
  }

  /**
   * MissionAnalytics upsert
   */
  export type MissionAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionAnalytics
     */
    select?: MissionAnalyticsSelect<ExtArgs> | null
    /**
     * The filter to search for the MissionAnalytics to update in case it exists.
     */
    where: MissionAnalyticsWhereUniqueInput
    /**
     * In case the MissionAnalytics found by the `where` argument doesn't exist, create a new MissionAnalytics with this data.
     */
    create: XOR<MissionAnalyticsCreateInput, MissionAnalyticsUncheckedCreateInput>
    /**
     * In case the MissionAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MissionAnalyticsUpdateInput, MissionAnalyticsUncheckedUpdateInput>
  }

  /**
   * MissionAnalytics delete
   */
  export type MissionAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionAnalytics
     */
    select?: MissionAnalyticsSelect<ExtArgs> | null
    /**
     * Filter which MissionAnalytics to delete.
     */
    where: MissionAnalyticsWhereUniqueInput
  }

  /**
   * MissionAnalytics deleteMany
   */
  export type MissionAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MissionAnalytics to delete
     */
    where?: MissionAnalyticsWhereInput
  }

  /**
   * MissionAnalytics without action
   */
  export type MissionAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionAnalytics
     */
    select?: MissionAnalyticsSelect<ExtArgs> | null
  }


  /**
   * Model MissionFeedback
   */

  export type AggregateMissionFeedback = {
    _count: MissionFeedbackCountAggregateOutputType | null
    _avg: MissionFeedbackAvgAggregateOutputType | null
    _sum: MissionFeedbackSumAggregateOutputType | null
    _min: MissionFeedbackMinAggregateOutputType | null
    _max: MissionFeedbackMaxAggregateOutputType | null
  }

  export type MissionFeedbackAvgAggregateOutputType = {
    helpfulnessRating: number | null
    relevanceScore: number | null
  }

  export type MissionFeedbackSumAggregateOutputType = {
    helpfulnessRating: number | null
    relevanceScore: number | null
  }

  export type MissionFeedbackMinAggregateOutputType = {
    id: string | null
    userId: string | null
    missionId: string | null
    helpfulnessRating: number | null
    relevanceScore: number | null
    paceRating: $Enums.PaceRating | null
    improvementSuggestions: string | null
    submittedAt: Date | null
  }

  export type MissionFeedbackMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    missionId: string | null
    helpfulnessRating: number | null
    relevanceScore: number | null
    paceRating: $Enums.PaceRating | null
    improvementSuggestions: string | null
    submittedAt: Date | null
  }

  export type MissionFeedbackCountAggregateOutputType = {
    id: number
    userId: number
    missionId: number
    helpfulnessRating: number
    relevanceScore: number
    paceRating: number
    improvementSuggestions: number
    submittedAt: number
    _all: number
  }


  export type MissionFeedbackAvgAggregateInputType = {
    helpfulnessRating?: true
    relevanceScore?: true
  }

  export type MissionFeedbackSumAggregateInputType = {
    helpfulnessRating?: true
    relevanceScore?: true
  }

  export type MissionFeedbackMinAggregateInputType = {
    id?: true
    userId?: true
    missionId?: true
    helpfulnessRating?: true
    relevanceScore?: true
    paceRating?: true
    improvementSuggestions?: true
    submittedAt?: true
  }

  export type MissionFeedbackMaxAggregateInputType = {
    id?: true
    userId?: true
    missionId?: true
    helpfulnessRating?: true
    relevanceScore?: true
    paceRating?: true
    improvementSuggestions?: true
    submittedAt?: true
  }

  export type MissionFeedbackCountAggregateInputType = {
    id?: true
    userId?: true
    missionId?: true
    helpfulnessRating?: true
    relevanceScore?: true
    paceRating?: true
    improvementSuggestions?: true
    submittedAt?: true
    _all?: true
  }

  export type MissionFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MissionFeedback to aggregate.
     */
    where?: MissionFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MissionFeedbacks to fetch.
     */
    orderBy?: MissionFeedbackOrderByWithRelationInput | MissionFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MissionFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MissionFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MissionFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MissionFeedbacks
    **/
    _count?: true | MissionFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MissionFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MissionFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MissionFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MissionFeedbackMaxAggregateInputType
  }

  export type GetMissionFeedbackAggregateType<T extends MissionFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateMissionFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMissionFeedback[P]>
      : GetScalarType<T[P], AggregateMissionFeedback[P]>
  }




  export type MissionFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MissionFeedbackWhereInput
    orderBy?: MissionFeedbackOrderByWithAggregationInput | MissionFeedbackOrderByWithAggregationInput[]
    by: MissionFeedbackScalarFieldEnum[] | MissionFeedbackScalarFieldEnum
    having?: MissionFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MissionFeedbackCountAggregateInputType | true
    _avg?: MissionFeedbackAvgAggregateInputType
    _sum?: MissionFeedbackSumAggregateInputType
    _min?: MissionFeedbackMinAggregateInputType
    _max?: MissionFeedbackMaxAggregateInputType
  }

  export type MissionFeedbackGroupByOutputType = {
    id: string
    userId: string
    missionId: string
    helpfulnessRating: number
    relevanceScore: number
    paceRating: $Enums.PaceRating
    improvementSuggestions: string | null
    submittedAt: Date
    _count: MissionFeedbackCountAggregateOutputType | null
    _avg: MissionFeedbackAvgAggregateOutputType | null
    _sum: MissionFeedbackSumAggregateOutputType | null
    _min: MissionFeedbackMinAggregateOutputType | null
    _max: MissionFeedbackMaxAggregateOutputType | null
  }

  type GetMissionFeedbackGroupByPayload<T extends MissionFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MissionFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MissionFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MissionFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], MissionFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type MissionFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    missionId?: boolean
    helpfulnessRating?: boolean
    relevanceScore?: boolean
    paceRating?: boolean
    improvementSuggestions?: boolean
    submittedAt?: boolean
    mission?: boolean | MissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["missionFeedback"]>

  export type MissionFeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    missionId?: boolean
    helpfulnessRating?: boolean
    relevanceScore?: boolean
    paceRating?: boolean
    improvementSuggestions?: boolean
    submittedAt?: boolean
    mission?: boolean | MissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["missionFeedback"]>

  export type MissionFeedbackSelectScalar = {
    id?: boolean
    userId?: boolean
    missionId?: boolean
    helpfulnessRating?: boolean
    relevanceScore?: boolean
    paceRating?: boolean
    improvementSuggestions?: boolean
    submittedAt?: boolean
  }

  export type MissionFeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mission?: boolean | MissionDefaultArgs<ExtArgs>
  }
  export type MissionFeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mission?: boolean | MissionDefaultArgs<ExtArgs>
  }

  export type $MissionFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MissionFeedback"
    objects: {
      mission: Prisma.$MissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      missionId: string
      helpfulnessRating: number
      relevanceScore: number
      paceRating: $Enums.PaceRating
      improvementSuggestions: string | null
      submittedAt: Date
    }, ExtArgs["result"]["missionFeedback"]>
    composites: {}
  }

  type MissionFeedbackGetPayload<S extends boolean | null | undefined | MissionFeedbackDefaultArgs> = $Result.GetResult<Prisma.$MissionFeedbackPayload, S>

  type MissionFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MissionFeedbackFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MissionFeedbackCountAggregateInputType | true
    }

  export interface MissionFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MissionFeedback'], meta: { name: 'MissionFeedback' } }
    /**
     * Find zero or one MissionFeedback that matches the filter.
     * @param {MissionFeedbackFindUniqueArgs} args - Arguments to find a MissionFeedback
     * @example
     * // Get one MissionFeedback
     * const missionFeedback = await prisma.missionFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MissionFeedbackFindUniqueArgs>(args: SelectSubset<T, MissionFeedbackFindUniqueArgs<ExtArgs>>): Prisma__MissionFeedbackClient<$Result.GetResult<Prisma.$MissionFeedbackPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MissionFeedback that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MissionFeedbackFindUniqueOrThrowArgs} args - Arguments to find a MissionFeedback
     * @example
     * // Get one MissionFeedback
     * const missionFeedback = await prisma.missionFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MissionFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, MissionFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MissionFeedbackClient<$Result.GetResult<Prisma.$MissionFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MissionFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionFeedbackFindFirstArgs} args - Arguments to find a MissionFeedback
     * @example
     * // Get one MissionFeedback
     * const missionFeedback = await prisma.missionFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MissionFeedbackFindFirstArgs>(args?: SelectSubset<T, MissionFeedbackFindFirstArgs<ExtArgs>>): Prisma__MissionFeedbackClient<$Result.GetResult<Prisma.$MissionFeedbackPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MissionFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionFeedbackFindFirstOrThrowArgs} args - Arguments to find a MissionFeedback
     * @example
     * // Get one MissionFeedback
     * const missionFeedback = await prisma.missionFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MissionFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, MissionFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__MissionFeedbackClient<$Result.GetResult<Prisma.$MissionFeedbackPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MissionFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MissionFeedbacks
     * const missionFeedbacks = await prisma.missionFeedback.findMany()
     * 
     * // Get first 10 MissionFeedbacks
     * const missionFeedbacks = await prisma.missionFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const missionFeedbackWithIdOnly = await prisma.missionFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MissionFeedbackFindManyArgs>(args?: SelectSubset<T, MissionFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionFeedbackPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MissionFeedback.
     * @param {MissionFeedbackCreateArgs} args - Arguments to create a MissionFeedback.
     * @example
     * // Create one MissionFeedback
     * const MissionFeedback = await prisma.missionFeedback.create({
     *   data: {
     *     // ... data to create a MissionFeedback
     *   }
     * })
     * 
     */
    create<T extends MissionFeedbackCreateArgs>(args: SelectSubset<T, MissionFeedbackCreateArgs<ExtArgs>>): Prisma__MissionFeedbackClient<$Result.GetResult<Prisma.$MissionFeedbackPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MissionFeedbacks.
     * @param {MissionFeedbackCreateManyArgs} args - Arguments to create many MissionFeedbacks.
     * @example
     * // Create many MissionFeedbacks
     * const missionFeedback = await prisma.missionFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MissionFeedbackCreateManyArgs>(args?: SelectSubset<T, MissionFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MissionFeedbacks and returns the data saved in the database.
     * @param {MissionFeedbackCreateManyAndReturnArgs} args - Arguments to create many MissionFeedbacks.
     * @example
     * // Create many MissionFeedbacks
     * const missionFeedback = await prisma.missionFeedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MissionFeedbacks and only return the `id`
     * const missionFeedbackWithIdOnly = await prisma.missionFeedback.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MissionFeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, MissionFeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionFeedbackPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MissionFeedback.
     * @param {MissionFeedbackDeleteArgs} args - Arguments to delete one MissionFeedback.
     * @example
     * // Delete one MissionFeedback
     * const MissionFeedback = await prisma.missionFeedback.delete({
     *   where: {
     *     // ... filter to delete one MissionFeedback
     *   }
     * })
     * 
     */
    delete<T extends MissionFeedbackDeleteArgs>(args: SelectSubset<T, MissionFeedbackDeleteArgs<ExtArgs>>): Prisma__MissionFeedbackClient<$Result.GetResult<Prisma.$MissionFeedbackPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MissionFeedback.
     * @param {MissionFeedbackUpdateArgs} args - Arguments to update one MissionFeedback.
     * @example
     * // Update one MissionFeedback
     * const missionFeedback = await prisma.missionFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MissionFeedbackUpdateArgs>(args: SelectSubset<T, MissionFeedbackUpdateArgs<ExtArgs>>): Prisma__MissionFeedbackClient<$Result.GetResult<Prisma.$MissionFeedbackPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MissionFeedbacks.
     * @param {MissionFeedbackDeleteManyArgs} args - Arguments to filter MissionFeedbacks to delete.
     * @example
     * // Delete a few MissionFeedbacks
     * const { count } = await prisma.missionFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MissionFeedbackDeleteManyArgs>(args?: SelectSubset<T, MissionFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MissionFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MissionFeedbacks
     * const missionFeedback = await prisma.missionFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MissionFeedbackUpdateManyArgs>(args: SelectSubset<T, MissionFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MissionFeedback.
     * @param {MissionFeedbackUpsertArgs} args - Arguments to update or create a MissionFeedback.
     * @example
     * // Update or create a MissionFeedback
     * const missionFeedback = await prisma.missionFeedback.upsert({
     *   create: {
     *     // ... data to create a MissionFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MissionFeedback we want to update
     *   }
     * })
     */
    upsert<T extends MissionFeedbackUpsertArgs>(args: SelectSubset<T, MissionFeedbackUpsertArgs<ExtArgs>>): Prisma__MissionFeedbackClient<$Result.GetResult<Prisma.$MissionFeedbackPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MissionFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionFeedbackCountArgs} args - Arguments to filter MissionFeedbacks to count.
     * @example
     * // Count the number of MissionFeedbacks
     * const count = await prisma.missionFeedback.count({
     *   where: {
     *     // ... the filter for the MissionFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends MissionFeedbackCountArgs>(
      args?: Subset<T, MissionFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MissionFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MissionFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MissionFeedbackAggregateArgs>(args: Subset<T, MissionFeedbackAggregateArgs>): Prisma.PrismaPromise<GetMissionFeedbackAggregateType<T>>

    /**
     * Group by MissionFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MissionFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MissionFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: MissionFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MissionFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMissionFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MissionFeedback model
   */
  readonly fields: MissionFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MissionFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MissionFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mission<T extends MissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MissionDefaultArgs<ExtArgs>>): Prisma__MissionClient<$Result.GetResult<Prisma.$MissionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MissionFeedback model
   */ 
  interface MissionFeedbackFieldRefs {
    readonly id: FieldRef<"MissionFeedback", 'String'>
    readonly userId: FieldRef<"MissionFeedback", 'String'>
    readonly missionId: FieldRef<"MissionFeedback", 'String'>
    readonly helpfulnessRating: FieldRef<"MissionFeedback", 'Int'>
    readonly relevanceScore: FieldRef<"MissionFeedback", 'Int'>
    readonly paceRating: FieldRef<"MissionFeedback", 'PaceRating'>
    readonly improvementSuggestions: FieldRef<"MissionFeedback", 'String'>
    readonly submittedAt: FieldRef<"MissionFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MissionFeedback findUnique
   */
  export type MissionFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionFeedback
     */
    select?: MissionFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which MissionFeedback to fetch.
     */
    where: MissionFeedbackWhereUniqueInput
  }

  /**
   * MissionFeedback findUniqueOrThrow
   */
  export type MissionFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionFeedback
     */
    select?: MissionFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which MissionFeedback to fetch.
     */
    where: MissionFeedbackWhereUniqueInput
  }

  /**
   * MissionFeedback findFirst
   */
  export type MissionFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionFeedback
     */
    select?: MissionFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which MissionFeedback to fetch.
     */
    where?: MissionFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MissionFeedbacks to fetch.
     */
    orderBy?: MissionFeedbackOrderByWithRelationInput | MissionFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MissionFeedbacks.
     */
    cursor?: MissionFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MissionFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MissionFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MissionFeedbacks.
     */
    distinct?: MissionFeedbackScalarFieldEnum | MissionFeedbackScalarFieldEnum[]
  }

  /**
   * MissionFeedback findFirstOrThrow
   */
  export type MissionFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionFeedback
     */
    select?: MissionFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which MissionFeedback to fetch.
     */
    where?: MissionFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MissionFeedbacks to fetch.
     */
    orderBy?: MissionFeedbackOrderByWithRelationInput | MissionFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MissionFeedbacks.
     */
    cursor?: MissionFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MissionFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MissionFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MissionFeedbacks.
     */
    distinct?: MissionFeedbackScalarFieldEnum | MissionFeedbackScalarFieldEnum[]
  }

  /**
   * MissionFeedback findMany
   */
  export type MissionFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionFeedback
     */
    select?: MissionFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which MissionFeedbacks to fetch.
     */
    where?: MissionFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MissionFeedbacks to fetch.
     */
    orderBy?: MissionFeedbackOrderByWithRelationInput | MissionFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MissionFeedbacks.
     */
    cursor?: MissionFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MissionFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MissionFeedbacks.
     */
    skip?: number
    distinct?: MissionFeedbackScalarFieldEnum | MissionFeedbackScalarFieldEnum[]
  }

  /**
   * MissionFeedback create
   */
  export type MissionFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionFeedback
     */
    select?: MissionFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a MissionFeedback.
     */
    data: XOR<MissionFeedbackCreateInput, MissionFeedbackUncheckedCreateInput>
  }

  /**
   * MissionFeedback createMany
   */
  export type MissionFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MissionFeedbacks.
     */
    data: MissionFeedbackCreateManyInput | MissionFeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MissionFeedback createManyAndReturn
   */
  export type MissionFeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionFeedback
     */
    select?: MissionFeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MissionFeedbacks.
     */
    data: MissionFeedbackCreateManyInput | MissionFeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionFeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MissionFeedback update
   */
  export type MissionFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionFeedback
     */
    select?: MissionFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a MissionFeedback.
     */
    data: XOR<MissionFeedbackUpdateInput, MissionFeedbackUncheckedUpdateInput>
    /**
     * Choose, which MissionFeedback to update.
     */
    where: MissionFeedbackWhereUniqueInput
  }

  /**
   * MissionFeedback updateMany
   */
  export type MissionFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MissionFeedbacks.
     */
    data: XOR<MissionFeedbackUpdateManyMutationInput, MissionFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which MissionFeedbacks to update
     */
    where?: MissionFeedbackWhereInput
  }

  /**
   * MissionFeedback upsert
   */
  export type MissionFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionFeedback
     */
    select?: MissionFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionFeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the MissionFeedback to update in case it exists.
     */
    where: MissionFeedbackWhereUniqueInput
    /**
     * In case the MissionFeedback found by the `where` argument doesn't exist, create a new MissionFeedback with this data.
     */
    create: XOR<MissionFeedbackCreateInput, MissionFeedbackUncheckedCreateInput>
    /**
     * In case the MissionFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MissionFeedbackUpdateInput, MissionFeedbackUncheckedUpdateInput>
  }

  /**
   * MissionFeedback delete
   */
  export type MissionFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionFeedback
     */
    select?: MissionFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionFeedbackInclude<ExtArgs> | null
    /**
     * Filter which MissionFeedback to delete.
     */
    where: MissionFeedbackWhereUniqueInput
  }

  /**
   * MissionFeedback deleteMany
   */
  export type MissionFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MissionFeedbacks to delete
     */
    where?: MissionFeedbackWhereInput
  }

  /**
   * MissionFeedback without action
   */
  export type MissionFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionFeedback
     */
    select?: MissionFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionFeedbackInclude<ExtArgs> | null
  }


  /**
   * Model MissionStreak
   */

  export type AggregateMissionStreak = {
    _count: MissionStreakCountAggregateOutputType | null
    _avg: MissionStreakAvgAggregateOutputType | null
    _sum: MissionStreakSumAggregateOutputType | null
    _min: MissionStreakMinAggregateOutputType | null
    _max: MissionStreakMaxAggregateOutputType | null
  }

  export type MissionStreakAvgAggregateOutputType = {
    currentStreak: number | null
    longestStreak: number | null
  }

  export type MissionStreakSumAggregateOutputType = {
    currentStreak: number | null
    longestStreak: number | null
  }

  export type MissionStreakMinAggregateOutputType = {
    id: string | null
    userId: string | null
    currentStreak: number | null
    longestStreak: number | null
    lastCompletedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MissionStreakMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    currentStreak: number | null
    longestStreak: number | null
    lastCompletedDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MissionStreakCountAggregateOutputType = {
    id: number
    userId: number
    currentStreak: number
    longestStreak: number
    lastCompletedDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MissionStreakAvgAggregateInputType = {
    currentStreak?: true
    longestStreak?: true
  }

  export type MissionStreakSumAggregateInputType = {
    currentStreak?: true
    longestStreak?: true
  }

  export type MissionStreakMinAggregateInputType = {
    id?: true
    userId?: true
    currentStreak?: true
    longestStreak?: true
    lastCompletedDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MissionStreakMaxAggregateInputType = {
    id?: true
    userId?: true
    currentStreak?: true
    longestStreak?: true
    lastCompletedDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MissionStreakCountAggregateInputType = {
    id?: true
    userId?: true
    currentStreak?: true
    longestStreak?: true
    lastCompletedDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MissionStreakAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MissionStreak to aggregate.
     */
    where?: MissionStreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MissionStreaks to fetch.
     */
    orderBy?: MissionStreakOrderByWithRelationInput | MissionStreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MissionStreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MissionStreaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MissionStreaks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MissionStreaks
    **/
    _count?: true | MissionStreakCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MissionStreakAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MissionStreakSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MissionStreakMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MissionStreakMaxAggregateInputType
  }

  export type GetMissionStreakAggregateType<T extends MissionStreakAggregateArgs> = {
        [P in keyof T & keyof AggregateMissionStreak]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMissionStreak[P]>
      : GetScalarType<T[P], AggregateMissionStreak[P]>
  }




  export type MissionStreakGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MissionStreakWhereInput
    orderBy?: MissionStreakOrderByWithAggregationInput | MissionStreakOrderByWithAggregationInput[]
    by: MissionStreakScalarFieldEnum[] | MissionStreakScalarFieldEnum
    having?: MissionStreakScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MissionStreakCountAggregateInputType | true
    _avg?: MissionStreakAvgAggregateInputType
    _sum?: MissionStreakSumAggregateInputType
    _min?: MissionStreakMinAggregateInputType
    _max?: MissionStreakMaxAggregateInputType
  }

  export type MissionStreakGroupByOutputType = {
    id: string
    userId: string
    currentStreak: number
    longestStreak: number
    lastCompletedDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MissionStreakCountAggregateOutputType | null
    _avg: MissionStreakAvgAggregateOutputType | null
    _sum: MissionStreakSumAggregateOutputType | null
    _min: MissionStreakMinAggregateOutputType | null
    _max: MissionStreakMaxAggregateOutputType | null
  }

  type GetMissionStreakGroupByPayload<T extends MissionStreakGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MissionStreakGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MissionStreakGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MissionStreakGroupByOutputType[P]>
            : GetScalarType<T[P], MissionStreakGroupByOutputType[P]>
        }
      >
    >


  export type MissionStreakSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    lastCompletedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["missionStreak"]>

  export type MissionStreakSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    lastCompletedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["missionStreak"]>

  export type MissionStreakSelectScalar = {
    id?: boolean
    userId?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    lastCompletedDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MissionStreakInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MissionStreakIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MissionStreakPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MissionStreak"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      currentStreak: number
      longestStreak: number
      lastCompletedDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["missionStreak"]>
    composites: {}
  }

  type MissionStreakGetPayload<S extends boolean | null | undefined | MissionStreakDefaultArgs> = $Result.GetResult<Prisma.$MissionStreakPayload, S>

  type MissionStreakCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MissionStreakFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MissionStreakCountAggregateInputType | true
    }

  export interface MissionStreakDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MissionStreak'], meta: { name: 'MissionStreak' } }
    /**
     * Find zero or one MissionStreak that matches the filter.
     * @param {MissionStreakFindUniqueArgs} args - Arguments to find a MissionStreak
     * @example
     * // Get one MissionStreak
     * const missionStreak = await prisma.missionStreak.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MissionStreakFindUniqueArgs>(args: SelectSubset<T, MissionStreakFindUniqueArgs<ExtArgs>>): Prisma__MissionStreakClient<$Result.GetResult<Prisma.$MissionStreakPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MissionStreak that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MissionStreakFindUniqueOrThrowArgs} args - Arguments to find a MissionStreak
     * @example
     * // Get one MissionStreak
     * const missionStreak = await prisma.missionStreak.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MissionStreakFindUniqueOrThrowArgs>(args: SelectSubset<T, MissionStreakFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MissionStreakClient<$Result.GetResult<Prisma.$MissionStreakPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MissionStreak that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionStreakFindFirstArgs} args - Arguments to find a MissionStreak
     * @example
     * // Get one MissionStreak
     * const missionStreak = await prisma.missionStreak.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MissionStreakFindFirstArgs>(args?: SelectSubset<T, MissionStreakFindFirstArgs<ExtArgs>>): Prisma__MissionStreakClient<$Result.GetResult<Prisma.$MissionStreakPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MissionStreak that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionStreakFindFirstOrThrowArgs} args - Arguments to find a MissionStreak
     * @example
     * // Get one MissionStreak
     * const missionStreak = await prisma.missionStreak.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MissionStreakFindFirstOrThrowArgs>(args?: SelectSubset<T, MissionStreakFindFirstOrThrowArgs<ExtArgs>>): Prisma__MissionStreakClient<$Result.GetResult<Prisma.$MissionStreakPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MissionStreaks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionStreakFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MissionStreaks
     * const missionStreaks = await prisma.missionStreak.findMany()
     * 
     * // Get first 10 MissionStreaks
     * const missionStreaks = await prisma.missionStreak.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const missionStreakWithIdOnly = await prisma.missionStreak.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MissionStreakFindManyArgs>(args?: SelectSubset<T, MissionStreakFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionStreakPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MissionStreak.
     * @param {MissionStreakCreateArgs} args - Arguments to create a MissionStreak.
     * @example
     * // Create one MissionStreak
     * const MissionStreak = await prisma.missionStreak.create({
     *   data: {
     *     // ... data to create a MissionStreak
     *   }
     * })
     * 
     */
    create<T extends MissionStreakCreateArgs>(args: SelectSubset<T, MissionStreakCreateArgs<ExtArgs>>): Prisma__MissionStreakClient<$Result.GetResult<Prisma.$MissionStreakPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MissionStreaks.
     * @param {MissionStreakCreateManyArgs} args - Arguments to create many MissionStreaks.
     * @example
     * // Create many MissionStreaks
     * const missionStreak = await prisma.missionStreak.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MissionStreakCreateManyArgs>(args?: SelectSubset<T, MissionStreakCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MissionStreaks and returns the data saved in the database.
     * @param {MissionStreakCreateManyAndReturnArgs} args - Arguments to create many MissionStreaks.
     * @example
     * // Create many MissionStreaks
     * const missionStreak = await prisma.missionStreak.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MissionStreaks and only return the `id`
     * const missionStreakWithIdOnly = await prisma.missionStreak.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MissionStreakCreateManyAndReturnArgs>(args?: SelectSubset<T, MissionStreakCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionStreakPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MissionStreak.
     * @param {MissionStreakDeleteArgs} args - Arguments to delete one MissionStreak.
     * @example
     * // Delete one MissionStreak
     * const MissionStreak = await prisma.missionStreak.delete({
     *   where: {
     *     // ... filter to delete one MissionStreak
     *   }
     * })
     * 
     */
    delete<T extends MissionStreakDeleteArgs>(args: SelectSubset<T, MissionStreakDeleteArgs<ExtArgs>>): Prisma__MissionStreakClient<$Result.GetResult<Prisma.$MissionStreakPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MissionStreak.
     * @param {MissionStreakUpdateArgs} args - Arguments to update one MissionStreak.
     * @example
     * // Update one MissionStreak
     * const missionStreak = await prisma.missionStreak.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MissionStreakUpdateArgs>(args: SelectSubset<T, MissionStreakUpdateArgs<ExtArgs>>): Prisma__MissionStreakClient<$Result.GetResult<Prisma.$MissionStreakPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MissionStreaks.
     * @param {MissionStreakDeleteManyArgs} args - Arguments to filter MissionStreaks to delete.
     * @example
     * // Delete a few MissionStreaks
     * const { count } = await prisma.missionStreak.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MissionStreakDeleteManyArgs>(args?: SelectSubset<T, MissionStreakDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MissionStreaks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionStreakUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MissionStreaks
     * const missionStreak = await prisma.missionStreak.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MissionStreakUpdateManyArgs>(args: SelectSubset<T, MissionStreakUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MissionStreak.
     * @param {MissionStreakUpsertArgs} args - Arguments to update or create a MissionStreak.
     * @example
     * // Update or create a MissionStreak
     * const missionStreak = await prisma.missionStreak.upsert({
     *   create: {
     *     // ... data to create a MissionStreak
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MissionStreak we want to update
     *   }
     * })
     */
    upsert<T extends MissionStreakUpsertArgs>(args: SelectSubset<T, MissionStreakUpsertArgs<ExtArgs>>): Prisma__MissionStreakClient<$Result.GetResult<Prisma.$MissionStreakPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MissionStreaks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionStreakCountArgs} args - Arguments to filter MissionStreaks to count.
     * @example
     * // Count the number of MissionStreaks
     * const count = await prisma.missionStreak.count({
     *   where: {
     *     // ... the filter for the MissionStreaks we want to count
     *   }
     * })
    **/
    count<T extends MissionStreakCountArgs>(
      args?: Subset<T, MissionStreakCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MissionStreakCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MissionStreak.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionStreakAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MissionStreakAggregateArgs>(args: Subset<T, MissionStreakAggregateArgs>): Prisma.PrismaPromise<GetMissionStreakAggregateType<T>>

    /**
     * Group by MissionStreak.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionStreakGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MissionStreakGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MissionStreakGroupByArgs['orderBy'] }
        : { orderBy?: MissionStreakGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MissionStreakGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMissionStreakGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MissionStreak model
   */
  readonly fields: MissionStreakFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MissionStreak.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MissionStreakClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MissionStreak model
   */ 
  interface MissionStreakFieldRefs {
    readonly id: FieldRef<"MissionStreak", 'String'>
    readonly userId: FieldRef<"MissionStreak", 'String'>
    readonly currentStreak: FieldRef<"MissionStreak", 'Int'>
    readonly longestStreak: FieldRef<"MissionStreak", 'Int'>
    readonly lastCompletedDate: FieldRef<"MissionStreak", 'DateTime'>
    readonly createdAt: FieldRef<"MissionStreak", 'DateTime'>
    readonly updatedAt: FieldRef<"MissionStreak", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MissionStreak findUnique
   */
  export type MissionStreakFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionStreak
     */
    select?: MissionStreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionStreakInclude<ExtArgs> | null
    /**
     * Filter, which MissionStreak to fetch.
     */
    where: MissionStreakWhereUniqueInput
  }

  /**
   * MissionStreak findUniqueOrThrow
   */
  export type MissionStreakFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionStreak
     */
    select?: MissionStreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionStreakInclude<ExtArgs> | null
    /**
     * Filter, which MissionStreak to fetch.
     */
    where: MissionStreakWhereUniqueInput
  }

  /**
   * MissionStreak findFirst
   */
  export type MissionStreakFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionStreak
     */
    select?: MissionStreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionStreakInclude<ExtArgs> | null
    /**
     * Filter, which MissionStreak to fetch.
     */
    where?: MissionStreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MissionStreaks to fetch.
     */
    orderBy?: MissionStreakOrderByWithRelationInput | MissionStreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MissionStreaks.
     */
    cursor?: MissionStreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MissionStreaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MissionStreaks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MissionStreaks.
     */
    distinct?: MissionStreakScalarFieldEnum | MissionStreakScalarFieldEnum[]
  }

  /**
   * MissionStreak findFirstOrThrow
   */
  export type MissionStreakFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionStreak
     */
    select?: MissionStreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionStreakInclude<ExtArgs> | null
    /**
     * Filter, which MissionStreak to fetch.
     */
    where?: MissionStreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MissionStreaks to fetch.
     */
    orderBy?: MissionStreakOrderByWithRelationInput | MissionStreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MissionStreaks.
     */
    cursor?: MissionStreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MissionStreaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MissionStreaks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MissionStreaks.
     */
    distinct?: MissionStreakScalarFieldEnum | MissionStreakScalarFieldEnum[]
  }

  /**
   * MissionStreak findMany
   */
  export type MissionStreakFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionStreak
     */
    select?: MissionStreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionStreakInclude<ExtArgs> | null
    /**
     * Filter, which MissionStreaks to fetch.
     */
    where?: MissionStreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MissionStreaks to fetch.
     */
    orderBy?: MissionStreakOrderByWithRelationInput | MissionStreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MissionStreaks.
     */
    cursor?: MissionStreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MissionStreaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MissionStreaks.
     */
    skip?: number
    distinct?: MissionStreakScalarFieldEnum | MissionStreakScalarFieldEnum[]
  }

  /**
   * MissionStreak create
   */
  export type MissionStreakCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionStreak
     */
    select?: MissionStreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionStreakInclude<ExtArgs> | null
    /**
     * The data needed to create a MissionStreak.
     */
    data: XOR<MissionStreakCreateInput, MissionStreakUncheckedCreateInput>
  }

  /**
   * MissionStreak createMany
   */
  export type MissionStreakCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MissionStreaks.
     */
    data: MissionStreakCreateManyInput | MissionStreakCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MissionStreak createManyAndReturn
   */
  export type MissionStreakCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionStreak
     */
    select?: MissionStreakSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MissionStreaks.
     */
    data: MissionStreakCreateManyInput | MissionStreakCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionStreakIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MissionStreak update
   */
  export type MissionStreakUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionStreak
     */
    select?: MissionStreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionStreakInclude<ExtArgs> | null
    /**
     * The data needed to update a MissionStreak.
     */
    data: XOR<MissionStreakUpdateInput, MissionStreakUncheckedUpdateInput>
    /**
     * Choose, which MissionStreak to update.
     */
    where: MissionStreakWhereUniqueInput
  }

  /**
   * MissionStreak updateMany
   */
  export type MissionStreakUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MissionStreaks.
     */
    data: XOR<MissionStreakUpdateManyMutationInput, MissionStreakUncheckedUpdateManyInput>
    /**
     * Filter which MissionStreaks to update
     */
    where?: MissionStreakWhereInput
  }

  /**
   * MissionStreak upsert
   */
  export type MissionStreakUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionStreak
     */
    select?: MissionStreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionStreakInclude<ExtArgs> | null
    /**
     * The filter to search for the MissionStreak to update in case it exists.
     */
    where: MissionStreakWhereUniqueInput
    /**
     * In case the MissionStreak found by the `where` argument doesn't exist, create a new MissionStreak with this data.
     */
    create: XOR<MissionStreakCreateInput, MissionStreakUncheckedCreateInput>
    /**
     * In case the MissionStreak was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MissionStreakUpdateInput, MissionStreakUncheckedUpdateInput>
  }

  /**
   * MissionStreak delete
   */
  export type MissionStreakDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionStreak
     */
    select?: MissionStreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionStreakInclude<ExtArgs> | null
    /**
     * Filter which MissionStreak to delete.
     */
    where: MissionStreakWhereUniqueInput
  }

  /**
   * MissionStreak deleteMany
   */
  export type MissionStreakDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MissionStreaks to delete
     */
    where?: MissionStreakWhereInput
  }

  /**
   * MissionStreak without action
   */
  export type MissionStreakDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionStreak
     */
    select?: MissionStreakSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionStreakInclude<ExtArgs> | null
  }


  /**
   * Model MissionReview
   */

  export type AggregateMissionReview = {
    _count: MissionReviewCountAggregateOutputType | null
    _min: MissionReviewMinAggregateOutputType | null
    _max: MissionReviewMaxAggregateOutputType | null
  }

  export type MissionReviewMinAggregateOutputType = {
    id: string | null
    userId: string | null
    period: $Enums.ReviewPeriod | null
    startDate: Date | null
    endDate: Date | null
    generatedAt: Date | null
  }

  export type MissionReviewMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    period: $Enums.ReviewPeriod | null
    startDate: Date | null
    endDate: Date | null
    generatedAt: Date | null
  }

  export type MissionReviewCountAggregateOutputType = {
    id: number
    userId: number
    period: number
    startDate: number
    endDate: number
    summary: number
    highlights: number
    insights: number
    recommendations: number
    generatedAt: number
    _all: number
  }


  export type MissionReviewMinAggregateInputType = {
    id?: true
    userId?: true
    period?: true
    startDate?: true
    endDate?: true
    generatedAt?: true
  }

  export type MissionReviewMaxAggregateInputType = {
    id?: true
    userId?: true
    period?: true
    startDate?: true
    endDate?: true
    generatedAt?: true
  }

  export type MissionReviewCountAggregateInputType = {
    id?: true
    userId?: true
    period?: true
    startDate?: true
    endDate?: true
    summary?: true
    highlights?: true
    insights?: true
    recommendations?: true
    generatedAt?: true
    _all?: true
  }

  export type MissionReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MissionReview to aggregate.
     */
    where?: MissionReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MissionReviews to fetch.
     */
    orderBy?: MissionReviewOrderByWithRelationInput | MissionReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MissionReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MissionReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MissionReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MissionReviews
    **/
    _count?: true | MissionReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MissionReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MissionReviewMaxAggregateInputType
  }

  export type GetMissionReviewAggregateType<T extends MissionReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateMissionReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMissionReview[P]>
      : GetScalarType<T[P], AggregateMissionReview[P]>
  }




  export type MissionReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MissionReviewWhereInput
    orderBy?: MissionReviewOrderByWithAggregationInput | MissionReviewOrderByWithAggregationInput[]
    by: MissionReviewScalarFieldEnum[] | MissionReviewScalarFieldEnum
    having?: MissionReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MissionReviewCountAggregateInputType | true
    _min?: MissionReviewMinAggregateInputType
    _max?: MissionReviewMaxAggregateInputType
  }

  export type MissionReviewGroupByOutputType = {
    id: string
    userId: string
    period: $Enums.ReviewPeriod
    startDate: Date
    endDate: Date
    summary: JsonValue
    highlights: JsonValue
    insights: JsonValue
    recommendations: JsonValue
    generatedAt: Date
    _count: MissionReviewCountAggregateOutputType | null
    _min: MissionReviewMinAggregateOutputType | null
    _max: MissionReviewMaxAggregateOutputType | null
  }

  type GetMissionReviewGroupByPayload<T extends MissionReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MissionReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MissionReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MissionReviewGroupByOutputType[P]>
            : GetScalarType<T[P], MissionReviewGroupByOutputType[P]>
        }
      >
    >


  export type MissionReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    period?: boolean
    startDate?: boolean
    endDate?: boolean
    summary?: boolean
    highlights?: boolean
    insights?: boolean
    recommendations?: boolean
    generatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["missionReview"]>

  export type MissionReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    period?: boolean
    startDate?: boolean
    endDate?: boolean
    summary?: boolean
    highlights?: boolean
    insights?: boolean
    recommendations?: boolean
    generatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["missionReview"]>

  export type MissionReviewSelectScalar = {
    id?: boolean
    userId?: boolean
    period?: boolean
    startDate?: boolean
    endDate?: boolean
    summary?: boolean
    highlights?: boolean
    insights?: boolean
    recommendations?: boolean
    generatedAt?: boolean
  }

  export type MissionReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MissionReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MissionReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MissionReview"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      period: $Enums.ReviewPeriod
      startDate: Date
      endDate: Date
      summary: Prisma.JsonValue
      highlights: Prisma.JsonValue
      insights: Prisma.JsonValue
      recommendations: Prisma.JsonValue
      generatedAt: Date
    }, ExtArgs["result"]["missionReview"]>
    composites: {}
  }

  type MissionReviewGetPayload<S extends boolean | null | undefined | MissionReviewDefaultArgs> = $Result.GetResult<Prisma.$MissionReviewPayload, S>

  type MissionReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MissionReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MissionReviewCountAggregateInputType | true
    }

  export interface MissionReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MissionReview'], meta: { name: 'MissionReview' } }
    /**
     * Find zero or one MissionReview that matches the filter.
     * @param {MissionReviewFindUniqueArgs} args - Arguments to find a MissionReview
     * @example
     * // Get one MissionReview
     * const missionReview = await prisma.missionReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MissionReviewFindUniqueArgs>(args: SelectSubset<T, MissionReviewFindUniqueArgs<ExtArgs>>): Prisma__MissionReviewClient<$Result.GetResult<Prisma.$MissionReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MissionReview that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MissionReviewFindUniqueOrThrowArgs} args - Arguments to find a MissionReview
     * @example
     * // Get one MissionReview
     * const missionReview = await prisma.missionReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MissionReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, MissionReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MissionReviewClient<$Result.GetResult<Prisma.$MissionReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MissionReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionReviewFindFirstArgs} args - Arguments to find a MissionReview
     * @example
     * // Get one MissionReview
     * const missionReview = await prisma.missionReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MissionReviewFindFirstArgs>(args?: SelectSubset<T, MissionReviewFindFirstArgs<ExtArgs>>): Prisma__MissionReviewClient<$Result.GetResult<Prisma.$MissionReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MissionReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionReviewFindFirstOrThrowArgs} args - Arguments to find a MissionReview
     * @example
     * // Get one MissionReview
     * const missionReview = await prisma.missionReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MissionReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, MissionReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__MissionReviewClient<$Result.GetResult<Prisma.$MissionReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MissionReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MissionReviews
     * const missionReviews = await prisma.missionReview.findMany()
     * 
     * // Get first 10 MissionReviews
     * const missionReviews = await prisma.missionReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const missionReviewWithIdOnly = await prisma.missionReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MissionReviewFindManyArgs>(args?: SelectSubset<T, MissionReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MissionReview.
     * @param {MissionReviewCreateArgs} args - Arguments to create a MissionReview.
     * @example
     * // Create one MissionReview
     * const MissionReview = await prisma.missionReview.create({
     *   data: {
     *     // ... data to create a MissionReview
     *   }
     * })
     * 
     */
    create<T extends MissionReviewCreateArgs>(args: SelectSubset<T, MissionReviewCreateArgs<ExtArgs>>): Prisma__MissionReviewClient<$Result.GetResult<Prisma.$MissionReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MissionReviews.
     * @param {MissionReviewCreateManyArgs} args - Arguments to create many MissionReviews.
     * @example
     * // Create many MissionReviews
     * const missionReview = await prisma.missionReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MissionReviewCreateManyArgs>(args?: SelectSubset<T, MissionReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MissionReviews and returns the data saved in the database.
     * @param {MissionReviewCreateManyAndReturnArgs} args - Arguments to create many MissionReviews.
     * @example
     * // Create many MissionReviews
     * const missionReview = await prisma.missionReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MissionReviews and only return the `id`
     * const missionReviewWithIdOnly = await prisma.missionReview.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MissionReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, MissionReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MissionReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MissionReview.
     * @param {MissionReviewDeleteArgs} args - Arguments to delete one MissionReview.
     * @example
     * // Delete one MissionReview
     * const MissionReview = await prisma.missionReview.delete({
     *   where: {
     *     // ... filter to delete one MissionReview
     *   }
     * })
     * 
     */
    delete<T extends MissionReviewDeleteArgs>(args: SelectSubset<T, MissionReviewDeleteArgs<ExtArgs>>): Prisma__MissionReviewClient<$Result.GetResult<Prisma.$MissionReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MissionReview.
     * @param {MissionReviewUpdateArgs} args - Arguments to update one MissionReview.
     * @example
     * // Update one MissionReview
     * const missionReview = await prisma.missionReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MissionReviewUpdateArgs>(args: SelectSubset<T, MissionReviewUpdateArgs<ExtArgs>>): Prisma__MissionReviewClient<$Result.GetResult<Prisma.$MissionReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MissionReviews.
     * @param {MissionReviewDeleteManyArgs} args - Arguments to filter MissionReviews to delete.
     * @example
     * // Delete a few MissionReviews
     * const { count } = await prisma.missionReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MissionReviewDeleteManyArgs>(args?: SelectSubset<T, MissionReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MissionReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MissionReviews
     * const missionReview = await prisma.missionReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MissionReviewUpdateManyArgs>(args: SelectSubset<T, MissionReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MissionReview.
     * @param {MissionReviewUpsertArgs} args - Arguments to update or create a MissionReview.
     * @example
     * // Update or create a MissionReview
     * const missionReview = await prisma.missionReview.upsert({
     *   create: {
     *     // ... data to create a MissionReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MissionReview we want to update
     *   }
     * })
     */
    upsert<T extends MissionReviewUpsertArgs>(args: SelectSubset<T, MissionReviewUpsertArgs<ExtArgs>>): Prisma__MissionReviewClient<$Result.GetResult<Prisma.$MissionReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MissionReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionReviewCountArgs} args - Arguments to filter MissionReviews to count.
     * @example
     * // Count the number of MissionReviews
     * const count = await prisma.missionReview.count({
     *   where: {
     *     // ... the filter for the MissionReviews we want to count
     *   }
     * })
    **/
    count<T extends MissionReviewCountArgs>(
      args?: Subset<T, MissionReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MissionReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MissionReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MissionReviewAggregateArgs>(args: Subset<T, MissionReviewAggregateArgs>): Prisma.PrismaPromise<GetMissionReviewAggregateType<T>>

    /**
     * Group by MissionReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MissionReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MissionReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MissionReviewGroupByArgs['orderBy'] }
        : { orderBy?: MissionReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MissionReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMissionReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MissionReview model
   */
  readonly fields: MissionReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MissionReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MissionReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MissionReview model
   */ 
  interface MissionReviewFieldRefs {
    readonly id: FieldRef<"MissionReview", 'String'>
    readonly userId: FieldRef<"MissionReview", 'String'>
    readonly period: FieldRef<"MissionReview", 'ReviewPeriod'>
    readonly startDate: FieldRef<"MissionReview", 'DateTime'>
    readonly endDate: FieldRef<"MissionReview", 'DateTime'>
    readonly summary: FieldRef<"MissionReview", 'Json'>
    readonly highlights: FieldRef<"MissionReview", 'Json'>
    readonly insights: FieldRef<"MissionReview", 'Json'>
    readonly recommendations: FieldRef<"MissionReview", 'Json'>
    readonly generatedAt: FieldRef<"MissionReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MissionReview findUnique
   */
  export type MissionReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionReview
     */
    select?: MissionReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionReviewInclude<ExtArgs> | null
    /**
     * Filter, which MissionReview to fetch.
     */
    where: MissionReviewWhereUniqueInput
  }

  /**
   * MissionReview findUniqueOrThrow
   */
  export type MissionReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionReview
     */
    select?: MissionReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionReviewInclude<ExtArgs> | null
    /**
     * Filter, which MissionReview to fetch.
     */
    where: MissionReviewWhereUniqueInput
  }

  /**
   * MissionReview findFirst
   */
  export type MissionReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionReview
     */
    select?: MissionReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionReviewInclude<ExtArgs> | null
    /**
     * Filter, which MissionReview to fetch.
     */
    where?: MissionReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MissionReviews to fetch.
     */
    orderBy?: MissionReviewOrderByWithRelationInput | MissionReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MissionReviews.
     */
    cursor?: MissionReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MissionReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MissionReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MissionReviews.
     */
    distinct?: MissionReviewScalarFieldEnum | MissionReviewScalarFieldEnum[]
  }

  /**
   * MissionReview findFirstOrThrow
   */
  export type MissionReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionReview
     */
    select?: MissionReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionReviewInclude<ExtArgs> | null
    /**
     * Filter, which MissionReview to fetch.
     */
    where?: MissionReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MissionReviews to fetch.
     */
    orderBy?: MissionReviewOrderByWithRelationInput | MissionReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MissionReviews.
     */
    cursor?: MissionReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MissionReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MissionReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MissionReviews.
     */
    distinct?: MissionReviewScalarFieldEnum | MissionReviewScalarFieldEnum[]
  }

  /**
   * MissionReview findMany
   */
  export type MissionReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionReview
     */
    select?: MissionReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionReviewInclude<ExtArgs> | null
    /**
     * Filter, which MissionReviews to fetch.
     */
    where?: MissionReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MissionReviews to fetch.
     */
    orderBy?: MissionReviewOrderByWithRelationInput | MissionReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MissionReviews.
     */
    cursor?: MissionReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MissionReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MissionReviews.
     */
    skip?: number
    distinct?: MissionReviewScalarFieldEnum | MissionReviewScalarFieldEnum[]
  }

  /**
   * MissionReview create
   */
  export type MissionReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionReview
     */
    select?: MissionReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a MissionReview.
     */
    data: XOR<MissionReviewCreateInput, MissionReviewUncheckedCreateInput>
  }

  /**
   * MissionReview createMany
   */
  export type MissionReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MissionReviews.
     */
    data: MissionReviewCreateManyInput | MissionReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MissionReview createManyAndReturn
   */
  export type MissionReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionReview
     */
    select?: MissionReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MissionReviews.
     */
    data: MissionReviewCreateManyInput | MissionReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MissionReview update
   */
  export type MissionReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionReview
     */
    select?: MissionReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a MissionReview.
     */
    data: XOR<MissionReviewUpdateInput, MissionReviewUncheckedUpdateInput>
    /**
     * Choose, which MissionReview to update.
     */
    where: MissionReviewWhereUniqueInput
  }

  /**
   * MissionReview updateMany
   */
  export type MissionReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MissionReviews.
     */
    data: XOR<MissionReviewUpdateManyMutationInput, MissionReviewUncheckedUpdateManyInput>
    /**
     * Filter which MissionReviews to update
     */
    where?: MissionReviewWhereInput
  }

  /**
   * MissionReview upsert
   */
  export type MissionReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionReview
     */
    select?: MissionReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the MissionReview to update in case it exists.
     */
    where: MissionReviewWhereUniqueInput
    /**
     * In case the MissionReview found by the `where` argument doesn't exist, create a new MissionReview with this data.
     */
    create: XOR<MissionReviewCreateInput, MissionReviewUncheckedCreateInput>
    /**
     * In case the MissionReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MissionReviewUpdateInput, MissionReviewUncheckedUpdateInput>
  }

  /**
   * MissionReview delete
   */
  export type MissionReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionReview
     */
    select?: MissionReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionReviewInclude<ExtArgs> | null
    /**
     * Filter which MissionReview to delete.
     */
    where: MissionReviewWhereUniqueInput
  }

  /**
   * MissionReview deleteMany
   */
  export type MissionReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MissionReviews to delete
     */
    where?: MissionReviewWhereInput
  }

  /**
   * MissionReview without action
   */
  export type MissionReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MissionReview
     */
    select?: MissionReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MissionReviewInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    defaultMissionMinutes: 'defaultMissionMinutes',
    missionDifficulty: 'missionDifficulty',
    preferredStudyTime: 'preferredStudyTime',
    autoGenerateMissions: 'autoGenerateMissions',
    performanceTrackingEnabled: 'performanceTrackingEnabled',
    includeInAnalytics: 'includeInAnalytics',
    lastMissionAdaptation: 'lastMissionAdaptation',
    behavioralAnalysisEnabled: 'behavioralAnalysisEnabled',
    learningStyleProfilingEnabled: 'learningStyleProfilingEnabled',
    shareAnonymizedPatterns: 'shareAnonymizedPatterns'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    code: 'code',
    term: 'term',
    color: 'color',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const LectureScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    title: 'title',
    fileName: 'fileName',
    fileUrl: 'fileUrl',
    fileSize: 'fileSize',
    processingStatus: 'processingStatus',
    uploadedAt: 'uploadedAt',
    processedAt: 'processedAt',
    processingProgress: 'processingProgress',
    totalPages: 'totalPages',
    processedPages: 'processedPages',
    processingStartedAt: 'processingStartedAt',
    estimatedCompletionAt: 'estimatedCompletionAt',
    weekNumber: 'weekNumber',
    topicTags: 'topicTags'
  };

  export type LectureScalarFieldEnum = (typeof LectureScalarFieldEnum)[keyof typeof LectureScalarFieldEnum]


  export const ContentChunkScalarFieldEnum: {
    id: 'id',
    lectureId: 'lectureId',
    content: 'content',
    chunkIndex: 'chunkIndex',
    pageNumber: 'pageNumber',
    createdAt: 'createdAt'
  };

  export type ContentChunkScalarFieldEnum = (typeof ContentChunkScalarFieldEnum)[keyof typeof ContentChunkScalarFieldEnum]


  export const LearningObjectiveScalarFieldEnum: {
    id: 'id',
    lectureId: 'lectureId',
    objective: 'objective',
    complexity: 'complexity',
    pageStart: 'pageStart',
    pageEnd: 'pageEnd',
    isHighYield: 'isHighYield',
    boardExamTags: 'boardExamTags',
    extractedBy: 'extractedBy',
    createdAt: 'createdAt',
    masteryLevel: 'masteryLevel',
    totalStudyTimeMs: 'totalStudyTimeMs',
    lastStudiedAt: 'lastStudiedAt',
    weaknessScore: 'weaknessScore'
  };

  export type LearningObjectiveScalarFieldEnum = (typeof LearningObjectiveScalarFieldEnum)[keyof typeof LearningObjectiveScalarFieldEnum]


  export const ObjectivePrerequisiteScalarFieldEnum: {
    id: 'id',
    objectiveId: 'objectiveId',
    prerequisiteId: 'prerequisiteId',
    strength: 'strength'
  };

  export type ObjectivePrerequisiteScalarFieldEnum = (typeof ObjectivePrerequisiteScalarFieldEnum)[keyof typeof ObjectivePrerequisiteScalarFieldEnum]


  export const MissionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    status: 'status',
    estimatedMinutes: 'estimatedMinutes',
    completedAt: 'completedAt',
    actualMinutes: 'actualMinutes',
    completedObjectivesCount: 'completedObjectivesCount',
    objectives: 'objectives',
    reviewCardCount: 'reviewCardCount',
    newContentCount: 'newContentCount',
    successScore: 'successScore',
    difficultyRating: 'difficultyRating'
  };

  export type MissionScalarFieldEnum = (typeof MissionScalarFieldEnum)[keyof typeof MissionScalarFieldEnum]


  export const CardScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    lectureId: 'lectureId',
    objectiveId: 'objectiveId',
    front: 'front',
    back: 'back',
    cardType: 'cardType',
    createdAt: 'createdAt',
    difficulty: 'difficulty',
    stability: 'stability',
    retrievability: 'retrievability',
    lastReviewedAt: 'lastReviewedAt',
    nextReviewAt: 'nextReviewAt',
    reviewCount: 'reviewCount',
    lapseCount: 'lapseCount'
  };

  export type CardScalarFieldEnum = (typeof CardScalarFieldEnum)[keyof typeof CardScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    cardId: 'cardId',
    sessionId: 'sessionId',
    rating: 'rating',
    timeSpentMs: 'timeSpentMs',
    reviewedAt: 'reviewedAt',
    difficultyBefore: 'difficultyBefore',
    stabilityBefore: 'stabilityBefore',
    difficultyAfter: 'difficultyAfter',
    stabilityAfter: 'stabilityAfter'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const StudySessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    missionId: 'missionId',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    durationMs: 'durationMs',
    reviewsCompleted: 'reviewsCompleted',
    newCardsStudied: 'newCardsStudied',
    sessionNotes: 'sessionNotes',
    currentObjectiveIndex: 'currentObjectiveIndex',
    missionObjectives: 'missionObjectives',
    objectiveCompletions: 'objectiveCompletions'
  };

  export type StudySessionScalarFieldEnum = (typeof StudySessionScalarFieldEnum)[keyof typeof StudySessionScalarFieldEnum]


  export const ConceptScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    createdAt: 'createdAt'
  };

  export type ConceptScalarFieldEnum = (typeof ConceptScalarFieldEnum)[keyof typeof ConceptScalarFieldEnum]


  export const ConceptRelationshipScalarFieldEnum: {
    id: 'id',
    fromConceptId: 'fromConceptId',
    toConceptId: 'toConceptId',
    relationship: 'relationship',
    strength: 'strength',
    createdAt: 'createdAt'
  };

  export type ConceptRelationshipScalarFieldEnum = (typeof ConceptRelationshipScalarFieldEnum)[keyof typeof ConceptRelationshipScalarFieldEnum]


  export const ValidationPromptScalarFieldEnum: {
    id: 'id',
    promptText: 'promptText',
    promptType: 'promptType',
    conceptName: 'conceptName',
    expectedCriteria: 'expectedCriteria',
    createdAt: 'createdAt'
  };

  export type ValidationPromptScalarFieldEnum = (typeof ValidationPromptScalarFieldEnum)[keyof typeof ValidationPromptScalarFieldEnum]


  export const ValidationResponseScalarFieldEnum: {
    id: 'id',
    promptId: 'promptId',
    sessionId: 'sessionId',
    userAnswer: 'userAnswer',
    aiEvaluation: 'aiEvaluation',
    score: 'score',
    confidence: 'confidence',
    respondedAt: 'respondedAt'
  };

  export type ValidationResponseScalarFieldEnum = (typeof ValidationResponseScalarFieldEnum)[keyof typeof ValidationResponseScalarFieldEnum]


  export const ComprehensionMetricScalarFieldEnum: {
    id: 'id',
    conceptName: 'conceptName',
    date: 'date',
    avgScore: 'avgScore',
    sampleSize: 'sampleSize',
    trend: 'trend'
  };

  export type ComprehensionMetricScalarFieldEnum = (typeof ComprehensionMetricScalarFieldEnum)[keyof typeof ComprehensionMetricScalarFieldEnum]


  export const BehavioralEventScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    eventType: 'eventType',
    eventData: 'eventData',
    timestamp: 'timestamp',
    sessionPerformanceScore: 'sessionPerformanceScore',
    engagementLevel: 'engagementLevel',
    completionQuality: 'completionQuality',
    timeOfDay: 'timeOfDay',
    dayOfWeek: 'dayOfWeek',
    contentType: 'contentType',
    difficultyLevel: 'difficultyLevel'
  };

  export type BehavioralEventScalarFieldEnum = (typeof BehavioralEventScalarFieldEnum)[keyof typeof BehavioralEventScalarFieldEnum]


  export const BehavioralPatternScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    patternType: 'patternType',
    patternName: 'patternName',
    confidence: 'confidence',
    evidence: 'evidence',
    detectedAt: 'detectedAt',
    lastSeenAt: 'lastSeenAt',
    occurrenceCount: 'occurrenceCount'
  };

  export type BehavioralPatternScalarFieldEnum = (typeof BehavioralPatternScalarFieldEnum)[keyof typeof BehavioralPatternScalarFieldEnum]


  export const BehavioralInsightScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    insightType: 'insightType',
    title: 'title',
    description: 'description',
    actionableRecommendation: 'actionableRecommendation',
    confidence: 'confidence',
    createdAt: 'createdAt',
    acknowledgedAt: 'acknowledgedAt',
    applied: 'applied'
  };

  export type BehavioralInsightScalarFieldEnum = (typeof BehavioralInsightScalarFieldEnum)[keyof typeof BehavioralInsightScalarFieldEnum]


  export const InsightPatternScalarFieldEnum: {
    id: 'id',
    insightId: 'insightId',
    patternId: 'patternId'
  };

  export type InsightPatternScalarFieldEnum = (typeof InsightPatternScalarFieldEnum)[keyof typeof InsightPatternScalarFieldEnum]


  export const UserLearningProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    preferredStudyTimes: 'preferredStudyTimes',
    averageSessionDuration: 'averageSessionDuration',
    optimalSessionDuration: 'optimalSessionDuration',
    contentPreferences: 'contentPreferences',
    learningStyleProfile: 'learningStyleProfile',
    personalizedForgettingCurve: 'personalizedForgettingCurve',
    lastAnalyzedAt: 'lastAnalyzedAt',
    dataQualityScore: 'dataQualityScore'
  };

  export type UserLearningProfileScalarFieldEnum = (typeof UserLearningProfileScalarFieldEnum)[keyof typeof UserLearningProfileScalarFieldEnum]


  export const LearningPatternScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    patternType: 'patternType',
    patternData: 'patternData',
    confidence: 'confidence',
    detectedAt: 'detectedAt',
    lastSeenAt: 'lastSeenAt'
  };

  export type LearningPatternScalarFieldEnum = (typeof LearningPatternScalarFieldEnum)[keyof typeof LearningPatternScalarFieldEnum]


  export const PerformancePredictionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    predictedFor: 'predictedFor',
    predictionType: 'predictionType',
    prediction: 'prediction',
    confidence: 'confidence',
    createdAt: 'createdAt'
  };

  export type PerformancePredictionScalarFieldEnum = (typeof PerformancePredictionScalarFieldEnum)[keyof typeof PerformancePredictionScalarFieldEnum]


  export const StrugglePredictionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    learningObjectiveId: 'learningObjectiveId',
    topicId: 'topicId',
    predictionDate: 'predictionDate',
    predictedStruggleProbability: 'predictedStruggleProbability',
    predictionConfidence: 'predictionConfidence',
    predictionStatus: 'predictionStatus',
    actualOutcome: 'actualOutcome',
    outcomeRecordedAt: 'outcomeRecordedAt',
    featureVector: 'featureVector'
  };

  export type StrugglePredictionScalarFieldEnum = (typeof StrugglePredictionScalarFieldEnum)[keyof typeof StrugglePredictionScalarFieldEnum]


  export const StruggleIndicatorScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    predictionId: 'predictionId',
    learningObjectiveId: 'learningObjectiveId',
    indicatorType: 'indicatorType',
    severity: 'severity',
    detectedAt: 'detectedAt',
    context: 'context'
  };

  export type StruggleIndicatorScalarFieldEnum = (typeof StruggleIndicatorScalarFieldEnum)[keyof typeof StruggleIndicatorScalarFieldEnum]


  export const InterventionRecommendationScalarFieldEnum: {
    id: 'id',
    predictionId: 'predictionId',
    userId: 'userId',
    interventionType: 'interventionType',
    description: 'description',
    reasoning: 'reasoning',
    priority: 'priority',
    status: 'status',
    appliedAt: 'appliedAt',
    appliedToMissionId: 'appliedToMissionId',
    effectiveness: 'effectiveness',
    createdAt: 'createdAt'
  };

  export type InterventionRecommendationScalarFieldEnum = (typeof InterventionRecommendationScalarFieldEnum)[keyof typeof InterventionRecommendationScalarFieldEnum]


  export const PredictionFeedbackScalarFieldEnum: {
    id: 'id',
    predictionId: 'predictionId',
    userId: 'userId',
    feedbackType: 'feedbackType',
    actualStruggle: 'actualStruggle',
    helpfulness: 'helpfulness',
    comments: 'comments',
    submittedAt: 'submittedAt'
  };

  export type PredictionFeedbackScalarFieldEnum = (typeof PredictionFeedbackScalarFieldEnum)[keyof typeof PredictionFeedbackScalarFieldEnum]


  export const PerformanceMetricScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    learningObjectiveId: 'learningObjectiveId',
    date: 'date',
    retentionScore: 'retentionScore',
    studyTimeMs: 'studyTimeMs',
    reviewCount: 'reviewCount',
    correctReviews: 'correctReviews',
    incorrectReviews: 'incorrectReviews',
    createdAt: 'createdAt'
  };

  export type PerformanceMetricScalarFieldEnum = (typeof PerformanceMetricScalarFieldEnum)[keyof typeof PerformanceMetricScalarFieldEnum]


  export const ExamScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    date: 'date',
    courseId: 'courseId',
    coverageTopics: 'coverageTopics',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamScalarFieldEnum = (typeof ExamScalarFieldEnum)[keyof typeof ExamScalarFieldEnum]


  export const CoursePriorityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    courseId: 'courseId',
    priorityLevel: 'priorityLevel',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CoursePriorityScalarFieldEnum = (typeof CoursePriorityScalarFieldEnum)[keyof typeof CoursePriorityScalarFieldEnum]


  export const PriorityFeedbackScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    objectiveId: 'objectiveId',
    suggestedPriority: 'suggestedPriority',
    userFeedback: 'userFeedback',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type PriorityFeedbackScalarFieldEnum = (typeof PriorityFeedbackScalarFieldEnum)[keyof typeof PriorityFeedbackScalarFieldEnum]


  export const StreakScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    currentStreak: 'currentStreak',
    longestStreak: 'longestStreak',
    lastStudyDate: 'lastStudyDate',
    freezesRemaining: 'freezesRemaining',
    freezeUsedDates: 'freezeUsedDates',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StreakScalarFieldEnum = (typeof StreakScalarFieldEnum)[keyof typeof StreakScalarFieldEnum]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    name: 'name',
    description: 'description',
    tier: 'tier',
    earnedAt: 'earnedAt',
    metadata: 'metadata'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const StudyGoalScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    goalType: 'goalType',
    targetValue: 'targetValue',
    currentProgress: 'currentProgress',
    period: 'period',
    startDate: 'startDate',
    endDate: 'endDate',
    isCompleted: 'isCompleted',
    completedAt: 'completedAt',
    createdAt: 'createdAt'
  };

  export type StudyGoalScalarFieldEnum = (typeof StudyGoalScalarFieldEnum)[keyof typeof StudyGoalScalarFieldEnum]


  export const MissionAnalyticsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    date: 'date',
    period: 'period',
    missionsGenerated: 'missionsGenerated',
    missionsCompleted: 'missionsCompleted',
    missionsSkipped: 'missionsSkipped',
    avgCompletionRate: 'avgCompletionRate',
    avgTimeAccuracy: 'avgTimeAccuracy',
    avgDifficultyRating: 'avgDifficultyRating',
    avgSuccessScore: 'avgSuccessScore',
    createdAt: 'createdAt'
  };

  export type MissionAnalyticsScalarFieldEnum = (typeof MissionAnalyticsScalarFieldEnum)[keyof typeof MissionAnalyticsScalarFieldEnum]


  export const MissionFeedbackScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    missionId: 'missionId',
    helpfulnessRating: 'helpfulnessRating',
    relevanceScore: 'relevanceScore',
    paceRating: 'paceRating',
    improvementSuggestions: 'improvementSuggestions',
    submittedAt: 'submittedAt'
  };

  export type MissionFeedbackScalarFieldEnum = (typeof MissionFeedbackScalarFieldEnum)[keyof typeof MissionFeedbackScalarFieldEnum]


  export const MissionStreakScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    currentStreak: 'currentStreak',
    longestStreak: 'longestStreak',
    lastCompletedDate: 'lastCompletedDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MissionStreakScalarFieldEnum = (typeof MissionStreakScalarFieldEnum)[keyof typeof MissionStreakScalarFieldEnum]


  export const MissionReviewScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    period: 'period',
    startDate: 'startDate',
    endDate: 'endDate',
    summary: 'summary',
    highlights: 'highlights',
    insights: 'insights',
    recommendations: 'recommendations',
    generatedAt: 'generatedAt'
  };

  export type MissionReviewScalarFieldEnum = (typeof MissionReviewScalarFieldEnum)[keyof typeof MissionReviewScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ProcessingStatus'
   */
  export type EnumProcessingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessingStatus'>
    


  /**
   * Reference to a field of type 'ProcessingStatus[]'
   */
  export type ListEnumProcessingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessingStatus[]'>
    


  /**
   * Reference to a field of type 'ObjectiveComplexity'
   */
  export type EnumObjectiveComplexityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ObjectiveComplexity'>
    


  /**
   * Reference to a field of type 'ObjectiveComplexity[]'
   */
  export type ListEnumObjectiveComplexityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ObjectiveComplexity[]'>
    


  /**
   * Reference to a field of type 'MasteryLevel'
   */
  export type EnumMasteryLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MasteryLevel'>
    


  /**
   * Reference to a field of type 'MasteryLevel[]'
   */
  export type ListEnumMasteryLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MasteryLevel[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'MissionStatus'
   */
  export type EnumMissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MissionStatus'>
    


  /**
   * Reference to a field of type 'MissionStatus[]'
   */
  export type ListEnumMissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MissionStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'CardType'
   */
  export type EnumCardTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CardType'>
    


  /**
   * Reference to a field of type 'CardType[]'
   */
  export type ListEnumCardTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CardType[]'>
    


  /**
   * Reference to a field of type 'ReviewRating'
   */
  export type EnumReviewRatingFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewRating'>
    


  /**
   * Reference to a field of type 'ReviewRating[]'
   */
  export type ListEnumReviewRatingFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewRating[]'>
    


  /**
   * Reference to a field of type 'RelationshipType'
   */
  export type EnumRelationshipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RelationshipType'>
    


  /**
   * Reference to a field of type 'RelationshipType[]'
   */
  export type ListEnumRelationshipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RelationshipType[]'>
    


  /**
   * Reference to a field of type 'PromptType'
   */
  export type EnumPromptTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PromptType'>
    


  /**
   * Reference to a field of type 'PromptType[]'
   */
  export type ListEnumPromptTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PromptType[]'>
    


  /**
   * Reference to a field of type 'EventType'
   */
  export type EnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType'>
    


  /**
   * Reference to a field of type 'EventType[]'
   */
  export type ListEnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType[]'>
    


  /**
   * Reference to a field of type 'EngagementLevel'
   */
  export type EnumEngagementLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EngagementLevel'>
    


  /**
   * Reference to a field of type 'EngagementLevel[]'
   */
  export type ListEnumEngagementLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EngagementLevel[]'>
    


  /**
   * Reference to a field of type 'CompletionQuality'
   */
  export type EnumCompletionQualityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompletionQuality'>
    


  /**
   * Reference to a field of type 'CompletionQuality[]'
   */
  export type ListEnumCompletionQualityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompletionQuality[]'>
    


  /**
   * Reference to a field of type 'BehavioralPatternType'
   */
  export type EnumBehavioralPatternTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BehavioralPatternType'>
    


  /**
   * Reference to a field of type 'BehavioralPatternType[]'
   */
  export type ListEnumBehavioralPatternTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BehavioralPatternType[]'>
    


  /**
   * Reference to a field of type 'InsightType'
   */
  export type EnumInsightTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsightType'>
    


  /**
   * Reference to a field of type 'InsightType[]'
   */
  export type ListEnumInsightTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsightType[]'>
    


  /**
   * Reference to a field of type 'PatternType'
   */
  export type EnumPatternTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PatternType'>
    


  /**
   * Reference to a field of type 'PatternType[]'
   */
  export type ListEnumPatternTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PatternType[]'>
    


  /**
   * Reference to a field of type 'PredictionStatus'
   */
  export type EnumPredictionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PredictionStatus'>
    


  /**
   * Reference to a field of type 'PredictionStatus[]'
   */
  export type ListEnumPredictionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PredictionStatus[]'>
    


  /**
   * Reference to a field of type 'IndicatorType'
   */
  export type EnumIndicatorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IndicatorType'>
    


  /**
   * Reference to a field of type 'IndicatorType[]'
   */
  export type ListEnumIndicatorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IndicatorType[]'>
    


  /**
   * Reference to a field of type 'Severity'
   */
  export type EnumSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Severity'>
    


  /**
   * Reference to a field of type 'Severity[]'
   */
  export type ListEnumSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Severity[]'>
    


  /**
   * Reference to a field of type 'InterventionType'
   */
  export type EnumInterventionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterventionType'>
    


  /**
   * Reference to a field of type 'InterventionType[]'
   */
  export type ListEnumInterventionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterventionType[]'>
    


  /**
   * Reference to a field of type 'InterventionStatus'
   */
  export type EnumInterventionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterventionStatus'>
    


  /**
   * Reference to a field of type 'InterventionStatus[]'
   */
  export type ListEnumInterventionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InterventionStatus[]'>
    


  /**
   * Reference to a field of type 'FeedbackType'
   */
  export type EnumFeedbackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackType'>
    


  /**
   * Reference to a field of type 'FeedbackType[]'
   */
  export type ListEnumFeedbackTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackType[]'>
    


  /**
   * Reference to a field of type 'PriorityLevel'
   */
  export type EnumPriorityLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PriorityLevel'>
    


  /**
   * Reference to a field of type 'PriorityLevel[]'
   */
  export type ListEnumPriorityLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PriorityLevel[]'>
    


  /**
   * Reference to a field of type 'FeedbackRating'
   */
  export type EnumFeedbackRatingFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackRating'>
    


  /**
   * Reference to a field of type 'FeedbackRating[]'
   */
  export type ListEnumFeedbackRatingFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeedbackRating[]'>
    


  /**
   * Reference to a field of type 'AchievementType'
   */
  export type EnumAchievementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AchievementType'>
    


  /**
   * Reference to a field of type 'AchievementType[]'
   */
  export type ListEnumAchievementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AchievementType[]'>
    


  /**
   * Reference to a field of type 'AchievementTier'
   */
  export type EnumAchievementTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AchievementTier'>
    


  /**
   * Reference to a field of type 'AchievementTier[]'
   */
  export type ListEnumAchievementTierFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AchievementTier[]'>
    


  /**
   * Reference to a field of type 'GoalType'
   */
  export type EnumGoalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GoalType'>
    


  /**
   * Reference to a field of type 'GoalType[]'
   */
  export type ListEnumGoalTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GoalType[]'>
    


  /**
   * Reference to a field of type 'GoalPeriod'
   */
  export type EnumGoalPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GoalPeriod'>
    


  /**
   * Reference to a field of type 'GoalPeriod[]'
   */
  export type ListEnumGoalPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GoalPeriod[]'>
    


  /**
   * Reference to a field of type 'AnalyticsPeriod'
   */
  export type EnumAnalyticsPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnalyticsPeriod'>
    


  /**
   * Reference to a field of type 'AnalyticsPeriod[]'
   */
  export type ListEnumAnalyticsPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnalyticsPeriod[]'>
    


  /**
   * Reference to a field of type 'PaceRating'
   */
  export type EnumPaceRatingFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaceRating'>
    


  /**
   * Reference to a field of type 'PaceRating[]'
   */
  export type ListEnumPaceRatingFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaceRating[]'>
    


  /**
   * Reference to a field of type 'ReviewPeriod'
   */
  export type EnumReviewPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewPeriod'>
    


  /**
   * Reference to a field of type 'ReviewPeriod[]'
   */
  export type ListEnumReviewPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewPeriod[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    defaultMissionMinutes?: IntFilter<"User"> | number
    missionDifficulty?: StringFilter<"User"> | string
    preferredStudyTime?: StringNullableFilter<"User"> | string | null
    autoGenerateMissions?: BoolFilter<"User"> | boolean
    performanceTrackingEnabled?: BoolFilter<"User"> | boolean
    includeInAnalytics?: BoolFilter<"User"> | boolean
    lastMissionAdaptation?: DateTimeNullableFilter<"User"> | Date | string | null
    behavioralAnalysisEnabled?: BoolFilter<"User"> | boolean
    learningStyleProfilingEnabled?: BoolFilter<"User"> | boolean
    shareAnonymizedPatterns?: BoolFilter<"User"> | boolean
    courses?: CourseListRelationFilter
    lectures?: LectureListRelationFilter
    studySessions?: StudySessionListRelationFilter
    missions?: MissionListRelationFilter
    reviews?: ReviewListRelationFilter
    exams?: ExamListRelationFilter
    coursePriorities?: CoursePriorityListRelationFilter
    streak?: XOR<StreakNullableRelationFilter, StreakWhereInput> | null
    achievements?: AchievementListRelationFilter
    studyGoals?: StudyGoalListRelationFilter
    missionStreak?: XOR<MissionStreakNullableRelationFilter, MissionStreakWhereInput> | null
    missionReviews?: MissionReviewListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    defaultMissionMinutes?: SortOrder
    missionDifficulty?: SortOrder
    preferredStudyTime?: SortOrderInput | SortOrder
    autoGenerateMissions?: SortOrder
    performanceTrackingEnabled?: SortOrder
    includeInAnalytics?: SortOrder
    lastMissionAdaptation?: SortOrderInput | SortOrder
    behavioralAnalysisEnabled?: SortOrder
    learningStyleProfilingEnabled?: SortOrder
    shareAnonymizedPatterns?: SortOrder
    courses?: CourseOrderByRelationAggregateInput
    lectures?: LectureOrderByRelationAggregateInput
    studySessions?: StudySessionOrderByRelationAggregateInput
    missions?: MissionOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    exams?: ExamOrderByRelationAggregateInput
    coursePriorities?: CoursePriorityOrderByRelationAggregateInput
    streak?: StreakOrderByWithRelationInput
    achievements?: AchievementOrderByRelationAggregateInput
    studyGoals?: StudyGoalOrderByRelationAggregateInput
    missionStreak?: MissionStreakOrderByWithRelationInput
    missionReviews?: MissionReviewOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    defaultMissionMinutes?: IntFilter<"User"> | number
    missionDifficulty?: StringFilter<"User"> | string
    preferredStudyTime?: StringNullableFilter<"User"> | string | null
    autoGenerateMissions?: BoolFilter<"User"> | boolean
    performanceTrackingEnabled?: BoolFilter<"User"> | boolean
    includeInAnalytics?: BoolFilter<"User"> | boolean
    lastMissionAdaptation?: DateTimeNullableFilter<"User"> | Date | string | null
    behavioralAnalysisEnabled?: BoolFilter<"User"> | boolean
    learningStyleProfilingEnabled?: BoolFilter<"User"> | boolean
    shareAnonymizedPatterns?: BoolFilter<"User"> | boolean
    courses?: CourseListRelationFilter
    lectures?: LectureListRelationFilter
    studySessions?: StudySessionListRelationFilter
    missions?: MissionListRelationFilter
    reviews?: ReviewListRelationFilter
    exams?: ExamListRelationFilter
    coursePriorities?: CoursePriorityListRelationFilter
    streak?: XOR<StreakNullableRelationFilter, StreakWhereInput> | null
    achievements?: AchievementListRelationFilter
    studyGoals?: StudyGoalListRelationFilter
    missionStreak?: XOR<MissionStreakNullableRelationFilter, MissionStreakWhereInput> | null
    missionReviews?: MissionReviewListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    defaultMissionMinutes?: SortOrder
    missionDifficulty?: SortOrder
    preferredStudyTime?: SortOrderInput | SortOrder
    autoGenerateMissions?: SortOrder
    performanceTrackingEnabled?: SortOrder
    includeInAnalytics?: SortOrder
    lastMissionAdaptation?: SortOrderInput | SortOrder
    behavioralAnalysisEnabled?: SortOrder
    learningStyleProfilingEnabled?: SortOrder
    shareAnonymizedPatterns?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    defaultMissionMinutes?: IntWithAggregatesFilter<"User"> | number
    missionDifficulty?: StringWithAggregatesFilter<"User"> | string
    preferredStudyTime?: StringNullableWithAggregatesFilter<"User"> | string | null
    autoGenerateMissions?: BoolWithAggregatesFilter<"User"> | boolean
    performanceTrackingEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    includeInAnalytics?: BoolWithAggregatesFilter<"User"> | boolean
    lastMissionAdaptation?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    behavioralAnalysisEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    learningStyleProfilingEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    shareAnonymizedPatterns?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: StringFilter<"Course"> | string
    userId?: StringFilter<"Course"> | string
    name?: StringFilter<"Course"> | string
    code?: StringNullableFilter<"Course"> | string | null
    term?: StringNullableFilter<"Course"> | string | null
    color?: StringNullableFilter<"Course"> | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    lectures?: LectureListRelationFilter
    cards?: CardListRelationFilter
    exams?: ExamListRelationFilter
    coursePriorities?: CoursePriorityListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    term?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    lectures?: LectureOrderByRelationAggregateInput
    cards?: CardOrderByRelationAggregateInput
    exams?: ExamOrderByRelationAggregateInput
    coursePriorities?: CoursePriorityOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    userId?: StringFilter<"Course"> | string
    name?: StringFilter<"Course"> | string
    code?: StringNullableFilter<"Course"> | string | null
    term?: StringNullableFilter<"Course"> | string | null
    color?: StringNullableFilter<"Course"> | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    lectures?: LectureListRelationFilter
    cards?: CardListRelationFilter
    exams?: ExamListRelationFilter
    coursePriorities?: CoursePriorityListRelationFilter
  }, "id">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    term?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Course"> | string
    userId?: StringWithAggregatesFilter<"Course"> | string
    name?: StringWithAggregatesFilter<"Course"> | string
    code?: StringNullableWithAggregatesFilter<"Course"> | string | null
    term?: StringNullableWithAggregatesFilter<"Course"> | string | null
    color?: StringNullableWithAggregatesFilter<"Course"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
  }

  export type LectureWhereInput = {
    AND?: LectureWhereInput | LectureWhereInput[]
    OR?: LectureWhereInput[]
    NOT?: LectureWhereInput | LectureWhereInput[]
    id?: StringFilter<"Lecture"> | string
    userId?: StringFilter<"Lecture"> | string
    courseId?: StringFilter<"Lecture"> | string
    title?: StringFilter<"Lecture"> | string
    fileName?: StringFilter<"Lecture"> | string
    fileUrl?: StringFilter<"Lecture"> | string
    fileSize?: IntFilter<"Lecture"> | number
    processingStatus?: EnumProcessingStatusFilter<"Lecture"> | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFilter<"Lecture"> | Date | string
    processedAt?: DateTimeNullableFilter<"Lecture"> | Date | string | null
    processingProgress?: IntFilter<"Lecture"> | number
    totalPages?: IntNullableFilter<"Lecture"> | number | null
    processedPages?: IntFilter<"Lecture"> | number
    processingStartedAt?: DateTimeNullableFilter<"Lecture"> | Date | string | null
    estimatedCompletionAt?: DateTimeNullableFilter<"Lecture"> | Date | string | null
    weekNumber?: IntNullableFilter<"Lecture"> | number | null
    topicTags?: StringNullableListFilter<"Lecture">
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    contentChunks?: ContentChunkListRelationFilter
    learningObjectives?: LearningObjectiveListRelationFilter
    cards?: CardListRelationFilter
  }

  export type LectureOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    processingStatus?: SortOrder
    uploadedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    processingProgress?: SortOrder
    totalPages?: SortOrderInput | SortOrder
    processedPages?: SortOrder
    processingStartedAt?: SortOrderInput | SortOrder
    estimatedCompletionAt?: SortOrderInput | SortOrder
    weekNumber?: SortOrderInput | SortOrder
    topicTags?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    contentChunks?: ContentChunkOrderByRelationAggregateInput
    learningObjectives?: LearningObjectiveOrderByRelationAggregateInput
    cards?: CardOrderByRelationAggregateInput
  }

  export type LectureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LectureWhereInput | LectureWhereInput[]
    OR?: LectureWhereInput[]
    NOT?: LectureWhereInput | LectureWhereInput[]
    userId?: StringFilter<"Lecture"> | string
    courseId?: StringFilter<"Lecture"> | string
    title?: StringFilter<"Lecture"> | string
    fileName?: StringFilter<"Lecture"> | string
    fileUrl?: StringFilter<"Lecture"> | string
    fileSize?: IntFilter<"Lecture"> | number
    processingStatus?: EnumProcessingStatusFilter<"Lecture"> | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFilter<"Lecture"> | Date | string
    processedAt?: DateTimeNullableFilter<"Lecture"> | Date | string | null
    processingProgress?: IntFilter<"Lecture"> | number
    totalPages?: IntNullableFilter<"Lecture"> | number | null
    processedPages?: IntFilter<"Lecture"> | number
    processingStartedAt?: DateTimeNullableFilter<"Lecture"> | Date | string | null
    estimatedCompletionAt?: DateTimeNullableFilter<"Lecture"> | Date | string | null
    weekNumber?: IntNullableFilter<"Lecture"> | number | null
    topicTags?: StringNullableListFilter<"Lecture">
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    contentChunks?: ContentChunkListRelationFilter
    learningObjectives?: LearningObjectiveListRelationFilter
    cards?: CardListRelationFilter
  }, "id">

  export type LectureOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    processingStatus?: SortOrder
    uploadedAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    processingProgress?: SortOrder
    totalPages?: SortOrderInput | SortOrder
    processedPages?: SortOrder
    processingStartedAt?: SortOrderInput | SortOrder
    estimatedCompletionAt?: SortOrderInput | SortOrder
    weekNumber?: SortOrderInput | SortOrder
    topicTags?: SortOrder
    _count?: LectureCountOrderByAggregateInput
    _avg?: LectureAvgOrderByAggregateInput
    _max?: LectureMaxOrderByAggregateInput
    _min?: LectureMinOrderByAggregateInput
    _sum?: LectureSumOrderByAggregateInput
  }

  export type LectureScalarWhereWithAggregatesInput = {
    AND?: LectureScalarWhereWithAggregatesInput | LectureScalarWhereWithAggregatesInput[]
    OR?: LectureScalarWhereWithAggregatesInput[]
    NOT?: LectureScalarWhereWithAggregatesInput | LectureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lecture"> | string
    userId?: StringWithAggregatesFilter<"Lecture"> | string
    courseId?: StringWithAggregatesFilter<"Lecture"> | string
    title?: StringWithAggregatesFilter<"Lecture"> | string
    fileName?: StringWithAggregatesFilter<"Lecture"> | string
    fileUrl?: StringWithAggregatesFilter<"Lecture"> | string
    fileSize?: IntWithAggregatesFilter<"Lecture"> | number
    processingStatus?: EnumProcessingStatusWithAggregatesFilter<"Lecture"> | $Enums.ProcessingStatus
    uploadedAt?: DateTimeWithAggregatesFilter<"Lecture"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"Lecture"> | Date | string | null
    processingProgress?: IntWithAggregatesFilter<"Lecture"> | number
    totalPages?: IntNullableWithAggregatesFilter<"Lecture"> | number | null
    processedPages?: IntWithAggregatesFilter<"Lecture"> | number
    processingStartedAt?: DateTimeNullableWithAggregatesFilter<"Lecture"> | Date | string | null
    estimatedCompletionAt?: DateTimeNullableWithAggregatesFilter<"Lecture"> | Date | string | null
    weekNumber?: IntNullableWithAggregatesFilter<"Lecture"> | number | null
    topicTags?: StringNullableListFilter<"Lecture">
  }

  export type ContentChunkWhereInput = {
    AND?: ContentChunkWhereInput | ContentChunkWhereInput[]
    OR?: ContentChunkWhereInput[]
    NOT?: ContentChunkWhereInput | ContentChunkWhereInput[]
    id?: StringFilter<"ContentChunk"> | string
    lectureId?: StringFilter<"ContentChunk"> | string
    content?: StringFilter<"ContentChunk"> | string
    chunkIndex?: IntFilter<"ContentChunk"> | number
    pageNumber?: IntNullableFilter<"ContentChunk"> | number | null
    createdAt?: DateTimeFilter<"ContentChunk"> | Date | string
    lecture?: XOR<LectureRelationFilter, LectureWhereInput>
  }

  export type ContentChunkOrderByWithRelationInput = {
    id?: SortOrder
    lectureId?: SortOrder
    content?: SortOrder
    chunkIndex?: SortOrder
    pageNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lecture?: LectureOrderByWithRelationInput
  }

  export type ContentChunkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContentChunkWhereInput | ContentChunkWhereInput[]
    OR?: ContentChunkWhereInput[]
    NOT?: ContentChunkWhereInput | ContentChunkWhereInput[]
    lectureId?: StringFilter<"ContentChunk"> | string
    content?: StringFilter<"ContentChunk"> | string
    chunkIndex?: IntFilter<"ContentChunk"> | number
    pageNumber?: IntNullableFilter<"ContentChunk"> | number | null
    createdAt?: DateTimeFilter<"ContentChunk"> | Date | string
    lecture?: XOR<LectureRelationFilter, LectureWhereInput>
  }, "id">

  export type ContentChunkOrderByWithAggregationInput = {
    id?: SortOrder
    lectureId?: SortOrder
    content?: SortOrder
    chunkIndex?: SortOrder
    pageNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ContentChunkCountOrderByAggregateInput
    _avg?: ContentChunkAvgOrderByAggregateInput
    _max?: ContentChunkMaxOrderByAggregateInput
    _min?: ContentChunkMinOrderByAggregateInput
    _sum?: ContentChunkSumOrderByAggregateInput
  }

  export type ContentChunkScalarWhereWithAggregatesInput = {
    AND?: ContentChunkScalarWhereWithAggregatesInput | ContentChunkScalarWhereWithAggregatesInput[]
    OR?: ContentChunkScalarWhereWithAggregatesInput[]
    NOT?: ContentChunkScalarWhereWithAggregatesInput | ContentChunkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContentChunk"> | string
    lectureId?: StringWithAggregatesFilter<"ContentChunk"> | string
    content?: StringWithAggregatesFilter<"ContentChunk"> | string
    chunkIndex?: IntWithAggregatesFilter<"ContentChunk"> | number
    pageNumber?: IntNullableWithAggregatesFilter<"ContentChunk"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ContentChunk"> | Date | string
  }

  export type LearningObjectiveWhereInput = {
    AND?: LearningObjectiveWhereInput | LearningObjectiveWhereInput[]
    OR?: LearningObjectiveWhereInput[]
    NOT?: LearningObjectiveWhereInput | LearningObjectiveWhereInput[]
    id?: StringFilter<"LearningObjective"> | string
    lectureId?: StringFilter<"LearningObjective"> | string
    objective?: StringFilter<"LearningObjective"> | string
    complexity?: EnumObjectiveComplexityFilter<"LearningObjective"> | $Enums.ObjectiveComplexity
    pageStart?: IntNullableFilter<"LearningObjective"> | number | null
    pageEnd?: IntNullableFilter<"LearningObjective"> | number | null
    isHighYield?: BoolFilter<"LearningObjective"> | boolean
    boardExamTags?: StringNullableListFilter<"LearningObjective">
    extractedBy?: StringFilter<"LearningObjective"> | string
    createdAt?: DateTimeFilter<"LearningObjective"> | Date | string
    masteryLevel?: EnumMasteryLevelFilter<"LearningObjective"> | $Enums.MasteryLevel
    totalStudyTimeMs?: IntFilter<"LearningObjective"> | number
    lastStudiedAt?: DateTimeNullableFilter<"LearningObjective"> | Date | string | null
    weaknessScore?: FloatFilter<"LearningObjective"> | number
    lecture?: XOR<LectureRelationFilter, LectureWhereInput>
    cards?: CardListRelationFilter
    prerequisites?: ObjectivePrerequisiteListRelationFilter
    dependents?: ObjectivePrerequisiteListRelationFilter
    performanceMetrics?: PerformanceMetricListRelationFilter
    priorityFeedback?: PriorityFeedbackListRelationFilter
    strugglePredictions?: StrugglePredictionListRelationFilter
    struggleIndicators?: StruggleIndicatorListRelationFilter
  }

  export type LearningObjectiveOrderByWithRelationInput = {
    id?: SortOrder
    lectureId?: SortOrder
    objective?: SortOrder
    complexity?: SortOrder
    pageStart?: SortOrderInput | SortOrder
    pageEnd?: SortOrderInput | SortOrder
    isHighYield?: SortOrder
    boardExamTags?: SortOrder
    extractedBy?: SortOrder
    createdAt?: SortOrder
    masteryLevel?: SortOrder
    totalStudyTimeMs?: SortOrder
    lastStudiedAt?: SortOrderInput | SortOrder
    weaknessScore?: SortOrder
    lecture?: LectureOrderByWithRelationInput
    cards?: CardOrderByRelationAggregateInput
    prerequisites?: ObjectivePrerequisiteOrderByRelationAggregateInput
    dependents?: ObjectivePrerequisiteOrderByRelationAggregateInput
    performanceMetrics?: PerformanceMetricOrderByRelationAggregateInput
    priorityFeedback?: PriorityFeedbackOrderByRelationAggregateInput
    strugglePredictions?: StrugglePredictionOrderByRelationAggregateInput
    struggleIndicators?: StruggleIndicatorOrderByRelationAggregateInput
  }

  export type LearningObjectiveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LearningObjectiveWhereInput | LearningObjectiveWhereInput[]
    OR?: LearningObjectiveWhereInput[]
    NOT?: LearningObjectiveWhereInput | LearningObjectiveWhereInput[]
    lectureId?: StringFilter<"LearningObjective"> | string
    objective?: StringFilter<"LearningObjective"> | string
    complexity?: EnumObjectiveComplexityFilter<"LearningObjective"> | $Enums.ObjectiveComplexity
    pageStart?: IntNullableFilter<"LearningObjective"> | number | null
    pageEnd?: IntNullableFilter<"LearningObjective"> | number | null
    isHighYield?: BoolFilter<"LearningObjective"> | boolean
    boardExamTags?: StringNullableListFilter<"LearningObjective">
    extractedBy?: StringFilter<"LearningObjective"> | string
    createdAt?: DateTimeFilter<"LearningObjective"> | Date | string
    masteryLevel?: EnumMasteryLevelFilter<"LearningObjective"> | $Enums.MasteryLevel
    totalStudyTimeMs?: IntFilter<"LearningObjective"> | number
    lastStudiedAt?: DateTimeNullableFilter<"LearningObjective"> | Date | string | null
    weaknessScore?: FloatFilter<"LearningObjective"> | number
    lecture?: XOR<LectureRelationFilter, LectureWhereInput>
    cards?: CardListRelationFilter
    prerequisites?: ObjectivePrerequisiteListRelationFilter
    dependents?: ObjectivePrerequisiteListRelationFilter
    performanceMetrics?: PerformanceMetricListRelationFilter
    priorityFeedback?: PriorityFeedbackListRelationFilter
    strugglePredictions?: StrugglePredictionListRelationFilter
    struggleIndicators?: StruggleIndicatorListRelationFilter
  }, "id">

  export type LearningObjectiveOrderByWithAggregationInput = {
    id?: SortOrder
    lectureId?: SortOrder
    objective?: SortOrder
    complexity?: SortOrder
    pageStart?: SortOrderInput | SortOrder
    pageEnd?: SortOrderInput | SortOrder
    isHighYield?: SortOrder
    boardExamTags?: SortOrder
    extractedBy?: SortOrder
    createdAt?: SortOrder
    masteryLevel?: SortOrder
    totalStudyTimeMs?: SortOrder
    lastStudiedAt?: SortOrderInput | SortOrder
    weaknessScore?: SortOrder
    _count?: LearningObjectiveCountOrderByAggregateInput
    _avg?: LearningObjectiveAvgOrderByAggregateInput
    _max?: LearningObjectiveMaxOrderByAggregateInput
    _min?: LearningObjectiveMinOrderByAggregateInput
    _sum?: LearningObjectiveSumOrderByAggregateInput
  }

  export type LearningObjectiveScalarWhereWithAggregatesInput = {
    AND?: LearningObjectiveScalarWhereWithAggregatesInput | LearningObjectiveScalarWhereWithAggregatesInput[]
    OR?: LearningObjectiveScalarWhereWithAggregatesInput[]
    NOT?: LearningObjectiveScalarWhereWithAggregatesInput | LearningObjectiveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LearningObjective"> | string
    lectureId?: StringWithAggregatesFilter<"LearningObjective"> | string
    objective?: StringWithAggregatesFilter<"LearningObjective"> | string
    complexity?: EnumObjectiveComplexityWithAggregatesFilter<"LearningObjective"> | $Enums.ObjectiveComplexity
    pageStart?: IntNullableWithAggregatesFilter<"LearningObjective"> | number | null
    pageEnd?: IntNullableWithAggregatesFilter<"LearningObjective"> | number | null
    isHighYield?: BoolWithAggregatesFilter<"LearningObjective"> | boolean
    boardExamTags?: StringNullableListFilter<"LearningObjective">
    extractedBy?: StringWithAggregatesFilter<"LearningObjective"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LearningObjective"> | Date | string
    masteryLevel?: EnumMasteryLevelWithAggregatesFilter<"LearningObjective"> | $Enums.MasteryLevel
    totalStudyTimeMs?: IntWithAggregatesFilter<"LearningObjective"> | number
    lastStudiedAt?: DateTimeNullableWithAggregatesFilter<"LearningObjective"> | Date | string | null
    weaknessScore?: FloatWithAggregatesFilter<"LearningObjective"> | number
  }

  export type ObjectivePrerequisiteWhereInput = {
    AND?: ObjectivePrerequisiteWhereInput | ObjectivePrerequisiteWhereInput[]
    OR?: ObjectivePrerequisiteWhereInput[]
    NOT?: ObjectivePrerequisiteWhereInput | ObjectivePrerequisiteWhereInput[]
    id?: StringFilter<"ObjectivePrerequisite"> | string
    objectiveId?: StringFilter<"ObjectivePrerequisite"> | string
    prerequisiteId?: StringFilter<"ObjectivePrerequisite"> | string
    strength?: FloatFilter<"ObjectivePrerequisite"> | number
    objective?: XOR<LearningObjectiveRelationFilter, LearningObjectiveWhereInput>
    prerequisite?: XOR<LearningObjectiveRelationFilter, LearningObjectiveWhereInput>
  }

  export type ObjectivePrerequisiteOrderByWithRelationInput = {
    id?: SortOrder
    objectiveId?: SortOrder
    prerequisiteId?: SortOrder
    strength?: SortOrder
    objective?: LearningObjectiveOrderByWithRelationInput
    prerequisite?: LearningObjectiveOrderByWithRelationInput
  }

  export type ObjectivePrerequisiteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    objectiveId_prerequisiteId?: ObjectivePrerequisiteObjectiveIdPrerequisiteIdCompoundUniqueInput
    AND?: ObjectivePrerequisiteWhereInput | ObjectivePrerequisiteWhereInput[]
    OR?: ObjectivePrerequisiteWhereInput[]
    NOT?: ObjectivePrerequisiteWhereInput | ObjectivePrerequisiteWhereInput[]
    objectiveId?: StringFilter<"ObjectivePrerequisite"> | string
    prerequisiteId?: StringFilter<"ObjectivePrerequisite"> | string
    strength?: FloatFilter<"ObjectivePrerequisite"> | number
    objective?: XOR<LearningObjectiveRelationFilter, LearningObjectiveWhereInput>
    prerequisite?: XOR<LearningObjectiveRelationFilter, LearningObjectiveWhereInput>
  }, "id" | "objectiveId_prerequisiteId">

  export type ObjectivePrerequisiteOrderByWithAggregationInput = {
    id?: SortOrder
    objectiveId?: SortOrder
    prerequisiteId?: SortOrder
    strength?: SortOrder
    _count?: ObjectivePrerequisiteCountOrderByAggregateInput
    _avg?: ObjectivePrerequisiteAvgOrderByAggregateInput
    _max?: ObjectivePrerequisiteMaxOrderByAggregateInput
    _min?: ObjectivePrerequisiteMinOrderByAggregateInput
    _sum?: ObjectivePrerequisiteSumOrderByAggregateInput
  }

  export type ObjectivePrerequisiteScalarWhereWithAggregatesInput = {
    AND?: ObjectivePrerequisiteScalarWhereWithAggregatesInput | ObjectivePrerequisiteScalarWhereWithAggregatesInput[]
    OR?: ObjectivePrerequisiteScalarWhereWithAggregatesInput[]
    NOT?: ObjectivePrerequisiteScalarWhereWithAggregatesInput | ObjectivePrerequisiteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ObjectivePrerequisite"> | string
    objectiveId?: StringWithAggregatesFilter<"ObjectivePrerequisite"> | string
    prerequisiteId?: StringWithAggregatesFilter<"ObjectivePrerequisite"> | string
    strength?: FloatWithAggregatesFilter<"ObjectivePrerequisite"> | number
  }

  export type MissionWhereInput = {
    AND?: MissionWhereInput | MissionWhereInput[]
    OR?: MissionWhereInput[]
    NOT?: MissionWhereInput | MissionWhereInput[]
    id?: StringFilter<"Mission"> | string
    userId?: StringFilter<"Mission"> | string
    date?: DateTimeFilter<"Mission"> | Date | string
    status?: EnumMissionStatusFilter<"Mission"> | $Enums.MissionStatus
    estimatedMinutes?: IntFilter<"Mission"> | number
    completedAt?: DateTimeNullableFilter<"Mission"> | Date | string | null
    actualMinutes?: IntNullableFilter<"Mission"> | number | null
    completedObjectivesCount?: IntFilter<"Mission"> | number
    objectives?: JsonFilter<"Mission">
    reviewCardCount?: IntFilter<"Mission"> | number
    newContentCount?: IntFilter<"Mission"> | number
    successScore?: FloatNullableFilter<"Mission"> | number | null
    difficultyRating?: IntNullableFilter<"Mission"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    studySessions?: StudySessionListRelationFilter
    feedback?: MissionFeedbackListRelationFilter
    interventions?: InterventionRecommendationListRelationFilter
  }

  export type MissionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    estimatedMinutes?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    actualMinutes?: SortOrderInput | SortOrder
    completedObjectivesCount?: SortOrder
    objectives?: SortOrder
    reviewCardCount?: SortOrder
    newContentCount?: SortOrder
    successScore?: SortOrderInput | SortOrder
    difficultyRating?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    studySessions?: StudySessionOrderByRelationAggregateInput
    feedback?: MissionFeedbackOrderByRelationAggregateInput
    interventions?: InterventionRecommendationOrderByRelationAggregateInput
  }

  export type MissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MissionWhereInput | MissionWhereInput[]
    OR?: MissionWhereInput[]
    NOT?: MissionWhereInput | MissionWhereInput[]
    userId?: StringFilter<"Mission"> | string
    date?: DateTimeFilter<"Mission"> | Date | string
    status?: EnumMissionStatusFilter<"Mission"> | $Enums.MissionStatus
    estimatedMinutes?: IntFilter<"Mission"> | number
    completedAt?: DateTimeNullableFilter<"Mission"> | Date | string | null
    actualMinutes?: IntNullableFilter<"Mission"> | number | null
    completedObjectivesCount?: IntFilter<"Mission"> | number
    objectives?: JsonFilter<"Mission">
    reviewCardCount?: IntFilter<"Mission"> | number
    newContentCount?: IntFilter<"Mission"> | number
    successScore?: FloatNullableFilter<"Mission"> | number | null
    difficultyRating?: IntNullableFilter<"Mission"> | number | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    studySessions?: StudySessionListRelationFilter
    feedback?: MissionFeedbackListRelationFilter
    interventions?: InterventionRecommendationListRelationFilter
  }, "id">

  export type MissionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    estimatedMinutes?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    actualMinutes?: SortOrderInput | SortOrder
    completedObjectivesCount?: SortOrder
    objectives?: SortOrder
    reviewCardCount?: SortOrder
    newContentCount?: SortOrder
    successScore?: SortOrderInput | SortOrder
    difficultyRating?: SortOrderInput | SortOrder
    _count?: MissionCountOrderByAggregateInput
    _avg?: MissionAvgOrderByAggregateInput
    _max?: MissionMaxOrderByAggregateInput
    _min?: MissionMinOrderByAggregateInput
    _sum?: MissionSumOrderByAggregateInput
  }

  export type MissionScalarWhereWithAggregatesInput = {
    AND?: MissionScalarWhereWithAggregatesInput | MissionScalarWhereWithAggregatesInput[]
    OR?: MissionScalarWhereWithAggregatesInput[]
    NOT?: MissionScalarWhereWithAggregatesInput | MissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Mission"> | string
    userId?: StringWithAggregatesFilter<"Mission"> | string
    date?: DateTimeWithAggregatesFilter<"Mission"> | Date | string
    status?: EnumMissionStatusWithAggregatesFilter<"Mission"> | $Enums.MissionStatus
    estimatedMinutes?: IntWithAggregatesFilter<"Mission"> | number
    completedAt?: DateTimeNullableWithAggregatesFilter<"Mission"> | Date | string | null
    actualMinutes?: IntNullableWithAggregatesFilter<"Mission"> | number | null
    completedObjectivesCount?: IntWithAggregatesFilter<"Mission"> | number
    objectives?: JsonWithAggregatesFilter<"Mission">
    reviewCardCount?: IntWithAggregatesFilter<"Mission"> | number
    newContentCount?: IntWithAggregatesFilter<"Mission"> | number
    successScore?: FloatNullableWithAggregatesFilter<"Mission"> | number | null
    difficultyRating?: IntNullableWithAggregatesFilter<"Mission"> | number | null
  }

  export type CardWhereInput = {
    AND?: CardWhereInput | CardWhereInput[]
    OR?: CardWhereInput[]
    NOT?: CardWhereInput | CardWhereInput[]
    id?: StringFilter<"Card"> | string
    courseId?: StringFilter<"Card"> | string
    lectureId?: StringNullableFilter<"Card"> | string | null
    objectiveId?: StringNullableFilter<"Card"> | string | null
    front?: StringFilter<"Card"> | string
    back?: StringFilter<"Card"> | string
    cardType?: EnumCardTypeFilter<"Card"> | $Enums.CardType
    createdAt?: DateTimeFilter<"Card"> | Date | string
    difficulty?: FloatFilter<"Card"> | number
    stability?: FloatFilter<"Card"> | number
    retrievability?: FloatFilter<"Card"> | number
    lastReviewedAt?: DateTimeNullableFilter<"Card"> | Date | string | null
    nextReviewAt?: DateTimeNullableFilter<"Card"> | Date | string | null
    reviewCount?: IntFilter<"Card"> | number
    lapseCount?: IntFilter<"Card"> | number
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    lecture?: XOR<LectureNullableRelationFilter, LectureWhereInput> | null
    objective?: XOR<LearningObjectiveNullableRelationFilter, LearningObjectiveWhereInput> | null
    reviews?: ReviewListRelationFilter
  }

  export type CardOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    lectureId?: SortOrderInput | SortOrder
    objectiveId?: SortOrderInput | SortOrder
    front?: SortOrder
    back?: SortOrder
    cardType?: SortOrder
    createdAt?: SortOrder
    difficulty?: SortOrder
    stability?: SortOrder
    retrievability?: SortOrder
    lastReviewedAt?: SortOrderInput | SortOrder
    nextReviewAt?: SortOrderInput | SortOrder
    reviewCount?: SortOrder
    lapseCount?: SortOrder
    course?: CourseOrderByWithRelationInput
    lecture?: LectureOrderByWithRelationInput
    objective?: LearningObjectiveOrderByWithRelationInput
    reviews?: ReviewOrderByRelationAggregateInput
  }

  export type CardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CardWhereInput | CardWhereInput[]
    OR?: CardWhereInput[]
    NOT?: CardWhereInput | CardWhereInput[]
    courseId?: StringFilter<"Card"> | string
    lectureId?: StringNullableFilter<"Card"> | string | null
    objectiveId?: StringNullableFilter<"Card"> | string | null
    front?: StringFilter<"Card"> | string
    back?: StringFilter<"Card"> | string
    cardType?: EnumCardTypeFilter<"Card"> | $Enums.CardType
    createdAt?: DateTimeFilter<"Card"> | Date | string
    difficulty?: FloatFilter<"Card"> | number
    stability?: FloatFilter<"Card"> | number
    retrievability?: FloatFilter<"Card"> | number
    lastReviewedAt?: DateTimeNullableFilter<"Card"> | Date | string | null
    nextReviewAt?: DateTimeNullableFilter<"Card"> | Date | string | null
    reviewCount?: IntFilter<"Card"> | number
    lapseCount?: IntFilter<"Card"> | number
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    lecture?: XOR<LectureNullableRelationFilter, LectureWhereInput> | null
    objective?: XOR<LearningObjectiveNullableRelationFilter, LearningObjectiveWhereInput> | null
    reviews?: ReviewListRelationFilter
  }, "id">

  export type CardOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    lectureId?: SortOrderInput | SortOrder
    objectiveId?: SortOrderInput | SortOrder
    front?: SortOrder
    back?: SortOrder
    cardType?: SortOrder
    createdAt?: SortOrder
    difficulty?: SortOrder
    stability?: SortOrder
    retrievability?: SortOrder
    lastReviewedAt?: SortOrderInput | SortOrder
    nextReviewAt?: SortOrderInput | SortOrder
    reviewCount?: SortOrder
    lapseCount?: SortOrder
    _count?: CardCountOrderByAggregateInput
    _avg?: CardAvgOrderByAggregateInput
    _max?: CardMaxOrderByAggregateInput
    _min?: CardMinOrderByAggregateInput
    _sum?: CardSumOrderByAggregateInput
  }

  export type CardScalarWhereWithAggregatesInput = {
    AND?: CardScalarWhereWithAggregatesInput | CardScalarWhereWithAggregatesInput[]
    OR?: CardScalarWhereWithAggregatesInput[]
    NOT?: CardScalarWhereWithAggregatesInput | CardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Card"> | string
    courseId?: StringWithAggregatesFilter<"Card"> | string
    lectureId?: StringNullableWithAggregatesFilter<"Card"> | string | null
    objectiveId?: StringNullableWithAggregatesFilter<"Card"> | string | null
    front?: StringWithAggregatesFilter<"Card"> | string
    back?: StringWithAggregatesFilter<"Card"> | string
    cardType?: EnumCardTypeWithAggregatesFilter<"Card"> | $Enums.CardType
    createdAt?: DateTimeWithAggregatesFilter<"Card"> | Date | string
    difficulty?: FloatWithAggregatesFilter<"Card"> | number
    stability?: FloatWithAggregatesFilter<"Card"> | number
    retrievability?: FloatWithAggregatesFilter<"Card"> | number
    lastReviewedAt?: DateTimeNullableWithAggregatesFilter<"Card"> | Date | string | null
    nextReviewAt?: DateTimeNullableWithAggregatesFilter<"Card"> | Date | string | null
    reviewCount?: IntWithAggregatesFilter<"Card"> | number
    lapseCount?: IntWithAggregatesFilter<"Card"> | number
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    cardId?: StringFilter<"Review"> | string
    sessionId?: StringNullableFilter<"Review"> | string | null
    rating?: EnumReviewRatingFilter<"Review"> | $Enums.ReviewRating
    timeSpentMs?: IntFilter<"Review"> | number
    reviewedAt?: DateTimeFilter<"Review"> | Date | string
    difficultyBefore?: FloatFilter<"Review"> | number
    stabilityBefore?: FloatFilter<"Review"> | number
    difficultyAfter?: FloatFilter<"Review"> | number
    stabilityAfter?: FloatFilter<"Review"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    card?: XOR<CardRelationFilter, CardWhereInput>
    session?: XOR<StudySessionNullableRelationFilter, StudySessionWhereInput> | null
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    cardId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    rating?: SortOrder
    timeSpentMs?: SortOrder
    reviewedAt?: SortOrder
    difficultyBefore?: SortOrder
    stabilityBefore?: SortOrder
    difficultyAfter?: SortOrder
    stabilityAfter?: SortOrder
    user?: UserOrderByWithRelationInput
    card?: CardOrderByWithRelationInput
    session?: StudySessionOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    userId?: StringFilter<"Review"> | string
    cardId?: StringFilter<"Review"> | string
    sessionId?: StringNullableFilter<"Review"> | string | null
    rating?: EnumReviewRatingFilter<"Review"> | $Enums.ReviewRating
    timeSpentMs?: IntFilter<"Review"> | number
    reviewedAt?: DateTimeFilter<"Review"> | Date | string
    difficultyBefore?: FloatFilter<"Review"> | number
    stabilityBefore?: FloatFilter<"Review"> | number
    difficultyAfter?: FloatFilter<"Review"> | number
    stabilityAfter?: FloatFilter<"Review"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    card?: XOR<CardRelationFilter, CardWhereInput>
    session?: XOR<StudySessionNullableRelationFilter, StudySessionWhereInput> | null
  }, "id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    cardId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    rating?: SortOrder
    timeSpentMs?: SortOrder
    reviewedAt?: SortOrder
    difficultyBefore?: SortOrder
    stabilityBefore?: SortOrder
    difficultyAfter?: SortOrder
    stabilityAfter?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    userId?: StringWithAggregatesFilter<"Review"> | string
    cardId?: StringWithAggregatesFilter<"Review"> | string
    sessionId?: StringNullableWithAggregatesFilter<"Review"> | string | null
    rating?: EnumReviewRatingWithAggregatesFilter<"Review"> | $Enums.ReviewRating
    timeSpentMs?: IntWithAggregatesFilter<"Review"> | number
    reviewedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    difficultyBefore?: FloatWithAggregatesFilter<"Review"> | number
    stabilityBefore?: FloatWithAggregatesFilter<"Review"> | number
    difficultyAfter?: FloatWithAggregatesFilter<"Review"> | number
    stabilityAfter?: FloatWithAggregatesFilter<"Review"> | number
  }

  export type StudySessionWhereInput = {
    AND?: StudySessionWhereInput | StudySessionWhereInput[]
    OR?: StudySessionWhereInput[]
    NOT?: StudySessionWhereInput | StudySessionWhereInput[]
    id?: StringFilter<"StudySession"> | string
    userId?: StringFilter<"StudySession"> | string
    missionId?: StringNullableFilter<"StudySession"> | string | null
    startedAt?: DateTimeFilter<"StudySession"> | Date | string
    completedAt?: DateTimeNullableFilter<"StudySession"> | Date | string | null
    durationMs?: IntNullableFilter<"StudySession"> | number | null
    reviewsCompleted?: IntFilter<"StudySession"> | number
    newCardsStudied?: IntFilter<"StudySession"> | number
    sessionNotes?: StringNullableFilter<"StudySession"> | string | null
    currentObjectiveIndex?: IntFilter<"StudySession"> | number
    missionObjectives?: JsonNullableFilter<"StudySession">
    objectiveCompletions?: JsonNullableFilter<"StudySession">
    user?: XOR<UserRelationFilter, UserWhereInput>
    mission?: XOR<MissionNullableRelationFilter, MissionWhereInput> | null
    reviews?: ReviewListRelationFilter
    validationResponses?: ValidationResponseListRelationFilter
  }

  export type StudySessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    missionId?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    reviewsCompleted?: SortOrder
    newCardsStudied?: SortOrder
    sessionNotes?: SortOrderInput | SortOrder
    currentObjectiveIndex?: SortOrder
    missionObjectives?: SortOrderInput | SortOrder
    objectiveCompletions?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    mission?: MissionOrderByWithRelationInput
    reviews?: ReviewOrderByRelationAggregateInput
    validationResponses?: ValidationResponseOrderByRelationAggregateInput
  }

  export type StudySessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudySessionWhereInput | StudySessionWhereInput[]
    OR?: StudySessionWhereInput[]
    NOT?: StudySessionWhereInput | StudySessionWhereInput[]
    userId?: StringFilter<"StudySession"> | string
    missionId?: StringNullableFilter<"StudySession"> | string | null
    startedAt?: DateTimeFilter<"StudySession"> | Date | string
    completedAt?: DateTimeNullableFilter<"StudySession"> | Date | string | null
    durationMs?: IntNullableFilter<"StudySession"> | number | null
    reviewsCompleted?: IntFilter<"StudySession"> | number
    newCardsStudied?: IntFilter<"StudySession"> | number
    sessionNotes?: StringNullableFilter<"StudySession"> | string | null
    currentObjectiveIndex?: IntFilter<"StudySession"> | number
    missionObjectives?: JsonNullableFilter<"StudySession">
    objectiveCompletions?: JsonNullableFilter<"StudySession">
    user?: XOR<UserRelationFilter, UserWhereInput>
    mission?: XOR<MissionNullableRelationFilter, MissionWhereInput> | null
    reviews?: ReviewListRelationFilter
    validationResponses?: ValidationResponseListRelationFilter
  }, "id">

  export type StudySessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    missionId?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    reviewsCompleted?: SortOrder
    newCardsStudied?: SortOrder
    sessionNotes?: SortOrderInput | SortOrder
    currentObjectiveIndex?: SortOrder
    missionObjectives?: SortOrderInput | SortOrder
    objectiveCompletions?: SortOrderInput | SortOrder
    _count?: StudySessionCountOrderByAggregateInput
    _avg?: StudySessionAvgOrderByAggregateInput
    _max?: StudySessionMaxOrderByAggregateInput
    _min?: StudySessionMinOrderByAggregateInput
    _sum?: StudySessionSumOrderByAggregateInput
  }

  export type StudySessionScalarWhereWithAggregatesInput = {
    AND?: StudySessionScalarWhereWithAggregatesInput | StudySessionScalarWhereWithAggregatesInput[]
    OR?: StudySessionScalarWhereWithAggregatesInput[]
    NOT?: StudySessionScalarWhereWithAggregatesInput | StudySessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudySession"> | string
    userId?: StringWithAggregatesFilter<"StudySession"> | string
    missionId?: StringNullableWithAggregatesFilter<"StudySession"> | string | null
    startedAt?: DateTimeWithAggregatesFilter<"StudySession"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"StudySession"> | Date | string | null
    durationMs?: IntNullableWithAggregatesFilter<"StudySession"> | number | null
    reviewsCompleted?: IntWithAggregatesFilter<"StudySession"> | number
    newCardsStudied?: IntWithAggregatesFilter<"StudySession"> | number
    sessionNotes?: StringNullableWithAggregatesFilter<"StudySession"> | string | null
    currentObjectiveIndex?: IntWithAggregatesFilter<"StudySession"> | number
    missionObjectives?: JsonNullableWithAggregatesFilter<"StudySession">
    objectiveCompletions?: JsonNullableWithAggregatesFilter<"StudySession">
  }

  export type ConceptWhereInput = {
    AND?: ConceptWhereInput | ConceptWhereInput[]
    OR?: ConceptWhereInput[]
    NOT?: ConceptWhereInput | ConceptWhereInput[]
    id?: StringFilter<"Concept"> | string
    name?: StringFilter<"Concept"> | string
    description?: StringNullableFilter<"Concept"> | string | null
    category?: StringNullableFilter<"Concept"> | string | null
    createdAt?: DateTimeFilter<"Concept"> | Date | string
    relatedFrom?: ConceptRelationshipListRelationFilter
    relatedTo?: ConceptRelationshipListRelationFilter
  }

  export type ConceptOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    relatedFrom?: ConceptRelationshipOrderByRelationAggregateInput
    relatedTo?: ConceptRelationshipOrderByRelationAggregateInput
  }

  export type ConceptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ConceptWhereInput | ConceptWhereInput[]
    OR?: ConceptWhereInput[]
    NOT?: ConceptWhereInput | ConceptWhereInput[]
    description?: StringNullableFilter<"Concept"> | string | null
    category?: StringNullableFilter<"Concept"> | string | null
    createdAt?: DateTimeFilter<"Concept"> | Date | string
    relatedFrom?: ConceptRelationshipListRelationFilter
    relatedTo?: ConceptRelationshipListRelationFilter
  }, "id" | "name">

  export type ConceptOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ConceptCountOrderByAggregateInput
    _max?: ConceptMaxOrderByAggregateInput
    _min?: ConceptMinOrderByAggregateInput
  }

  export type ConceptScalarWhereWithAggregatesInput = {
    AND?: ConceptScalarWhereWithAggregatesInput | ConceptScalarWhereWithAggregatesInput[]
    OR?: ConceptScalarWhereWithAggregatesInput[]
    NOT?: ConceptScalarWhereWithAggregatesInput | ConceptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Concept"> | string
    name?: StringWithAggregatesFilter<"Concept"> | string
    description?: StringNullableWithAggregatesFilter<"Concept"> | string | null
    category?: StringNullableWithAggregatesFilter<"Concept"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Concept"> | Date | string
  }

  export type ConceptRelationshipWhereInput = {
    AND?: ConceptRelationshipWhereInput | ConceptRelationshipWhereInput[]
    OR?: ConceptRelationshipWhereInput[]
    NOT?: ConceptRelationshipWhereInput | ConceptRelationshipWhereInput[]
    id?: StringFilter<"ConceptRelationship"> | string
    fromConceptId?: StringFilter<"ConceptRelationship"> | string
    toConceptId?: StringFilter<"ConceptRelationship"> | string
    relationship?: EnumRelationshipTypeFilter<"ConceptRelationship"> | $Enums.RelationshipType
    strength?: FloatFilter<"ConceptRelationship"> | number
    createdAt?: DateTimeFilter<"ConceptRelationship"> | Date | string
    fromConcept?: XOR<ConceptRelationFilter, ConceptWhereInput>
    toConcept?: XOR<ConceptRelationFilter, ConceptWhereInput>
  }

  export type ConceptRelationshipOrderByWithRelationInput = {
    id?: SortOrder
    fromConceptId?: SortOrder
    toConceptId?: SortOrder
    relationship?: SortOrder
    strength?: SortOrder
    createdAt?: SortOrder
    fromConcept?: ConceptOrderByWithRelationInput
    toConcept?: ConceptOrderByWithRelationInput
  }

  export type ConceptRelationshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fromConceptId_toConceptId_relationship?: ConceptRelationshipFromConceptIdToConceptIdRelationshipCompoundUniqueInput
    AND?: ConceptRelationshipWhereInput | ConceptRelationshipWhereInput[]
    OR?: ConceptRelationshipWhereInput[]
    NOT?: ConceptRelationshipWhereInput | ConceptRelationshipWhereInput[]
    fromConceptId?: StringFilter<"ConceptRelationship"> | string
    toConceptId?: StringFilter<"ConceptRelationship"> | string
    relationship?: EnumRelationshipTypeFilter<"ConceptRelationship"> | $Enums.RelationshipType
    strength?: FloatFilter<"ConceptRelationship"> | number
    createdAt?: DateTimeFilter<"ConceptRelationship"> | Date | string
    fromConcept?: XOR<ConceptRelationFilter, ConceptWhereInput>
    toConcept?: XOR<ConceptRelationFilter, ConceptWhereInput>
  }, "id" | "fromConceptId_toConceptId_relationship">

  export type ConceptRelationshipOrderByWithAggregationInput = {
    id?: SortOrder
    fromConceptId?: SortOrder
    toConceptId?: SortOrder
    relationship?: SortOrder
    strength?: SortOrder
    createdAt?: SortOrder
    _count?: ConceptRelationshipCountOrderByAggregateInput
    _avg?: ConceptRelationshipAvgOrderByAggregateInput
    _max?: ConceptRelationshipMaxOrderByAggregateInput
    _min?: ConceptRelationshipMinOrderByAggregateInput
    _sum?: ConceptRelationshipSumOrderByAggregateInput
  }

  export type ConceptRelationshipScalarWhereWithAggregatesInput = {
    AND?: ConceptRelationshipScalarWhereWithAggregatesInput | ConceptRelationshipScalarWhereWithAggregatesInput[]
    OR?: ConceptRelationshipScalarWhereWithAggregatesInput[]
    NOT?: ConceptRelationshipScalarWhereWithAggregatesInput | ConceptRelationshipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConceptRelationship"> | string
    fromConceptId?: StringWithAggregatesFilter<"ConceptRelationship"> | string
    toConceptId?: StringWithAggregatesFilter<"ConceptRelationship"> | string
    relationship?: EnumRelationshipTypeWithAggregatesFilter<"ConceptRelationship"> | $Enums.RelationshipType
    strength?: FloatWithAggregatesFilter<"ConceptRelationship"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ConceptRelationship"> | Date | string
  }

  export type ValidationPromptWhereInput = {
    AND?: ValidationPromptWhereInput | ValidationPromptWhereInput[]
    OR?: ValidationPromptWhereInput[]
    NOT?: ValidationPromptWhereInput | ValidationPromptWhereInput[]
    id?: StringFilter<"ValidationPrompt"> | string
    promptText?: StringFilter<"ValidationPrompt"> | string
    promptType?: EnumPromptTypeFilter<"ValidationPrompt"> | $Enums.PromptType
    conceptName?: StringFilter<"ValidationPrompt"> | string
    expectedCriteria?: StringNullableListFilter<"ValidationPrompt">
    createdAt?: DateTimeFilter<"ValidationPrompt"> | Date | string
    responses?: ValidationResponseListRelationFilter
  }

  export type ValidationPromptOrderByWithRelationInput = {
    id?: SortOrder
    promptText?: SortOrder
    promptType?: SortOrder
    conceptName?: SortOrder
    expectedCriteria?: SortOrder
    createdAt?: SortOrder
    responses?: ValidationResponseOrderByRelationAggregateInput
  }

  export type ValidationPromptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ValidationPromptWhereInput | ValidationPromptWhereInput[]
    OR?: ValidationPromptWhereInput[]
    NOT?: ValidationPromptWhereInput | ValidationPromptWhereInput[]
    promptText?: StringFilter<"ValidationPrompt"> | string
    promptType?: EnumPromptTypeFilter<"ValidationPrompt"> | $Enums.PromptType
    conceptName?: StringFilter<"ValidationPrompt"> | string
    expectedCriteria?: StringNullableListFilter<"ValidationPrompt">
    createdAt?: DateTimeFilter<"ValidationPrompt"> | Date | string
    responses?: ValidationResponseListRelationFilter
  }, "id">

  export type ValidationPromptOrderByWithAggregationInput = {
    id?: SortOrder
    promptText?: SortOrder
    promptType?: SortOrder
    conceptName?: SortOrder
    expectedCriteria?: SortOrder
    createdAt?: SortOrder
    _count?: ValidationPromptCountOrderByAggregateInput
    _max?: ValidationPromptMaxOrderByAggregateInput
    _min?: ValidationPromptMinOrderByAggregateInput
  }

  export type ValidationPromptScalarWhereWithAggregatesInput = {
    AND?: ValidationPromptScalarWhereWithAggregatesInput | ValidationPromptScalarWhereWithAggregatesInput[]
    OR?: ValidationPromptScalarWhereWithAggregatesInput[]
    NOT?: ValidationPromptScalarWhereWithAggregatesInput | ValidationPromptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ValidationPrompt"> | string
    promptText?: StringWithAggregatesFilter<"ValidationPrompt"> | string
    promptType?: EnumPromptTypeWithAggregatesFilter<"ValidationPrompt"> | $Enums.PromptType
    conceptName?: StringWithAggregatesFilter<"ValidationPrompt"> | string
    expectedCriteria?: StringNullableListFilter<"ValidationPrompt">
    createdAt?: DateTimeWithAggregatesFilter<"ValidationPrompt"> | Date | string
  }

  export type ValidationResponseWhereInput = {
    AND?: ValidationResponseWhereInput | ValidationResponseWhereInput[]
    OR?: ValidationResponseWhereInput[]
    NOT?: ValidationResponseWhereInput | ValidationResponseWhereInput[]
    id?: StringFilter<"ValidationResponse"> | string
    promptId?: StringFilter<"ValidationResponse"> | string
    sessionId?: StringNullableFilter<"ValidationResponse"> | string | null
    userAnswer?: StringFilter<"ValidationResponse"> | string
    aiEvaluation?: StringFilter<"ValidationResponse"> | string
    score?: FloatFilter<"ValidationResponse"> | number
    confidence?: FloatNullableFilter<"ValidationResponse"> | number | null
    respondedAt?: DateTimeFilter<"ValidationResponse"> | Date | string
    prompt?: XOR<ValidationPromptRelationFilter, ValidationPromptWhereInput>
    session?: XOR<StudySessionNullableRelationFilter, StudySessionWhereInput> | null
  }

  export type ValidationResponseOrderByWithRelationInput = {
    id?: SortOrder
    promptId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    userAnswer?: SortOrder
    aiEvaluation?: SortOrder
    score?: SortOrder
    confidence?: SortOrderInput | SortOrder
    respondedAt?: SortOrder
    prompt?: ValidationPromptOrderByWithRelationInput
    session?: StudySessionOrderByWithRelationInput
  }

  export type ValidationResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ValidationResponseWhereInput | ValidationResponseWhereInput[]
    OR?: ValidationResponseWhereInput[]
    NOT?: ValidationResponseWhereInput | ValidationResponseWhereInput[]
    promptId?: StringFilter<"ValidationResponse"> | string
    sessionId?: StringNullableFilter<"ValidationResponse"> | string | null
    userAnswer?: StringFilter<"ValidationResponse"> | string
    aiEvaluation?: StringFilter<"ValidationResponse"> | string
    score?: FloatFilter<"ValidationResponse"> | number
    confidence?: FloatNullableFilter<"ValidationResponse"> | number | null
    respondedAt?: DateTimeFilter<"ValidationResponse"> | Date | string
    prompt?: XOR<ValidationPromptRelationFilter, ValidationPromptWhereInput>
    session?: XOR<StudySessionNullableRelationFilter, StudySessionWhereInput> | null
  }, "id">

  export type ValidationResponseOrderByWithAggregationInput = {
    id?: SortOrder
    promptId?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    userAnswer?: SortOrder
    aiEvaluation?: SortOrder
    score?: SortOrder
    confidence?: SortOrderInput | SortOrder
    respondedAt?: SortOrder
    _count?: ValidationResponseCountOrderByAggregateInput
    _avg?: ValidationResponseAvgOrderByAggregateInput
    _max?: ValidationResponseMaxOrderByAggregateInput
    _min?: ValidationResponseMinOrderByAggregateInput
    _sum?: ValidationResponseSumOrderByAggregateInput
  }

  export type ValidationResponseScalarWhereWithAggregatesInput = {
    AND?: ValidationResponseScalarWhereWithAggregatesInput | ValidationResponseScalarWhereWithAggregatesInput[]
    OR?: ValidationResponseScalarWhereWithAggregatesInput[]
    NOT?: ValidationResponseScalarWhereWithAggregatesInput | ValidationResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ValidationResponse"> | string
    promptId?: StringWithAggregatesFilter<"ValidationResponse"> | string
    sessionId?: StringNullableWithAggregatesFilter<"ValidationResponse"> | string | null
    userAnswer?: StringWithAggregatesFilter<"ValidationResponse"> | string
    aiEvaluation?: StringWithAggregatesFilter<"ValidationResponse"> | string
    score?: FloatWithAggregatesFilter<"ValidationResponse"> | number
    confidence?: FloatNullableWithAggregatesFilter<"ValidationResponse"> | number | null
    respondedAt?: DateTimeWithAggregatesFilter<"ValidationResponse"> | Date | string
  }

  export type ComprehensionMetricWhereInput = {
    AND?: ComprehensionMetricWhereInput | ComprehensionMetricWhereInput[]
    OR?: ComprehensionMetricWhereInput[]
    NOT?: ComprehensionMetricWhereInput | ComprehensionMetricWhereInput[]
    id?: StringFilter<"ComprehensionMetric"> | string
    conceptName?: StringFilter<"ComprehensionMetric"> | string
    date?: DateTimeFilter<"ComprehensionMetric"> | Date | string
    avgScore?: FloatFilter<"ComprehensionMetric"> | number
    sampleSize?: IntFilter<"ComprehensionMetric"> | number
    trend?: StringNullableFilter<"ComprehensionMetric"> | string | null
  }

  export type ComprehensionMetricOrderByWithRelationInput = {
    id?: SortOrder
    conceptName?: SortOrder
    date?: SortOrder
    avgScore?: SortOrder
    sampleSize?: SortOrder
    trend?: SortOrderInput | SortOrder
  }

  export type ComprehensionMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conceptName_date?: ComprehensionMetricConceptNameDateCompoundUniqueInput
    AND?: ComprehensionMetricWhereInput | ComprehensionMetricWhereInput[]
    OR?: ComprehensionMetricWhereInput[]
    NOT?: ComprehensionMetricWhereInput | ComprehensionMetricWhereInput[]
    conceptName?: StringFilter<"ComprehensionMetric"> | string
    date?: DateTimeFilter<"ComprehensionMetric"> | Date | string
    avgScore?: FloatFilter<"ComprehensionMetric"> | number
    sampleSize?: IntFilter<"ComprehensionMetric"> | number
    trend?: StringNullableFilter<"ComprehensionMetric"> | string | null
  }, "id" | "conceptName_date">

  export type ComprehensionMetricOrderByWithAggregationInput = {
    id?: SortOrder
    conceptName?: SortOrder
    date?: SortOrder
    avgScore?: SortOrder
    sampleSize?: SortOrder
    trend?: SortOrderInput | SortOrder
    _count?: ComprehensionMetricCountOrderByAggregateInput
    _avg?: ComprehensionMetricAvgOrderByAggregateInput
    _max?: ComprehensionMetricMaxOrderByAggregateInput
    _min?: ComprehensionMetricMinOrderByAggregateInput
    _sum?: ComprehensionMetricSumOrderByAggregateInput
  }

  export type ComprehensionMetricScalarWhereWithAggregatesInput = {
    AND?: ComprehensionMetricScalarWhereWithAggregatesInput | ComprehensionMetricScalarWhereWithAggregatesInput[]
    OR?: ComprehensionMetricScalarWhereWithAggregatesInput[]
    NOT?: ComprehensionMetricScalarWhereWithAggregatesInput | ComprehensionMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ComprehensionMetric"> | string
    conceptName?: StringWithAggregatesFilter<"ComprehensionMetric"> | string
    date?: DateTimeWithAggregatesFilter<"ComprehensionMetric"> | Date | string
    avgScore?: FloatWithAggregatesFilter<"ComprehensionMetric"> | number
    sampleSize?: IntWithAggregatesFilter<"ComprehensionMetric"> | number
    trend?: StringNullableWithAggregatesFilter<"ComprehensionMetric"> | string | null
  }

  export type BehavioralEventWhereInput = {
    AND?: BehavioralEventWhereInput | BehavioralEventWhereInput[]
    OR?: BehavioralEventWhereInput[]
    NOT?: BehavioralEventWhereInput | BehavioralEventWhereInput[]
    id?: StringFilter<"BehavioralEvent"> | string
    userId?: StringFilter<"BehavioralEvent"> | string
    eventType?: EnumEventTypeFilter<"BehavioralEvent"> | $Enums.EventType
    eventData?: JsonFilter<"BehavioralEvent">
    timestamp?: DateTimeFilter<"BehavioralEvent"> | Date | string
    sessionPerformanceScore?: IntNullableFilter<"BehavioralEvent"> | number | null
    engagementLevel?: EnumEngagementLevelNullableFilter<"BehavioralEvent"> | $Enums.EngagementLevel | null
    completionQuality?: EnumCompletionQualityNullableFilter<"BehavioralEvent"> | $Enums.CompletionQuality | null
    timeOfDay?: IntNullableFilter<"BehavioralEvent"> | number | null
    dayOfWeek?: IntNullableFilter<"BehavioralEvent"> | number | null
    contentType?: StringNullableFilter<"BehavioralEvent"> | string | null
    difficultyLevel?: StringNullableFilter<"BehavioralEvent"> | string | null
  }

  export type BehavioralEventOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    eventData?: SortOrder
    timestamp?: SortOrder
    sessionPerformanceScore?: SortOrderInput | SortOrder
    engagementLevel?: SortOrderInput | SortOrder
    completionQuality?: SortOrderInput | SortOrder
    timeOfDay?: SortOrderInput | SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    contentType?: SortOrderInput | SortOrder
    difficultyLevel?: SortOrderInput | SortOrder
  }

  export type BehavioralEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BehavioralEventWhereInput | BehavioralEventWhereInput[]
    OR?: BehavioralEventWhereInput[]
    NOT?: BehavioralEventWhereInput | BehavioralEventWhereInput[]
    userId?: StringFilter<"BehavioralEvent"> | string
    eventType?: EnumEventTypeFilter<"BehavioralEvent"> | $Enums.EventType
    eventData?: JsonFilter<"BehavioralEvent">
    timestamp?: DateTimeFilter<"BehavioralEvent"> | Date | string
    sessionPerformanceScore?: IntNullableFilter<"BehavioralEvent"> | number | null
    engagementLevel?: EnumEngagementLevelNullableFilter<"BehavioralEvent"> | $Enums.EngagementLevel | null
    completionQuality?: EnumCompletionQualityNullableFilter<"BehavioralEvent"> | $Enums.CompletionQuality | null
    timeOfDay?: IntNullableFilter<"BehavioralEvent"> | number | null
    dayOfWeek?: IntNullableFilter<"BehavioralEvent"> | number | null
    contentType?: StringNullableFilter<"BehavioralEvent"> | string | null
    difficultyLevel?: StringNullableFilter<"BehavioralEvent"> | string | null
  }, "id">

  export type BehavioralEventOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    eventData?: SortOrder
    timestamp?: SortOrder
    sessionPerformanceScore?: SortOrderInput | SortOrder
    engagementLevel?: SortOrderInput | SortOrder
    completionQuality?: SortOrderInput | SortOrder
    timeOfDay?: SortOrderInput | SortOrder
    dayOfWeek?: SortOrderInput | SortOrder
    contentType?: SortOrderInput | SortOrder
    difficultyLevel?: SortOrderInput | SortOrder
    _count?: BehavioralEventCountOrderByAggregateInput
    _avg?: BehavioralEventAvgOrderByAggregateInput
    _max?: BehavioralEventMaxOrderByAggregateInput
    _min?: BehavioralEventMinOrderByAggregateInput
    _sum?: BehavioralEventSumOrderByAggregateInput
  }

  export type BehavioralEventScalarWhereWithAggregatesInput = {
    AND?: BehavioralEventScalarWhereWithAggregatesInput | BehavioralEventScalarWhereWithAggregatesInput[]
    OR?: BehavioralEventScalarWhereWithAggregatesInput[]
    NOT?: BehavioralEventScalarWhereWithAggregatesInput | BehavioralEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BehavioralEvent"> | string
    userId?: StringWithAggregatesFilter<"BehavioralEvent"> | string
    eventType?: EnumEventTypeWithAggregatesFilter<"BehavioralEvent"> | $Enums.EventType
    eventData?: JsonWithAggregatesFilter<"BehavioralEvent">
    timestamp?: DateTimeWithAggregatesFilter<"BehavioralEvent"> | Date | string
    sessionPerformanceScore?: IntNullableWithAggregatesFilter<"BehavioralEvent"> | number | null
    engagementLevel?: EnumEngagementLevelNullableWithAggregatesFilter<"BehavioralEvent"> | $Enums.EngagementLevel | null
    completionQuality?: EnumCompletionQualityNullableWithAggregatesFilter<"BehavioralEvent"> | $Enums.CompletionQuality | null
    timeOfDay?: IntNullableWithAggregatesFilter<"BehavioralEvent"> | number | null
    dayOfWeek?: IntNullableWithAggregatesFilter<"BehavioralEvent"> | number | null
    contentType?: StringNullableWithAggregatesFilter<"BehavioralEvent"> | string | null
    difficultyLevel?: StringNullableWithAggregatesFilter<"BehavioralEvent"> | string | null
  }

  export type BehavioralPatternWhereInput = {
    AND?: BehavioralPatternWhereInput | BehavioralPatternWhereInput[]
    OR?: BehavioralPatternWhereInput[]
    NOT?: BehavioralPatternWhereInput | BehavioralPatternWhereInput[]
    id?: StringFilter<"BehavioralPattern"> | string
    userId?: StringFilter<"BehavioralPattern"> | string
    patternType?: EnumBehavioralPatternTypeFilter<"BehavioralPattern"> | $Enums.BehavioralPatternType
    patternName?: StringFilter<"BehavioralPattern"> | string
    confidence?: FloatFilter<"BehavioralPattern"> | number
    evidence?: JsonFilter<"BehavioralPattern">
    detectedAt?: DateTimeFilter<"BehavioralPattern"> | Date | string
    lastSeenAt?: DateTimeFilter<"BehavioralPattern"> | Date | string
    occurrenceCount?: IntFilter<"BehavioralPattern"> | number
    insights?: InsightPatternListRelationFilter
  }

  export type BehavioralPatternOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    patternType?: SortOrder
    patternName?: SortOrder
    confidence?: SortOrder
    evidence?: SortOrder
    detectedAt?: SortOrder
    lastSeenAt?: SortOrder
    occurrenceCount?: SortOrder
    insights?: InsightPatternOrderByRelationAggregateInput
  }

  export type BehavioralPatternWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BehavioralPatternWhereInput | BehavioralPatternWhereInput[]
    OR?: BehavioralPatternWhereInput[]
    NOT?: BehavioralPatternWhereInput | BehavioralPatternWhereInput[]
    userId?: StringFilter<"BehavioralPattern"> | string
    patternType?: EnumBehavioralPatternTypeFilter<"BehavioralPattern"> | $Enums.BehavioralPatternType
    patternName?: StringFilter<"BehavioralPattern"> | string
    confidence?: FloatFilter<"BehavioralPattern"> | number
    evidence?: JsonFilter<"BehavioralPattern">
    detectedAt?: DateTimeFilter<"BehavioralPattern"> | Date | string
    lastSeenAt?: DateTimeFilter<"BehavioralPattern"> | Date | string
    occurrenceCount?: IntFilter<"BehavioralPattern"> | number
    insights?: InsightPatternListRelationFilter
  }, "id">

  export type BehavioralPatternOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    patternType?: SortOrder
    patternName?: SortOrder
    confidence?: SortOrder
    evidence?: SortOrder
    detectedAt?: SortOrder
    lastSeenAt?: SortOrder
    occurrenceCount?: SortOrder
    _count?: BehavioralPatternCountOrderByAggregateInput
    _avg?: BehavioralPatternAvgOrderByAggregateInput
    _max?: BehavioralPatternMaxOrderByAggregateInput
    _min?: BehavioralPatternMinOrderByAggregateInput
    _sum?: BehavioralPatternSumOrderByAggregateInput
  }

  export type BehavioralPatternScalarWhereWithAggregatesInput = {
    AND?: BehavioralPatternScalarWhereWithAggregatesInput | BehavioralPatternScalarWhereWithAggregatesInput[]
    OR?: BehavioralPatternScalarWhereWithAggregatesInput[]
    NOT?: BehavioralPatternScalarWhereWithAggregatesInput | BehavioralPatternScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BehavioralPattern"> | string
    userId?: StringWithAggregatesFilter<"BehavioralPattern"> | string
    patternType?: EnumBehavioralPatternTypeWithAggregatesFilter<"BehavioralPattern"> | $Enums.BehavioralPatternType
    patternName?: StringWithAggregatesFilter<"BehavioralPattern"> | string
    confidence?: FloatWithAggregatesFilter<"BehavioralPattern"> | number
    evidence?: JsonWithAggregatesFilter<"BehavioralPattern">
    detectedAt?: DateTimeWithAggregatesFilter<"BehavioralPattern"> | Date | string
    lastSeenAt?: DateTimeWithAggregatesFilter<"BehavioralPattern"> | Date | string
    occurrenceCount?: IntWithAggregatesFilter<"BehavioralPattern"> | number
  }

  export type BehavioralInsightWhereInput = {
    AND?: BehavioralInsightWhereInput | BehavioralInsightWhereInput[]
    OR?: BehavioralInsightWhereInput[]
    NOT?: BehavioralInsightWhereInput | BehavioralInsightWhereInput[]
    id?: StringFilter<"BehavioralInsight"> | string
    userId?: StringFilter<"BehavioralInsight"> | string
    insightType?: EnumInsightTypeFilter<"BehavioralInsight"> | $Enums.InsightType
    title?: StringFilter<"BehavioralInsight"> | string
    description?: StringFilter<"BehavioralInsight"> | string
    actionableRecommendation?: StringFilter<"BehavioralInsight"> | string
    confidence?: FloatFilter<"BehavioralInsight"> | number
    createdAt?: DateTimeFilter<"BehavioralInsight"> | Date | string
    acknowledgedAt?: DateTimeNullableFilter<"BehavioralInsight"> | Date | string | null
    applied?: BoolFilter<"BehavioralInsight"> | boolean
    patterns?: InsightPatternListRelationFilter
  }

  export type BehavioralInsightOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    insightType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    actionableRecommendation?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    applied?: SortOrder
    patterns?: InsightPatternOrderByRelationAggregateInput
  }

  export type BehavioralInsightWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BehavioralInsightWhereInput | BehavioralInsightWhereInput[]
    OR?: BehavioralInsightWhereInput[]
    NOT?: BehavioralInsightWhereInput | BehavioralInsightWhereInput[]
    userId?: StringFilter<"BehavioralInsight"> | string
    insightType?: EnumInsightTypeFilter<"BehavioralInsight"> | $Enums.InsightType
    title?: StringFilter<"BehavioralInsight"> | string
    description?: StringFilter<"BehavioralInsight"> | string
    actionableRecommendation?: StringFilter<"BehavioralInsight"> | string
    confidence?: FloatFilter<"BehavioralInsight"> | number
    createdAt?: DateTimeFilter<"BehavioralInsight"> | Date | string
    acknowledgedAt?: DateTimeNullableFilter<"BehavioralInsight"> | Date | string | null
    applied?: BoolFilter<"BehavioralInsight"> | boolean
    patterns?: InsightPatternListRelationFilter
  }, "id">

  export type BehavioralInsightOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    insightType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    actionableRecommendation?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    applied?: SortOrder
    _count?: BehavioralInsightCountOrderByAggregateInput
    _avg?: BehavioralInsightAvgOrderByAggregateInput
    _max?: BehavioralInsightMaxOrderByAggregateInput
    _min?: BehavioralInsightMinOrderByAggregateInput
    _sum?: BehavioralInsightSumOrderByAggregateInput
  }

  export type BehavioralInsightScalarWhereWithAggregatesInput = {
    AND?: BehavioralInsightScalarWhereWithAggregatesInput | BehavioralInsightScalarWhereWithAggregatesInput[]
    OR?: BehavioralInsightScalarWhereWithAggregatesInput[]
    NOT?: BehavioralInsightScalarWhereWithAggregatesInput | BehavioralInsightScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BehavioralInsight"> | string
    userId?: StringWithAggregatesFilter<"BehavioralInsight"> | string
    insightType?: EnumInsightTypeWithAggregatesFilter<"BehavioralInsight"> | $Enums.InsightType
    title?: StringWithAggregatesFilter<"BehavioralInsight"> | string
    description?: StringWithAggregatesFilter<"BehavioralInsight"> | string
    actionableRecommendation?: StringWithAggregatesFilter<"BehavioralInsight"> | string
    confidence?: FloatWithAggregatesFilter<"BehavioralInsight"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BehavioralInsight"> | Date | string
    acknowledgedAt?: DateTimeNullableWithAggregatesFilter<"BehavioralInsight"> | Date | string | null
    applied?: BoolWithAggregatesFilter<"BehavioralInsight"> | boolean
  }

  export type InsightPatternWhereInput = {
    AND?: InsightPatternWhereInput | InsightPatternWhereInput[]
    OR?: InsightPatternWhereInput[]
    NOT?: InsightPatternWhereInput | InsightPatternWhereInput[]
    id?: StringFilter<"InsightPattern"> | string
    insightId?: StringFilter<"InsightPattern"> | string
    patternId?: StringFilter<"InsightPattern"> | string
    insight?: XOR<BehavioralInsightRelationFilter, BehavioralInsightWhereInput>
    pattern?: XOR<BehavioralPatternRelationFilter, BehavioralPatternWhereInput>
  }

  export type InsightPatternOrderByWithRelationInput = {
    id?: SortOrder
    insightId?: SortOrder
    patternId?: SortOrder
    insight?: BehavioralInsightOrderByWithRelationInput
    pattern?: BehavioralPatternOrderByWithRelationInput
  }

  export type InsightPatternWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    insightId_patternId?: InsightPatternInsightIdPatternIdCompoundUniqueInput
    AND?: InsightPatternWhereInput | InsightPatternWhereInput[]
    OR?: InsightPatternWhereInput[]
    NOT?: InsightPatternWhereInput | InsightPatternWhereInput[]
    insightId?: StringFilter<"InsightPattern"> | string
    patternId?: StringFilter<"InsightPattern"> | string
    insight?: XOR<BehavioralInsightRelationFilter, BehavioralInsightWhereInput>
    pattern?: XOR<BehavioralPatternRelationFilter, BehavioralPatternWhereInput>
  }, "id" | "insightId_patternId">

  export type InsightPatternOrderByWithAggregationInput = {
    id?: SortOrder
    insightId?: SortOrder
    patternId?: SortOrder
    _count?: InsightPatternCountOrderByAggregateInput
    _max?: InsightPatternMaxOrderByAggregateInput
    _min?: InsightPatternMinOrderByAggregateInput
  }

  export type InsightPatternScalarWhereWithAggregatesInput = {
    AND?: InsightPatternScalarWhereWithAggregatesInput | InsightPatternScalarWhereWithAggregatesInput[]
    OR?: InsightPatternScalarWhereWithAggregatesInput[]
    NOT?: InsightPatternScalarWhereWithAggregatesInput | InsightPatternScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InsightPattern"> | string
    insightId?: StringWithAggregatesFilter<"InsightPattern"> | string
    patternId?: StringWithAggregatesFilter<"InsightPattern"> | string
  }

  export type UserLearningProfileWhereInput = {
    AND?: UserLearningProfileWhereInput | UserLearningProfileWhereInput[]
    OR?: UserLearningProfileWhereInput[]
    NOT?: UserLearningProfileWhereInput | UserLearningProfileWhereInput[]
    id?: StringFilter<"UserLearningProfile"> | string
    userId?: StringFilter<"UserLearningProfile"> | string
    preferredStudyTimes?: JsonFilter<"UserLearningProfile">
    averageSessionDuration?: IntFilter<"UserLearningProfile"> | number
    optimalSessionDuration?: IntFilter<"UserLearningProfile"> | number
    contentPreferences?: JsonFilter<"UserLearningProfile">
    learningStyleProfile?: JsonFilter<"UserLearningProfile">
    personalizedForgettingCurve?: JsonFilter<"UserLearningProfile">
    lastAnalyzedAt?: DateTimeFilter<"UserLearningProfile"> | Date | string
    dataQualityScore?: FloatFilter<"UserLearningProfile"> | number
  }

  export type UserLearningProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    preferredStudyTimes?: SortOrder
    averageSessionDuration?: SortOrder
    optimalSessionDuration?: SortOrder
    contentPreferences?: SortOrder
    learningStyleProfile?: SortOrder
    personalizedForgettingCurve?: SortOrder
    lastAnalyzedAt?: SortOrder
    dataQualityScore?: SortOrder
  }

  export type UserLearningProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserLearningProfileWhereInput | UserLearningProfileWhereInput[]
    OR?: UserLearningProfileWhereInput[]
    NOT?: UserLearningProfileWhereInput | UserLearningProfileWhereInput[]
    preferredStudyTimes?: JsonFilter<"UserLearningProfile">
    averageSessionDuration?: IntFilter<"UserLearningProfile"> | number
    optimalSessionDuration?: IntFilter<"UserLearningProfile"> | number
    contentPreferences?: JsonFilter<"UserLearningProfile">
    learningStyleProfile?: JsonFilter<"UserLearningProfile">
    personalizedForgettingCurve?: JsonFilter<"UserLearningProfile">
    lastAnalyzedAt?: DateTimeFilter<"UserLearningProfile"> | Date | string
    dataQualityScore?: FloatFilter<"UserLearningProfile"> | number
  }, "id" | "userId">

  export type UserLearningProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    preferredStudyTimes?: SortOrder
    averageSessionDuration?: SortOrder
    optimalSessionDuration?: SortOrder
    contentPreferences?: SortOrder
    learningStyleProfile?: SortOrder
    personalizedForgettingCurve?: SortOrder
    lastAnalyzedAt?: SortOrder
    dataQualityScore?: SortOrder
    _count?: UserLearningProfileCountOrderByAggregateInput
    _avg?: UserLearningProfileAvgOrderByAggregateInput
    _max?: UserLearningProfileMaxOrderByAggregateInput
    _min?: UserLearningProfileMinOrderByAggregateInput
    _sum?: UserLearningProfileSumOrderByAggregateInput
  }

  export type UserLearningProfileScalarWhereWithAggregatesInput = {
    AND?: UserLearningProfileScalarWhereWithAggregatesInput | UserLearningProfileScalarWhereWithAggregatesInput[]
    OR?: UserLearningProfileScalarWhereWithAggregatesInput[]
    NOT?: UserLearningProfileScalarWhereWithAggregatesInput | UserLearningProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserLearningProfile"> | string
    userId?: StringWithAggregatesFilter<"UserLearningProfile"> | string
    preferredStudyTimes?: JsonWithAggregatesFilter<"UserLearningProfile">
    averageSessionDuration?: IntWithAggregatesFilter<"UserLearningProfile"> | number
    optimalSessionDuration?: IntWithAggregatesFilter<"UserLearningProfile"> | number
    contentPreferences?: JsonWithAggregatesFilter<"UserLearningProfile">
    learningStyleProfile?: JsonWithAggregatesFilter<"UserLearningProfile">
    personalizedForgettingCurve?: JsonWithAggregatesFilter<"UserLearningProfile">
    lastAnalyzedAt?: DateTimeWithAggregatesFilter<"UserLearningProfile"> | Date | string
    dataQualityScore?: FloatWithAggregatesFilter<"UserLearningProfile"> | number
  }

  export type LearningPatternWhereInput = {
    AND?: LearningPatternWhereInput | LearningPatternWhereInput[]
    OR?: LearningPatternWhereInput[]
    NOT?: LearningPatternWhereInput | LearningPatternWhereInput[]
    id?: StringFilter<"LearningPattern"> | string
    userId?: StringFilter<"LearningPattern"> | string
    patternType?: EnumPatternTypeFilter<"LearningPattern"> | $Enums.PatternType
    patternData?: JsonFilter<"LearningPattern">
    confidence?: FloatFilter<"LearningPattern"> | number
    detectedAt?: DateTimeFilter<"LearningPattern"> | Date | string
    lastSeenAt?: DateTimeFilter<"LearningPattern"> | Date | string
  }

  export type LearningPatternOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    patternType?: SortOrder
    patternData?: SortOrder
    confidence?: SortOrder
    detectedAt?: SortOrder
    lastSeenAt?: SortOrder
  }

  export type LearningPatternWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LearningPatternWhereInput | LearningPatternWhereInput[]
    OR?: LearningPatternWhereInput[]
    NOT?: LearningPatternWhereInput | LearningPatternWhereInput[]
    userId?: StringFilter<"LearningPattern"> | string
    patternType?: EnumPatternTypeFilter<"LearningPattern"> | $Enums.PatternType
    patternData?: JsonFilter<"LearningPattern">
    confidence?: FloatFilter<"LearningPattern"> | number
    detectedAt?: DateTimeFilter<"LearningPattern"> | Date | string
    lastSeenAt?: DateTimeFilter<"LearningPattern"> | Date | string
  }, "id">

  export type LearningPatternOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    patternType?: SortOrder
    patternData?: SortOrder
    confidence?: SortOrder
    detectedAt?: SortOrder
    lastSeenAt?: SortOrder
    _count?: LearningPatternCountOrderByAggregateInput
    _avg?: LearningPatternAvgOrderByAggregateInput
    _max?: LearningPatternMaxOrderByAggregateInput
    _min?: LearningPatternMinOrderByAggregateInput
    _sum?: LearningPatternSumOrderByAggregateInput
  }

  export type LearningPatternScalarWhereWithAggregatesInput = {
    AND?: LearningPatternScalarWhereWithAggregatesInput | LearningPatternScalarWhereWithAggregatesInput[]
    OR?: LearningPatternScalarWhereWithAggregatesInput[]
    NOT?: LearningPatternScalarWhereWithAggregatesInput | LearningPatternScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LearningPattern"> | string
    userId?: StringWithAggregatesFilter<"LearningPattern"> | string
    patternType?: EnumPatternTypeWithAggregatesFilter<"LearningPattern"> | $Enums.PatternType
    patternData?: JsonWithAggregatesFilter<"LearningPattern">
    confidence?: FloatWithAggregatesFilter<"LearningPattern"> | number
    detectedAt?: DateTimeWithAggregatesFilter<"LearningPattern"> | Date | string
    lastSeenAt?: DateTimeWithAggregatesFilter<"LearningPattern"> | Date | string
  }

  export type PerformancePredictionWhereInput = {
    AND?: PerformancePredictionWhereInput | PerformancePredictionWhereInput[]
    OR?: PerformancePredictionWhereInput[]
    NOT?: PerformancePredictionWhereInput | PerformancePredictionWhereInput[]
    id?: StringFilter<"PerformancePrediction"> | string
    userId?: StringFilter<"PerformancePrediction"> | string
    predictedFor?: DateTimeFilter<"PerformancePrediction"> | Date | string
    predictionType?: StringFilter<"PerformancePrediction"> | string
    prediction?: JsonFilter<"PerformancePrediction">
    confidence?: FloatFilter<"PerformancePrediction"> | number
    createdAt?: DateTimeFilter<"PerformancePrediction"> | Date | string
  }

  export type PerformancePredictionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    predictedFor?: SortOrder
    predictionType?: SortOrder
    prediction?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
  }

  export type PerformancePredictionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PerformancePredictionWhereInput | PerformancePredictionWhereInput[]
    OR?: PerformancePredictionWhereInput[]
    NOT?: PerformancePredictionWhereInput | PerformancePredictionWhereInput[]
    userId?: StringFilter<"PerformancePrediction"> | string
    predictedFor?: DateTimeFilter<"PerformancePrediction"> | Date | string
    predictionType?: StringFilter<"PerformancePrediction"> | string
    prediction?: JsonFilter<"PerformancePrediction">
    confidence?: FloatFilter<"PerformancePrediction"> | number
    createdAt?: DateTimeFilter<"PerformancePrediction"> | Date | string
  }, "id">

  export type PerformancePredictionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    predictedFor?: SortOrder
    predictionType?: SortOrder
    prediction?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    _count?: PerformancePredictionCountOrderByAggregateInput
    _avg?: PerformancePredictionAvgOrderByAggregateInput
    _max?: PerformancePredictionMaxOrderByAggregateInput
    _min?: PerformancePredictionMinOrderByAggregateInput
    _sum?: PerformancePredictionSumOrderByAggregateInput
  }

  export type PerformancePredictionScalarWhereWithAggregatesInput = {
    AND?: PerformancePredictionScalarWhereWithAggregatesInput | PerformancePredictionScalarWhereWithAggregatesInput[]
    OR?: PerformancePredictionScalarWhereWithAggregatesInput[]
    NOT?: PerformancePredictionScalarWhereWithAggregatesInput | PerformancePredictionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PerformancePrediction"> | string
    userId?: StringWithAggregatesFilter<"PerformancePrediction"> | string
    predictedFor?: DateTimeWithAggregatesFilter<"PerformancePrediction"> | Date | string
    predictionType?: StringWithAggregatesFilter<"PerformancePrediction"> | string
    prediction?: JsonWithAggregatesFilter<"PerformancePrediction">
    confidence?: FloatWithAggregatesFilter<"PerformancePrediction"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PerformancePrediction"> | Date | string
  }

  export type StrugglePredictionWhereInput = {
    AND?: StrugglePredictionWhereInput | StrugglePredictionWhereInput[]
    OR?: StrugglePredictionWhereInput[]
    NOT?: StrugglePredictionWhereInput | StrugglePredictionWhereInput[]
    id?: StringFilter<"StrugglePrediction"> | string
    userId?: StringFilter<"StrugglePrediction"> | string
    learningObjectiveId?: StringNullableFilter<"StrugglePrediction"> | string | null
    topicId?: StringNullableFilter<"StrugglePrediction"> | string | null
    predictionDate?: DateTimeFilter<"StrugglePrediction"> | Date | string
    predictedStruggleProbability?: FloatFilter<"StrugglePrediction"> | number
    predictionConfidence?: FloatFilter<"StrugglePrediction"> | number
    predictionStatus?: EnumPredictionStatusFilter<"StrugglePrediction"> | $Enums.PredictionStatus
    actualOutcome?: BoolNullableFilter<"StrugglePrediction"> | boolean | null
    outcomeRecordedAt?: DateTimeNullableFilter<"StrugglePrediction"> | Date | string | null
    featureVector?: JsonFilter<"StrugglePrediction">
    learningObjective?: XOR<LearningObjectiveNullableRelationFilter, LearningObjectiveWhereInput> | null
    indicators?: StruggleIndicatorListRelationFilter
    interventions?: InterventionRecommendationListRelationFilter
    feedbacks?: PredictionFeedbackListRelationFilter
  }

  export type StrugglePredictionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    learningObjectiveId?: SortOrderInput | SortOrder
    topicId?: SortOrderInput | SortOrder
    predictionDate?: SortOrder
    predictedStruggleProbability?: SortOrder
    predictionConfidence?: SortOrder
    predictionStatus?: SortOrder
    actualOutcome?: SortOrderInput | SortOrder
    outcomeRecordedAt?: SortOrderInput | SortOrder
    featureVector?: SortOrder
    learningObjective?: LearningObjectiveOrderByWithRelationInput
    indicators?: StruggleIndicatorOrderByRelationAggregateInput
    interventions?: InterventionRecommendationOrderByRelationAggregateInput
    feedbacks?: PredictionFeedbackOrderByRelationAggregateInput
  }

  export type StrugglePredictionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StrugglePredictionWhereInput | StrugglePredictionWhereInput[]
    OR?: StrugglePredictionWhereInput[]
    NOT?: StrugglePredictionWhereInput | StrugglePredictionWhereInput[]
    userId?: StringFilter<"StrugglePrediction"> | string
    learningObjectiveId?: StringNullableFilter<"StrugglePrediction"> | string | null
    topicId?: StringNullableFilter<"StrugglePrediction"> | string | null
    predictionDate?: DateTimeFilter<"StrugglePrediction"> | Date | string
    predictedStruggleProbability?: FloatFilter<"StrugglePrediction"> | number
    predictionConfidence?: FloatFilter<"StrugglePrediction"> | number
    predictionStatus?: EnumPredictionStatusFilter<"StrugglePrediction"> | $Enums.PredictionStatus
    actualOutcome?: BoolNullableFilter<"StrugglePrediction"> | boolean | null
    outcomeRecordedAt?: DateTimeNullableFilter<"StrugglePrediction"> | Date | string | null
    featureVector?: JsonFilter<"StrugglePrediction">
    learningObjective?: XOR<LearningObjectiveNullableRelationFilter, LearningObjectiveWhereInput> | null
    indicators?: StruggleIndicatorListRelationFilter
    interventions?: InterventionRecommendationListRelationFilter
    feedbacks?: PredictionFeedbackListRelationFilter
  }, "id">

  export type StrugglePredictionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    learningObjectiveId?: SortOrderInput | SortOrder
    topicId?: SortOrderInput | SortOrder
    predictionDate?: SortOrder
    predictedStruggleProbability?: SortOrder
    predictionConfidence?: SortOrder
    predictionStatus?: SortOrder
    actualOutcome?: SortOrderInput | SortOrder
    outcomeRecordedAt?: SortOrderInput | SortOrder
    featureVector?: SortOrder
    _count?: StrugglePredictionCountOrderByAggregateInput
    _avg?: StrugglePredictionAvgOrderByAggregateInput
    _max?: StrugglePredictionMaxOrderByAggregateInput
    _min?: StrugglePredictionMinOrderByAggregateInput
    _sum?: StrugglePredictionSumOrderByAggregateInput
  }

  export type StrugglePredictionScalarWhereWithAggregatesInput = {
    AND?: StrugglePredictionScalarWhereWithAggregatesInput | StrugglePredictionScalarWhereWithAggregatesInput[]
    OR?: StrugglePredictionScalarWhereWithAggregatesInput[]
    NOT?: StrugglePredictionScalarWhereWithAggregatesInput | StrugglePredictionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StrugglePrediction"> | string
    userId?: StringWithAggregatesFilter<"StrugglePrediction"> | string
    learningObjectiveId?: StringNullableWithAggregatesFilter<"StrugglePrediction"> | string | null
    topicId?: StringNullableWithAggregatesFilter<"StrugglePrediction"> | string | null
    predictionDate?: DateTimeWithAggregatesFilter<"StrugglePrediction"> | Date | string
    predictedStruggleProbability?: FloatWithAggregatesFilter<"StrugglePrediction"> | number
    predictionConfidence?: FloatWithAggregatesFilter<"StrugglePrediction"> | number
    predictionStatus?: EnumPredictionStatusWithAggregatesFilter<"StrugglePrediction"> | $Enums.PredictionStatus
    actualOutcome?: BoolNullableWithAggregatesFilter<"StrugglePrediction"> | boolean | null
    outcomeRecordedAt?: DateTimeNullableWithAggregatesFilter<"StrugglePrediction"> | Date | string | null
    featureVector?: JsonWithAggregatesFilter<"StrugglePrediction">
  }

  export type StruggleIndicatorWhereInput = {
    AND?: StruggleIndicatorWhereInput | StruggleIndicatorWhereInput[]
    OR?: StruggleIndicatorWhereInput[]
    NOT?: StruggleIndicatorWhereInput | StruggleIndicatorWhereInput[]
    id?: StringFilter<"StruggleIndicator"> | string
    userId?: StringFilter<"StruggleIndicator"> | string
    predictionId?: StringNullableFilter<"StruggleIndicator"> | string | null
    learningObjectiveId?: StringFilter<"StruggleIndicator"> | string
    indicatorType?: EnumIndicatorTypeFilter<"StruggleIndicator"> | $Enums.IndicatorType
    severity?: EnumSeverityFilter<"StruggleIndicator"> | $Enums.Severity
    detectedAt?: DateTimeFilter<"StruggleIndicator"> | Date | string
    context?: JsonFilter<"StruggleIndicator">
    prediction?: XOR<StrugglePredictionNullableRelationFilter, StrugglePredictionWhereInput> | null
    learningObjective?: XOR<LearningObjectiveRelationFilter, LearningObjectiveWhereInput>
  }

  export type StruggleIndicatorOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    predictionId?: SortOrderInput | SortOrder
    learningObjectiveId?: SortOrder
    indicatorType?: SortOrder
    severity?: SortOrder
    detectedAt?: SortOrder
    context?: SortOrder
    prediction?: StrugglePredictionOrderByWithRelationInput
    learningObjective?: LearningObjectiveOrderByWithRelationInput
  }

  export type StruggleIndicatorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StruggleIndicatorWhereInput | StruggleIndicatorWhereInput[]
    OR?: StruggleIndicatorWhereInput[]
    NOT?: StruggleIndicatorWhereInput | StruggleIndicatorWhereInput[]
    userId?: StringFilter<"StruggleIndicator"> | string
    predictionId?: StringNullableFilter<"StruggleIndicator"> | string | null
    learningObjectiveId?: StringFilter<"StruggleIndicator"> | string
    indicatorType?: EnumIndicatorTypeFilter<"StruggleIndicator"> | $Enums.IndicatorType
    severity?: EnumSeverityFilter<"StruggleIndicator"> | $Enums.Severity
    detectedAt?: DateTimeFilter<"StruggleIndicator"> | Date | string
    context?: JsonFilter<"StruggleIndicator">
    prediction?: XOR<StrugglePredictionNullableRelationFilter, StrugglePredictionWhereInput> | null
    learningObjective?: XOR<LearningObjectiveRelationFilter, LearningObjectiveWhereInput>
  }, "id">

  export type StruggleIndicatorOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    predictionId?: SortOrderInput | SortOrder
    learningObjectiveId?: SortOrder
    indicatorType?: SortOrder
    severity?: SortOrder
    detectedAt?: SortOrder
    context?: SortOrder
    _count?: StruggleIndicatorCountOrderByAggregateInput
    _max?: StruggleIndicatorMaxOrderByAggregateInput
    _min?: StruggleIndicatorMinOrderByAggregateInput
  }

  export type StruggleIndicatorScalarWhereWithAggregatesInput = {
    AND?: StruggleIndicatorScalarWhereWithAggregatesInput | StruggleIndicatorScalarWhereWithAggregatesInput[]
    OR?: StruggleIndicatorScalarWhereWithAggregatesInput[]
    NOT?: StruggleIndicatorScalarWhereWithAggregatesInput | StruggleIndicatorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StruggleIndicator"> | string
    userId?: StringWithAggregatesFilter<"StruggleIndicator"> | string
    predictionId?: StringNullableWithAggregatesFilter<"StruggleIndicator"> | string | null
    learningObjectiveId?: StringWithAggregatesFilter<"StruggleIndicator"> | string
    indicatorType?: EnumIndicatorTypeWithAggregatesFilter<"StruggleIndicator"> | $Enums.IndicatorType
    severity?: EnumSeverityWithAggregatesFilter<"StruggleIndicator"> | $Enums.Severity
    detectedAt?: DateTimeWithAggregatesFilter<"StruggleIndicator"> | Date | string
    context?: JsonWithAggregatesFilter<"StruggleIndicator">
  }

  export type InterventionRecommendationWhereInput = {
    AND?: InterventionRecommendationWhereInput | InterventionRecommendationWhereInput[]
    OR?: InterventionRecommendationWhereInput[]
    NOT?: InterventionRecommendationWhereInput | InterventionRecommendationWhereInput[]
    id?: StringFilter<"InterventionRecommendation"> | string
    predictionId?: StringFilter<"InterventionRecommendation"> | string
    userId?: StringFilter<"InterventionRecommendation"> | string
    interventionType?: EnumInterventionTypeFilter<"InterventionRecommendation"> | $Enums.InterventionType
    description?: StringFilter<"InterventionRecommendation"> | string
    reasoning?: StringFilter<"InterventionRecommendation"> | string
    priority?: IntFilter<"InterventionRecommendation"> | number
    status?: EnumInterventionStatusFilter<"InterventionRecommendation"> | $Enums.InterventionStatus
    appliedAt?: DateTimeNullableFilter<"InterventionRecommendation"> | Date | string | null
    appliedToMissionId?: StringNullableFilter<"InterventionRecommendation"> | string | null
    effectiveness?: FloatNullableFilter<"InterventionRecommendation"> | number | null
    createdAt?: DateTimeFilter<"InterventionRecommendation"> | Date | string
    prediction?: XOR<StrugglePredictionRelationFilter, StrugglePredictionWhereInput>
    mission?: XOR<MissionNullableRelationFilter, MissionWhereInput> | null
  }

  export type InterventionRecommendationOrderByWithRelationInput = {
    id?: SortOrder
    predictionId?: SortOrder
    userId?: SortOrder
    interventionType?: SortOrder
    description?: SortOrder
    reasoning?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    appliedAt?: SortOrderInput | SortOrder
    appliedToMissionId?: SortOrderInput | SortOrder
    effectiveness?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    prediction?: StrugglePredictionOrderByWithRelationInput
    mission?: MissionOrderByWithRelationInput
  }

  export type InterventionRecommendationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InterventionRecommendationWhereInput | InterventionRecommendationWhereInput[]
    OR?: InterventionRecommendationWhereInput[]
    NOT?: InterventionRecommendationWhereInput | InterventionRecommendationWhereInput[]
    predictionId?: StringFilter<"InterventionRecommendation"> | string
    userId?: StringFilter<"InterventionRecommendation"> | string
    interventionType?: EnumInterventionTypeFilter<"InterventionRecommendation"> | $Enums.InterventionType
    description?: StringFilter<"InterventionRecommendation"> | string
    reasoning?: StringFilter<"InterventionRecommendation"> | string
    priority?: IntFilter<"InterventionRecommendation"> | number
    status?: EnumInterventionStatusFilter<"InterventionRecommendation"> | $Enums.InterventionStatus
    appliedAt?: DateTimeNullableFilter<"InterventionRecommendation"> | Date | string | null
    appliedToMissionId?: StringNullableFilter<"InterventionRecommendation"> | string | null
    effectiveness?: FloatNullableFilter<"InterventionRecommendation"> | number | null
    createdAt?: DateTimeFilter<"InterventionRecommendation"> | Date | string
    prediction?: XOR<StrugglePredictionRelationFilter, StrugglePredictionWhereInput>
    mission?: XOR<MissionNullableRelationFilter, MissionWhereInput> | null
  }, "id">

  export type InterventionRecommendationOrderByWithAggregationInput = {
    id?: SortOrder
    predictionId?: SortOrder
    userId?: SortOrder
    interventionType?: SortOrder
    description?: SortOrder
    reasoning?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    appliedAt?: SortOrderInput | SortOrder
    appliedToMissionId?: SortOrderInput | SortOrder
    effectiveness?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InterventionRecommendationCountOrderByAggregateInput
    _avg?: InterventionRecommendationAvgOrderByAggregateInput
    _max?: InterventionRecommendationMaxOrderByAggregateInput
    _min?: InterventionRecommendationMinOrderByAggregateInput
    _sum?: InterventionRecommendationSumOrderByAggregateInput
  }

  export type InterventionRecommendationScalarWhereWithAggregatesInput = {
    AND?: InterventionRecommendationScalarWhereWithAggregatesInput | InterventionRecommendationScalarWhereWithAggregatesInput[]
    OR?: InterventionRecommendationScalarWhereWithAggregatesInput[]
    NOT?: InterventionRecommendationScalarWhereWithAggregatesInput | InterventionRecommendationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InterventionRecommendation"> | string
    predictionId?: StringWithAggregatesFilter<"InterventionRecommendation"> | string
    userId?: StringWithAggregatesFilter<"InterventionRecommendation"> | string
    interventionType?: EnumInterventionTypeWithAggregatesFilter<"InterventionRecommendation"> | $Enums.InterventionType
    description?: StringWithAggregatesFilter<"InterventionRecommendation"> | string
    reasoning?: StringWithAggregatesFilter<"InterventionRecommendation"> | string
    priority?: IntWithAggregatesFilter<"InterventionRecommendation"> | number
    status?: EnumInterventionStatusWithAggregatesFilter<"InterventionRecommendation"> | $Enums.InterventionStatus
    appliedAt?: DateTimeNullableWithAggregatesFilter<"InterventionRecommendation"> | Date | string | null
    appliedToMissionId?: StringNullableWithAggregatesFilter<"InterventionRecommendation"> | string | null
    effectiveness?: FloatNullableWithAggregatesFilter<"InterventionRecommendation"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"InterventionRecommendation"> | Date | string
  }

  export type PredictionFeedbackWhereInput = {
    AND?: PredictionFeedbackWhereInput | PredictionFeedbackWhereInput[]
    OR?: PredictionFeedbackWhereInput[]
    NOT?: PredictionFeedbackWhereInput | PredictionFeedbackWhereInput[]
    id?: StringFilter<"PredictionFeedback"> | string
    predictionId?: StringFilter<"PredictionFeedback"> | string
    userId?: StringFilter<"PredictionFeedback"> | string
    feedbackType?: EnumFeedbackTypeFilter<"PredictionFeedback"> | $Enums.FeedbackType
    actualStruggle?: BoolFilter<"PredictionFeedback"> | boolean
    helpfulness?: IntNullableFilter<"PredictionFeedback"> | number | null
    comments?: StringNullableFilter<"PredictionFeedback"> | string | null
    submittedAt?: DateTimeFilter<"PredictionFeedback"> | Date | string
    prediction?: XOR<StrugglePredictionRelationFilter, StrugglePredictionWhereInput>
  }

  export type PredictionFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    predictionId?: SortOrder
    userId?: SortOrder
    feedbackType?: SortOrder
    actualStruggle?: SortOrder
    helpfulness?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    prediction?: StrugglePredictionOrderByWithRelationInput
  }

  export type PredictionFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PredictionFeedbackWhereInput | PredictionFeedbackWhereInput[]
    OR?: PredictionFeedbackWhereInput[]
    NOT?: PredictionFeedbackWhereInput | PredictionFeedbackWhereInput[]
    predictionId?: StringFilter<"PredictionFeedback"> | string
    userId?: StringFilter<"PredictionFeedback"> | string
    feedbackType?: EnumFeedbackTypeFilter<"PredictionFeedback"> | $Enums.FeedbackType
    actualStruggle?: BoolFilter<"PredictionFeedback"> | boolean
    helpfulness?: IntNullableFilter<"PredictionFeedback"> | number | null
    comments?: StringNullableFilter<"PredictionFeedback"> | string | null
    submittedAt?: DateTimeFilter<"PredictionFeedback"> | Date | string
    prediction?: XOR<StrugglePredictionRelationFilter, StrugglePredictionWhereInput>
  }, "id">

  export type PredictionFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    predictionId?: SortOrder
    userId?: SortOrder
    feedbackType?: SortOrder
    actualStruggle?: SortOrder
    helpfulness?: SortOrderInput | SortOrder
    comments?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    _count?: PredictionFeedbackCountOrderByAggregateInput
    _avg?: PredictionFeedbackAvgOrderByAggregateInput
    _max?: PredictionFeedbackMaxOrderByAggregateInput
    _min?: PredictionFeedbackMinOrderByAggregateInput
    _sum?: PredictionFeedbackSumOrderByAggregateInput
  }

  export type PredictionFeedbackScalarWhereWithAggregatesInput = {
    AND?: PredictionFeedbackScalarWhereWithAggregatesInput | PredictionFeedbackScalarWhereWithAggregatesInput[]
    OR?: PredictionFeedbackScalarWhereWithAggregatesInput[]
    NOT?: PredictionFeedbackScalarWhereWithAggregatesInput | PredictionFeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PredictionFeedback"> | string
    predictionId?: StringWithAggregatesFilter<"PredictionFeedback"> | string
    userId?: StringWithAggregatesFilter<"PredictionFeedback"> | string
    feedbackType?: EnumFeedbackTypeWithAggregatesFilter<"PredictionFeedback"> | $Enums.FeedbackType
    actualStruggle?: BoolWithAggregatesFilter<"PredictionFeedback"> | boolean
    helpfulness?: IntNullableWithAggregatesFilter<"PredictionFeedback"> | number | null
    comments?: StringNullableWithAggregatesFilter<"PredictionFeedback"> | string | null
    submittedAt?: DateTimeWithAggregatesFilter<"PredictionFeedback"> | Date | string
  }

  export type PerformanceMetricWhereInput = {
    AND?: PerformanceMetricWhereInput | PerformanceMetricWhereInput[]
    OR?: PerformanceMetricWhereInput[]
    NOT?: PerformanceMetricWhereInput | PerformanceMetricWhereInput[]
    id?: StringFilter<"PerformanceMetric"> | string
    userId?: StringFilter<"PerformanceMetric"> | string
    learningObjectiveId?: StringFilter<"PerformanceMetric"> | string
    date?: DateTimeFilter<"PerformanceMetric"> | Date | string
    retentionScore?: FloatFilter<"PerformanceMetric"> | number
    studyTimeMs?: IntFilter<"PerformanceMetric"> | number
    reviewCount?: IntFilter<"PerformanceMetric"> | number
    correctReviews?: IntFilter<"PerformanceMetric"> | number
    incorrectReviews?: IntFilter<"PerformanceMetric"> | number
    createdAt?: DateTimeFilter<"PerformanceMetric"> | Date | string
    learningObjective?: XOR<LearningObjectiveRelationFilter, LearningObjectiveWhereInput>
  }

  export type PerformanceMetricOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    learningObjectiveId?: SortOrder
    date?: SortOrder
    retentionScore?: SortOrder
    studyTimeMs?: SortOrder
    reviewCount?: SortOrder
    correctReviews?: SortOrder
    incorrectReviews?: SortOrder
    createdAt?: SortOrder
    learningObjective?: LearningObjectiveOrderByWithRelationInput
  }

  export type PerformanceMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_learningObjectiveId_date?: PerformanceMetricUserIdLearningObjectiveIdDateCompoundUniqueInput
    AND?: PerformanceMetricWhereInput | PerformanceMetricWhereInput[]
    OR?: PerformanceMetricWhereInput[]
    NOT?: PerformanceMetricWhereInput | PerformanceMetricWhereInput[]
    userId?: StringFilter<"PerformanceMetric"> | string
    learningObjectiveId?: StringFilter<"PerformanceMetric"> | string
    date?: DateTimeFilter<"PerformanceMetric"> | Date | string
    retentionScore?: FloatFilter<"PerformanceMetric"> | number
    studyTimeMs?: IntFilter<"PerformanceMetric"> | number
    reviewCount?: IntFilter<"PerformanceMetric"> | number
    correctReviews?: IntFilter<"PerformanceMetric"> | number
    incorrectReviews?: IntFilter<"PerformanceMetric"> | number
    createdAt?: DateTimeFilter<"PerformanceMetric"> | Date | string
    learningObjective?: XOR<LearningObjectiveRelationFilter, LearningObjectiveWhereInput>
  }, "id" | "userId_learningObjectiveId_date">

  export type PerformanceMetricOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    learningObjectiveId?: SortOrder
    date?: SortOrder
    retentionScore?: SortOrder
    studyTimeMs?: SortOrder
    reviewCount?: SortOrder
    correctReviews?: SortOrder
    incorrectReviews?: SortOrder
    createdAt?: SortOrder
    _count?: PerformanceMetricCountOrderByAggregateInput
    _avg?: PerformanceMetricAvgOrderByAggregateInput
    _max?: PerformanceMetricMaxOrderByAggregateInput
    _min?: PerformanceMetricMinOrderByAggregateInput
    _sum?: PerformanceMetricSumOrderByAggregateInput
  }

  export type PerformanceMetricScalarWhereWithAggregatesInput = {
    AND?: PerformanceMetricScalarWhereWithAggregatesInput | PerformanceMetricScalarWhereWithAggregatesInput[]
    OR?: PerformanceMetricScalarWhereWithAggregatesInput[]
    NOT?: PerformanceMetricScalarWhereWithAggregatesInput | PerformanceMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PerformanceMetric"> | string
    userId?: StringWithAggregatesFilter<"PerformanceMetric"> | string
    learningObjectiveId?: StringWithAggregatesFilter<"PerformanceMetric"> | string
    date?: DateTimeWithAggregatesFilter<"PerformanceMetric"> | Date | string
    retentionScore?: FloatWithAggregatesFilter<"PerformanceMetric"> | number
    studyTimeMs?: IntWithAggregatesFilter<"PerformanceMetric"> | number
    reviewCount?: IntWithAggregatesFilter<"PerformanceMetric"> | number
    correctReviews?: IntWithAggregatesFilter<"PerformanceMetric"> | number
    incorrectReviews?: IntWithAggregatesFilter<"PerformanceMetric"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PerformanceMetric"> | Date | string
  }

  export type ExamWhereInput = {
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    id?: StringFilter<"Exam"> | string
    userId?: StringFilter<"Exam"> | string
    name?: StringFilter<"Exam"> | string
    date?: DateTimeFilter<"Exam"> | Date | string
    courseId?: StringFilter<"Exam"> | string
    coverageTopics?: StringNullableListFilter<"Exam">
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }

  export type ExamOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    date?: SortOrder
    courseId?: SortOrder
    coverageTopics?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type ExamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    userId?: StringFilter<"Exam"> | string
    name?: StringFilter<"Exam"> | string
    date?: DateTimeFilter<"Exam"> | Date | string
    courseId?: StringFilter<"Exam"> | string
    coverageTopics?: StringNullableListFilter<"Exam">
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }, "id">

  export type ExamOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    date?: SortOrder
    courseId?: SortOrder
    coverageTopics?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExamCountOrderByAggregateInput
    _max?: ExamMaxOrderByAggregateInput
    _min?: ExamMinOrderByAggregateInput
  }

  export type ExamScalarWhereWithAggregatesInput = {
    AND?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    OR?: ExamScalarWhereWithAggregatesInput[]
    NOT?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Exam"> | string
    userId?: StringWithAggregatesFilter<"Exam"> | string
    name?: StringWithAggregatesFilter<"Exam"> | string
    date?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    courseId?: StringWithAggregatesFilter<"Exam"> | string
    coverageTopics?: StringNullableListFilter<"Exam">
    createdAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
  }

  export type CoursePriorityWhereInput = {
    AND?: CoursePriorityWhereInput | CoursePriorityWhereInput[]
    OR?: CoursePriorityWhereInput[]
    NOT?: CoursePriorityWhereInput | CoursePriorityWhereInput[]
    id?: StringFilter<"CoursePriority"> | string
    userId?: StringFilter<"CoursePriority"> | string
    courseId?: StringFilter<"CoursePriority"> | string
    priorityLevel?: EnumPriorityLevelFilter<"CoursePriority"> | $Enums.PriorityLevel
    createdAt?: DateTimeFilter<"CoursePriority"> | Date | string
    updatedAt?: DateTimeFilter<"CoursePriority"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }

  export type CoursePriorityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    priorityLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type CoursePriorityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_courseId?: CoursePriorityUserIdCourseIdCompoundUniqueInput
    AND?: CoursePriorityWhereInput | CoursePriorityWhereInput[]
    OR?: CoursePriorityWhereInput[]
    NOT?: CoursePriorityWhereInput | CoursePriorityWhereInput[]
    userId?: StringFilter<"CoursePriority"> | string
    courseId?: StringFilter<"CoursePriority"> | string
    priorityLevel?: EnumPriorityLevelFilter<"CoursePriority"> | $Enums.PriorityLevel
    createdAt?: DateTimeFilter<"CoursePriority"> | Date | string
    updatedAt?: DateTimeFilter<"CoursePriority"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }, "id" | "userId_courseId">

  export type CoursePriorityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    priorityLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CoursePriorityCountOrderByAggregateInput
    _max?: CoursePriorityMaxOrderByAggregateInput
    _min?: CoursePriorityMinOrderByAggregateInput
  }

  export type CoursePriorityScalarWhereWithAggregatesInput = {
    AND?: CoursePriorityScalarWhereWithAggregatesInput | CoursePriorityScalarWhereWithAggregatesInput[]
    OR?: CoursePriorityScalarWhereWithAggregatesInput[]
    NOT?: CoursePriorityScalarWhereWithAggregatesInput | CoursePriorityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CoursePriority"> | string
    userId?: StringWithAggregatesFilter<"CoursePriority"> | string
    courseId?: StringWithAggregatesFilter<"CoursePriority"> | string
    priorityLevel?: EnumPriorityLevelWithAggregatesFilter<"CoursePriority"> | $Enums.PriorityLevel
    createdAt?: DateTimeWithAggregatesFilter<"CoursePriority"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CoursePriority"> | Date | string
  }

  export type PriorityFeedbackWhereInput = {
    AND?: PriorityFeedbackWhereInput | PriorityFeedbackWhereInput[]
    OR?: PriorityFeedbackWhereInput[]
    NOT?: PriorityFeedbackWhereInput | PriorityFeedbackWhereInput[]
    id?: StringFilter<"PriorityFeedback"> | string
    userId?: StringFilter<"PriorityFeedback"> | string
    objectiveId?: StringFilter<"PriorityFeedback"> | string
    suggestedPriority?: FloatFilter<"PriorityFeedback"> | number
    userFeedback?: EnumFeedbackRatingFilter<"PriorityFeedback"> | $Enums.FeedbackRating
    notes?: StringNullableFilter<"PriorityFeedback"> | string | null
    createdAt?: DateTimeFilter<"PriorityFeedback"> | Date | string
    learningObjective?: XOR<LearningObjectiveRelationFilter, LearningObjectiveWhereInput>
  }

  export type PriorityFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    objectiveId?: SortOrder
    suggestedPriority?: SortOrder
    userFeedback?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    learningObjective?: LearningObjectiveOrderByWithRelationInput
  }

  export type PriorityFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PriorityFeedbackWhereInput | PriorityFeedbackWhereInput[]
    OR?: PriorityFeedbackWhereInput[]
    NOT?: PriorityFeedbackWhereInput | PriorityFeedbackWhereInput[]
    userId?: StringFilter<"PriorityFeedback"> | string
    objectiveId?: StringFilter<"PriorityFeedback"> | string
    suggestedPriority?: FloatFilter<"PriorityFeedback"> | number
    userFeedback?: EnumFeedbackRatingFilter<"PriorityFeedback"> | $Enums.FeedbackRating
    notes?: StringNullableFilter<"PriorityFeedback"> | string | null
    createdAt?: DateTimeFilter<"PriorityFeedback"> | Date | string
    learningObjective?: XOR<LearningObjectiveRelationFilter, LearningObjectiveWhereInput>
  }, "id">

  export type PriorityFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    objectiveId?: SortOrder
    suggestedPriority?: SortOrder
    userFeedback?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PriorityFeedbackCountOrderByAggregateInput
    _avg?: PriorityFeedbackAvgOrderByAggregateInput
    _max?: PriorityFeedbackMaxOrderByAggregateInput
    _min?: PriorityFeedbackMinOrderByAggregateInput
    _sum?: PriorityFeedbackSumOrderByAggregateInput
  }

  export type PriorityFeedbackScalarWhereWithAggregatesInput = {
    AND?: PriorityFeedbackScalarWhereWithAggregatesInput | PriorityFeedbackScalarWhereWithAggregatesInput[]
    OR?: PriorityFeedbackScalarWhereWithAggregatesInput[]
    NOT?: PriorityFeedbackScalarWhereWithAggregatesInput | PriorityFeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PriorityFeedback"> | string
    userId?: StringWithAggregatesFilter<"PriorityFeedback"> | string
    objectiveId?: StringWithAggregatesFilter<"PriorityFeedback"> | string
    suggestedPriority?: FloatWithAggregatesFilter<"PriorityFeedback"> | number
    userFeedback?: EnumFeedbackRatingWithAggregatesFilter<"PriorityFeedback"> | $Enums.FeedbackRating
    notes?: StringNullableWithAggregatesFilter<"PriorityFeedback"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PriorityFeedback"> | Date | string
  }

  export type StreakWhereInput = {
    AND?: StreakWhereInput | StreakWhereInput[]
    OR?: StreakWhereInput[]
    NOT?: StreakWhereInput | StreakWhereInput[]
    id?: StringFilter<"Streak"> | string
    userId?: StringFilter<"Streak"> | string
    currentStreak?: IntFilter<"Streak"> | number
    longestStreak?: IntFilter<"Streak"> | number
    lastStudyDate?: DateTimeNullableFilter<"Streak"> | Date | string | null
    freezesRemaining?: IntFilter<"Streak"> | number
    freezeUsedDates?: StringNullableListFilter<"Streak">
    createdAt?: DateTimeFilter<"Streak"> | Date | string
    updatedAt?: DateTimeFilter<"Streak"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type StreakOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastStudyDate?: SortOrderInput | SortOrder
    freezesRemaining?: SortOrder
    freezeUsedDates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type StreakWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: StreakWhereInput | StreakWhereInput[]
    OR?: StreakWhereInput[]
    NOT?: StreakWhereInput | StreakWhereInput[]
    currentStreak?: IntFilter<"Streak"> | number
    longestStreak?: IntFilter<"Streak"> | number
    lastStudyDate?: DateTimeNullableFilter<"Streak"> | Date | string | null
    freezesRemaining?: IntFilter<"Streak"> | number
    freezeUsedDates?: StringNullableListFilter<"Streak">
    createdAt?: DateTimeFilter<"Streak"> | Date | string
    updatedAt?: DateTimeFilter<"Streak"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type StreakOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastStudyDate?: SortOrderInput | SortOrder
    freezesRemaining?: SortOrder
    freezeUsedDates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StreakCountOrderByAggregateInput
    _avg?: StreakAvgOrderByAggregateInput
    _max?: StreakMaxOrderByAggregateInput
    _min?: StreakMinOrderByAggregateInput
    _sum?: StreakSumOrderByAggregateInput
  }

  export type StreakScalarWhereWithAggregatesInput = {
    AND?: StreakScalarWhereWithAggregatesInput | StreakScalarWhereWithAggregatesInput[]
    OR?: StreakScalarWhereWithAggregatesInput[]
    NOT?: StreakScalarWhereWithAggregatesInput | StreakScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Streak"> | string
    userId?: StringWithAggregatesFilter<"Streak"> | string
    currentStreak?: IntWithAggregatesFilter<"Streak"> | number
    longestStreak?: IntWithAggregatesFilter<"Streak"> | number
    lastStudyDate?: DateTimeNullableWithAggregatesFilter<"Streak"> | Date | string | null
    freezesRemaining?: IntWithAggregatesFilter<"Streak"> | number
    freezeUsedDates?: StringNullableListFilter<"Streak">
    createdAt?: DateTimeWithAggregatesFilter<"Streak"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Streak"> | Date | string
  }

  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: StringFilter<"Achievement"> | string
    userId?: StringFilter<"Achievement"> | string
    type?: EnumAchievementTypeFilter<"Achievement"> | $Enums.AchievementType
    name?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    tier?: EnumAchievementTierFilter<"Achievement"> | $Enums.AchievementTier
    earnedAt?: DateTimeFilter<"Achievement"> | Date | string
    metadata?: JsonNullableFilter<"Achievement">
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tier?: SortOrder
    earnedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    userId?: StringFilter<"Achievement"> | string
    type?: EnumAchievementTypeFilter<"Achievement"> | $Enums.AchievementType
    name?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    tier?: EnumAchievementTierFilter<"Achievement"> | $Enums.AchievementTier
    earnedAt?: DateTimeFilter<"Achievement"> | Date | string
    metadata?: JsonNullableFilter<"Achievement">
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tier?: SortOrder
    earnedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Achievement"> | string
    userId?: StringWithAggregatesFilter<"Achievement"> | string
    type?: EnumAchievementTypeWithAggregatesFilter<"Achievement"> | $Enums.AchievementType
    name?: StringWithAggregatesFilter<"Achievement"> | string
    description?: StringWithAggregatesFilter<"Achievement"> | string
    tier?: EnumAchievementTierWithAggregatesFilter<"Achievement"> | $Enums.AchievementTier
    earnedAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"Achievement">
  }

  export type StudyGoalWhereInput = {
    AND?: StudyGoalWhereInput | StudyGoalWhereInput[]
    OR?: StudyGoalWhereInput[]
    NOT?: StudyGoalWhereInput | StudyGoalWhereInput[]
    id?: StringFilter<"StudyGoal"> | string
    userId?: StringFilter<"StudyGoal"> | string
    goalType?: EnumGoalTypeFilter<"StudyGoal"> | $Enums.GoalType
    targetValue?: IntFilter<"StudyGoal"> | number
    currentProgress?: IntFilter<"StudyGoal"> | number
    period?: EnumGoalPeriodFilter<"StudyGoal"> | $Enums.GoalPeriod
    startDate?: DateTimeFilter<"StudyGoal"> | Date | string
    endDate?: DateTimeFilter<"StudyGoal"> | Date | string
    isCompleted?: BoolFilter<"StudyGoal"> | boolean
    completedAt?: DateTimeNullableFilter<"StudyGoal"> | Date | string | null
    createdAt?: DateTimeFilter<"StudyGoal"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type StudyGoalOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    goalType?: SortOrder
    targetValue?: SortOrder
    currentProgress?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type StudyGoalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudyGoalWhereInput | StudyGoalWhereInput[]
    OR?: StudyGoalWhereInput[]
    NOT?: StudyGoalWhereInput | StudyGoalWhereInput[]
    userId?: StringFilter<"StudyGoal"> | string
    goalType?: EnumGoalTypeFilter<"StudyGoal"> | $Enums.GoalType
    targetValue?: IntFilter<"StudyGoal"> | number
    currentProgress?: IntFilter<"StudyGoal"> | number
    period?: EnumGoalPeriodFilter<"StudyGoal"> | $Enums.GoalPeriod
    startDate?: DateTimeFilter<"StudyGoal"> | Date | string
    endDate?: DateTimeFilter<"StudyGoal"> | Date | string
    isCompleted?: BoolFilter<"StudyGoal"> | boolean
    completedAt?: DateTimeNullableFilter<"StudyGoal"> | Date | string | null
    createdAt?: DateTimeFilter<"StudyGoal"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type StudyGoalOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    goalType?: SortOrder
    targetValue?: SortOrder
    currentProgress?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StudyGoalCountOrderByAggregateInput
    _avg?: StudyGoalAvgOrderByAggregateInput
    _max?: StudyGoalMaxOrderByAggregateInput
    _min?: StudyGoalMinOrderByAggregateInput
    _sum?: StudyGoalSumOrderByAggregateInput
  }

  export type StudyGoalScalarWhereWithAggregatesInput = {
    AND?: StudyGoalScalarWhereWithAggregatesInput | StudyGoalScalarWhereWithAggregatesInput[]
    OR?: StudyGoalScalarWhereWithAggregatesInput[]
    NOT?: StudyGoalScalarWhereWithAggregatesInput | StudyGoalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudyGoal"> | string
    userId?: StringWithAggregatesFilter<"StudyGoal"> | string
    goalType?: EnumGoalTypeWithAggregatesFilter<"StudyGoal"> | $Enums.GoalType
    targetValue?: IntWithAggregatesFilter<"StudyGoal"> | number
    currentProgress?: IntWithAggregatesFilter<"StudyGoal"> | number
    period?: EnumGoalPeriodWithAggregatesFilter<"StudyGoal"> | $Enums.GoalPeriod
    startDate?: DateTimeWithAggregatesFilter<"StudyGoal"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"StudyGoal"> | Date | string
    isCompleted?: BoolWithAggregatesFilter<"StudyGoal"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"StudyGoal"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StudyGoal"> | Date | string
  }

  export type MissionAnalyticsWhereInput = {
    AND?: MissionAnalyticsWhereInput | MissionAnalyticsWhereInput[]
    OR?: MissionAnalyticsWhereInput[]
    NOT?: MissionAnalyticsWhereInput | MissionAnalyticsWhereInput[]
    id?: StringFilter<"MissionAnalytics"> | string
    userId?: StringFilter<"MissionAnalytics"> | string
    date?: DateTimeFilter<"MissionAnalytics"> | Date | string
    period?: EnumAnalyticsPeriodFilter<"MissionAnalytics"> | $Enums.AnalyticsPeriod
    missionsGenerated?: IntFilter<"MissionAnalytics"> | number
    missionsCompleted?: IntFilter<"MissionAnalytics"> | number
    missionsSkipped?: IntFilter<"MissionAnalytics"> | number
    avgCompletionRate?: FloatFilter<"MissionAnalytics"> | number
    avgTimeAccuracy?: FloatFilter<"MissionAnalytics"> | number
    avgDifficultyRating?: FloatFilter<"MissionAnalytics"> | number
    avgSuccessScore?: FloatFilter<"MissionAnalytics"> | number
    createdAt?: DateTimeFilter<"MissionAnalytics"> | Date | string
  }

  export type MissionAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    period?: SortOrder
    missionsGenerated?: SortOrder
    missionsCompleted?: SortOrder
    missionsSkipped?: SortOrder
    avgCompletionRate?: SortOrder
    avgTimeAccuracy?: SortOrder
    avgDifficultyRating?: SortOrder
    avgSuccessScore?: SortOrder
    createdAt?: SortOrder
  }

  export type MissionAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_date_period?: MissionAnalyticsUserIdDatePeriodCompoundUniqueInput
    AND?: MissionAnalyticsWhereInput | MissionAnalyticsWhereInput[]
    OR?: MissionAnalyticsWhereInput[]
    NOT?: MissionAnalyticsWhereInput | MissionAnalyticsWhereInput[]
    userId?: StringFilter<"MissionAnalytics"> | string
    date?: DateTimeFilter<"MissionAnalytics"> | Date | string
    period?: EnumAnalyticsPeriodFilter<"MissionAnalytics"> | $Enums.AnalyticsPeriod
    missionsGenerated?: IntFilter<"MissionAnalytics"> | number
    missionsCompleted?: IntFilter<"MissionAnalytics"> | number
    missionsSkipped?: IntFilter<"MissionAnalytics"> | number
    avgCompletionRate?: FloatFilter<"MissionAnalytics"> | number
    avgTimeAccuracy?: FloatFilter<"MissionAnalytics"> | number
    avgDifficultyRating?: FloatFilter<"MissionAnalytics"> | number
    avgSuccessScore?: FloatFilter<"MissionAnalytics"> | number
    createdAt?: DateTimeFilter<"MissionAnalytics"> | Date | string
  }, "id" | "userId_date_period">

  export type MissionAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    period?: SortOrder
    missionsGenerated?: SortOrder
    missionsCompleted?: SortOrder
    missionsSkipped?: SortOrder
    avgCompletionRate?: SortOrder
    avgTimeAccuracy?: SortOrder
    avgDifficultyRating?: SortOrder
    avgSuccessScore?: SortOrder
    createdAt?: SortOrder
    _count?: MissionAnalyticsCountOrderByAggregateInput
    _avg?: MissionAnalyticsAvgOrderByAggregateInput
    _max?: MissionAnalyticsMaxOrderByAggregateInput
    _min?: MissionAnalyticsMinOrderByAggregateInput
    _sum?: MissionAnalyticsSumOrderByAggregateInput
  }

  export type MissionAnalyticsScalarWhereWithAggregatesInput = {
    AND?: MissionAnalyticsScalarWhereWithAggregatesInput | MissionAnalyticsScalarWhereWithAggregatesInput[]
    OR?: MissionAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: MissionAnalyticsScalarWhereWithAggregatesInput | MissionAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MissionAnalytics"> | string
    userId?: StringWithAggregatesFilter<"MissionAnalytics"> | string
    date?: DateTimeWithAggregatesFilter<"MissionAnalytics"> | Date | string
    period?: EnumAnalyticsPeriodWithAggregatesFilter<"MissionAnalytics"> | $Enums.AnalyticsPeriod
    missionsGenerated?: IntWithAggregatesFilter<"MissionAnalytics"> | number
    missionsCompleted?: IntWithAggregatesFilter<"MissionAnalytics"> | number
    missionsSkipped?: IntWithAggregatesFilter<"MissionAnalytics"> | number
    avgCompletionRate?: FloatWithAggregatesFilter<"MissionAnalytics"> | number
    avgTimeAccuracy?: FloatWithAggregatesFilter<"MissionAnalytics"> | number
    avgDifficultyRating?: FloatWithAggregatesFilter<"MissionAnalytics"> | number
    avgSuccessScore?: FloatWithAggregatesFilter<"MissionAnalytics"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MissionAnalytics"> | Date | string
  }

  export type MissionFeedbackWhereInput = {
    AND?: MissionFeedbackWhereInput | MissionFeedbackWhereInput[]
    OR?: MissionFeedbackWhereInput[]
    NOT?: MissionFeedbackWhereInput | MissionFeedbackWhereInput[]
    id?: StringFilter<"MissionFeedback"> | string
    userId?: StringFilter<"MissionFeedback"> | string
    missionId?: StringFilter<"MissionFeedback"> | string
    helpfulnessRating?: IntFilter<"MissionFeedback"> | number
    relevanceScore?: IntFilter<"MissionFeedback"> | number
    paceRating?: EnumPaceRatingFilter<"MissionFeedback"> | $Enums.PaceRating
    improvementSuggestions?: StringNullableFilter<"MissionFeedback"> | string | null
    submittedAt?: DateTimeFilter<"MissionFeedback"> | Date | string
    mission?: XOR<MissionRelationFilter, MissionWhereInput>
  }

  export type MissionFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    missionId?: SortOrder
    helpfulnessRating?: SortOrder
    relevanceScore?: SortOrder
    paceRating?: SortOrder
    improvementSuggestions?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    mission?: MissionOrderByWithRelationInput
  }

  export type MissionFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MissionFeedbackWhereInput | MissionFeedbackWhereInput[]
    OR?: MissionFeedbackWhereInput[]
    NOT?: MissionFeedbackWhereInput | MissionFeedbackWhereInput[]
    userId?: StringFilter<"MissionFeedback"> | string
    missionId?: StringFilter<"MissionFeedback"> | string
    helpfulnessRating?: IntFilter<"MissionFeedback"> | number
    relevanceScore?: IntFilter<"MissionFeedback"> | number
    paceRating?: EnumPaceRatingFilter<"MissionFeedback"> | $Enums.PaceRating
    improvementSuggestions?: StringNullableFilter<"MissionFeedback"> | string | null
    submittedAt?: DateTimeFilter<"MissionFeedback"> | Date | string
    mission?: XOR<MissionRelationFilter, MissionWhereInput>
  }, "id">

  export type MissionFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    missionId?: SortOrder
    helpfulnessRating?: SortOrder
    relevanceScore?: SortOrder
    paceRating?: SortOrder
    improvementSuggestions?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    _count?: MissionFeedbackCountOrderByAggregateInput
    _avg?: MissionFeedbackAvgOrderByAggregateInput
    _max?: MissionFeedbackMaxOrderByAggregateInput
    _min?: MissionFeedbackMinOrderByAggregateInput
    _sum?: MissionFeedbackSumOrderByAggregateInput
  }

  export type MissionFeedbackScalarWhereWithAggregatesInput = {
    AND?: MissionFeedbackScalarWhereWithAggregatesInput | MissionFeedbackScalarWhereWithAggregatesInput[]
    OR?: MissionFeedbackScalarWhereWithAggregatesInput[]
    NOT?: MissionFeedbackScalarWhereWithAggregatesInput | MissionFeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MissionFeedback"> | string
    userId?: StringWithAggregatesFilter<"MissionFeedback"> | string
    missionId?: StringWithAggregatesFilter<"MissionFeedback"> | string
    helpfulnessRating?: IntWithAggregatesFilter<"MissionFeedback"> | number
    relevanceScore?: IntWithAggregatesFilter<"MissionFeedback"> | number
    paceRating?: EnumPaceRatingWithAggregatesFilter<"MissionFeedback"> | $Enums.PaceRating
    improvementSuggestions?: StringNullableWithAggregatesFilter<"MissionFeedback"> | string | null
    submittedAt?: DateTimeWithAggregatesFilter<"MissionFeedback"> | Date | string
  }

  export type MissionStreakWhereInput = {
    AND?: MissionStreakWhereInput | MissionStreakWhereInput[]
    OR?: MissionStreakWhereInput[]
    NOT?: MissionStreakWhereInput | MissionStreakWhereInput[]
    id?: StringFilter<"MissionStreak"> | string
    userId?: StringFilter<"MissionStreak"> | string
    currentStreak?: IntFilter<"MissionStreak"> | number
    longestStreak?: IntFilter<"MissionStreak"> | number
    lastCompletedDate?: DateTimeNullableFilter<"MissionStreak"> | Date | string | null
    createdAt?: DateTimeFilter<"MissionStreak"> | Date | string
    updatedAt?: DateTimeFilter<"MissionStreak"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MissionStreakOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastCompletedDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MissionStreakWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: MissionStreakWhereInput | MissionStreakWhereInput[]
    OR?: MissionStreakWhereInput[]
    NOT?: MissionStreakWhereInput | MissionStreakWhereInput[]
    currentStreak?: IntFilter<"MissionStreak"> | number
    longestStreak?: IntFilter<"MissionStreak"> | number
    lastCompletedDate?: DateTimeNullableFilter<"MissionStreak"> | Date | string | null
    createdAt?: DateTimeFilter<"MissionStreak"> | Date | string
    updatedAt?: DateTimeFilter<"MissionStreak"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type MissionStreakOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastCompletedDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MissionStreakCountOrderByAggregateInput
    _avg?: MissionStreakAvgOrderByAggregateInput
    _max?: MissionStreakMaxOrderByAggregateInput
    _min?: MissionStreakMinOrderByAggregateInput
    _sum?: MissionStreakSumOrderByAggregateInput
  }

  export type MissionStreakScalarWhereWithAggregatesInput = {
    AND?: MissionStreakScalarWhereWithAggregatesInput | MissionStreakScalarWhereWithAggregatesInput[]
    OR?: MissionStreakScalarWhereWithAggregatesInput[]
    NOT?: MissionStreakScalarWhereWithAggregatesInput | MissionStreakScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MissionStreak"> | string
    userId?: StringWithAggregatesFilter<"MissionStreak"> | string
    currentStreak?: IntWithAggregatesFilter<"MissionStreak"> | number
    longestStreak?: IntWithAggregatesFilter<"MissionStreak"> | number
    lastCompletedDate?: DateTimeNullableWithAggregatesFilter<"MissionStreak"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MissionStreak"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MissionStreak"> | Date | string
  }

  export type MissionReviewWhereInput = {
    AND?: MissionReviewWhereInput | MissionReviewWhereInput[]
    OR?: MissionReviewWhereInput[]
    NOT?: MissionReviewWhereInput | MissionReviewWhereInput[]
    id?: StringFilter<"MissionReview"> | string
    userId?: StringFilter<"MissionReview"> | string
    period?: EnumReviewPeriodFilter<"MissionReview"> | $Enums.ReviewPeriod
    startDate?: DateTimeFilter<"MissionReview"> | Date | string
    endDate?: DateTimeFilter<"MissionReview"> | Date | string
    summary?: JsonFilter<"MissionReview">
    highlights?: JsonFilter<"MissionReview">
    insights?: JsonFilter<"MissionReview">
    recommendations?: JsonFilter<"MissionReview">
    generatedAt?: DateTimeFilter<"MissionReview"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MissionReviewOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    summary?: SortOrder
    highlights?: SortOrder
    insights?: SortOrder
    recommendations?: SortOrder
    generatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MissionReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_period_startDate?: MissionReviewUserIdPeriodStartDateCompoundUniqueInput
    AND?: MissionReviewWhereInput | MissionReviewWhereInput[]
    OR?: MissionReviewWhereInput[]
    NOT?: MissionReviewWhereInput | MissionReviewWhereInput[]
    userId?: StringFilter<"MissionReview"> | string
    period?: EnumReviewPeriodFilter<"MissionReview"> | $Enums.ReviewPeriod
    startDate?: DateTimeFilter<"MissionReview"> | Date | string
    endDate?: DateTimeFilter<"MissionReview"> | Date | string
    summary?: JsonFilter<"MissionReview">
    highlights?: JsonFilter<"MissionReview">
    insights?: JsonFilter<"MissionReview">
    recommendations?: JsonFilter<"MissionReview">
    generatedAt?: DateTimeFilter<"MissionReview"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_period_startDate">

  export type MissionReviewOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    summary?: SortOrder
    highlights?: SortOrder
    insights?: SortOrder
    recommendations?: SortOrder
    generatedAt?: SortOrder
    _count?: MissionReviewCountOrderByAggregateInput
    _max?: MissionReviewMaxOrderByAggregateInput
    _min?: MissionReviewMinOrderByAggregateInput
  }

  export type MissionReviewScalarWhereWithAggregatesInput = {
    AND?: MissionReviewScalarWhereWithAggregatesInput | MissionReviewScalarWhereWithAggregatesInput[]
    OR?: MissionReviewScalarWhereWithAggregatesInput[]
    NOT?: MissionReviewScalarWhereWithAggregatesInput | MissionReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MissionReview"> | string
    userId?: StringWithAggregatesFilter<"MissionReview"> | string
    period?: EnumReviewPeriodWithAggregatesFilter<"MissionReview"> | $Enums.ReviewPeriod
    startDate?: DateTimeWithAggregatesFilter<"MissionReview"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"MissionReview"> | Date | string
    summary?: JsonWithAggregatesFilter<"MissionReview">
    highlights?: JsonWithAggregatesFilter<"MissionReview">
    insights?: JsonWithAggregatesFilter<"MissionReview">
    recommendations?: JsonWithAggregatesFilter<"MissionReview">
    generatedAt?: DateTimeWithAggregatesFilter<"MissionReview"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: CourseCreateNestedManyWithoutUserInput
    lectures?: LectureCreateNestedManyWithoutUserInput
    studySessions?: StudySessionCreateNestedManyWithoutUserInput
    missions?: MissionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    exams?: ExamCreateNestedManyWithoutUserInput
    coursePriorities?: CoursePriorityCreateNestedManyWithoutUserInput
    streak?: StreakCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    studyGoals?: StudyGoalCreateNestedManyWithoutUserInput
    missionStreak?: MissionStreakCreateNestedOneWithoutUserInput
    missionReviews?: MissionReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    lectures?: LectureUncheckedCreateNestedManyWithoutUserInput
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutUserInput
    missions?: MissionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamUncheckedCreateNestedManyWithoutUserInput
    coursePriorities?: CoursePriorityUncheckedCreateNestedManyWithoutUserInput
    streak?: StreakUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    studyGoals?: StudyGoalUncheckedCreateNestedManyWithoutUserInput
    missionStreak?: MissionStreakUncheckedCreateNestedOneWithoutUserInput
    missionReviews?: MissionReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseUpdateManyWithoutUserNestedInput
    lectures?: LectureUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUpdateManyWithoutUserNestedInput
    missions?: MissionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    exams?: ExamUpdateManyWithoutUserNestedInput
    coursePriorities?: CoursePriorityUpdateManyWithoutUserNestedInput
    streak?: StreakUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    studyGoals?: StudyGoalUpdateManyWithoutUserNestedInput
    missionStreak?: MissionStreakUpdateOneWithoutUserNestedInput
    missionReviews?: MissionReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    lectures?: LectureUncheckedUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUncheckedUpdateManyWithoutUserNestedInput
    missions?: MissionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUserNestedInput
    coursePriorities?: CoursePriorityUncheckedUpdateManyWithoutUserNestedInput
    streak?: StreakUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    studyGoals?: StudyGoalUncheckedUpdateManyWithoutUserNestedInput
    missionStreak?: MissionStreakUncheckedUpdateOneWithoutUserNestedInput
    missionReviews?: MissionReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CourseCreateInput = {
    id?: string
    name: string
    code?: string | null
    term?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCoursesInput
    lectures?: LectureCreateNestedManyWithoutCourseInput
    cards?: CardCreateNestedManyWithoutCourseInput
    exams?: ExamCreateNestedManyWithoutCourseInput
    coursePriorities?: CoursePriorityCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    code?: string | null
    term?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lectures?: LectureUncheckedCreateNestedManyWithoutCourseInput
    cards?: CardUncheckedCreateNestedManyWithoutCourseInput
    exams?: ExamUncheckedCreateNestedManyWithoutCourseInput
    coursePriorities?: CoursePriorityUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoursesNestedInput
    lectures?: LectureUpdateManyWithoutCourseNestedInput
    cards?: CardUpdateManyWithoutCourseNestedInput
    exams?: ExamUpdateManyWithoutCourseNestedInput
    coursePriorities?: CoursePriorityUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LectureUncheckedUpdateManyWithoutCourseNestedInput
    cards?: CardUncheckedUpdateManyWithoutCourseNestedInput
    exams?: ExamUncheckedUpdateManyWithoutCourseNestedInput
    coursePriorities?: CoursePriorityUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    userId: string
    name: string
    code?: string | null
    term?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LectureCreateInput = {
    id?: string
    title: string
    fileName: string
    fileUrl: string
    fileSize: number
    processingStatus?: $Enums.ProcessingStatus
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    processingProgress?: number
    totalPages?: number | null
    processedPages?: number
    processingStartedAt?: Date | string | null
    estimatedCompletionAt?: Date | string | null
    weekNumber?: number | null
    topicTags?: LectureCreatetopicTagsInput | string[]
    user: UserCreateNestedOneWithoutLecturesInput
    course: CourseCreateNestedOneWithoutLecturesInput
    contentChunks?: ContentChunkCreateNestedManyWithoutLectureInput
    learningObjectives?: LearningObjectiveCreateNestedManyWithoutLectureInput
    cards?: CardCreateNestedManyWithoutLectureInput
  }

  export type LectureUncheckedCreateInput = {
    id?: string
    userId: string
    courseId: string
    title: string
    fileName: string
    fileUrl: string
    fileSize: number
    processingStatus?: $Enums.ProcessingStatus
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    processingProgress?: number
    totalPages?: number | null
    processedPages?: number
    processingStartedAt?: Date | string | null
    estimatedCompletionAt?: Date | string | null
    weekNumber?: number | null
    topicTags?: LectureCreatetopicTagsInput | string[]
    contentChunks?: ContentChunkUncheckedCreateNestedManyWithoutLectureInput
    learningObjectives?: LearningObjectiveUncheckedCreateNestedManyWithoutLectureInput
    cards?: CardUncheckedCreateNestedManyWithoutLectureInput
  }

  export type LectureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingProgress?: IntFieldUpdateOperationsInput | number
    totalPages?: NullableIntFieldUpdateOperationsInput | number | null
    processedPages?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weekNumber?: NullableIntFieldUpdateOperationsInput | number | null
    topicTags?: LectureUpdatetopicTagsInput | string[]
    user?: UserUpdateOneRequiredWithoutLecturesNestedInput
    course?: CourseUpdateOneRequiredWithoutLecturesNestedInput
    contentChunks?: ContentChunkUpdateManyWithoutLectureNestedInput
    learningObjectives?: LearningObjectiveUpdateManyWithoutLectureNestedInput
    cards?: CardUpdateManyWithoutLectureNestedInput
  }

  export type LectureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingProgress?: IntFieldUpdateOperationsInput | number
    totalPages?: NullableIntFieldUpdateOperationsInput | number | null
    processedPages?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weekNumber?: NullableIntFieldUpdateOperationsInput | number | null
    topicTags?: LectureUpdatetopicTagsInput | string[]
    contentChunks?: ContentChunkUncheckedUpdateManyWithoutLectureNestedInput
    learningObjectives?: LearningObjectiveUncheckedUpdateManyWithoutLectureNestedInput
    cards?: CardUncheckedUpdateManyWithoutLectureNestedInput
  }

  export type LectureCreateManyInput = {
    id?: string
    userId: string
    courseId: string
    title: string
    fileName: string
    fileUrl: string
    fileSize: number
    processingStatus?: $Enums.ProcessingStatus
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    processingProgress?: number
    totalPages?: number | null
    processedPages?: number
    processingStartedAt?: Date | string | null
    estimatedCompletionAt?: Date | string | null
    weekNumber?: number | null
    topicTags?: LectureCreatetopicTagsInput | string[]
  }

  export type LectureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingProgress?: IntFieldUpdateOperationsInput | number
    totalPages?: NullableIntFieldUpdateOperationsInput | number | null
    processedPages?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weekNumber?: NullableIntFieldUpdateOperationsInput | number | null
    topicTags?: LectureUpdatetopicTagsInput | string[]
  }

  export type LectureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingProgress?: IntFieldUpdateOperationsInput | number
    totalPages?: NullableIntFieldUpdateOperationsInput | number | null
    processedPages?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weekNumber?: NullableIntFieldUpdateOperationsInput | number | null
    topicTags?: LectureUpdatetopicTagsInput | string[]
  }

  export type ContentChunkCreateInput = {
    id?: string
    content: string
    chunkIndex: number
    pageNumber?: number | null
    createdAt?: Date | string
    lecture: LectureCreateNestedOneWithoutContentChunksInput
  }

  export type ContentChunkUncheckedCreateInput = {
    id?: string
    lectureId: string
    content: string
    chunkIndex: number
    pageNumber?: number | null
    createdAt?: Date | string
  }

  export type ContentChunkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lecture?: LectureUpdateOneRequiredWithoutContentChunksNestedInput
  }

  export type ContentChunkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentChunkCreateManyInput = {
    id?: string
    lectureId: string
    content: string
    chunkIndex: number
    pageNumber?: number | null
    createdAt?: Date | string
  }

  export type ContentChunkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentChunkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningObjectiveCreateInput = {
    id?: string
    objective: string
    complexity?: $Enums.ObjectiveComplexity
    pageStart?: number | null
    pageEnd?: number | null
    isHighYield?: boolean
    boardExamTags?: LearningObjectiveCreateboardExamTagsInput | string[]
    extractedBy?: string
    createdAt?: Date | string
    masteryLevel?: $Enums.MasteryLevel
    totalStudyTimeMs?: number
    lastStudiedAt?: Date | string | null
    weaknessScore?: number
    lecture: LectureCreateNestedOneWithoutLearningObjectivesInput
    cards?: CardCreateNestedManyWithoutObjectiveInput
    prerequisites?: ObjectivePrerequisiteCreateNestedManyWithoutObjectiveInput
    dependents?: ObjectivePrerequisiteCreateNestedManyWithoutPrerequisiteInput
    performanceMetrics?: PerformanceMetricCreateNestedManyWithoutLearningObjectiveInput
    priorityFeedback?: PriorityFeedbackCreateNestedManyWithoutLearningObjectiveInput
    strugglePredictions?: StrugglePredictionCreateNestedManyWithoutLearningObjectiveInput
    struggleIndicators?: StruggleIndicatorCreateNestedManyWithoutLearningObjectiveInput
  }

  export type LearningObjectiveUncheckedCreateInput = {
    id?: string
    lectureId: string
    objective: string
    complexity?: $Enums.ObjectiveComplexity
    pageStart?: number | null
    pageEnd?: number | null
    isHighYield?: boolean
    boardExamTags?: LearningObjectiveCreateboardExamTagsInput | string[]
    extractedBy?: string
    createdAt?: Date | string
    masteryLevel?: $Enums.MasteryLevel
    totalStudyTimeMs?: number
    lastStudiedAt?: Date | string | null
    weaknessScore?: number
    cards?: CardUncheckedCreateNestedManyWithoutObjectiveInput
    prerequisites?: ObjectivePrerequisiteUncheckedCreateNestedManyWithoutObjectiveInput
    dependents?: ObjectivePrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput
    performanceMetrics?: PerformanceMetricUncheckedCreateNestedManyWithoutLearningObjectiveInput
    priorityFeedback?: PriorityFeedbackUncheckedCreateNestedManyWithoutLearningObjectiveInput
    strugglePredictions?: StrugglePredictionUncheckedCreateNestedManyWithoutLearningObjectiveInput
    struggleIndicators?: StruggleIndicatorUncheckedCreateNestedManyWithoutLearningObjectiveInput
  }

  export type LearningObjectiveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    complexity?: EnumObjectiveComplexityFieldUpdateOperationsInput | $Enums.ObjectiveComplexity
    pageStart?: NullableIntFieldUpdateOperationsInput | number | null
    pageEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isHighYield?: BoolFieldUpdateOperationsInput | boolean
    boardExamTags?: LearningObjectiveUpdateboardExamTagsInput | string[]
    extractedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masteryLevel?: EnumMasteryLevelFieldUpdateOperationsInput | $Enums.MasteryLevel
    totalStudyTimeMs?: IntFieldUpdateOperationsInput | number
    lastStudiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weaknessScore?: FloatFieldUpdateOperationsInput | number
    lecture?: LectureUpdateOneRequiredWithoutLearningObjectivesNestedInput
    cards?: CardUpdateManyWithoutObjectiveNestedInput
    prerequisites?: ObjectivePrerequisiteUpdateManyWithoutObjectiveNestedInput
    dependents?: ObjectivePrerequisiteUpdateManyWithoutPrerequisiteNestedInput
    performanceMetrics?: PerformanceMetricUpdateManyWithoutLearningObjectiveNestedInput
    priorityFeedback?: PriorityFeedbackUpdateManyWithoutLearningObjectiveNestedInput
    strugglePredictions?: StrugglePredictionUpdateManyWithoutLearningObjectiveNestedInput
    struggleIndicators?: StruggleIndicatorUpdateManyWithoutLearningObjectiveNestedInput
  }

  export type LearningObjectiveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    complexity?: EnumObjectiveComplexityFieldUpdateOperationsInput | $Enums.ObjectiveComplexity
    pageStart?: NullableIntFieldUpdateOperationsInput | number | null
    pageEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isHighYield?: BoolFieldUpdateOperationsInput | boolean
    boardExamTags?: LearningObjectiveUpdateboardExamTagsInput | string[]
    extractedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masteryLevel?: EnumMasteryLevelFieldUpdateOperationsInput | $Enums.MasteryLevel
    totalStudyTimeMs?: IntFieldUpdateOperationsInput | number
    lastStudiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weaknessScore?: FloatFieldUpdateOperationsInput | number
    cards?: CardUncheckedUpdateManyWithoutObjectiveNestedInput
    prerequisites?: ObjectivePrerequisiteUncheckedUpdateManyWithoutObjectiveNestedInput
    dependents?: ObjectivePrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput
    performanceMetrics?: PerformanceMetricUncheckedUpdateManyWithoutLearningObjectiveNestedInput
    priorityFeedback?: PriorityFeedbackUncheckedUpdateManyWithoutLearningObjectiveNestedInput
    strugglePredictions?: StrugglePredictionUncheckedUpdateManyWithoutLearningObjectiveNestedInput
    struggleIndicators?: StruggleIndicatorUncheckedUpdateManyWithoutLearningObjectiveNestedInput
  }

  export type LearningObjectiveCreateManyInput = {
    id?: string
    lectureId: string
    objective: string
    complexity?: $Enums.ObjectiveComplexity
    pageStart?: number | null
    pageEnd?: number | null
    isHighYield?: boolean
    boardExamTags?: LearningObjectiveCreateboardExamTagsInput | string[]
    extractedBy?: string
    createdAt?: Date | string
    masteryLevel?: $Enums.MasteryLevel
    totalStudyTimeMs?: number
    lastStudiedAt?: Date | string | null
    weaknessScore?: number
  }

  export type LearningObjectiveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    complexity?: EnumObjectiveComplexityFieldUpdateOperationsInput | $Enums.ObjectiveComplexity
    pageStart?: NullableIntFieldUpdateOperationsInput | number | null
    pageEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isHighYield?: BoolFieldUpdateOperationsInput | boolean
    boardExamTags?: LearningObjectiveUpdateboardExamTagsInput | string[]
    extractedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masteryLevel?: EnumMasteryLevelFieldUpdateOperationsInput | $Enums.MasteryLevel
    totalStudyTimeMs?: IntFieldUpdateOperationsInput | number
    lastStudiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weaknessScore?: FloatFieldUpdateOperationsInput | number
  }

  export type LearningObjectiveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    complexity?: EnumObjectiveComplexityFieldUpdateOperationsInput | $Enums.ObjectiveComplexity
    pageStart?: NullableIntFieldUpdateOperationsInput | number | null
    pageEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isHighYield?: BoolFieldUpdateOperationsInput | boolean
    boardExamTags?: LearningObjectiveUpdateboardExamTagsInput | string[]
    extractedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masteryLevel?: EnumMasteryLevelFieldUpdateOperationsInput | $Enums.MasteryLevel
    totalStudyTimeMs?: IntFieldUpdateOperationsInput | number
    lastStudiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weaknessScore?: FloatFieldUpdateOperationsInput | number
  }

  export type ObjectivePrerequisiteCreateInput = {
    id?: string
    strength?: number
    objective: LearningObjectiveCreateNestedOneWithoutPrerequisitesInput
    prerequisite: LearningObjectiveCreateNestedOneWithoutDependentsInput
  }

  export type ObjectivePrerequisiteUncheckedCreateInput = {
    id?: string
    objectiveId: string
    prerequisiteId: string
    strength?: number
  }

  export type ObjectivePrerequisiteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
    objective?: LearningObjectiveUpdateOneRequiredWithoutPrerequisitesNestedInput
    prerequisite?: LearningObjectiveUpdateOneRequiredWithoutDependentsNestedInput
  }

  export type ObjectivePrerequisiteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    objectiveId?: StringFieldUpdateOperationsInput | string
    prerequisiteId?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
  }

  export type ObjectivePrerequisiteCreateManyInput = {
    id?: string
    objectiveId: string
    prerequisiteId: string
    strength?: number
  }

  export type ObjectivePrerequisiteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
  }

  export type ObjectivePrerequisiteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    objectiveId?: StringFieldUpdateOperationsInput | string
    prerequisiteId?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
  }

  export type MissionCreateInput = {
    id?: string
    date?: Date | string
    status?: $Enums.MissionStatus
    estimatedMinutes: number
    completedAt?: Date | string | null
    actualMinutes?: number | null
    completedObjectivesCount?: number
    objectives: JsonNullValueInput | InputJsonValue
    reviewCardCount?: number
    newContentCount?: number
    successScore?: number | null
    difficultyRating?: number | null
    user: UserCreateNestedOneWithoutMissionsInput
    studySessions?: StudySessionCreateNestedManyWithoutMissionInput
    feedback?: MissionFeedbackCreateNestedManyWithoutMissionInput
    interventions?: InterventionRecommendationCreateNestedManyWithoutMissionInput
  }

  export type MissionUncheckedCreateInput = {
    id?: string
    userId: string
    date?: Date | string
    status?: $Enums.MissionStatus
    estimatedMinutes: number
    completedAt?: Date | string | null
    actualMinutes?: number | null
    completedObjectivesCount?: number
    objectives: JsonNullValueInput | InputJsonValue
    reviewCardCount?: number
    newContentCount?: number
    successScore?: number | null
    difficultyRating?: number | null
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutMissionInput
    feedback?: MissionFeedbackUncheckedCreateNestedManyWithoutMissionInput
    interventions?: InterventionRecommendationUncheckedCreateNestedManyWithoutMissionInput
  }

  export type MissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMissionStatusFieldUpdateOperationsInput | $Enums.MissionStatus
    estimatedMinutes?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    completedObjectivesCount?: IntFieldUpdateOperationsInput | number
    objectives?: JsonNullValueInput | InputJsonValue
    reviewCardCount?: IntFieldUpdateOperationsInput | number
    newContentCount?: IntFieldUpdateOperationsInput | number
    successScore?: NullableFloatFieldUpdateOperationsInput | number | null
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutMissionsNestedInput
    studySessions?: StudySessionUpdateManyWithoutMissionNestedInput
    feedback?: MissionFeedbackUpdateManyWithoutMissionNestedInput
    interventions?: InterventionRecommendationUpdateManyWithoutMissionNestedInput
  }

  export type MissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMissionStatusFieldUpdateOperationsInput | $Enums.MissionStatus
    estimatedMinutes?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    completedObjectivesCount?: IntFieldUpdateOperationsInput | number
    objectives?: JsonNullValueInput | InputJsonValue
    reviewCardCount?: IntFieldUpdateOperationsInput | number
    newContentCount?: IntFieldUpdateOperationsInput | number
    successScore?: NullableFloatFieldUpdateOperationsInput | number | null
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    studySessions?: StudySessionUncheckedUpdateManyWithoutMissionNestedInput
    feedback?: MissionFeedbackUncheckedUpdateManyWithoutMissionNestedInput
    interventions?: InterventionRecommendationUncheckedUpdateManyWithoutMissionNestedInput
  }

  export type MissionCreateManyInput = {
    id?: string
    userId: string
    date?: Date | string
    status?: $Enums.MissionStatus
    estimatedMinutes: number
    completedAt?: Date | string | null
    actualMinutes?: number | null
    completedObjectivesCount?: number
    objectives: JsonNullValueInput | InputJsonValue
    reviewCardCount?: number
    newContentCount?: number
    successScore?: number | null
    difficultyRating?: number | null
  }

  export type MissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMissionStatusFieldUpdateOperationsInput | $Enums.MissionStatus
    estimatedMinutes?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    completedObjectivesCount?: IntFieldUpdateOperationsInput | number
    objectives?: JsonNullValueInput | InputJsonValue
    reviewCardCount?: IntFieldUpdateOperationsInput | number
    newContentCount?: IntFieldUpdateOperationsInput | number
    successScore?: NullableFloatFieldUpdateOperationsInput | number | null
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMissionStatusFieldUpdateOperationsInput | $Enums.MissionStatus
    estimatedMinutes?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    completedObjectivesCount?: IntFieldUpdateOperationsInput | number
    objectives?: JsonNullValueInput | InputJsonValue
    reviewCardCount?: IntFieldUpdateOperationsInput | number
    newContentCount?: IntFieldUpdateOperationsInput | number
    successScore?: NullableFloatFieldUpdateOperationsInput | number | null
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CardCreateInput = {
    id?: string
    front: string
    back: string
    cardType?: $Enums.CardType
    createdAt?: Date | string
    difficulty?: number
    stability?: number
    retrievability?: number
    lastReviewedAt?: Date | string | null
    nextReviewAt?: Date | string | null
    reviewCount?: number
    lapseCount?: number
    course: CourseCreateNestedOneWithoutCardsInput
    lecture?: LectureCreateNestedOneWithoutCardsInput
    objective?: LearningObjectiveCreateNestedOneWithoutCardsInput
    reviews?: ReviewCreateNestedManyWithoutCardInput
  }

  export type CardUncheckedCreateInput = {
    id?: string
    courseId: string
    lectureId?: string | null
    objectiveId?: string | null
    front: string
    back: string
    cardType?: $Enums.CardType
    createdAt?: Date | string
    difficulty?: number
    stability?: number
    retrievability?: number
    lastReviewedAt?: Date | string | null
    nextReviewAt?: Date | string | null
    reviewCount?: number
    lapseCount?: number
    reviews?: ReviewUncheckedCreateNestedManyWithoutCardInput
  }

  export type CardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    front?: StringFieldUpdateOperationsInput | string
    back?: StringFieldUpdateOperationsInput | string
    cardType?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficulty?: FloatFieldUpdateOperationsInput | number
    stability?: FloatFieldUpdateOperationsInput | number
    retrievability?: FloatFieldUpdateOperationsInput | number
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    lapseCount?: IntFieldUpdateOperationsInput | number
    course?: CourseUpdateOneRequiredWithoutCardsNestedInput
    lecture?: LectureUpdateOneWithoutCardsNestedInput
    objective?: LearningObjectiveUpdateOneWithoutCardsNestedInput
    reviews?: ReviewUpdateManyWithoutCardNestedInput
  }

  export type CardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    lectureId?: NullableStringFieldUpdateOperationsInput | string | null
    objectiveId?: NullableStringFieldUpdateOperationsInput | string | null
    front?: StringFieldUpdateOperationsInput | string
    back?: StringFieldUpdateOperationsInput | string
    cardType?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficulty?: FloatFieldUpdateOperationsInput | number
    stability?: FloatFieldUpdateOperationsInput | number
    retrievability?: FloatFieldUpdateOperationsInput | number
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    lapseCount?: IntFieldUpdateOperationsInput | number
    reviews?: ReviewUncheckedUpdateManyWithoutCardNestedInput
  }

  export type CardCreateManyInput = {
    id?: string
    courseId: string
    lectureId?: string | null
    objectiveId?: string | null
    front: string
    back: string
    cardType?: $Enums.CardType
    createdAt?: Date | string
    difficulty?: number
    stability?: number
    retrievability?: number
    lastReviewedAt?: Date | string | null
    nextReviewAt?: Date | string | null
    reviewCount?: number
    lapseCount?: number
  }

  export type CardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    front?: StringFieldUpdateOperationsInput | string
    back?: StringFieldUpdateOperationsInput | string
    cardType?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficulty?: FloatFieldUpdateOperationsInput | number
    stability?: FloatFieldUpdateOperationsInput | number
    retrievability?: FloatFieldUpdateOperationsInput | number
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    lapseCount?: IntFieldUpdateOperationsInput | number
  }

  export type CardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    lectureId?: NullableStringFieldUpdateOperationsInput | string | null
    objectiveId?: NullableStringFieldUpdateOperationsInput | string | null
    front?: StringFieldUpdateOperationsInput | string
    back?: StringFieldUpdateOperationsInput | string
    cardType?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficulty?: FloatFieldUpdateOperationsInput | number
    stability?: FloatFieldUpdateOperationsInput | number
    retrievability?: FloatFieldUpdateOperationsInput | number
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    lapseCount?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewCreateInput = {
    id?: string
    rating: $Enums.ReviewRating
    timeSpentMs: number
    reviewedAt?: Date | string
    difficultyBefore: number
    stabilityBefore: number
    difficultyAfter: number
    stabilityAfter: number
    user: UserCreateNestedOneWithoutReviewsInput
    card: CardCreateNestedOneWithoutReviewsInput
    session?: StudySessionCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    userId: string
    cardId: string
    sessionId?: string | null
    rating: $Enums.ReviewRating
    timeSpentMs: number
    reviewedAt?: Date | string
    difficultyBefore: number
    stabilityBefore: number
    difficultyAfter: number
    stabilityAfter: number
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: EnumReviewRatingFieldUpdateOperationsInput | $Enums.ReviewRating
    timeSpentMs?: IntFieldUpdateOperationsInput | number
    reviewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficultyBefore?: FloatFieldUpdateOperationsInput | number
    stabilityBefore?: FloatFieldUpdateOperationsInput | number
    difficultyAfter?: FloatFieldUpdateOperationsInput | number
    stabilityAfter?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    card?: CardUpdateOneRequiredWithoutReviewsNestedInput
    session?: StudySessionUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: EnumReviewRatingFieldUpdateOperationsInput | $Enums.ReviewRating
    timeSpentMs?: IntFieldUpdateOperationsInput | number
    reviewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficultyBefore?: FloatFieldUpdateOperationsInput | number
    stabilityBefore?: FloatFieldUpdateOperationsInput | number
    difficultyAfter?: FloatFieldUpdateOperationsInput | number
    stabilityAfter?: FloatFieldUpdateOperationsInput | number
  }

  export type ReviewCreateManyInput = {
    id?: string
    userId: string
    cardId: string
    sessionId?: string | null
    rating: $Enums.ReviewRating
    timeSpentMs: number
    reviewedAt?: Date | string
    difficultyBefore: number
    stabilityBefore: number
    difficultyAfter: number
    stabilityAfter: number
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: EnumReviewRatingFieldUpdateOperationsInput | $Enums.ReviewRating
    timeSpentMs?: IntFieldUpdateOperationsInput | number
    reviewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficultyBefore?: FloatFieldUpdateOperationsInput | number
    stabilityBefore?: FloatFieldUpdateOperationsInput | number
    difficultyAfter?: FloatFieldUpdateOperationsInput | number
    stabilityAfter?: FloatFieldUpdateOperationsInput | number
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: EnumReviewRatingFieldUpdateOperationsInput | $Enums.ReviewRating
    timeSpentMs?: IntFieldUpdateOperationsInput | number
    reviewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficultyBefore?: FloatFieldUpdateOperationsInput | number
    stabilityBefore?: FloatFieldUpdateOperationsInput | number
    difficultyAfter?: FloatFieldUpdateOperationsInput | number
    stabilityAfter?: FloatFieldUpdateOperationsInput | number
  }

  export type StudySessionCreateInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    reviewsCompleted?: number
    newCardsStudied?: number
    sessionNotes?: string | null
    currentObjectiveIndex?: number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutStudySessionsInput
    mission?: MissionCreateNestedOneWithoutStudySessionsInput
    reviews?: ReviewCreateNestedManyWithoutSessionInput
    validationResponses?: ValidationResponseCreateNestedManyWithoutSessionInput
  }

  export type StudySessionUncheckedCreateInput = {
    id?: string
    userId: string
    missionId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    reviewsCompleted?: number
    newCardsStudied?: number
    sessionNotes?: string | null
    currentObjectiveIndex?: number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
    reviews?: ReviewUncheckedCreateNestedManyWithoutSessionInput
    validationResponses?: ValidationResponseUncheckedCreateNestedManyWithoutSessionInput
  }

  export type StudySessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    reviewsCompleted?: IntFieldUpdateOperationsInput | number
    newCardsStudied?: IntFieldUpdateOperationsInput | number
    sessionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    currentObjectiveIndex?: IntFieldUpdateOperationsInput | number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutStudySessionsNestedInput
    mission?: MissionUpdateOneWithoutStudySessionsNestedInput
    reviews?: ReviewUpdateManyWithoutSessionNestedInput
    validationResponses?: ValidationResponseUpdateManyWithoutSessionNestedInput
  }

  export type StudySessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    missionId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    reviewsCompleted?: IntFieldUpdateOperationsInput | number
    newCardsStudied?: IntFieldUpdateOperationsInput | number
    sessionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    currentObjectiveIndex?: IntFieldUpdateOperationsInput | number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
    reviews?: ReviewUncheckedUpdateManyWithoutSessionNestedInput
    validationResponses?: ValidationResponseUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type StudySessionCreateManyInput = {
    id?: string
    userId: string
    missionId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    reviewsCompleted?: number
    newCardsStudied?: number
    sessionNotes?: string | null
    currentObjectiveIndex?: number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StudySessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    reviewsCompleted?: IntFieldUpdateOperationsInput | number
    newCardsStudied?: IntFieldUpdateOperationsInput | number
    sessionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    currentObjectiveIndex?: IntFieldUpdateOperationsInput | number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StudySessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    missionId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    reviewsCompleted?: IntFieldUpdateOperationsInput | number
    newCardsStudied?: IntFieldUpdateOperationsInput | number
    sessionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    currentObjectiveIndex?: IntFieldUpdateOperationsInput | number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ConceptCreateInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    relatedFrom?: ConceptRelationshipCreateNestedManyWithoutFromConceptInput
    relatedTo?: ConceptRelationshipCreateNestedManyWithoutToConceptInput
  }

  export type ConceptUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    relatedFrom?: ConceptRelationshipUncheckedCreateNestedManyWithoutFromConceptInput
    relatedTo?: ConceptRelationshipUncheckedCreateNestedManyWithoutToConceptInput
  }

  export type ConceptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedFrom?: ConceptRelationshipUpdateManyWithoutFromConceptNestedInput
    relatedTo?: ConceptRelationshipUpdateManyWithoutToConceptNestedInput
  }

  export type ConceptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedFrom?: ConceptRelationshipUncheckedUpdateManyWithoutFromConceptNestedInput
    relatedTo?: ConceptRelationshipUncheckedUpdateManyWithoutToConceptNestedInput
  }

  export type ConceptCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
  }

  export type ConceptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptRelationshipCreateInput = {
    id?: string
    relationship: $Enums.RelationshipType
    strength?: number
    createdAt?: Date | string
    fromConcept: ConceptCreateNestedOneWithoutRelatedFromInput
    toConcept: ConceptCreateNestedOneWithoutRelatedToInput
  }

  export type ConceptRelationshipUncheckedCreateInput = {
    id?: string
    fromConceptId: string
    toConceptId: string
    relationship: $Enums.RelationshipType
    strength?: number
    createdAt?: Date | string
  }

  export type ConceptRelationshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    strength?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromConcept?: ConceptUpdateOneRequiredWithoutRelatedFromNestedInput
    toConcept?: ConceptUpdateOneRequiredWithoutRelatedToNestedInput
  }

  export type ConceptRelationshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromConceptId?: StringFieldUpdateOperationsInput | string
    toConceptId?: StringFieldUpdateOperationsInput | string
    relationship?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    strength?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptRelationshipCreateManyInput = {
    id?: string
    fromConceptId: string
    toConceptId: string
    relationship: $Enums.RelationshipType
    strength?: number
    createdAt?: Date | string
  }

  export type ConceptRelationshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    strength?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptRelationshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromConceptId?: StringFieldUpdateOperationsInput | string
    toConceptId?: StringFieldUpdateOperationsInput | string
    relationship?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    strength?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ValidationPromptCreateInput = {
    id?: string
    promptText: string
    promptType: $Enums.PromptType
    conceptName: string
    expectedCriteria?: ValidationPromptCreateexpectedCriteriaInput | string[]
    createdAt?: Date | string
    responses?: ValidationResponseCreateNestedManyWithoutPromptInput
  }

  export type ValidationPromptUncheckedCreateInput = {
    id?: string
    promptText: string
    promptType: $Enums.PromptType
    conceptName: string
    expectedCriteria?: ValidationPromptCreateexpectedCriteriaInput | string[]
    createdAt?: Date | string
    responses?: ValidationResponseUncheckedCreateNestedManyWithoutPromptInput
  }

  export type ValidationPromptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptText?: StringFieldUpdateOperationsInput | string
    promptType?: EnumPromptTypeFieldUpdateOperationsInput | $Enums.PromptType
    conceptName?: StringFieldUpdateOperationsInput | string
    expectedCriteria?: ValidationPromptUpdateexpectedCriteriaInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: ValidationResponseUpdateManyWithoutPromptNestedInput
  }

  export type ValidationPromptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptText?: StringFieldUpdateOperationsInput | string
    promptType?: EnumPromptTypeFieldUpdateOperationsInput | $Enums.PromptType
    conceptName?: StringFieldUpdateOperationsInput | string
    expectedCriteria?: ValidationPromptUpdateexpectedCriteriaInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: ValidationResponseUncheckedUpdateManyWithoutPromptNestedInput
  }

  export type ValidationPromptCreateManyInput = {
    id?: string
    promptText: string
    promptType: $Enums.PromptType
    conceptName: string
    expectedCriteria?: ValidationPromptCreateexpectedCriteriaInput | string[]
    createdAt?: Date | string
  }

  export type ValidationPromptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptText?: StringFieldUpdateOperationsInput | string
    promptType?: EnumPromptTypeFieldUpdateOperationsInput | $Enums.PromptType
    conceptName?: StringFieldUpdateOperationsInput | string
    expectedCriteria?: ValidationPromptUpdateexpectedCriteriaInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ValidationPromptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptText?: StringFieldUpdateOperationsInput | string
    promptType?: EnumPromptTypeFieldUpdateOperationsInput | $Enums.PromptType
    conceptName?: StringFieldUpdateOperationsInput | string
    expectedCriteria?: ValidationPromptUpdateexpectedCriteriaInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ValidationResponseCreateInput = {
    id?: string
    userAnswer: string
    aiEvaluation: string
    score: number
    confidence?: number | null
    respondedAt?: Date | string
    prompt: ValidationPromptCreateNestedOneWithoutResponsesInput
    session?: StudySessionCreateNestedOneWithoutValidationResponsesInput
  }

  export type ValidationResponseUncheckedCreateInput = {
    id?: string
    promptId: string
    sessionId?: string | null
    userAnswer: string
    aiEvaluation: string
    score: number
    confidence?: number | null
    respondedAt?: Date | string
  }

  export type ValidationResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userAnswer?: StringFieldUpdateOperationsInput | string
    aiEvaluation?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prompt?: ValidationPromptUpdateOneRequiredWithoutResponsesNestedInput
    session?: StudySessionUpdateOneWithoutValidationResponsesNestedInput
  }

  export type ValidationResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userAnswer?: StringFieldUpdateOperationsInput | string
    aiEvaluation?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ValidationResponseCreateManyInput = {
    id?: string
    promptId: string
    sessionId?: string | null
    userAnswer: string
    aiEvaluation: string
    score: number
    confidence?: number | null
    respondedAt?: Date | string
  }

  export type ValidationResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userAnswer?: StringFieldUpdateOperationsInput | string
    aiEvaluation?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ValidationResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userAnswer?: StringFieldUpdateOperationsInput | string
    aiEvaluation?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComprehensionMetricCreateInput = {
    id?: string
    conceptName: string
    date?: Date | string
    avgScore: number
    sampleSize: number
    trend?: string | null
  }

  export type ComprehensionMetricUncheckedCreateInput = {
    id?: string
    conceptName: string
    date?: Date | string
    avgScore: number
    sampleSize: number
    trend?: string | null
  }

  export type ComprehensionMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    avgScore?: FloatFieldUpdateOperationsInput | number
    sampleSize?: IntFieldUpdateOperationsInput | number
    trend?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ComprehensionMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    avgScore?: FloatFieldUpdateOperationsInput | number
    sampleSize?: IntFieldUpdateOperationsInput | number
    trend?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ComprehensionMetricCreateManyInput = {
    id?: string
    conceptName: string
    date?: Date | string
    avgScore: number
    sampleSize: number
    trend?: string | null
  }

  export type ComprehensionMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    avgScore?: FloatFieldUpdateOperationsInput | number
    sampleSize?: IntFieldUpdateOperationsInput | number
    trend?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ComprehensionMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conceptName?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    avgScore?: FloatFieldUpdateOperationsInput | number
    sampleSize?: IntFieldUpdateOperationsInput | number
    trend?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BehavioralEventCreateInput = {
    id?: string
    userId: string
    eventType: $Enums.EventType
    eventData: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    sessionPerformanceScore?: number | null
    engagementLevel?: $Enums.EngagementLevel | null
    completionQuality?: $Enums.CompletionQuality | null
    timeOfDay?: number | null
    dayOfWeek?: number | null
    contentType?: string | null
    difficultyLevel?: string | null
  }

  export type BehavioralEventUncheckedCreateInput = {
    id?: string
    userId: string
    eventType: $Enums.EventType
    eventData: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    sessionPerformanceScore?: number | null
    engagementLevel?: $Enums.EngagementLevel | null
    completionQuality?: $Enums.CompletionQuality | null
    timeOfDay?: number | null
    dayOfWeek?: number | null
    contentType?: string | null
    difficultyLevel?: string | null
  }

  export type BehavioralEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    eventData?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionPerformanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    engagementLevel?: NullableEnumEngagementLevelFieldUpdateOperationsInput | $Enums.EngagementLevel | null
    completionQuality?: NullableEnumCompletionQualityFieldUpdateOperationsInput | $Enums.CompletionQuality | null
    timeOfDay?: NullableIntFieldUpdateOperationsInput | number | null
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BehavioralEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    eventData?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionPerformanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    engagementLevel?: NullableEnumEngagementLevelFieldUpdateOperationsInput | $Enums.EngagementLevel | null
    completionQuality?: NullableEnumCompletionQualityFieldUpdateOperationsInput | $Enums.CompletionQuality | null
    timeOfDay?: NullableIntFieldUpdateOperationsInput | number | null
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BehavioralEventCreateManyInput = {
    id?: string
    userId: string
    eventType: $Enums.EventType
    eventData: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    sessionPerformanceScore?: number | null
    engagementLevel?: $Enums.EngagementLevel | null
    completionQuality?: $Enums.CompletionQuality | null
    timeOfDay?: number | null
    dayOfWeek?: number | null
    contentType?: string | null
    difficultyLevel?: string | null
  }

  export type BehavioralEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    eventData?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionPerformanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    engagementLevel?: NullableEnumEngagementLevelFieldUpdateOperationsInput | $Enums.EngagementLevel | null
    completionQuality?: NullableEnumCompletionQualityFieldUpdateOperationsInput | $Enums.CompletionQuality | null
    timeOfDay?: NullableIntFieldUpdateOperationsInput | number | null
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BehavioralEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumEventTypeFieldUpdateOperationsInput | $Enums.EventType
    eventData?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    sessionPerformanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    engagementLevel?: NullableEnumEngagementLevelFieldUpdateOperationsInput | $Enums.EngagementLevel | null
    completionQuality?: NullableEnumCompletionQualityFieldUpdateOperationsInput | $Enums.CompletionQuality | null
    timeOfDay?: NullableIntFieldUpdateOperationsInput | number | null
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    difficultyLevel?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BehavioralPatternCreateInput = {
    id?: string
    userId: string
    patternType: $Enums.BehavioralPatternType
    patternName: string
    confidence: number
    evidence: JsonNullValueInput | InputJsonValue
    detectedAt?: Date | string
    lastSeenAt?: Date | string
    occurrenceCount?: number
    insights?: InsightPatternCreateNestedManyWithoutPatternInput
  }

  export type BehavioralPatternUncheckedCreateInput = {
    id?: string
    userId: string
    patternType: $Enums.BehavioralPatternType
    patternName: string
    confidence: number
    evidence: JsonNullValueInput | InputJsonValue
    detectedAt?: Date | string
    lastSeenAt?: Date | string
    occurrenceCount?: number
    insights?: InsightPatternUncheckedCreateNestedManyWithoutPatternInput
  }

  export type BehavioralPatternUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    patternType?: EnumBehavioralPatternTypeFieldUpdateOperationsInput | $Enums.BehavioralPatternType
    patternName?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: JsonNullValueInput | InputJsonValue
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    occurrenceCount?: IntFieldUpdateOperationsInput | number
    insights?: InsightPatternUpdateManyWithoutPatternNestedInput
  }

  export type BehavioralPatternUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    patternType?: EnumBehavioralPatternTypeFieldUpdateOperationsInput | $Enums.BehavioralPatternType
    patternName?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: JsonNullValueInput | InputJsonValue
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    occurrenceCount?: IntFieldUpdateOperationsInput | number
    insights?: InsightPatternUncheckedUpdateManyWithoutPatternNestedInput
  }

  export type BehavioralPatternCreateManyInput = {
    id?: string
    userId: string
    patternType: $Enums.BehavioralPatternType
    patternName: string
    confidence: number
    evidence: JsonNullValueInput | InputJsonValue
    detectedAt?: Date | string
    lastSeenAt?: Date | string
    occurrenceCount?: number
  }

  export type BehavioralPatternUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    patternType?: EnumBehavioralPatternTypeFieldUpdateOperationsInput | $Enums.BehavioralPatternType
    patternName?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: JsonNullValueInput | InputJsonValue
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    occurrenceCount?: IntFieldUpdateOperationsInput | number
  }

  export type BehavioralPatternUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    patternType?: EnumBehavioralPatternTypeFieldUpdateOperationsInput | $Enums.BehavioralPatternType
    patternName?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: JsonNullValueInput | InputJsonValue
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    occurrenceCount?: IntFieldUpdateOperationsInput | number
  }

  export type BehavioralInsightCreateInput = {
    id?: string
    userId: string
    insightType: $Enums.InsightType
    title: string
    description: string
    actionableRecommendation: string
    confidence: number
    createdAt?: Date | string
    acknowledgedAt?: Date | string | null
    applied?: boolean
    patterns?: InsightPatternCreateNestedManyWithoutInsightInput
  }

  export type BehavioralInsightUncheckedCreateInput = {
    id?: string
    userId: string
    insightType: $Enums.InsightType
    title: string
    description: string
    actionableRecommendation: string
    confidence: number
    createdAt?: Date | string
    acknowledgedAt?: Date | string | null
    applied?: boolean
    patterns?: InsightPatternUncheckedCreateNestedManyWithoutInsightInput
  }

  export type BehavioralInsightUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    insightType?: EnumInsightTypeFieldUpdateOperationsInput | $Enums.InsightType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionableRecommendation?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied?: BoolFieldUpdateOperationsInput | boolean
    patterns?: InsightPatternUpdateManyWithoutInsightNestedInput
  }

  export type BehavioralInsightUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    insightType?: EnumInsightTypeFieldUpdateOperationsInput | $Enums.InsightType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionableRecommendation?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied?: BoolFieldUpdateOperationsInput | boolean
    patterns?: InsightPatternUncheckedUpdateManyWithoutInsightNestedInput
  }

  export type BehavioralInsightCreateManyInput = {
    id?: string
    userId: string
    insightType: $Enums.InsightType
    title: string
    description: string
    actionableRecommendation: string
    confidence: number
    createdAt?: Date | string
    acknowledgedAt?: Date | string | null
    applied?: boolean
  }

  export type BehavioralInsightUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    insightType?: EnumInsightTypeFieldUpdateOperationsInput | $Enums.InsightType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionableRecommendation?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BehavioralInsightUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    insightType?: EnumInsightTypeFieldUpdateOperationsInput | $Enums.InsightType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionableRecommendation?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InsightPatternCreateInput = {
    id?: string
    insight: BehavioralInsightCreateNestedOneWithoutPatternsInput
    pattern: BehavioralPatternCreateNestedOneWithoutInsightsInput
  }

  export type InsightPatternUncheckedCreateInput = {
    id?: string
    insightId: string
    patternId: string
  }

  export type InsightPatternUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    insight?: BehavioralInsightUpdateOneRequiredWithoutPatternsNestedInput
    pattern?: BehavioralPatternUpdateOneRequiredWithoutInsightsNestedInput
  }

  export type InsightPatternUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
  }

  export type InsightPatternCreateManyInput = {
    id?: string
    insightId: string
    patternId: string
  }

  export type InsightPatternUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type InsightPatternUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
  }

  export type UserLearningProfileCreateInput = {
    id?: string
    userId: string
    preferredStudyTimes: JsonNullValueInput | InputJsonValue
    averageSessionDuration: number
    optimalSessionDuration: number
    contentPreferences: JsonNullValueInput | InputJsonValue
    learningStyleProfile: JsonNullValueInput | InputJsonValue
    personalizedForgettingCurve: JsonNullValueInput | InputJsonValue
    lastAnalyzedAt?: Date | string
    dataQualityScore?: number
  }

  export type UserLearningProfileUncheckedCreateInput = {
    id?: string
    userId: string
    preferredStudyTimes: JsonNullValueInput | InputJsonValue
    averageSessionDuration: number
    optimalSessionDuration: number
    contentPreferences: JsonNullValueInput | InputJsonValue
    learningStyleProfile: JsonNullValueInput | InputJsonValue
    personalizedForgettingCurve: JsonNullValueInput | InputJsonValue
    lastAnalyzedAt?: Date | string
    dataQualityScore?: number
  }

  export type UserLearningProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    preferredStudyTimes?: JsonNullValueInput | InputJsonValue
    averageSessionDuration?: IntFieldUpdateOperationsInput | number
    optimalSessionDuration?: IntFieldUpdateOperationsInput | number
    contentPreferences?: JsonNullValueInput | InputJsonValue
    learningStyleProfile?: JsonNullValueInput | InputJsonValue
    personalizedForgettingCurve?: JsonNullValueInput | InputJsonValue
    lastAnalyzedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataQualityScore?: FloatFieldUpdateOperationsInput | number
  }

  export type UserLearningProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    preferredStudyTimes?: JsonNullValueInput | InputJsonValue
    averageSessionDuration?: IntFieldUpdateOperationsInput | number
    optimalSessionDuration?: IntFieldUpdateOperationsInput | number
    contentPreferences?: JsonNullValueInput | InputJsonValue
    learningStyleProfile?: JsonNullValueInput | InputJsonValue
    personalizedForgettingCurve?: JsonNullValueInput | InputJsonValue
    lastAnalyzedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataQualityScore?: FloatFieldUpdateOperationsInput | number
  }

  export type UserLearningProfileCreateManyInput = {
    id?: string
    userId: string
    preferredStudyTimes: JsonNullValueInput | InputJsonValue
    averageSessionDuration: number
    optimalSessionDuration: number
    contentPreferences: JsonNullValueInput | InputJsonValue
    learningStyleProfile: JsonNullValueInput | InputJsonValue
    personalizedForgettingCurve: JsonNullValueInput | InputJsonValue
    lastAnalyzedAt?: Date | string
    dataQualityScore?: number
  }

  export type UserLearningProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    preferredStudyTimes?: JsonNullValueInput | InputJsonValue
    averageSessionDuration?: IntFieldUpdateOperationsInput | number
    optimalSessionDuration?: IntFieldUpdateOperationsInput | number
    contentPreferences?: JsonNullValueInput | InputJsonValue
    learningStyleProfile?: JsonNullValueInput | InputJsonValue
    personalizedForgettingCurve?: JsonNullValueInput | InputJsonValue
    lastAnalyzedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataQualityScore?: FloatFieldUpdateOperationsInput | number
  }

  export type UserLearningProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    preferredStudyTimes?: JsonNullValueInput | InputJsonValue
    averageSessionDuration?: IntFieldUpdateOperationsInput | number
    optimalSessionDuration?: IntFieldUpdateOperationsInput | number
    contentPreferences?: JsonNullValueInput | InputJsonValue
    learningStyleProfile?: JsonNullValueInput | InputJsonValue
    personalizedForgettingCurve?: JsonNullValueInput | InputJsonValue
    lastAnalyzedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dataQualityScore?: FloatFieldUpdateOperationsInput | number
  }

  export type LearningPatternCreateInput = {
    id?: string
    userId: string
    patternType: $Enums.PatternType
    patternData: JsonNullValueInput | InputJsonValue
    confidence: number
    detectedAt?: Date | string
    lastSeenAt?: Date | string
  }

  export type LearningPatternUncheckedCreateInput = {
    id?: string
    userId: string
    patternType: $Enums.PatternType
    patternData: JsonNullValueInput | InputJsonValue
    confidence: number
    detectedAt?: Date | string
    lastSeenAt?: Date | string
  }

  export type LearningPatternUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    patternType?: EnumPatternTypeFieldUpdateOperationsInput | $Enums.PatternType
    patternData?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningPatternUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    patternType?: EnumPatternTypeFieldUpdateOperationsInput | $Enums.PatternType
    patternData?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningPatternCreateManyInput = {
    id?: string
    userId: string
    patternType: $Enums.PatternType
    patternData: JsonNullValueInput | InputJsonValue
    confidence: number
    detectedAt?: Date | string
    lastSeenAt?: Date | string
  }

  export type LearningPatternUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    patternType?: EnumPatternTypeFieldUpdateOperationsInput | $Enums.PatternType
    patternData?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningPatternUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    patternType?: EnumPatternTypeFieldUpdateOperationsInput | $Enums.PatternType
    patternData?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformancePredictionCreateInput = {
    id?: string
    userId: string
    predictedFor: Date | string
    predictionType: string
    prediction: JsonNullValueInput | InputJsonValue
    confidence: number
    createdAt?: Date | string
  }

  export type PerformancePredictionUncheckedCreateInput = {
    id?: string
    userId: string
    predictedFor: Date | string
    predictionType: string
    prediction: JsonNullValueInput | InputJsonValue
    confidence: number
    createdAt?: Date | string
  }

  export type PerformancePredictionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    predictedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    predictionType?: StringFieldUpdateOperationsInput | string
    prediction?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformancePredictionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    predictedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    predictionType?: StringFieldUpdateOperationsInput | string
    prediction?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformancePredictionCreateManyInput = {
    id?: string
    userId: string
    predictedFor: Date | string
    predictionType: string
    prediction: JsonNullValueInput | InputJsonValue
    confidence: number
    createdAt?: Date | string
  }

  export type PerformancePredictionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    predictedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    predictionType?: StringFieldUpdateOperationsInput | string
    prediction?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformancePredictionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    predictedFor?: DateTimeFieldUpdateOperationsInput | Date | string
    predictionType?: StringFieldUpdateOperationsInput | string
    prediction?: JsonNullValueInput | InputJsonValue
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrugglePredictionCreateInput = {
    id?: string
    userId: string
    topicId?: string | null
    predictionDate?: Date | string
    predictedStruggleProbability: number
    predictionConfidence: number
    predictionStatus?: $Enums.PredictionStatus
    actualOutcome?: boolean | null
    outcomeRecordedAt?: Date | string | null
    featureVector: JsonNullValueInput | InputJsonValue
    learningObjective?: LearningObjectiveCreateNestedOneWithoutStrugglePredictionsInput
    indicators?: StruggleIndicatorCreateNestedManyWithoutPredictionInput
    interventions?: InterventionRecommendationCreateNestedManyWithoutPredictionInput
    feedbacks?: PredictionFeedbackCreateNestedManyWithoutPredictionInput
  }

  export type StrugglePredictionUncheckedCreateInput = {
    id?: string
    userId: string
    learningObjectiveId?: string | null
    topicId?: string | null
    predictionDate?: Date | string
    predictedStruggleProbability: number
    predictionConfidence: number
    predictionStatus?: $Enums.PredictionStatus
    actualOutcome?: boolean | null
    outcomeRecordedAt?: Date | string | null
    featureVector: JsonNullValueInput | InputJsonValue
    indicators?: StruggleIndicatorUncheckedCreateNestedManyWithoutPredictionInput
    interventions?: InterventionRecommendationUncheckedCreateNestedManyWithoutPredictionInput
    feedbacks?: PredictionFeedbackUncheckedCreateNestedManyWithoutPredictionInput
  }

  export type StrugglePredictionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    predictionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    predictedStruggleProbability?: FloatFieldUpdateOperationsInput | number
    predictionConfidence?: FloatFieldUpdateOperationsInput | number
    predictionStatus?: EnumPredictionStatusFieldUpdateOperationsInput | $Enums.PredictionStatus
    actualOutcome?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outcomeRecordedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featureVector?: JsonNullValueInput | InputJsonValue
    learningObjective?: LearningObjectiveUpdateOneWithoutStrugglePredictionsNestedInput
    indicators?: StruggleIndicatorUpdateManyWithoutPredictionNestedInput
    interventions?: InterventionRecommendationUpdateManyWithoutPredictionNestedInput
    feedbacks?: PredictionFeedbackUpdateManyWithoutPredictionNestedInput
  }

  export type StrugglePredictionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    learningObjectiveId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    predictionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    predictedStruggleProbability?: FloatFieldUpdateOperationsInput | number
    predictionConfidence?: FloatFieldUpdateOperationsInput | number
    predictionStatus?: EnumPredictionStatusFieldUpdateOperationsInput | $Enums.PredictionStatus
    actualOutcome?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outcomeRecordedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featureVector?: JsonNullValueInput | InputJsonValue
    indicators?: StruggleIndicatorUncheckedUpdateManyWithoutPredictionNestedInput
    interventions?: InterventionRecommendationUncheckedUpdateManyWithoutPredictionNestedInput
    feedbacks?: PredictionFeedbackUncheckedUpdateManyWithoutPredictionNestedInput
  }

  export type StrugglePredictionCreateManyInput = {
    id?: string
    userId: string
    learningObjectiveId?: string | null
    topicId?: string | null
    predictionDate?: Date | string
    predictedStruggleProbability: number
    predictionConfidence: number
    predictionStatus?: $Enums.PredictionStatus
    actualOutcome?: boolean | null
    outcomeRecordedAt?: Date | string | null
    featureVector: JsonNullValueInput | InputJsonValue
  }

  export type StrugglePredictionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    predictionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    predictedStruggleProbability?: FloatFieldUpdateOperationsInput | number
    predictionConfidence?: FloatFieldUpdateOperationsInput | number
    predictionStatus?: EnumPredictionStatusFieldUpdateOperationsInput | $Enums.PredictionStatus
    actualOutcome?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outcomeRecordedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featureVector?: JsonNullValueInput | InputJsonValue
  }

  export type StrugglePredictionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    learningObjectiveId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    predictionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    predictedStruggleProbability?: FloatFieldUpdateOperationsInput | number
    predictionConfidence?: FloatFieldUpdateOperationsInput | number
    predictionStatus?: EnumPredictionStatusFieldUpdateOperationsInput | $Enums.PredictionStatus
    actualOutcome?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outcomeRecordedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featureVector?: JsonNullValueInput | InputJsonValue
  }

  export type StruggleIndicatorCreateInput = {
    id?: string
    userId: string
    indicatorType: $Enums.IndicatorType
    severity?: $Enums.Severity
    detectedAt?: Date | string
    context: JsonNullValueInput | InputJsonValue
    prediction?: StrugglePredictionCreateNestedOneWithoutIndicatorsInput
    learningObjective: LearningObjectiveCreateNestedOneWithoutStruggleIndicatorsInput
  }

  export type StruggleIndicatorUncheckedCreateInput = {
    id?: string
    userId: string
    predictionId?: string | null
    learningObjectiveId: string
    indicatorType: $Enums.IndicatorType
    severity?: $Enums.Severity
    detectedAt?: Date | string
    context: JsonNullValueInput | InputJsonValue
  }

  export type StruggleIndicatorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    indicatorType?: EnumIndicatorTypeFieldUpdateOperationsInput | $Enums.IndicatorType
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: JsonNullValueInput | InputJsonValue
    prediction?: StrugglePredictionUpdateOneWithoutIndicatorsNestedInput
    learningObjective?: LearningObjectiveUpdateOneRequiredWithoutStruggleIndicatorsNestedInput
  }

  export type StruggleIndicatorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    predictionId?: NullableStringFieldUpdateOperationsInput | string | null
    learningObjectiveId?: StringFieldUpdateOperationsInput | string
    indicatorType?: EnumIndicatorTypeFieldUpdateOperationsInput | $Enums.IndicatorType
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: JsonNullValueInput | InputJsonValue
  }

  export type StruggleIndicatorCreateManyInput = {
    id?: string
    userId: string
    predictionId?: string | null
    learningObjectiveId: string
    indicatorType: $Enums.IndicatorType
    severity?: $Enums.Severity
    detectedAt?: Date | string
    context: JsonNullValueInput | InputJsonValue
  }

  export type StruggleIndicatorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    indicatorType?: EnumIndicatorTypeFieldUpdateOperationsInput | $Enums.IndicatorType
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: JsonNullValueInput | InputJsonValue
  }

  export type StruggleIndicatorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    predictionId?: NullableStringFieldUpdateOperationsInput | string | null
    learningObjectiveId?: StringFieldUpdateOperationsInput | string
    indicatorType?: EnumIndicatorTypeFieldUpdateOperationsInput | $Enums.IndicatorType
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: JsonNullValueInput | InputJsonValue
  }

  export type InterventionRecommendationCreateInput = {
    id?: string
    userId: string
    interventionType: $Enums.InterventionType
    description: string
    reasoning: string
    priority?: number
    status?: $Enums.InterventionStatus
    appliedAt?: Date | string | null
    effectiveness?: number | null
    createdAt?: Date | string
    prediction: StrugglePredictionCreateNestedOneWithoutInterventionsInput
    mission?: MissionCreateNestedOneWithoutInterventionsInput
  }

  export type InterventionRecommendationUncheckedCreateInput = {
    id?: string
    predictionId: string
    userId: string
    interventionType: $Enums.InterventionType
    description: string
    reasoning: string
    priority?: number
    status?: $Enums.InterventionStatus
    appliedAt?: Date | string | null
    appliedToMissionId?: string | null
    effectiveness?: number | null
    createdAt?: Date | string
  }

  export type InterventionRecommendationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    interventionType?: EnumInterventionTypeFieldUpdateOperationsInput | $Enums.InterventionType
    description?: StringFieldUpdateOperationsInput | string
    reasoning?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prediction?: StrugglePredictionUpdateOneRequiredWithoutInterventionsNestedInput
    mission?: MissionUpdateOneWithoutInterventionsNestedInput
  }

  export type InterventionRecommendationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    predictionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    interventionType?: EnumInterventionTypeFieldUpdateOperationsInput | $Enums.InterventionType
    description?: StringFieldUpdateOperationsInput | string
    reasoning?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedToMissionId?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionRecommendationCreateManyInput = {
    id?: string
    predictionId: string
    userId: string
    interventionType: $Enums.InterventionType
    description: string
    reasoning: string
    priority?: number
    status?: $Enums.InterventionStatus
    appliedAt?: Date | string | null
    appliedToMissionId?: string | null
    effectiveness?: number | null
    createdAt?: Date | string
  }

  export type InterventionRecommendationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    interventionType?: EnumInterventionTypeFieldUpdateOperationsInput | $Enums.InterventionType
    description?: StringFieldUpdateOperationsInput | string
    reasoning?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionRecommendationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    predictionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    interventionType?: EnumInterventionTypeFieldUpdateOperationsInput | $Enums.InterventionType
    description?: StringFieldUpdateOperationsInput | string
    reasoning?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedToMissionId?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionFeedbackCreateInput = {
    id?: string
    userId: string
    feedbackType: $Enums.FeedbackType
    actualStruggle: boolean
    helpfulness?: number | null
    comments?: string | null
    submittedAt?: Date | string
    prediction: StrugglePredictionCreateNestedOneWithoutFeedbacksInput
  }

  export type PredictionFeedbackUncheckedCreateInput = {
    id?: string
    predictionId: string
    userId: string
    feedbackType: $Enums.FeedbackType
    actualStruggle: boolean
    helpfulness?: number | null
    comments?: string | null
    submittedAt?: Date | string
  }

  export type PredictionFeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feedbackType?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    actualStruggle?: BoolFieldUpdateOperationsInput | boolean
    helpfulness?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prediction?: StrugglePredictionUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type PredictionFeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    predictionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feedbackType?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    actualStruggle?: BoolFieldUpdateOperationsInput | boolean
    helpfulness?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionFeedbackCreateManyInput = {
    id?: string
    predictionId: string
    userId: string
    feedbackType: $Enums.FeedbackType
    actualStruggle: boolean
    helpfulness?: number | null
    comments?: string | null
    submittedAt?: Date | string
  }

  export type PredictionFeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feedbackType?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    actualStruggle?: BoolFieldUpdateOperationsInput | boolean
    helpfulness?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionFeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    predictionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feedbackType?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    actualStruggle?: BoolFieldUpdateOperationsInput | boolean
    helpfulness?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceMetricCreateInput = {
    id?: string
    userId: string
    date?: Date | string
    retentionScore: number
    studyTimeMs: number
    reviewCount: number
    correctReviews: number
    incorrectReviews: number
    createdAt?: Date | string
    learningObjective: LearningObjectiveCreateNestedOneWithoutPerformanceMetricsInput
  }

  export type PerformanceMetricUncheckedCreateInput = {
    id?: string
    userId: string
    learningObjectiveId: string
    date?: Date | string
    retentionScore: number
    studyTimeMs: number
    reviewCount: number
    correctReviews: number
    incorrectReviews: number
    createdAt?: Date | string
  }

  export type PerformanceMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionScore?: FloatFieldUpdateOperationsInput | number
    studyTimeMs?: IntFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    correctReviews?: IntFieldUpdateOperationsInput | number
    incorrectReviews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learningObjective?: LearningObjectiveUpdateOneRequiredWithoutPerformanceMetricsNestedInput
  }

  export type PerformanceMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    learningObjectiveId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionScore?: FloatFieldUpdateOperationsInput | number
    studyTimeMs?: IntFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    correctReviews?: IntFieldUpdateOperationsInput | number
    incorrectReviews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceMetricCreateManyInput = {
    id?: string
    userId: string
    learningObjectiveId: string
    date?: Date | string
    retentionScore: number
    studyTimeMs: number
    reviewCount: number
    correctReviews: number
    incorrectReviews: number
    createdAt?: Date | string
  }

  export type PerformanceMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionScore?: FloatFieldUpdateOperationsInput | number
    studyTimeMs?: IntFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    correctReviews?: IntFieldUpdateOperationsInput | number
    incorrectReviews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    learningObjectiveId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionScore?: FloatFieldUpdateOperationsInput | number
    studyTimeMs?: IntFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    correctReviews?: IntFieldUpdateOperationsInput | number
    incorrectReviews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCreateInput = {
    id?: string
    name: string
    date: Date | string
    coverageTopics?: ExamCreatecoverageTopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutExamsInput
    course: CourseCreateNestedOneWithoutExamsInput
  }

  export type ExamUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    date: Date | string
    courseId: string
    coverageTopics?: ExamCreatecoverageTopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    coverageTopics?: ExamUpdatecoverageTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExamsNestedInput
    course?: CourseUpdateOneRequiredWithoutExamsNestedInput
  }

  export type ExamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: StringFieldUpdateOperationsInput | string
    coverageTopics?: ExamUpdatecoverageTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCreateManyInput = {
    id?: string
    userId: string
    name: string
    date: Date | string
    courseId: string
    coverageTopics?: ExamCreatecoverageTopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    coverageTopics?: ExamUpdatecoverageTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: StringFieldUpdateOperationsInput | string
    coverageTopics?: ExamUpdatecoverageTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoursePriorityCreateInput = {
    id?: string
    priorityLevel?: $Enums.PriorityLevel
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCoursePrioritiesInput
    course: CourseCreateNestedOneWithoutCoursePrioritiesInput
  }

  export type CoursePriorityUncheckedCreateInput = {
    id?: string
    userId: string
    courseId: string
    priorityLevel?: $Enums.PriorityLevel
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoursePriorityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    priorityLevel?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoursePrioritiesNestedInput
    course?: CourseUpdateOneRequiredWithoutCoursePrioritiesNestedInput
  }

  export type CoursePriorityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    priorityLevel?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoursePriorityCreateManyInput = {
    id?: string
    userId: string
    courseId: string
    priorityLevel?: $Enums.PriorityLevel
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoursePriorityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    priorityLevel?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoursePriorityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    priorityLevel?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriorityFeedbackCreateInput = {
    id?: string
    userId: string
    suggestedPriority: number
    userFeedback: $Enums.FeedbackRating
    notes?: string | null
    createdAt?: Date | string
    learningObjective: LearningObjectiveCreateNestedOneWithoutPriorityFeedbackInput
  }

  export type PriorityFeedbackUncheckedCreateInput = {
    id?: string
    userId: string
    objectiveId: string
    suggestedPriority: number
    userFeedback: $Enums.FeedbackRating
    notes?: string | null
    createdAt?: Date | string
  }

  export type PriorityFeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    suggestedPriority?: FloatFieldUpdateOperationsInput | number
    userFeedback?: EnumFeedbackRatingFieldUpdateOperationsInput | $Enums.FeedbackRating
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    learningObjective?: LearningObjectiveUpdateOneRequiredWithoutPriorityFeedbackNestedInput
  }

  export type PriorityFeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    objectiveId?: StringFieldUpdateOperationsInput | string
    suggestedPriority?: FloatFieldUpdateOperationsInput | number
    userFeedback?: EnumFeedbackRatingFieldUpdateOperationsInput | $Enums.FeedbackRating
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriorityFeedbackCreateManyInput = {
    id?: string
    userId: string
    objectiveId: string
    suggestedPriority: number
    userFeedback: $Enums.FeedbackRating
    notes?: string | null
    createdAt?: Date | string
  }

  export type PriorityFeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    suggestedPriority?: FloatFieldUpdateOperationsInput | number
    userFeedback?: EnumFeedbackRatingFieldUpdateOperationsInput | $Enums.FeedbackRating
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriorityFeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    objectiveId?: StringFieldUpdateOperationsInput | string
    suggestedPriority?: FloatFieldUpdateOperationsInput | number
    userFeedback?: EnumFeedbackRatingFieldUpdateOperationsInput | $Enums.FeedbackRating
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreakCreateInput = {
    id?: string
    currentStreak?: number
    longestStreak?: number
    lastStudyDate?: Date | string | null
    freezesRemaining?: number
    freezeUsedDates?: StreakCreatefreezeUsedDatesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStreakInput
  }

  export type StreakUncheckedCreateInput = {
    id?: string
    userId: string
    currentStreak?: number
    longestStreak?: number
    lastStudyDate?: Date | string | null
    freezesRemaining?: number
    freezeUsedDates?: StreakCreatefreezeUsedDatesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StreakUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastStudyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    freezesRemaining?: IntFieldUpdateOperationsInput | number
    freezeUsedDates?: StreakUpdatefreezeUsedDatesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStreakNestedInput
  }

  export type StreakUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastStudyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    freezesRemaining?: IntFieldUpdateOperationsInput | number
    freezeUsedDates?: StreakUpdatefreezeUsedDatesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreakCreateManyInput = {
    id?: string
    userId: string
    currentStreak?: number
    longestStreak?: number
    lastStudyDate?: Date | string | null
    freezesRemaining?: number
    freezeUsedDates?: StreakCreatefreezeUsedDatesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StreakUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastStudyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    freezesRemaining?: IntFieldUpdateOperationsInput | number
    freezeUsedDates?: StreakUpdatefreezeUsedDatesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreakUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastStudyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    freezesRemaining?: IntFieldUpdateOperationsInput | number
    freezeUsedDates?: StreakUpdatefreezeUsedDatesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementCreateInput = {
    id?: string
    type: $Enums.AchievementType
    name: string
    description: string
    tier?: $Enums.AchievementTier
    earnedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutAchievementsInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.AchievementType
    name: string
    description: string
    tier?: $Enums.AchievementTier
    earnedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAchievementTypeFieldUpdateOperationsInput | $Enums.AchievementType
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tier?: EnumAchievementTierFieldUpdateOperationsInput | $Enums.AchievementTier
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumAchievementTypeFieldUpdateOperationsInput | $Enums.AchievementType
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tier?: EnumAchievementTierFieldUpdateOperationsInput | $Enums.AchievementTier
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AchievementCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.AchievementType
    name: string
    description: string
    tier?: $Enums.AchievementTier
    earnedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAchievementTypeFieldUpdateOperationsInput | $Enums.AchievementType
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tier?: EnumAchievementTierFieldUpdateOperationsInput | $Enums.AchievementTier
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumAchievementTypeFieldUpdateOperationsInput | $Enums.AchievementType
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tier?: EnumAchievementTierFieldUpdateOperationsInput | $Enums.AchievementTier
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StudyGoalCreateInput = {
    id?: string
    goalType: $Enums.GoalType
    targetValue: number
    currentProgress?: number
    period: $Enums.GoalPeriod
    startDate: Date | string
    endDate: Date | string
    isCompleted?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutStudyGoalsInput
  }

  export type StudyGoalUncheckedCreateInput = {
    id?: string
    userId: string
    goalType: $Enums.GoalType
    targetValue: number
    currentProgress?: number
    period: $Enums.GoalPeriod
    startDate: Date | string
    endDate: Date | string
    isCompleted?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type StudyGoalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalType?: EnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType
    targetValue?: IntFieldUpdateOperationsInput | number
    currentProgress?: IntFieldUpdateOperationsInput | number
    period?: EnumGoalPeriodFieldUpdateOperationsInput | $Enums.GoalPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudyGoalsNestedInput
  }

  export type StudyGoalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    goalType?: EnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType
    targetValue?: IntFieldUpdateOperationsInput | number
    currentProgress?: IntFieldUpdateOperationsInput | number
    period?: EnumGoalPeriodFieldUpdateOperationsInput | $Enums.GoalPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyGoalCreateManyInput = {
    id?: string
    userId: string
    goalType: $Enums.GoalType
    targetValue: number
    currentProgress?: number
    period: $Enums.GoalPeriod
    startDate: Date | string
    endDate: Date | string
    isCompleted?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type StudyGoalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalType?: EnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType
    targetValue?: IntFieldUpdateOperationsInput | number
    currentProgress?: IntFieldUpdateOperationsInput | number
    period?: EnumGoalPeriodFieldUpdateOperationsInput | $Enums.GoalPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyGoalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    goalType?: EnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType
    targetValue?: IntFieldUpdateOperationsInput | number
    currentProgress?: IntFieldUpdateOperationsInput | number
    period?: EnumGoalPeriodFieldUpdateOperationsInput | $Enums.GoalPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionAnalyticsCreateInput = {
    id?: string
    userId: string
    date?: Date | string
    period: $Enums.AnalyticsPeriod
    missionsGenerated: number
    missionsCompleted: number
    missionsSkipped: number
    avgCompletionRate: number
    avgTimeAccuracy: number
    avgDifficultyRating: number
    avgSuccessScore: number
    createdAt?: Date | string
  }

  export type MissionAnalyticsUncheckedCreateInput = {
    id?: string
    userId: string
    date?: Date | string
    period: $Enums.AnalyticsPeriod
    missionsGenerated: number
    missionsCompleted: number
    missionsSkipped: number
    avgCompletionRate: number
    avgTimeAccuracy: number
    avgDifficultyRating: number
    avgSuccessScore: number
    createdAt?: Date | string
  }

  export type MissionAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: EnumAnalyticsPeriodFieldUpdateOperationsInput | $Enums.AnalyticsPeriod
    missionsGenerated?: IntFieldUpdateOperationsInput | number
    missionsCompleted?: IntFieldUpdateOperationsInput | number
    missionsSkipped?: IntFieldUpdateOperationsInput | number
    avgCompletionRate?: FloatFieldUpdateOperationsInput | number
    avgTimeAccuracy?: FloatFieldUpdateOperationsInput | number
    avgDifficultyRating?: FloatFieldUpdateOperationsInput | number
    avgSuccessScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: EnumAnalyticsPeriodFieldUpdateOperationsInput | $Enums.AnalyticsPeriod
    missionsGenerated?: IntFieldUpdateOperationsInput | number
    missionsCompleted?: IntFieldUpdateOperationsInput | number
    missionsSkipped?: IntFieldUpdateOperationsInput | number
    avgCompletionRate?: FloatFieldUpdateOperationsInput | number
    avgTimeAccuracy?: FloatFieldUpdateOperationsInput | number
    avgDifficultyRating?: FloatFieldUpdateOperationsInput | number
    avgSuccessScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionAnalyticsCreateManyInput = {
    id?: string
    userId: string
    date?: Date | string
    period: $Enums.AnalyticsPeriod
    missionsGenerated: number
    missionsCompleted: number
    missionsSkipped: number
    avgCompletionRate: number
    avgTimeAccuracy: number
    avgDifficultyRating: number
    avgSuccessScore: number
    createdAt?: Date | string
  }

  export type MissionAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: EnumAnalyticsPeriodFieldUpdateOperationsInput | $Enums.AnalyticsPeriod
    missionsGenerated?: IntFieldUpdateOperationsInput | number
    missionsCompleted?: IntFieldUpdateOperationsInput | number
    missionsSkipped?: IntFieldUpdateOperationsInput | number
    avgCompletionRate?: FloatFieldUpdateOperationsInput | number
    avgTimeAccuracy?: FloatFieldUpdateOperationsInput | number
    avgDifficultyRating?: FloatFieldUpdateOperationsInput | number
    avgSuccessScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    period?: EnumAnalyticsPeriodFieldUpdateOperationsInput | $Enums.AnalyticsPeriod
    missionsGenerated?: IntFieldUpdateOperationsInput | number
    missionsCompleted?: IntFieldUpdateOperationsInput | number
    missionsSkipped?: IntFieldUpdateOperationsInput | number
    avgCompletionRate?: FloatFieldUpdateOperationsInput | number
    avgTimeAccuracy?: FloatFieldUpdateOperationsInput | number
    avgDifficultyRating?: FloatFieldUpdateOperationsInput | number
    avgSuccessScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionFeedbackCreateInput = {
    id?: string
    userId: string
    helpfulnessRating: number
    relevanceScore: number
    paceRating: $Enums.PaceRating
    improvementSuggestions?: string | null
    submittedAt?: Date | string
    mission: MissionCreateNestedOneWithoutFeedbackInput
  }

  export type MissionFeedbackUncheckedCreateInput = {
    id?: string
    userId: string
    missionId: string
    helpfulnessRating: number
    relevanceScore: number
    paceRating: $Enums.PaceRating
    improvementSuggestions?: string | null
    submittedAt?: Date | string
  }

  export type MissionFeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    helpfulnessRating?: IntFieldUpdateOperationsInput | number
    relevanceScore?: IntFieldUpdateOperationsInput | number
    paceRating?: EnumPaceRatingFieldUpdateOperationsInput | $Enums.PaceRating
    improvementSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mission?: MissionUpdateOneRequiredWithoutFeedbackNestedInput
  }

  export type MissionFeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    missionId?: StringFieldUpdateOperationsInput | string
    helpfulnessRating?: IntFieldUpdateOperationsInput | number
    relevanceScore?: IntFieldUpdateOperationsInput | number
    paceRating?: EnumPaceRatingFieldUpdateOperationsInput | $Enums.PaceRating
    improvementSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionFeedbackCreateManyInput = {
    id?: string
    userId: string
    missionId: string
    helpfulnessRating: number
    relevanceScore: number
    paceRating: $Enums.PaceRating
    improvementSuggestions?: string | null
    submittedAt?: Date | string
  }

  export type MissionFeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    helpfulnessRating?: IntFieldUpdateOperationsInput | number
    relevanceScore?: IntFieldUpdateOperationsInput | number
    paceRating?: EnumPaceRatingFieldUpdateOperationsInput | $Enums.PaceRating
    improvementSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionFeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    missionId?: StringFieldUpdateOperationsInput | string
    helpfulnessRating?: IntFieldUpdateOperationsInput | number
    relevanceScore?: IntFieldUpdateOperationsInput | number
    paceRating?: EnumPaceRatingFieldUpdateOperationsInput | $Enums.PaceRating
    improvementSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionStreakCreateInput = {
    id?: string
    currentStreak?: number
    longestStreak?: number
    lastCompletedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMissionStreakInput
  }

  export type MissionStreakUncheckedCreateInput = {
    id?: string
    userId: string
    currentStreak?: number
    longestStreak?: number
    lastCompletedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MissionStreakUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMissionStreakNestedInput
  }

  export type MissionStreakUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionStreakCreateManyInput = {
    id?: string
    userId: string
    currentStreak?: number
    longestStreak?: number
    lastCompletedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MissionStreakUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionStreakUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionReviewCreateInput = {
    id?: string
    period: $Enums.ReviewPeriod
    startDate: Date | string
    endDate: Date | string
    summary: JsonNullValueInput | InputJsonValue
    highlights: JsonNullValueInput | InputJsonValue
    insights: JsonNullValueInput | InputJsonValue
    recommendations: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
    user: UserCreateNestedOneWithoutMissionReviewsInput
  }

  export type MissionReviewUncheckedCreateInput = {
    id?: string
    userId: string
    period: $Enums.ReviewPeriod
    startDate: Date | string
    endDate: Date | string
    summary: JsonNullValueInput | InputJsonValue
    highlights: JsonNullValueInput | InputJsonValue
    insights: JsonNullValueInput | InputJsonValue
    recommendations: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
  }

  export type MissionReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: EnumReviewPeriodFieldUpdateOperationsInput | $Enums.ReviewPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: JsonNullValueInput | InputJsonValue
    highlights?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMissionReviewsNestedInput
  }

  export type MissionReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    period?: EnumReviewPeriodFieldUpdateOperationsInput | $Enums.ReviewPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: JsonNullValueInput | InputJsonValue
    highlights?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionReviewCreateManyInput = {
    id?: string
    userId: string
    period: $Enums.ReviewPeriod
    startDate: Date | string
    endDate: Date | string
    summary: JsonNullValueInput | InputJsonValue
    highlights: JsonNullValueInput | InputJsonValue
    insights: JsonNullValueInput | InputJsonValue
    recommendations: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
  }

  export type MissionReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: EnumReviewPeriodFieldUpdateOperationsInput | $Enums.ReviewPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: JsonNullValueInput | InputJsonValue
    highlights?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    period?: EnumReviewPeriodFieldUpdateOperationsInput | $Enums.ReviewPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: JsonNullValueInput | InputJsonValue
    highlights?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type LectureListRelationFilter = {
    every?: LectureWhereInput
    some?: LectureWhereInput
    none?: LectureWhereInput
  }

  export type StudySessionListRelationFilter = {
    every?: StudySessionWhereInput
    some?: StudySessionWhereInput
    none?: StudySessionWhereInput
  }

  export type MissionListRelationFilter = {
    every?: MissionWhereInput
    some?: MissionWhereInput
    none?: MissionWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type ExamListRelationFilter = {
    every?: ExamWhereInput
    some?: ExamWhereInput
    none?: ExamWhereInput
  }

  export type CoursePriorityListRelationFilter = {
    every?: CoursePriorityWhereInput
    some?: CoursePriorityWhereInput
    none?: CoursePriorityWhereInput
  }

  export type StreakNullableRelationFilter = {
    is?: StreakWhereInput | null
    isNot?: StreakWhereInput | null
  }

  export type AchievementListRelationFilter = {
    every?: AchievementWhereInput
    some?: AchievementWhereInput
    none?: AchievementWhereInput
  }

  export type StudyGoalListRelationFilter = {
    every?: StudyGoalWhereInput
    some?: StudyGoalWhereInput
    none?: StudyGoalWhereInput
  }

  export type MissionStreakNullableRelationFilter = {
    is?: MissionStreakWhereInput | null
    isNot?: MissionStreakWhereInput | null
  }

  export type MissionReviewListRelationFilter = {
    every?: MissionReviewWhereInput
    some?: MissionReviewWhereInput
    none?: MissionReviewWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LectureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudySessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoursePriorityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudyGoalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MissionReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    defaultMissionMinutes?: SortOrder
    missionDifficulty?: SortOrder
    preferredStudyTime?: SortOrder
    autoGenerateMissions?: SortOrder
    performanceTrackingEnabled?: SortOrder
    includeInAnalytics?: SortOrder
    lastMissionAdaptation?: SortOrder
    behavioralAnalysisEnabled?: SortOrder
    learningStyleProfilingEnabled?: SortOrder
    shareAnonymizedPatterns?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    defaultMissionMinutes?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    defaultMissionMinutes?: SortOrder
    missionDifficulty?: SortOrder
    preferredStudyTime?: SortOrder
    autoGenerateMissions?: SortOrder
    performanceTrackingEnabled?: SortOrder
    includeInAnalytics?: SortOrder
    lastMissionAdaptation?: SortOrder
    behavioralAnalysisEnabled?: SortOrder
    learningStyleProfilingEnabled?: SortOrder
    shareAnonymizedPatterns?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    defaultMissionMinutes?: SortOrder
    missionDifficulty?: SortOrder
    preferredStudyTime?: SortOrder
    autoGenerateMissions?: SortOrder
    performanceTrackingEnabled?: SortOrder
    includeInAnalytics?: SortOrder
    lastMissionAdaptation?: SortOrder
    behavioralAnalysisEnabled?: SortOrder
    learningStyleProfilingEnabled?: SortOrder
    shareAnonymizedPatterns?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    defaultMissionMinutes?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CardListRelationFilter = {
    every?: CardWhereInput
    some?: CardWhereInput
    none?: CardWhereInput
  }

  export type CardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    term?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    term?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    term?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumProcessingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusFilter<$PrismaModel> | $Enums.ProcessingStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type CourseRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type ContentChunkListRelationFilter = {
    every?: ContentChunkWhereInput
    some?: ContentChunkWhereInput
    none?: ContentChunkWhereInput
  }

  export type LearningObjectiveListRelationFilter = {
    every?: LearningObjectiveWhereInput
    some?: LearningObjectiveWhereInput
    none?: LearningObjectiveWhereInput
  }

  export type ContentChunkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LearningObjectiveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LectureCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    processingStatus?: SortOrder
    uploadedAt?: SortOrder
    processedAt?: SortOrder
    processingProgress?: SortOrder
    totalPages?: SortOrder
    processedPages?: SortOrder
    processingStartedAt?: SortOrder
    estimatedCompletionAt?: SortOrder
    weekNumber?: SortOrder
    topicTags?: SortOrder
  }

  export type LectureAvgOrderByAggregateInput = {
    fileSize?: SortOrder
    processingProgress?: SortOrder
    totalPages?: SortOrder
    processedPages?: SortOrder
    weekNumber?: SortOrder
  }

  export type LectureMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    processingStatus?: SortOrder
    uploadedAt?: SortOrder
    processedAt?: SortOrder
    processingProgress?: SortOrder
    totalPages?: SortOrder
    processedPages?: SortOrder
    processingStartedAt?: SortOrder
    estimatedCompletionAt?: SortOrder
    weekNumber?: SortOrder
  }

  export type LectureMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    processingStatus?: SortOrder
    uploadedAt?: SortOrder
    processedAt?: SortOrder
    processingProgress?: SortOrder
    totalPages?: SortOrder
    processedPages?: SortOrder
    processingStartedAt?: SortOrder
    estimatedCompletionAt?: SortOrder
    weekNumber?: SortOrder
  }

  export type LectureSumOrderByAggregateInput = {
    fileSize?: SortOrder
    processingProgress?: SortOrder
    totalPages?: SortOrder
    processedPages?: SortOrder
    weekNumber?: SortOrder
  }

  export type EnumProcessingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcessingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessingStatusFilter<$PrismaModel>
    _max?: NestedEnumProcessingStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type LectureRelationFilter = {
    is?: LectureWhereInput
    isNot?: LectureWhereInput
  }

  export type ContentChunkCountOrderByAggregateInput = {
    id?: SortOrder
    lectureId?: SortOrder
    content?: SortOrder
    chunkIndex?: SortOrder
    pageNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentChunkAvgOrderByAggregateInput = {
    chunkIndex?: SortOrder
    pageNumber?: SortOrder
  }

  export type ContentChunkMaxOrderByAggregateInput = {
    id?: SortOrder
    lectureId?: SortOrder
    content?: SortOrder
    chunkIndex?: SortOrder
    pageNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentChunkMinOrderByAggregateInput = {
    id?: SortOrder
    lectureId?: SortOrder
    content?: SortOrder
    chunkIndex?: SortOrder
    pageNumber?: SortOrder
    createdAt?: SortOrder
  }

  export type ContentChunkSumOrderByAggregateInput = {
    chunkIndex?: SortOrder
    pageNumber?: SortOrder
  }

  export type EnumObjectiveComplexityFilter<$PrismaModel = never> = {
    equals?: $Enums.ObjectiveComplexity | EnumObjectiveComplexityFieldRefInput<$PrismaModel>
    in?: $Enums.ObjectiveComplexity[] | ListEnumObjectiveComplexityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ObjectiveComplexity[] | ListEnumObjectiveComplexityFieldRefInput<$PrismaModel>
    not?: NestedEnumObjectiveComplexityFilter<$PrismaModel> | $Enums.ObjectiveComplexity
  }

  export type EnumMasteryLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.MasteryLevel | EnumMasteryLevelFieldRefInput<$PrismaModel>
    in?: $Enums.MasteryLevel[] | ListEnumMasteryLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.MasteryLevel[] | ListEnumMasteryLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumMasteryLevelFilter<$PrismaModel> | $Enums.MasteryLevel
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ObjectivePrerequisiteListRelationFilter = {
    every?: ObjectivePrerequisiteWhereInput
    some?: ObjectivePrerequisiteWhereInput
    none?: ObjectivePrerequisiteWhereInput
  }

  export type PerformanceMetricListRelationFilter = {
    every?: PerformanceMetricWhereInput
    some?: PerformanceMetricWhereInput
    none?: PerformanceMetricWhereInput
  }

  export type PriorityFeedbackListRelationFilter = {
    every?: PriorityFeedbackWhereInput
    some?: PriorityFeedbackWhereInput
    none?: PriorityFeedbackWhereInput
  }

  export type StrugglePredictionListRelationFilter = {
    every?: StrugglePredictionWhereInput
    some?: StrugglePredictionWhereInput
    none?: StrugglePredictionWhereInput
  }

  export type StruggleIndicatorListRelationFilter = {
    every?: StruggleIndicatorWhereInput
    some?: StruggleIndicatorWhereInput
    none?: StruggleIndicatorWhereInput
  }

  export type ObjectivePrerequisiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PerformanceMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PriorityFeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StrugglePredictionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StruggleIndicatorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LearningObjectiveCountOrderByAggregateInput = {
    id?: SortOrder
    lectureId?: SortOrder
    objective?: SortOrder
    complexity?: SortOrder
    pageStart?: SortOrder
    pageEnd?: SortOrder
    isHighYield?: SortOrder
    boardExamTags?: SortOrder
    extractedBy?: SortOrder
    createdAt?: SortOrder
    masteryLevel?: SortOrder
    totalStudyTimeMs?: SortOrder
    lastStudiedAt?: SortOrder
    weaknessScore?: SortOrder
  }

  export type LearningObjectiveAvgOrderByAggregateInput = {
    pageStart?: SortOrder
    pageEnd?: SortOrder
    totalStudyTimeMs?: SortOrder
    weaknessScore?: SortOrder
  }

  export type LearningObjectiveMaxOrderByAggregateInput = {
    id?: SortOrder
    lectureId?: SortOrder
    objective?: SortOrder
    complexity?: SortOrder
    pageStart?: SortOrder
    pageEnd?: SortOrder
    isHighYield?: SortOrder
    extractedBy?: SortOrder
    createdAt?: SortOrder
    masteryLevel?: SortOrder
    totalStudyTimeMs?: SortOrder
    lastStudiedAt?: SortOrder
    weaknessScore?: SortOrder
  }

  export type LearningObjectiveMinOrderByAggregateInput = {
    id?: SortOrder
    lectureId?: SortOrder
    objective?: SortOrder
    complexity?: SortOrder
    pageStart?: SortOrder
    pageEnd?: SortOrder
    isHighYield?: SortOrder
    extractedBy?: SortOrder
    createdAt?: SortOrder
    masteryLevel?: SortOrder
    totalStudyTimeMs?: SortOrder
    lastStudiedAt?: SortOrder
    weaknessScore?: SortOrder
  }

  export type LearningObjectiveSumOrderByAggregateInput = {
    pageStart?: SortOrder
    pageEnd?: SortOrder
    totalStudyTimeMs?: SortOrder
    weaknessScore?: SortOrder
  }

  export type EnumObjectiveComplexityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ObjectiveComplexity | EnumObjectiveComplexityFieldRefInput<$PrismaModel>
    in?: $Enums.ObjectiveComplexity[] | ListEnumObjectiveComplexityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ObjectiveComplexity[] | ListEnumObjectiveComplexityFieldRefInput<$PrismaModel>
    not?: NestedEnumObjectiveComplexityWithAggregatesFilter<$PrismaModel> | $Enums.ObjectiveComplexity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumObjectiveComplexityFilter<$PrismaModel>
    _max?: NestedEnumObjectiveComplexityFilter<$PrismaModel>
  }

  export type EnumMasteryLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MasteryLevel | EnumMasteryLevelFieldRefInput<$PrismaModel>
    in?: $Enums.MasteryLevel[] | ListEnumMasteryLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.MasteryLevel[] | ListEnumMasteryLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumMasteryLevelWithAggregatesFilter<$PrismaModel> | $Enums.MasteryLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMasteryLevelFilter<$PrismaModel>
    _max?: NestedEnumMasteryLevelFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type LearningObjectiveRelationFilter = {
    is?: LearningObjectiveWhereInput
    isNot?: LearningObjectiveWhereInput
  }

  export type ObjectivePrerequisiteObjectiveIdPrerequisiteIdCompoundUniqueInput = {
    objectiveId: string
    prerequisiteId: string
  }

  export type ObjectivePrerequisiteCountOrderByAggregateInput = {
    id?: SortOrder
    objectiveId?: SortOrder
    prerequisiteId?: SortOrder
    strength?: SortOrder
  }

  export type ObjectivePrerequisiteAvgOrderByAggregateInput = {
    strength?: SortOrder
  }

  export type ObjectivePrerequisiteMaxOrderByAggregateInput = {
    id?: SortOrder
    objectiveId?: SortOrder
    prerequisiteId?: SortOrder
    strength?: SortOrder
  }

  export type ObjectivePrerequisiteMinOrderByAggregateInput = {
    id?: SortOrder
    objectiveId?: SortOrder
    prerequisiteId?: SortOrder
    strength?: SortOrder
  }

  export type ObjectivePrerequisiteSumOrderByAggregateInput = {
    strength?: SortOrder
  }

  export type EnumMissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MissionStatus | EnumMissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MissionStatus[] | ListEnumMissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MissionStatus[] | ListEnumMissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMissionStatusFilter<$PrismaModel> | $Enums.MissionStatus
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type MissionFeedbackListRelationFilter = {
    every?: MissionFeedbackWhereInput
    some?: MissionFeedbackWhereInput
    none?: MissionFeedbackWhereInput
  }

  export type InterventionRecommendationListRelationFilter = {
    every?: InterventionRecommendationWhereInput
    some?: InterventionRecommendationWhereInput
    none?: InterventionRecommendationWhereInput
  }

  export type MissionFeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterventionRecommendationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MissionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    estimatedMinutes?: SortOrder
    completedAt?: SortOrder
    actualMinutes?: SortOrder
    completedObjectivesCount?: SortOrder
    objectives?: SortOrder
    reviewCardCount?: SortOrder
    newContentCount?: SortOrder
    successScore?: SortOrder
    difficultyRating?: SortOrder
  }

  export type MissionAvgOrderByAggregateInput = {
    estimatedMinutes?: SortOrder
    actualMinutes?: SortOrder
    completedObjectivesCount?: SortOrder
    reviewCardCount?: SortOrder
    newContentCount?: SortOrder
    successScore?: SortOrder
    difficultyRating?: SortOrder
  }

  export type MissionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    estimatedMinutes?: SortOrder
    completedAt?: SortOrder
    actualMinutes?: SortOrder
    completedObjectivesCount?: SortOrder
    reviewCardCount?: SortOrder
    newContentCount?: SortOrder
    successScore?: SortOrder
    difficultyRating?: SortOrder
  }

  export type MissionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    estimatedMinutes?: SortOrder
    completedAt?: SortOrder
    actualMinutes?: SortOrder
    completedObjectivesCount?: SortOrder
    reviewCardCount?: SortOrder
    newContentCount?: SortOrder
    successScore?: SortOrder
    difficultyRating?: SortOrder
  }

  export type MissionSumOrderByAggregateInput = {
    estimatedMinutes?: SortOrder
    actualMinutes?: SortOrder
    completedObjectivesCount?: SortOrder
    reviewCardCount?: SortOrder
    newContentCount?: SortOrder
    successScore?: SortOrder
    difficultyRating?: SortOrder
  }

  export type EnumMissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MissionStatus | EnumMissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MissionStatus[] | ListEnumMissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MissionStatus[] | ListEnumMissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.MissionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMissionStatusFilter<$PrismaModel>
    _max?: NestedEnumMissionStatusFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumCardTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CardType | EnumCardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CardType[] | ListEnumCardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CardType[] | ListEnumCardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCardTypeFilter<$PrismaModel> | $Enums.CardType
  }

  export type LectureNullableRelationFilter = {
    is?: LectureWhereInput | null
    isNot?: LectureWhereInput | null
  }

  export type LearningObjectiveNullableRelationFilter = {
    is?: LearningObjectiveWhereInput | null
    isNot?: LearningObjectiveWhereInput | null
  }

  export type CardCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    lectureId?: SortOrder
    objectiveId?: SortOrder
    front?: SortOrder
    back?: SortOrder
    cardType?: SortOrder
    createdAt?: SortOrder
    difficulty?: SortOrder
    stability?: SortOrder
    retrievability?: SortOrder
    lastReviewedAt?: SortOrder
    nextReviewAt?: SortOrder
    reviewCount?: SortOrder
    lapseCount?: SortOrder
  }

  export type CardAvgOrderByAggregateInput = {
    difficulty?: SortOrder
    stability?: SortOrder
    retrievability?: SortOrder
    reviewCount?: SortOrder
    lapseCount?: SortOrder
  }

  export type CardMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    lectureId?: SortOrder
    objectiveId?: SortOrder
    front?: SortOrder
    back?: SortOrder
    cardType?: SortOrder
    createdAt?: SortOrder
    difficulty?: SortOrder
    stability?: SortOrder
    retrievability?: SortOrder
    lastReviewedAt?: SortOrder
    nextReviewAt?: SortOrder
    reviewCount?: SortOrder
    lapseCount?: SortOrder
  }

  export type CardMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    lectureId?: SortOrder
    objectiveId?: SortOrder
    front?: SortOrder
    back?: SortOrder
    cardType?: SortOrder
    createdAt?: SortOrder
    difficulty?: SortOrder
    stability?: SortOrder
    retrievability?: SortOrder
    lastReviewedAt?: SortOrder
    nextReviewAt?: SortOrder
    reviewCount?: SortOrder
    lapseCount?: SortOrder
  }

  export type CardSumOrderByAggregateInput = {
    difficulty?: SortOrder
    stability?: SortOrder
    retrievability?: SortOrder
    reviewCount?: SortOrder
    lapseCount?: SortOrder
  }

  export type EnumCardTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CardType | EnumCardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CardType[] | ListEnumCardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CardType[] | ListEnumCardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCardTypeWithAggregatesFilter<$PrismaModel> | $Enums.CardType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCardTypeFilter<$PrismaModel>
    _max?: NestedEnumCardTypeFilter<$PrismaModel>
  }

  export type EnumReviewRatingFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewRating | EnumReviewRatingFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewRating[] | ListEnumReviewRatingFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewRating[] | ListEnumReviewRatingFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewRatingFilter<$PrismaModel> | $Enums.ReviewRating
  }

  export type CardRelationFilter = {
    is?: CardWhereInput
    isNot?: CardWhereInput
  }

  export type StudySessionNullableRelationFilter = {
    is?: StudySessionWhereInput | null
    isNot?: StudySessionWhereInput | null
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cardId?: SortOrder
    sessionId?: SortOrder
    rating?: SortOrder
    timeSpentMs?: SortOrder
    reviewedAt?: SortOrder
    difficultyBefore?: SortOrder
    stabilityBefore?: SortOrder
    difficultyAfter?: SortOrder
    stabilityAfter?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    timeSpentMs?: SortOrder
    difficultyBefore?: SortOrder
    stabilityBefore?: SortOrder
    difficultyAfter?: SortOrder
    stabilityAfter?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cardId?: SortOrder
    sessionId?: SortOrder
    rating?: SortOrder
    timeSpentMs?: SortOrder
    reviewedAt?: SortOrder
    difficultyBefore?: SortOrder
    stabilityBefore?: SortOrder
    difficultyAfter?: SortOrder
    stabilityAfter?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    cardId?: SortOrder
    sessionId?: SortOrder
    rating?: SortOrder
    timeSpentMs?: SortOrder
    reviewedAt?: SortOrder
    difficultyBefore?: SortOrder
    stabilityBefore?: SortOrder
    difficultyAfter?: SortOrder
    stabilityAfter?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    timeSpentMs?: SortOrder
    difficultyBefore?: SortOrder
    stabilityBefore?: SortOrder
    difficultyAfter?: SortOrder
    stabilityAfter?: SortOrder
  }

  export type EnumReviewRatingWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewRating | EnumReviewRatingFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewRating[] | ListEnumReviewRatingFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewRating[] | ListEnumReviewRatingFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewRatingWithAggregatesFilter<$PrismaModel> | $Enums.ReviewRating
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewRatingFilter<$PrismaModel>
    _max?: NestedEnumReviewRatingFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type MissionNullableRelationFilter = {
    is?: MissionWhereInput | null
    isNot?: MissionWhereInput | null
  }

  export type ValidationResponseListRelationFilter = {
    every?: ValidationResponseWhereInput
    some?: ValidationResponseWhereInput
    none?: ValidationResponseWhereInput
  }

  export type ValidationResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudySessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    missionId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    durationMs?: SortOrder
    reviewsCompleted?: SortOrder
    newCardsStudied?: SortOrder
    sessionNotes?: SortOrder
    currentObjectiveIndex?: SortOrder
    missionObjectives?: SortOrder
    objectiveCompletions?: SortOrder
  }

  export type StudySessionAvgOrderByAggregateInput = {
    durationMs?: SortOrder
    reviewsCompleted?: SortOrder
    newCardsStudied?: SortOrder
    currentObjectiveIndex?: SortOrder
  }

  export type StudySessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    missionId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    durationMs?: SortOrder
    reviewsCompleted?: SortOrder
    newCardsStudied?: SortOrder
    sessionNotes?: SortOrder
    currentObjectiveIndex?: SortOrder
  }

  export type StudySessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    missionId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    durationMs?: SortOrder
    reviewsCompleted?: SortOrder
    newCardsStudied?: SortOrder
    sessionNotes?: SortOrder
    currentObjectiveIndex?: SortOrder
  }

  export type StudySessionSumOrderByAggregateInput = {
    durationMs?: SortOrder
    reviewsCompleted?: SortOrder
    newCardsStudied?: SortOrder
    currentObjectiveIndex?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ConceptRelationshipListRelationFilter = {
    every?: ConceptRelationshipWhereInput
    some?: ConceptRelationshipWhereInput
    none?: ConceptRelationshipWhereInput
  }

  export type ConceptRelationshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConceptCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type ConceptMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type ConceptMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumRelationshipTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationshipType | EnumRelationshipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationshipType[] | ListEnumRelationshipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationshipType[] | ListEnumRelationshipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationshipTypeFilter<$PrismaModel> | $Enums.RelationshipType
  }

  export type ConceptRelationFilter = {
    is?: ConceptWhereInput
    isNot?: ConceptWhereInput
  }

  export type ConceptRelationshipFromConceptIdToConceptIdRelationshipCompoundUniqueInput = {
    fromConceptId: string
    toConceptId: string
    relationship: $Enums.RelationshipType
  }

  export type ConceptRelationshipCountOrderByAggregateInput = {
    id?: SortOrder
    fromConceptId?: SortOrder
    toConceptId?: SortOrder
    relationship?: SortOrder
    strength?: SortOrder
    createdAt?: SortOrder
  }

  export type ConceptRelationshipAvgOrderByAggregateInput = {
    strength?: SortOrder
  }

  export type ConceptRelationshipMaxOrderByAggregateInput = {
    id?: SortOrder
    fromConceptId?: SortOrder
    toConceptId?: SortOrder
    relationship?: SortOrder
    strength?: SortOrder
    createdAt?: SortOrder
  }

  export type ConceptRelationshipMinOrderByAggregateInput = {
    id?: SortOrder
    fromConceptId?: SortOrder
    toConceptId?: SortOrder
    relationship?: SortOrder
    strength?: SortOrder
    createdAt?: SortOrder
  }

  export type ConceptRelationshipSumOrderByAggregateInput = {
    strength?: SortOrder
  }

  export type EnumRelationshipTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationshipType | EnumRelationshipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationshipType[] | ListEnumRelationshipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationshipType[] | ListEnumRelationshipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationshipTypeWithAggregatesFilter<$PrismaModel> | $Enums.RelationshipType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRelationshipTypeFilter<$PrismaModel>
    _max?: NestedEnumRelationshipTypeFilter<$PrismaModel>
  }

  export type EnumPromptTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PromptType | EnumPromptTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PromptType[] | ListEnumPromptTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromptType[] | ListEnumPromptTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPromptTypeFilter<$PrismaModel> | $Enums.PromptType
  }

  export type ValidationPromptCountOrderByAggregateInput = {
    id?: SortOrder
    promptText?: SortOrder
    promptType?: SortOrder
    conceptName?: SortOrder
    expectedCriteria?: SortOrder
    createdAt?: SortOrder
  }

  export type ValidationPromptMaxOrderByAggregateInput = {
    id?: SortOrder
    promptText?: SortOrder
    promptType?: SortOrder
    conceptName?: SortOrder
    createdAt?: SortOrder
  }

  export type ValidationPromptMinOrderByAggregateInput = {
    id?: SortOrder
    promptText?: SortOrder
    promptType?: SortOrder
    conceptName?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumPromptTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PromptType | EnumPromptTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PromptType[] | ListEnumPromptTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromptType[] | ListEnumPromptTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPromptTypeWithAggregatesFilter<$PrismaModel> | $Enums.PromptType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPromptTypeFilter<$PrismaModel>
    _max?: NestedEnumPromptTypeFilter<$PrismaModel>
  }

  export type ValidationPromptRelationFilter = {
    is?: ValidationPromptWhereInput
    isNot?: ValidationPromptWhereInput
  }

  export type ValidationResponseCountOrderByAggregateInput = {
    id?: SortOrder
    promptId?: SortOrder
    sessionId?: SortOrder
    userAnswer?: SortOrder
    aiEvaluation?: SortOrder
    score?: SortOrder
    confidence?: SortOrder
    respondedAt?: SortOrder
  }

  export type ValidationResponseAvgOrderByAggregateInput = {
    score?: SortOrder
    confidence?: SortOrder
  }

  export type ValidationResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    promptId?: SortOrder
    sessionId?: SortOrder
    userAnswer?: SortOrder
    aiEvaluation?: SortOrder
    score?: SortOrder
    confidence?: SortOrder
    respondedAt?: SortOrder
  }

  export type ValidationResponseMinOrderByAggregateInput = {
    id?: SortOrder
    promptId?: SortOrder
    sessionId?: SortOrder
    userAnswer?: SortOrder
    aiEvaluation?: SortOrder
    score?: SortOrder
    confidence?: SortOrder
    respondedAt?: SortOrder
  }

  export type ValidationResponseSumOrderByAggregateInput = {
    score?: SortOrder
    confidence?: SortOrder
  }

  export type ComprehensionMetricConceptNameDateCompoundUniqueInput = {
    conceptName: string
    date: Date | string
  }

  export type ComprehensionMetricCountOrderByAggregateInput = {
    id?: SortOrder
    conceptName?: SortOrder
    date?: SortOrder
    avgScore?: SortOrder
    sampleSize?: SortOrder
    trend?: SortOrder
  }

  export type ComprehensionMetricAvgOrderByAggregateInput = {
    avgScore?: SortOrder
    sampleSize?: SortOrder
  }

  export type ComprehensionMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    conceptName?: SortOrder
    date?: SortOrder
    avgScore?: SortOrder
    sampleSize?: SortOrder
    trend?: SortOrder
  }

  export type ComprehensionMetricMinOrderByAggregateInput = {
    id?: SortOrder
    conceptName?: SortOrder
    date?: SortOrder
    avgScore?: SortOrder
    sampleSize?: SortOrder
    trend?: SortOrder
  }

  export type ComprehensionMetricSumOrderByAggregateInput = {
    avgScore?: SortOrder
    sampleSize?: SortOrder
  }

  export type EnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType
  }

  export type EnumEngagementLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EngagementLevel | EnumEngagementLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.EngagementLevel[] | ListEnumEngagementLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EngagementLevel[] | ListEnumEngagementLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEngagementLevelNullableFilter<$PrismaModel> | $Enums.EngagementLevel | null
  }

  export type EnumCompletionQualityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CompletionQuality | EnumCompletionQualityFieldRefInput<$PrismaModel> | null
    in?: $Enums.CompletionQuality[] | ListEnumCompletionQualityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CompletionQuality[] | ListEnumCompletionQualityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCompletionQualityNullableFilter<$PrismaModel> | $Enums.CompletionQuality | null
  }

  export type BehavioralEventCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    eventData?: SortOrder
    timestamp?: SortOrder
    sessionPerformanceScore?: SortOrder
    engagementLevel?: SortOrder
    completionQuality?: SortOrder
    timeOfDay?: SortOrder
    dayOfWeek?: SortOrder
    contentType?: SortOrder
    difficultyLevel?: SortOrder
  }

  export type BehavioralEventAvgOrderByAggregateInput = {
    sessionPerformanceScore?: SortOrder
    timeOfDay?: SortOrder
    dayOfWeek?: SortOrder
  }

  export type BehavioralEventMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    timestamp?: SortOrder
    sessionPerformanceScore?: SortOrder
    engagementLevel?: SortOrder
    completionQuality?: SortOrder
    timeOfDay?: SortOrder
    dayOfWeek?: SortOrder
    contentType?: SortOrder
    difficultyLevel?: SortOrder
  }

  export type BehavioralEventMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    timestamp?: SortOrder
    sessionPerformanceScore?: SortOrder
    engagementLevel?: SortOrder
    completionQuality?: SortOrder
    timeOfDay?: SortOrder
    dayOfWeek?: SortOrder
    contentType?: SortOrder
    difficultyLevel?: SortOrder
  }

  export type BehavioralEventSumOrderByAggregateInput = {
    sessionPerformanceScore?: SortOrder
    timeOfDay?: SortOrder
    dayOfWeek?: SortOrder
  }

  export type EnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEventTypeFilter<$PrismaModel>
  }

  export type EnumEngagementLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EngagementLevel | EnumEngagementLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.EngagementLevel[] | ListEnumEngagementLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EngagementLevel[] | ListEnumEngagementLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEngagementLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.EngagementLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEngagementLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumEngagementLevelNullableFilter<$PrismaModel>
  }

  export type EnumCompletionQualityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompletionQuality | EnumCompletionQualityFieldRefInput<$PrismaModel> | null
    in?: $Enums.CompletionQuality[] | ListEnumCompletionQualityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CompletionQuality[] | ListEnumCompletionQualityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCompletionQualityNullableWithAggregatesFilter<$PrismaModel> | $Enums.CompletionQuality | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCompletionQualityNullableFilter<$PrismaModel>
    _max?: NestedEnumCompletionQualityNullableFilter<$PrismaModel>
  }

  export type EnumBehavioralPatternTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BehavioralPatternType | EnumBehavioralPatternTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BehavioralPatternType[] | ListEnumBehavioralPatternTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BehavioralPatternType[] | ListEnumBehavioralPatternTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBehavioralPatternTypeFilter<$PrismaModel> | $Enums.BehavioralPatternType
  }

  export type InsightPatternListRelationFilter = {
    every?: InsightPatternWhereInput
    some?: InsightPatternWhereInput
    none?: InsightPatternWhereInput
  }

  export type InsightPatternOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BehavioralPatternCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    patternType?: SortOrder
    patternName?: SortOrder
    confidence?: SortOrder
    evidence?: SortOrder
    detectedAt?: SortOrder
    lastSeenAt?: SortOrder
    occurrenceCount?: SortOrder
  }

  export type BehavioralPatternAvgOrderByAggregateInput = {
    confidence?: SortOrder
    occurrenceCount?: SortOrder
  }

  export type BehavioralPatternMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    patternType?: SortOrder
    patternName?: SortOrder
    confidence?: SortOrder
    detectedAt?: SortOrder
    lastSeenAt?: SortOrder
    occurrenceCount?: SortOrder
  }

  export type BehavioralPatternMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    patternType?: SortOrder
    patternName?: SortOrder
    confidence?: SortOrder
    detectedAt?: SortOrder
    lastSeenAt?: SortOrder
    occurrenceCount?: SortOrder
  }

  export type BehavioralPatternSumOrderByAggregateInput = {
    confidence?: SortOrder
    occurrenceCount?: SortOrder
  }

  export type EnumBehavioralPatternTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BehavioralPatternType | EnumBehavioralPatternTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BehavioralPatternType[] | ListEnumBehavioralPatternTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BehavioralPatternType[] | ListEnumBehavioralPatternTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBehavioralPatternTypeWithAggregatesFilter<$PrismaModel> | $Enums.BehavioralPatternType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBehavioralPatternTypeFilter<$PrismaModel>
    _max?: NestedEnumBehavioralPatternTypeFilter<$PrismaModel>
  }

  export type EnumInsightTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightType | EnumInsightTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InsightType[] | ListEnumInsightTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightType[] | ListEnumInsightTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightTypeFilter<$PrismaModel> | $Enums.InsightType
  }

  export type BehavioralInsightCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    insightType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    actionableRecommendation?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    acknowledgedAt?: SortOrder
    applied?: SortOrder
  }

  export type BehavioralInsightAvgOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type BehavioralInsightMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    insightType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    actionableRecommendation?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    acknowledgedAt?: SortOrder
    applied?: SortOrder
  }

  export type BehavioralInsightMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    insightType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    actionableRecommendation?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    acknowledgedAt?: SortOrder
    applied?: SortOrder
  }

  export type BehavioralInsightSumOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type EnumInsightTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightType | EnumInsightTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InsightType[] | ListEnumInsightTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightType[] | ListEnumInsightTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightTypeWithAggregatesFilter<$PrismaModel> | $Enums.InsightType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsightTypeFilter<$PrismaModel>
    _max?: NestedEnumInsightTypeFilter<$PrismaModel>
  }

  export type BehavioralInsightRelationFilter = {
    is?: BehavioralInsightWhereInput
    isNot?: BehavioralInsightWhereInput
  }

  export type BehavioralPatternRelationFilter = {
    is?: BehavioralPatternWhereInput
    isNot?: BehavioralPatternWhereInput
  }

  export type InsightPatternInsightIdPatternIdCompoundUniqueInput = {
    insightId: string
    patternId: string
  }

  export type InsightPatternCountOrderByAggregateInput = {
    id?: SortOrder
    insightId?: SortOrder
    patternId?: SortOrder
  }

  export type InsightPatternMaxOrderByAggregateInput = {
    id?: SortOrder
    insightId?: SortOrder
    patternId?: SortOrder
  }

  export type InsightPatternMinOrderByAggregateInput = {
    id?: SortOrder
    insightId?: SortOrder
    patternId?: SortOrder
  }

  export type UserLearningProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    preferredStudyTimes?: SortOrder
    averageSessionDuration?: SortOrder
    optimalSessionDuration?: SortOrder
    contentPreferences?: SortOrder
    learningStyleProfile?: SortOrder
    personalizedForgettingCurve?: SortOrder
    lastAnalyzedAt?: SortOrder
    dataQualityScore?: SortOrder
  }

  export type UserLearningProfileAvgOrderByAggregateInput = {
    averageSessionDuration?: SortOrder
    optimalSessionDuration?: SortOrder
    dataQualityScore?: SortOrder
  }

  export type UserLearningProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    averageSessionDuration?: SortOrder
    optimalSessionDuration?: SortOrder
    lastAnalyzedAt?: SortOrder
    dataQualityScore?: SortOrder
  }

  export type UserLearningProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    averageSessionDuration?: SortOrder
    optimalSessionDuration?: SortOrder
    lastAnalyzedAt?: SortOrder
    dataQualityScore?: SortOrder
  }

  export type UserLearningProfileSumOrderByAggregateInput = {
    averageSessionDuration?: SortOrder
    optimalSessionDuration?: SortOrder
    dataQualityScore?: SortOrder
  }

  export type EnumPatternTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PatternType | EnumPatternTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PatternType[] | ListEnumPatternTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PatternType[] | ListEnumPatternTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPatternTypeFilter<$PrismaModel> | $Enums.PatternType
  }

  export type LearningPatternCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    patternType?: SortOrder
    patternData?: SortOrder
    confidence?: SortOrder
    detectedAt?: SortOrder
    lastSeenAt?: SortOrder
  }

  export type LearningPatternAvgOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type LearningPatternMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    patternType?: SortOrder
    confidence?: SortOrder
    detectedAt?: SortOrder
    lastSeenAt?: SortOrder
  }

  export type LearningPatternMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    patternType?: SortOrder
    confidence?: SortOrder
    detectedAt?: SortOrder
    lastSeenAt?: SortOrder
  }

  export type LearningPatternSumOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type EnumPatternTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PatternType | EnumPatternTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PatternType[] | ListEnumPatternTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PatternType[] | ListEnumPatternTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPatternTypeWithAggregatesFilter<$PrismaModel> | $Enums.PatternType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPatternTypeFilter<$PrismaModel>
    _max?: NestedEnumPatternTypeFilter<$PrismaModel>
  }

  export type PerformancePredictionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    predictedFor?: SortOrder
    predictionType?: SortOrder
    prediction?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
  }

  export type PerformancePredictionAvgOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type PerformancePredictionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    predictedFor?: SortOrder
    predictionType?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
  }

  export type PerformancePredictionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    predictedFor?: SortOrder
    predictionType?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
  }

  export type PerformancePredictionSumOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type EnumPredictionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PredictionStatus | EnumPredictionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PredictionStatus[] | ListEnumPredictionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PredictionStatus[] | ListEnumPredictionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPredictionStatusFilter<$PrismaModel> | $Enums.PredictionStatus
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type PredictionFeedbackListRelationFilter = {
    every?: PredictionFeedbackWhereInput
    some?: PredictionFeedbackWhereInput
    none?: PredictionFeedbackWhereInput
  }

  export type PredictionFeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StrugglePredictionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    learningObjectiveId?: SortOrder
    topicId?: SortOrder
    predictionDate?: SortOrder
    predictedStruggleProbability?: SortOrder
    predictionConfidence?: SortOrder
    predictionStatus?: SortOrder
    actualOutcome?: SortOrder
    outcomeRecordedAt?: SortOrder
    featureVector?: SortOrder
  }

  export type StrugglePredictionAvgOrderByAggregateInput = {
    predictedStruggleProbability?: SortOrder
    predictionConfidence?: SortOrder
  }

  export type StrugglePredictionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    learningObjectiveId?: SortOrder
    topicId?: SortOrder
    predictionDate?: SortOrder
    predictedStruggleProbability?: SortOrder
    predictionConfidence?: SortOrder
    predictionStatus?: SortOrder
    actualOutcome?: SortOrder
    outcomeRecordedAt?: SortOrder
  }

  export type StrugglePredictionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    learningObjectiveId?: SortOrder
    topicId?: SortOrder
    predictionDate?: SortOrder
    predictedStruggleProbability?: SortOrder
    predictionConfidence?: SortOrder
    predictionStatus?: SortOrder
    actualOutcome?: SortOrder
    outcomeRecordedAt?: SortOrder
  }

  export type StrugglePredictionSumOrderByAggregateInput = {
    predictedStruggleProbability?: SortOrder
    predictionConfidence?: SortOrder
  }

  export type EnumPredictionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PredictionStatus | EnumPredictionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PredictionStatus[] | ListEnumPredictionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PredictionStatus[] | ListEnumPredictionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPredictionStatusWithAggregatesFilter<$PrismaModel> | $Enums.PredictionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPredictionStatusFilter<$PrismaModel>
    _max?: NestedEnumPredictionStatusFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumIndicatorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IndicatorType | EnumIndicatorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IndicatorType[] | ListEnumIndicatorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IndicatorType[] | ListEnumIndicatorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIndicatorTypeFilter<$PrismaModel> | $Enums.IndicatorType
  }

  export type EnumSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSeverityFilter<$PrismaModel> | $Enums.Severity
  }

  export type StrugglePredictionNullableRelationFilter = {
    is?: StrugglePredictionWhereInput | null
    isNot?: StrugglePredictionWhereInput | null
  }

  export type StruggleIndicatorCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    predictionId?: SortOrder
    learningObjectiveId?: SortOrder
    indicatorType?: SortOrder
    severity?: SortOrder
    detectedAt?: SortOrder
    context?: SortOrder
  }

  export type StruggleIndicatorMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    predictionId?: SortOrder
    learningObjectiveId?: SortOrder
    indicatorType?: SortOrder
    severity?: SortOrder
    detectedAt?: SortOrder
  }

  export type StruggleIndicatorMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    predictionId?: SortOrder
    learningObjectiveId?: SortOrder
    indicatorType?: SortOrder
    severity?: SortOrder
    detectedAt?: SortOrder
  }

  export type EnumIndicatorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IndicatorType | EnumIndicatorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IndicatorType[] | ListEnumIndicatorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IndicatorType[] | ListEnumIndicatorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIndicatorTypeWithAggregatesFilter<$PrismaModel> | $Enums.IndicatorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIndicatorTypeFilter<$PrismaModel>
    _max?: NestedEnumIndicatorTypeFilter<$PrismaModel>
  }

  export type EnumSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSeverityWithAggregatesFilter<$PrismaModel> | $Enums.Severity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeverityFilter<$PrismaModel>
    _max?: NestedEnumSeverityFilter<$PrismaModel>
  }

  export type EnumInterventionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InterventionType | EnumInterventionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InterventionType[] | ListEnumInterventionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterventionType[] | ListEnumInterventionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInterventionTypeFilter<$PrismaModel> | $Enums.InterventionType
  }

  export type EnumInterventionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InterventionStatus | EnumInterventionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InterventionStatus[] | ListEnumInterventionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterventionStatus[] | ListEnumInterventionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInterventionStatusFilter<$PrismaModel> | $Enums.InterventionStatus
  }

  export type StrugglePredictionRelationFilter = {
    is?: StrugglePredictionWhereInput
    isNot?: StrugglePredictionWhereInput
  }

  export type InterventionRecommendationCountOrderByAggregateInput = {
    id?: SortOrder
    predictionId?: SortOrder
    userId?: SortOrder
    interventionType?: SortOrder
    description?: SortOrder
    reasoning?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    appliedAt?: SortOrder
    appliedToMissionId?: SortOrder
    effectiveness?: SortOrder
    createdAt?: SortOrder
  }

  export type InterventionRecommendationAvgOrderByAggregateInput = {
    priority?: SortOrder
    effectiveness?: SortOrder
  }

  export type InterventionRecommendationMaxOrderByAggregateInput = {
    id?: SortOrder
    predictionId?: SortOrder
    userId?: SortOrder
    interventionType?: SortOrder
    description?: SortOrder
    reasoning?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    appliedAt?: SortOrder
    appliedToMissionId?: SortOrder
    effectiveness?: SortOrder
    createdAt?: SortOrder
  }

  export type InterventionRecommendationMinOrderByAggregateInput = {
    id?: SortOrder
    predictionId?: SortOrder
    userId?: SortOrder
    interventionType?: SortOrder
    description?: SortOrder
    reasoning?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    appliedAt?: SortOrder
    appliedToMissionId?: SortOrder
    effectiveness?: SortOrder
    createdAt?: SortOrder
  }

  export type InterventionRecommendationSumOrderByAggregateInput = {
    priority?: SortOrder
    effectiveness?: SortOrder
  }

  export type EnumInterventionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterventionType | EnumInterventionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InterventionType[] | ListEnumInterventionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterventionType[] | ListEnumInterventionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInterventionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InterventionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInterventionTypeFilter<$PrismaModel>
    _max?: NestedEnumInterventionTypeFilter<$PrismaModel>
  }

  export type EnumInterventionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterventionStatus | EnumInterventionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InterventionStatus[] | ListEnumInterventionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterventionStatus[] | ListEnumInterventionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInterventionStatusWithAggregatesFilter<$PrismaModel> | $Enums.InterventionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInterventionStatusFilter<$PrismaModel>
    _max?: NestedEnumInterventionStatusFilter<$PrismaModel>
  }

  export type EnumFeedbackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeFilter<$PrismaModel> | $Enums.FeedbackType
  }

  export type PredictionFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    predictionId?: SortOrder
    userId?: SortOrder
    feedbackType?: SortOrder
    actualStruggle?: SortOrder
    helpfulness?: SortOrder
    comments?: SortOrder
    submittedAt?: SortOrder
  }

  export type PredictionFeedbackAvgOrderByAggregateInput = {
    helpfulness?: SortOrder
  }

  export type PredictionFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    predictionId?: SortOrder
    userId?: SortOrder
    feedbackType?: SortOrder
    actualStruggle?: SortOrder
    helpfulness?: SortOrder
    comments?: SortOrder
    submittedAt?: SortOrder
  }

  export type PredictionFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    predictionId?: SortOrder
    userId?: SortOrder
    feedbackType?: SortOrder
    actualStruggle?: SortOrder
    helpfulness?: SortOrder
    comments?: SortOrder
    submittedAt?: SortOrder
  }

  export type PredictionFeedbackSumOrderByAggregateInput = {
    helpfulness?: SortOrder
  }

  export type EnumFeedbackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackTypeFilter<$PrismaModel>
    _max?: NestedEnumFeedbackTypeFilter<$PrismaModel>
  }

  export type PerformanceMetricUserIdLearningObjectiveIdDateCompoundUniqueInput = {
    userId: string
    learningObjectiveId: string
    date: Date | string
  }

  export type PerformanceMetricCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    learningObjectiveId?: SortOrder
    date?: SortOrder
    retentionScore?: SortOrder
    studyTimeMs?: SortOrder
    reviewCount?: SortOrder
    correctReviews?: SortOrder
    incorrectReviews?: SortOrder
    createdAt?: SortOrder
  }

  export type PerformanceMetricAvgOrderByAggregateInput = {
    retentionScore?: SortOrder
    studyTimeMs?: SortOrder
    reviewCount?: SortOrder
    correctReviews?: SortOrder
    incorrectReviews?: SortOrder
  }

  export type PerformanceMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    learningObjectiveId?: SortOrder
    date?: SortOrder
    retentionScore?: SortOrder
    studyTimeMs?: SortOrder
    reviewCount?: SortOrder
    correctReviews?: SortOrder
    incorrectReviews?: SortOrder
    createdAt?: SortOrder
  }

  export type PerformanceMetricMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    learningObjectiveId?: SortOrder
    date?: SortOrder
    retentionScore?: SortOrder
    studyTimeMs?: SortOrder
    reviewCount?: SortOrder
    correctReviews?: SortOrder
    incorrectReviews?: SortOrder
    createdAt?: SortOrder
  }

  export type PerformanceMetricSumOrderByAggregateInput = {
    retentionScore?: SortOrder
    studyTimeMs?: SortOrder
    reviewCount?: SortOrder
    correctReviews?: SortOrder
    incorrectReviews?: SortOrder
  }

  export type ExamCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    date?: SortOrder
    courseId?: SortOrder
    coverageTopics?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    date?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    date?: SortOrder
    courseId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPriorityLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.PriorityLevel | EnumPriorityLevelFieldRefInput<$PrismaModel>
    in?: $Enums.PriorityLevel[] | ListEnumPriorityLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PriorityLevel[] | ListEnumPriorityLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityLevelFilter<$PrismaModel> | $Enums.PriorityLevel
  }

  export type CoursePriorityUserIdCourseIdCompoundUniqueInput = {
    userId: string
    courseId: string
  }

  export type CoursePriorityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    priorityLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoursePriorityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    priorityLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoursePriorityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    courseId?: SortOrder
    priorityLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPriorityLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PriorityLevel | EnumPriorityLevelFieldRefInput<$PrismaModel>
    in?: $Enums.PriorityLevel[] | ListEnumPriorityLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PriorityLevel[] | ListEnumPriorityLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityLevelWithAggregatesFilter<$PrismaModel> | $Enums.PriorityLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityLevelFilter<$PrismaModel>
    _max?: NestedEnumPriorityLevelFilter<$PrismaModel>
  }

  export type EnumFeedbackRatingFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackRating | EnumFeedbackRatingFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackRating[] | ListEnumFeedbackRatingFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackRating[] | ListEnumFeedbackRatingFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackRatingFilter<$PrismaModel> | $Enums.FeedbackRating
  }

  export type PriorityFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    objectiveId?: SortOrder
    suggestedPriority?: SortOrder
    userFeedback?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type PriorityFeedbackAvgOrderByAggregateInput = {
    suggestedPriority?: SortOrder
  }

  export type PriorityFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    objectiveId?: SortOrder
    suggestedPriority?: SortOrder
    userFeedback?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type PriorityFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    objectiveId?: SortOrder
    suggestedPriority?: SortOrder
    userFeedback?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type PriorityFeedbackSumOrderByAggregateInput = {
    suggestedPriority?: SortOrder
  }

  export type EnumFeedbackRatingWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackRating | EnumFeedbackRatingFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackRating[] | ListEnumFeedbackRatingFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackRating[] | ListEnumFeedbackRatingFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackRatingWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackRating
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackRatingFilter<$PrismaModel>
    _max?: NestedEnumFeedbackRatingFilter<$PrismaModel>
  }

  export type StreakCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastStudyDate?: SortOrder
    freezesRemaining?: SortOrder
    freezeUsedDates?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StreakAvgOrderByAggregateInput = {
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    freezesRemaining?: SortOrder
  }

  export type StreakMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastStudyDate?: SortOrder
    freezesRemaining?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StreakMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastStudyDate?: SortOrder
    freezesRemaining?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StreakSumOrderByAggregateInput = {
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    freezesRemaining?: SortOrder
  }

  export type EnumAchievementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementType | EnumAchievementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementType[] | ListEnumAchievementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementType[] | ListEnumAchievementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementTypeFilter<$PrismaModel> | $Enums.AchievementType
  }

  export type EnumAchievementTierFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementTier | EnumAchievementTierFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementTier[] | ListEnumAchievementTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementTier[] | ListEnumAchievementTierFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementTierFilter<$PrismaModel> | $Enums.AchievementTier
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tier?: SortOrder
    earnedAt?: SortOrder
    metadata?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tier?: SortOrder
    earnedAt?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tier?: SortOrder
    earnedAt?: SortOrder
  }

  export type EnumAchievementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementType | EnumAchievementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementType[] | ListEnumAchievementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementType[] | ListEnumAchievementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementTypeWithAggregatesFilter<$PrismaModel> | $Enums.AchievementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAchievementTypeFilter<$PrismaModel>
    _max?: NestedEnumAchievementTypeFilter<$PrismaModel>
  }

  export type EnumAchievementTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementTier | EnumAchievementTierFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementTier[] | ListEnumAchievementTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementTier[] | ListEnumAchievementTierFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementTierWithAggregatesFilter<$PrismaModel> | $Enums.AchievementTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAchievementTierFilter<$PrismaModel>
    _max?: NestedEnumAchievementTierFilter<$PrismaModel>
  }

  export type EnumGoalTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalType | EnumGoalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GoalType[] | ListEnumGoalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GoalType[] | ListEnumGoalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGoalTypeFilter<$PrismaModel> | $Enums.GoalType
  }

  export type EnumGoalPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalPeriod | EnumGoalPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.GoalPeriod[] | ListEnumGoalPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.GoalPeriod[] | ListEnumGoalPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumGoalPeriodFilter<$PrismaModel> | $Enums.GoalPeriod
  }

  export type StudyGoalCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    goalType?: SortOrder
    targetValue?: SortOrder
    currentProgress?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StudyGoalAvgOrderByAggregateInput = {
    targetValue?: SortOrder
    currentProgress?: SortOrder
  }

  export type StudyGoalMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    goalType?: SortOrder
    targetValue?: SortOrder
    currentProgress?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StudyGoalMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    goalType?: SortOrder
    targetValue?: SortOrder
    currentProgress?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StudyGoalSumOrderByAggregateInput = {
    targetValue?: SortOrder
    currentProgress?: SortOrder
  }

  export type EnumGoalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalType | EnumGoalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GoalType[] | ListEnumGoalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GoalType[] | ListEnumGoalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGoalTypeWithAggregatesFilter<$PrismaModel> | $Enums.GoalType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGoalTypeFilter<$PrismaModel>
    _max?: NestedEnumGoalTypeFilter<$PrismaModel>
  }

  export type EnumGoalPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalPeriod | EnumGoalPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.GoalPeriod[] | ListEnumGoalPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.GoalPeriod[] | ListEnumGoalPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumGoalPeriodWithAggregatesFilter<$PrismaModel> | $Enums.GoalPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGoalPeriodFilter<$PrismaModel>
    _max?: NestedEnumGoalPeriodFilter<$PrismaModel>
  }

  export type EnumAnalyticsPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalyticsPeriod | EnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.AnalyticsPeriod[] | ListEnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalyticsPeriod[] | ListEnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalyticsPeriodFilter<$PrismaModel> | $Enums.AnalyticsPeriod
  }

  export type MissionAnalyticsUserIdDatePeriodCompoundUniqueInput = {
    userId: string
    date: Date | string
    period: $Enums.AnalyticsPeriod
  }

  export type MissionAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    period?: SortOrder
    missionsGenerated?: SortOrder
    missionsCompleted?: SortOrder
    missionsSkipped?: SortOrder
    avgCompletionRate?: SortOrder
    avgTimeAccuracy?: SortOrder
    avgDifficultyRating?: SortOrder
    avgSuccessScore?: SortOrder
    createdAt?: SortOrder
  }

  export type MissionAnalyticsAvgOrderByAggregateInput = {
    missionsGenerated?: SortOrder
    missionsCompleted?: SortOrder
    missionsSkipped?: SortOrder
    avgCompletionRate?: SortOrder
    avgTimeAccuracy?: SortOrder
    avgDifficultyRating?: SortOrder
    avgSuccessScore?: SortOrder
  }

  export type MissionAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    period?: SortOrder
    missionsGenerated?: SortOrder
    missionsCompleted?: SortOrder
    missionsSkipped?: SortOrder
    avgCompletionRate?: SortOrder
    avgTimeAccuracy?: SortOrder
    avgDifficultyRating?: SortOrder
    avgSuccessScore?: SortOrder
    createdAt?: SortOrder
  }

  export type MissionAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    date?: SortOrder
    period?: SortOrder
    missionsGenerated?: SortOrder
    missionsCompleted?: SortOrder
    missionsSkipped?: SortOrder
    avgCompletionRate?: SortOrder
    avgTimeAccuracy?: SortOrder
    avgDifficultyRating?: SortOrder
    avgSuccessScore?: SortOrder
    createdAt?: SortOrder
  }

  export type MissionAnalyticsSumOrderByAggregateInput = {
    missionsGenerated?: SortOrder
    missionsCompleted?: SortOrder
    missionsSkipped?: SortOrder
    avgCompletionRate?: SortOrder
    avgTimeAccuracy?: SortOrder
    avgDifficultyRating?: SortOrder
    avgSuccessScore?: SortOrder
  }

  export type EnumAnalyticsPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalyticsPeriod | EnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.AnalyticsPeriod[] | ListEnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalyticsPeriod[] | ListEnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalyticsPeriodWithAggregatesFilter<$PrismaModel> | $Enums.AnalyticsPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnalyticsPeriodFilter<$PrismaModel>
    _max?: NestedEnumAnalyticsPeriodFilter<$PrismaModel>
  }

  export type EnumPaceRatingFilter<$PrismaModel = never> = {
    equals?: $Enums.PaceRating | EnumPaceRatingFieldRefInput<$PrismaModel>
    in?: $Enums.PaceRating[] | ListEnumPaceRatingFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaceRating[] | ListEnumPaceRatingFieldRefInput<$PrismaModel>
    not?: NestedEnumPaceRatingFilter<$PrismaModel> | $Enums.PaceRating
  }

  export type MissionRelationFilter = {
    is?: MissionWhereInput
    isNot?: MissionWhereInput
  }

  export type MissionFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    missionId?: SortOrder
    helpfulnessRating?: SortOrder
    relevanceScore?: SortOrder
    paceRating?: SortOrder
    improvementSuggestions?: SortOrder
    submittedAt?: SortOrder
  }

  export type MissionFeedbackAvgOrderByAggregateInput = {
    helpfulnessRating?: SortOrder
    relevanceScore?: SortOrder
  }

  export type MissionFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    missionId?: SortOrder
    helpfulnessRating?: SortOrder
    relevanceScore?: SortOrder
    paceRating?: SortOrder
    improvementSuggestions?: SortOrder
    submittedAt?: SortOrder
  }

  export type MissionFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    missionId?: SortOrder
    helpfulnessRating?: SortOrder
    relevanceScore?: SortOrder
    paceRating?: SortOrder
    improvementSuggestions?: SortOrder
    submittedAt?: SortOrder
  }

  export type MissionFeedbackSumOrderByAggregateInput = {
    helpfulnessRating?: SortOrder
    relevanceScore?: SortOrder
  }

  export type EnumPaceRatingWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaceRating | EnumPaceRatingFieldRefInput<$PrismaModel>
    in?: $Enums.PaceRating[] | ListEnumPaceRatingFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaceRating[] | ListEnumPaceRatingFieldRefInput<$PrismaModel>
    not?: NestedEnumPaceRatingWithAggregatesFilter<$PrismaModel> | $Enums.PaceRating
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaceRatingFilter<$PrismaModel>
    _max?: NestedEnumPaceRatingFilter<$PrismaModel>
  }

  export type MissionStreakCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastCompletedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MissionStreakAvgOrderByAggregateInput = {
    currentStreak?: SortOrder
    longestStreak?: SortOrder
  }

  export type MissionStreakMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastCompletedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MissionStreakMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastCompletedDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MissionStreakSumOrderByAggregateInput = {
    currentStreak?: SortOrder
    longestStreak?: SortOrder
  }

  export type EnumReviewPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewPeriod | EnumReviewPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewPeriod[] | ListEnumReviewPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewPeriod[] | ListEnumReviewPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewPeriodFilter<$PrismaModel> | $Enums.ReviewPeriod
  }

  export type MissionReviewUserIdPeriodStartDateCompoundUniqueInput = {
    userId: string
    period: $Enums.ReviewPeriod
    startDate: Date | string
  }

  export type MissionReviewCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    summary?: SortOrder
    highlights?: SortOrder
    insights?: SortOrder
    recommendations?: SortOrder
    generatedAt?: SortOrder
  }

  export type MissionReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    generatedAt?: SortOrder
  }

  export type MissionReviewMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    period?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    generatedAt?: SortOrder
  }

  export type EnumReviewPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewPeriod | EnumReviewPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewPeriod[] | ListEnumReviewPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewPeriod[] | ListEnumReviewPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewPeriodWithAggregatesFilter<$PrismaModel> | $Enums.ReviewPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewPeriodFilter<$PrismaModel>
    _max?: NestedEnumReviewPeriodFilter<$PrismaModel>
  }

  export type CourseCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseCreateWithoutUserInput, CourseUncheckedCreateWithoutUserInput> | CourseCreateWithoutUserInput[] | CourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutUserInput | CourseCreateOrConnectWithoutUserInput[]
    createMany?: CourseCreateManyUserInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type LectureCreateNestedManyWithoutUserInput = {
    create?: XOR<LectureCreateWithoutUserInput, LectureUncheckedCreateWithoutUserInput> | LectureCreateWithoutUserInput[] | LectureUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LectureCreateOrConnectWithoutUserInput | LectureCreateOrConnectWithoutUserInput[]
    createMany?: LectureCreateManyUserInputEnvelope
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
  }

  export type StudySessionCreateNestedManyWithoutUserInput = {
    create?: XOR<StudySessionCreateWithoutUserInput, StudySessionUncheckedCreateWithoutUserInput> | StudySessionCreateWithoutUserInput[] | StudySessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudySessionCreateOrConnectWithoutUserInput | StudySessionCreateOrConnectWithoutUserInput[]
    createMany?: StudySessionCreateManyUserInputEnvelope
    connect?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
  }

  export type MissionCreateNestedManyWithoutUserInput = {
    create?: XOR<MissionCreateWithoutUserInput, MissionUncheckedCreateWithoutUserInput> | MissionCreateWithoutUserInput[] | MissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MissionCreateOrConnectWithoutUserInput | MissionCreateOrConnectWithoutUserInput[]
    createMany?: MissionCreateManyUserInputEnvelope
    connect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ExamCreateNestedManyWithoutUserInput = {
    create?: XOR<ExamCreateWithoutUserInput, ExamUncheckedCreateWithoutUserInput> | ExamCreateWithoutUserInput[] | ExamUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutUserInput | ExamCreateOrConnectWithoutUserInput[]
    createMany?: ExamCreateManyUserInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type CoursePriorityCreateNestedManyWithoutUserInput = {
    create?: XOR<CoursePriorityCreateWithoutUserInput, CoursePriorityUncheckedCreateWithoutUserInput> | CoursePriorityCreateWithoutUserInput[] | CoursePriorityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CoursePriorityCreateOrConnectWithoutUserInput | CoursePriorityCreateOrConnectWithoutUserInput[]
    createMany?: CoursePriorityCreateManyUserInputEnvelope
    connect?: CoursePriorityWhereUniqueInput | CoursePriorityWhereUniqueInput[]
  }

  export type StreakCreateNestedOneWithoutUserInput = {
    create?: XOR<StreakCreateWithoutUserInput, StreakUncheckedCreateWithoutUserInput>
    connectOrCreate?: StreakCreateOrConnectWithoutUserInput
    connect?: StreakWhereUniqueInput
  }

  export type AchievementCreateNestedManyWithoutUserInput = {
    create?: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput> | AchievementCreateWithoutUserInput[] | AchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserInput | AchievementCreateOrConnectWithoutUserInput[]
    createMany?: AchievementCreateManyUserInputEnvelope
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
  }

  export type StudyGoalCreateNestedManyWithoutUserInput = {
    create?: XOR<StudyGoalCreateWithoutUserInput, StudyGoalUncheckedCreateWithoutUserInput> | StudyGoalCreateWithoutUserInput[] | StudyGoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudyGoalCreateOrConnectWithoutUserInput | StudyGoalCreateOrConnectWithoutUserInput[]
    createMany?: StudyGoalCreateManyUserInputEnvelope
    connect?: StudyGoalWhereUniqueInput | StudyGoalWhereUniqueInput[]
  }

  export type MissionStreakCreateNestedOneWithoutUserInput = {
    create?: XOR<MissionStreakCreateWithoutUserInput, MissionStreakUncheckedCreateWithoutUserInput>
    connectOrCreate?: MissionStreakCreateOrConnectWithoutUserInput
    connect?: MissionStreakWhereUniqueInput
  }

  export type MissionReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<MissionReviewCreateWithoutUserInput, MissionReviewUncheckedCreateWithoutUserInput> | MissionReviewCreateWithoutUserInput[] | MissionReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MissionReviewCreateOrConnectWithoutUserInput | MissionReviewCreateOrConnectWithoutUserInput[]
    createMany?: MissionReviewCreateManyUserInputEnvelope
    connect?: MissionReviewWhereUniqueInput | MissionReviewWhereUniqueInput[]
  }

  export type CourseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CourseCreateWithoutUserInput, CourseUncheckedCreateWithoutUserInput> | CourseCreateWithoutUserInput[] | CourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutUserInput | CourseCreateOrConnectWithoutUserInput[]
    createMany?: CourseCreateManyUserInputEnvelope
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
  }

  export type LectureUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LectureCreateWithoutUserInput, LectureUncheckedCreateWithoutUserInput> | LectureCreateWithoutUserInput[] | LectureUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LectureCreateOrConnectWithoutUserInput | LectureCreateOrConnectWithoutUserInput[]
    createMany?: LectureCreateManyUserInputEnvelope
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
  }

  export type StudySessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StudySessionCreateWithoutUserInput, StudySessionUncheckedCreateWithoutUserInput> | StudySessionCreateWithoutUserInput[] | StudySessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudySessionCreateOrConnectWithoutUserInput | StudySessionCreateOrConnectWithoutUserInput[]
    createMany?: StudySessionCreateManyUserInputEnvelope
    connect?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
  }

  export type MissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MissionCreateWithoutUserInput, MissionUncheckedCreateWithoutUserInput> | MissionCreateWithoutUserInput[] | MissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MissionCreateOrConnectWithoutUserInput | MissionCreateOrConnectWithoutUserInput[]
    createMany?: MissionCreateManyUserInputEnvelope
    connect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExamCreateWithoutUserInput, ExamUncheckedCreateWithoutUserInput> | ExamCreateWithoutUserInput[] | ExamUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutUserInput | ExamCreateOrConnectWithoutUserInput[]
    createMany?: ExamCreateManyUserInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type CoursePriorityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CoursePriorityCreateWithoutUserInput, CoursePriorityUncheckedCreateWithoutUserInput> | CoursePriorityCreateWithoutUserInput[] | CoursePriorityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CoursePriorityCreateOrConnectWithoutUserInput | CoursePriorityCreateOrConnectWithoutUserInput[]
    createMany?: CoursePriorityCreateManyUserInputEnvelope
    connect?: CoursePriorityWhereUniqueInput | CoursePriorityWhereUniqueInput[]
  }

  export type StreakUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StreakCreateWithoutUserInput, StreakUncheckedCreateWithoutUserInput>
    connectOrCreate?: StreakCreateOrConnectWithoutUserInput
    connect?: StreakWhereUniqueInput
  }

  export type AchievementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput> | AchievementCreateWithoutUserInput[] | AchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserInput | AchievementCreateOrConnectWithoutUserInput[]
    createMany?: AchievementCreateManyUserInputEnvelope
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
  }

  export type StudyGoalUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StudyGoalCreateWithoutUserInput, StudyGoalUncheckedCreateWithoutUserInput> | StudyGoalCreateWithoutUserInput[] | StudyGoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudyGoalCreateOrConnectWithoutUserInput | StudyGoalCreateOrConnectWithoutUserInput[]
    createMany?: StudyGoalCreateManyUserInputEnvelope
    connect?: StudyGoalWhereUniqueInput | StudyGoalWhereUniqueInput[]
  }

  export type MissionStreakUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<MissionStreakCreateWithoutUserInput, MissionStreakUncheckedCreateWithoutUserInput>
    connectOrCreate?: MissionStreakCreateOrConnectWithoutUserInput
    connect?: MissionStreakWhereUniqueInput
  }

  export type MissionReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MissionReviewCreateWithoutUserInput, MissionReviewUncheckedCreateWithoutUserInput> | MissionReviewCreateWithoutUserInput[] | MissionReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MissionReviewCreateOrConnectWithoutUserInput | MissionReviewCreateOrConnectWithoutUserInput[]
    createMany?: MissionReviewCreateManyUserInputEnvelope
    connect?: MissionReviewWhereUniqueInput | MissionReviewWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CourseUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseCreateWithoutUserInput, CourseUncheckedCreateWithoutUserInput> | CourseCreateWithoutUserInput[] | CourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutUserInput | CourseCreateOrConnectWithoutUserInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutUserInput | CourseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseCreateManyUserInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutUserInput | CourseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutUserInput | CourseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type LectureUpdateManyWithoutUserNestedInput = {
    create?: XOR<LectureCreateWithoutUserInput, LectureUncheckedCreateWithoutUserInput> | LectureCreateWithoutUserInput[] | LectureUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LectureCreateOrConnectWithoutUserInput | LectureCreateOrConnectWithoutUserInput[]
    upsert?: LectureUpsertWithWhereUniqueWithoutUserInput | LectureUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LectureCreateManyUserInputEnvelope
    set?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    disconnect?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    delete?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    update?: LectureUpdateWithWhereUniqueWithoutUserInput | LectureUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LectureUpdateManyWithWhereWithoutUserInput | LectureUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LectureScalarWhereInput | LectureScalarWhereInput[]
  }

  export type StudySessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<StudySessionCreateWithoutUserInput, StudySessionUncheckedCreateWithoutUserInput> | StudySessionCreateWithoutUserInput[] | StudySessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudySessionCreateOrConnectWithoutUserInput | StudySessionCreateOrConnectWithoutUserInput[]
    upsert?: StudySessionUpsertWithWhereUniqueWithoutUserInput | StudySessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StudySessionCreateManyUserInputEnvelope
    set?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    disconnect?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    delete?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    connect?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    update?: StudySessionUpdateWithWhereUniqueWithoutUserInput | StudySessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StudySessionUpdateManyWithWhereWithoutUserInput | StudySessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StudySessionScalarWhereInput | StudySessionScalarWhereInput[]
  }

  export type MissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<MissionCreateWithoutUserInput, MissionUncheckedCreateWithoutUserInput> | MissionCreateWithoutUserInput[] | MissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MissionCreateOrConnectWithoutUserInput | MissionCreateOrConnectWithoutUserInput[]
    upsert?: MissionUpsertWithWhereUniqueWithoutUserInput | MissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MissionCreateManyUserInputEnvelope
    set?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    disconnect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    delete?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    connect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    update?: MissionUpdateWithWhereUniqueWithoutUserInput | MissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MissionUpdateManyWithWhereWithoutUserInput | MissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MissionScalarWhereInput | MissionScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ExamUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExamCreateWithoutUserInput, ExamUncheckedCreateWithoutUserInput> | ExamCreateWithoutUserInput[] | ExamUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutUserInput | ExamCreateOrConnectWithoutUserInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutUserInput | ExamUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExamCreateManyUserInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutUserInput | ExamUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutUserInput | ExamUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type CoursePriorityUpdateManyWithoutUserNestedInput = {
    create?: XOR<CoursePriorityCreateWithoutUserInput, CoursePriorityUncheckedCreateWithoutUserInput> | CoursePriorityCreateWithoutUserInput[] | CoursePriorityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CoursePriorityCreateOrConnectWithoutUserInput | CoursePriorityCreateOrConnectWithoutUserInput[]
    upsert?: CoursePriorityUpsertWithWhereUniqueWithoutUserInput | CoursePriorityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CoursePriorityCreateManyUserInputEnvelope
    set?: CoursePriorityWhereUniqueInput | CoursePriorityWhereUniqueInput[]
    disconnect?: CoursePriorityWhereUniqueInput | CoursePriorityWhereUniqueInput[]
    delete?: CoursePriorityWhereUniqueInput | CoursePriorityWhereUniqueInput[]
    connect?: CoursePriorityWhereUniqueInput | CoursePriorityWhereUniqueInput[]
    update?: CoursePriorityUpdateWithWhereUniqueWithoutUserInput | CoursePriorityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CoursePriorityUpdateManyWithWhereWithoutUserInput | CoursePriorityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CoursePriorityScalarWhereInput | CoursePriorityScalarWhereInput[]
  }

  export type StreakUpdateOneWithoutUserNestedInput = {
    create?: XOR<StreakCreateWithoutUserInput, StreakUncheckedCreateWithoutUserInput>
    connectOrCreate?: StreakCreateOrConnectWithoutUserInput
    upsert?: StreakUpsertWithoutUserInput
    disconnect?: StreakWhereInput | boolean
    delete?: StreakWhereInput | boolean
    connect?: StreakWhereUniqueInput
    update?: XOR<XOR<StreakUpdateToOneWithWhereWithoutUserInput, StreakUpdateWithoutUserInput>, StreakUncheckedUpdateWithoutUserInput>
  }

  export type AchievementUpdateManyWithoutUserNestedInput = {
    create?: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput> | AchievementCreateWithoutUserInput[] | AchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserInput | AchievementCreateOrConnectWithoutUserInput[]
    upsert?: AchievementUpsertWithWhereUniqueWithoutUserInput | AchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AchievementCreateManyUserInputEnvelope
    set?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    disconnect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    delete?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    update?: AchievementUpdateWithWhereUniqueWithoutUserInput | AchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AchievementUpdateManyWithWhereWithoutUserInput | AchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
  }

  export type StudyGoalUpdateManyWithoutUserNestedInput = {
    create?: XOR<StudyGoalCreateWithoutUserInput, StudyGoalUncheckedCreateWithoutUserInput> | StudyGoalCreateWithoutUserInput[] | StudyGoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudyGoalCreateOrConnectWithoutUserInput | StudyGoalCreateOrConnectWithoutUserInput[]
    upsert?: StudyGoalUpsertWithWhereUniqueWithoutUserInput | StudyGoalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StudyGoalCreateManyUserInputEnvelope
    set?: StudyGoalWhereUniqueInput | StudyGoalWhereUniqueInput[]
    disconnect?: StudyGoalWhereUniqueInput | StudyGoalWhereUniqueInput[]
    delete?: StudyGoalWhereUniqueInput | StudyGoalWhereUniqueInput[]
    connect?: StudyGoalWhereUniqueInput | StudyGoalWhereUniqueInput[]
    update?: StudyGoalUpdateWithWhereUniqueWithoutUserInput | StudyGoalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StudyGoalUpdateManyWithWhereWithoutUserInput | StudyGoalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StudyGoalScalarWhereInput | StudyGoalScalarWhereInput[]
  }

  export type MissionStreakUpdateOneWithoutUserNestedInput = {
    create?: XOR<MissionStreakCreateWithoutUserInput, MissionStreakUncheckedCreateWithoutUserInput>
    connectOrCreate?: MissionStreakCreateOrConnectWithoutUserInput
    upsert?: MissionStreakUpsertWithoutUserInput
    disconnect?: MissionStreakWhereInput | boolean
    delete?: MissionStreakWhereInput | boolean
    connect?: MissionStreakWhereUniqueInput
    update?: XOR<XOR<MissionStreakUpdateToOneWithWhereWithoutUserInput, MissionStreakUpdateWithoutUserInput>, MissionStreakUncheckedUpdateWithoutUserInput>
  }

  export type MissionReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<MissionReviewCreateWithoutUserInput, MissionReviewUncheckedCreateWithoutUserInput> | MissionReviewCreateWithoutUserInput[] | MissionReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MissionReviewCreateOrConnectWithoutUserInput | MissionReviewCreateOrConnectWithoutUserInput[]
    upsert?: MissionReviewUpsertWithWhereUniqueWithoutUserInput | MissionReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MissionReviewCreateManyUserInputEnvelope
    set?: MissionReviewWhereUniqueInput | MissionReviewWhereUniqueInput[]
    disconnect?: MissionReviewWhereUniqueInput | MissionReviewWhereUniqueInput[]
    delete?: MissionReviewWhereUniqueInput | MissionReviewWhereUniqueInput[]
    connect?: MissionReviewWhereUniqueInput | MissionReviewWhereUniqueInput[]
    update?: MissionReviewUpdateWithWhereUniqueWithoutUserInput | MissionReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MissionReviewUpdateManyWithWhereWithoutUserInput | MissionReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MissionReviewScalarWhereInput | MissionReviewScalarWhereInput[]
  }

  export type CourseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CourseCreateWithoutUserInput, CourseUncheckedCreateWithoutUserInput> | CourseCreateWithoutUserInput[] | CourseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CourseCreateOrConnectWithoutUserInput | CourseCreateOrConnectWithoutUserInput[]
    upsert?: CourseUpsertWithWhereUniqueWithoutUserInput | CourseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CourseCreateManyUserInputEnvelope
    set?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    disconnect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    delete?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    connect?: CourseWhereUniqueInput | CourseWhereUniqueInput[]
    update?: CourseUpdateWithWhereUniqueWithoutUserInput | CourseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CourseUpdateManyWithWhereWithoutUserInput | CourseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CourseScalarWhereInput | CourseScalarWhereInput[]
  }

  export type LectureUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LectureCreateWithoutUserInput, LectureUncheckedCreateWithoutUserInput> | LectureCreateWithoutUserInput[] | LectureUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LectureCreateOrConnectWithoutUserInput | LectureCreateOrConnectWithoutUserInput[]
    upsert?: LectureUpsertWithWhereUniqueWithoutUserInput | LectureUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LectureCreateManyUserInputEnvelope
    set?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    disconnect?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    delete?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    update?: LectureUpdateWithWhereUniqueWithoutUserInput | LectureUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LectureUpdateManyWithWhereWithoutUserInput | LectureUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LectureScalarWhereInput | LectureScalarWhereInput[]
  }

  export type StudySessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StudySessionCreateWithoutUserInput, StudySessionUncheckedCreateWithoutUserInput> | StudySessionCreateWithoutUserInput[] | StudySessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudySessionCreateOrConnectWithoutUserInput | StudySessionCreateOrConnectWithoutUserInput[]
    upsert?: StudySessionUpsertWithWhereUniqueWithoutUserInput | StudySessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StudySessionCreateManyUserInputEnvelope
    set?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    disconnect?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    delete?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    connect?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    update?: StudySessionUpdateWithWhereUniqueWithoutUserInput | StudySessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StudySessionUpdateManyWithWhereWithoutUserInput | StudySessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StudySessionScalarWhereInput | StudySessionScalarWhereInput[]
  }

  export type MissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MissionCreateWithoutUserInput, MissionUncheckedCreateWithoutUserInput> | MissionCreateWithoutUserInput[] | MissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MissionCreateOrConnectWithoutUserInput | MissionCreateOrConnectWithoutUserInput[]
    upsert?: MissionUpsertWithWhereUniqueWithoutUserInput | MissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MissionCreateManyUserInputEnvelope
    set?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    disconnect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    delete?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    connect?: MissionWhereUniqueInput | MissionWhereUniqueInput[]
    update?: MissionUpdateWithWhereUniqueWithoutUserInput | MissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MissionUpdateManyWithWhereWithoutUserInput | MissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MissionScalarWhereInput | MissionScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExamCreateWithoutUserInput, ExamUncheckedCreateWithoutUserInput> | ExamCreateWithoutUserInput[] | ExamUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutUserInput | ExamCreateOrConnectWithoutUserInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutUserInput | ExamUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExamCreateManyUserInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutUserInput | ExamUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutUserInput | ExamUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type CoursePriorityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CoursePriorityCreateWithoutUserInput, CoursePriorityUncheckedCreateWithoutUserInput> | CoursePriorityCreateWithoutUserInput[] | CoursePriorityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CoursePriorityCreateOrConnectWithoutUserInput | CoursePriorityCreateOrConnectWithoutUserInput[]
    upsert?: CoursePriorityUpsertWithWhereUniqueWithoutUserInput | CoursePriorityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CoursePriorityCreateManyUserInputEnvelope
    set?: CoursePriorityWhereUniqueInput | CoursePriorityWhereUniqueInput[]
    disconnect?: CoursePriorityWhereUniqueInput | CoursePriorityWhereUniqueInput[]
    delete?: CoursePriorityWhereUniqueInput | CoursePriorityWhereUniqueInput[]
    connect?: CoursePriorityWhereUniqueInput | CoursePriorityWhereUniqueInput[]
    update?: CoursePriorityUpdateWithWhereUniqueWithoutUserInput | CoursePriorityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CoursePriorityUpdateManyWithWhereWithoutUserInput | CoursePriorityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CoursePriorityScalarWhereInput | CoursePriorityScalarWhereInput[]
  }

  export type StreakUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StreakCreateWithoutUserInput, StreakUncheckedCreateWithoutUserInput>
    connectOrCreate?: StreakCreateOrConnectWithoutUserInput
    upsert?: StreakUpsertWithoutUserInput
    disconnect?: StreakWhereInput | boolean
    delete?: StreakWhereInput | boolean
    connect?: StreakWhereUniqueInput
    update?: XOR<XOR<StreakUpdateToOneWithWhereWithoutUserInput, StreakUpdateWithoutUserInput>, StreakUncheckedUpdateWithoutUserInput>
  }

  export type AchievementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput> | AchievementCreateWithoutUserInput[] | AchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserInput | AchievementCreateOrConnectWithoutUserInput[]
    upsert?: AchievementUpsertWithWhereUniqueWithoutUserInput | AchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AchievementCreateManyUserInputEnvelope
    set?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    disconnect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    delete?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    update?: AchievementUpdateWithWhereUniqueWithoutUserInput | AchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AchievementUpdateManyWithWhereWithoutUserInput | AchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
  }

  export type StudyGoalUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StudyGoalCreateWithoutUserInput, StudyGoalUncheckedCreateWithoutUserInput> | StudyGoalCreateWithoutUserInput[] | StudyGoalUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudyGoalCreateOrConnectWithoutUserInput | StudyGoalCreateOrConnectWithoutUserInput[]
    upsert?: StudyGoalUpsertWithWhereUniqueWithoutUserInput | StudyGoalUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StudyGoalCreateManyUserInputEnvelope
    set?: StudyGoalWhereUniqueInput | StudyGoalWhereUniqueInput[]
    disconnect?: StudyGoalWhereUniqueInput | StudyGoalWhereUniqueInput[]
    delete?: StudyGoalWhereUniqueInput | StudyGoalWhereUniqueInput[]
    connect?: StudyGoalWhereUniqueInput | StudyGoalWhereUniqueInput[]
    update?: StudyGoalUpdateWithWhereUniqueWithoutUserInput | StudyGoalUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StudyGoalUpdateManyWithWhereWithoutUserInput | StudyGoalUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StudyGoalScalarWhereInput | StudyGoalScalarWhereInput[]
  }

  export type MissionStreakUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<MissionStreakCreateWithoutUserInput, MissionStreakUncheckedCreateWithoutUserInput>
    connectOrCreate?: MissionStreakCreateOrConnectWithoutUserInput
    upsert?: MissionStreakUpsertWithoutUserInput
    disconnect?: MissionStreakWhereInput | boolean
    delete?: MissionStreakWhereInput | boolean
    connect?: MissionStreakWhereUniqueInput
    update?: XOR<XOR<MissionStreakUpdateToOneWithWhereWithoutUserInput, MissionStreakUpdateWithoutUserInput>, MissionStreakUncheckedUpdateWithoutUserInput>
  }

  export type MissionReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MissionReviewCreateWithoutUserInput, MissionReviewUncheckedCreateWithoutUserInput> | MissionReviewCreateWithoutUserInput[] | MissionReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MissionReviewCreateOrConnectWithoutUserInput | MissionReviewCreateOrConnectWithoutUserInput[]
    upsert?: MissionReviewUpsertWithWhereUniqueWithoutUserInput | MissionReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MissionReviewCreateManyUserInputEnvelope
    set?: MissionReviewWhereUniqueInput | MissionReviewWhereUniqueInput[]
    disconnect?: MissionReviewWhereUniqueInput | MissionReviewWhereUniqueInput[]
    delete?: MissionReviewWhereUniqueInput | MissionReviewWhereUniqueInput[]
    connect?: MissionReviewWhereUniqueInput | MissionReviewWhereUniqueInput[]
    update?: MissionReviewUpdateWithWhereUniqueWithoutUserInput | MissionReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MissionReviewUpdateManyWithWhereWithoutUserInput | MissionReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MissionReviewScalarWhereInput | MissionReviewScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCoursesInput = {
    create?: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoursesInput
    connect?: UserWhereUniqueInput
  }

  export type LectureCreateNestedManyWithoutCourseInput = {
    create?: XOR<LectureCreateWithoutCourseInput, LectureUncheckedCreateWithoutCourseInput> | LectureCreateWithoutCourseInput[] | LectureUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LectureCreateOrConnectWithoutCourseInput | LectureCreateOrConnectWithoutCourseInput[]
    createMany?: LectureCreateManyCourseInputEnvelope
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
  }

  export type CardCreateNestedManyWithoutCourseInput = {
    create?: XOR<CardCreateWithoutCourseInput, CardUncheckedCreateWithoutCourseInput> | CardCreateWithoutCourseInput[] | CardUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CardCreateOrConnectWithoutCourseInput | CardCreateOrConnectWithoutCourseInput[]
    createMany?: CardCreateManyCourseInputEnvelope
    connect?: CardWhereUniqueInput | CardWhereUniqueInput[]
  }

  export type ExamCreateNestedManyWithoutCourseInput = {
    create?: XOR<ExamCreateWithoutCourseInput, ExamUncheckedCreateWithoutCourseInput> | ExamCreateWithoutCourseInput[] | ExamUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutCourseInput | ExamCreateOrConnectWithoutCourseInput[]
    createMany?: ExamCreateManyCourseInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type CoursePriorityCreateNestedManyWithoutCourseInput = {
    create?: XOR<CoursePriorityCreateWithoutCourseInput, CoursePriorityUncheckedCreateWithoutCourseInput> | CoursePriorityCreateWithoutCourseInput[] | CoursePriorityUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CoursePriorityCreateOrConnectWithoutCourseInput | CoursePriorityCreateOrConnectWithoutCourseInput[]
    createMany?: CoursePriorityCreateManyCourseInputEnvelope
    connect?: CoursePriorityWhereUniqueInput | CoursePriorityWhereUniqueInput[]
  }

  export type LectureUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<LectureCreateWithoutCourseInput, LectureUncheckedCreateWithoutCourseInput> | LectureCreateWithoutCourseInput[] | LectureUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LectureCreateOrConnectWithoutCourseInput | LectureCreateOrConnectWithoutCourseInput[]
    createMany?: LectureCreateManyCourseInputEnvelope
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
  }

  export type CardUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CardCreateWithoutCourseInput, CardUncheckedCreateWithoutCourseInput> | CardCreateWithoutCourseInput[] | CardUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CardCreateOrConnectWithoutCourseInput | CardCreateOrConnectWithoutCourseInput[]
    createMany?: CardCreateManyCourseInputEnvelope
    connect?: CardWhereUniqueInput | CardWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<ExamCreateWithoutCourseInput, ExamUncheckedCreateWithoutCourseInput> | ExamCreateWithoutCourseInput[] | ExamUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutCourseInput | ExamCreateOrConnectWithoutCourseInput[]
    createMany?: ExamCreateManyCourseInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type CoursePriorityUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CoursePriorityCreateWithoutCourseInput, CoursePriorityUncheckedCreateWithoutCourseInput> | CoursePriorityCreateWithoutCourseInput[] | CoursePriorityUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CoursePriorityCreateOrConnectWithoutCourseInput | CoursePriorityCreateOrConnectWithoutCourseInput[]
    createMany?: CoursePriorityCreateManyCourseInputEnvelope
    connect?: CoursePriorityWhereUniqueInput | CoursePriorityWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoursesInput
    upsert?: UserUpsertWithoutCoursesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCoursesInput, UserUpdateWithoutCoursesInput>, UserUncheckedUpdateWithoutCoursesInput>
  }

  export type LectureUpdateManyWithoutCourseNestedInput = {
    create?: XOR<LectureCreateWithoutCourseInput, LectureUncheckedCreateWithoutCourseInput> | LectureCreateWithoutCourseInput[] | LectureUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LectureCreateOrConnectWithoutCourseInput | LectureCreateOrConnectWithoutCourseInput[]
    upsert?: LectureUpsertWithWhereUniqueWithoutCourseInput | LectureUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: LectureCreateManyCourseInputEnvelope
    set?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    disconnect?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    delete?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    update?: LectureUpdateWithWhereUniqueWithoutCourseInput | LectureUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: LectureUpdateManyWithWhereWithoutCourseInput | LectureUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: LectureScalarWhereInput | LectureScalarWhereInput[]
  }

  export type CardUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CardCreateWithoutCourseInput, CardUncheckedCreateWithoutCourseInput> | CardCreateWithoutCourseInput[] | CardUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CardCreateOrConnectWithoutCourseInput | CardCreateOrConnectWithoutCourseInput[]
    upsert?: CardUpsertWithWhereUniqueWithoutCourseInput | CardUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CardCreateManyCourseInputEnvelope
    set?: CardWhereUniqueInput | CardWhereUniqueInput[]
    disconnect?: CardWhereUniqueInput | CardWhereUniqueInput[]
    delete?: CardWhereUniqueInput | CardWhereUniqueInput[]
    connect?: CardWhereUniqueInput | CardWhereUniqueInput[]
    update?: CardUpdateWithWhereUniqueWithoutCourseInput | CardUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CardUpdateManyWithWhereWithoutCourseInput | CardUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CardScalarWhereInput | CardScalarWhereInput[]
  }

  export type ExamUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ExamCreateWithoutCourseInput, ExamUncheckedCreateWithoutCourseInput> | ExamCreateWithoutCourseInput[] | ExamUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutCourseInput | ExamCreateOrConnectWithoutCourseInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutCourseInput | ExamUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ExamCreateManyCourseInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutCourseInput | ExamUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutCourseInput | ExamUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type CoursePriorityUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CoursePriorityCreateWithoutCourseInput, CoursePriorityUncheckedCreateWithoutCourseInput> | CoursePriorityCreateWithoutCourseInput[] | CoursePriorityUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CoursePriorityCreateOrConnectWithoutCourseInput | CoursePriorityCreateOrConnectWithoutCourseInput[]
    upsert?: CoursePriorityUpsertWithWhereUniqueWithoutCourseInput | CoursePriorityUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CoursePriorityCreateManyCourseInputEnvelope
    set?: CoursePriorityWhereUniqueInput | CoursePriorityWhereUniqueInput[]
    disconnect?: CoursePriorityWhereUniqueInput | CoursePriorityWhereUniqueInput[]
    delete?: CoursePriorityWhereUniqueInput | CoursePriorityWhereUniqueInput[]
    connect?: CoursePriorityWhereUniqueInput | CoursePriorityWhereUniqueInput[]
    update?: CoursePriorityUpdateWithWhereUniqueWithoutCourseInput | CoursePriorityUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CoursePriorityUpdateManyWithWhereWithoutCourseInput | CoursePriorityUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CoursePriorityScalarWhereInput | CoursePriorityScalarWhereInput[]
  }

  export type LectureUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<LectureCreateWithoutCourseInput, LectureUncheckedCreateWithoutCourseInput> | LectureCreateWithoutCourseInput[] | LectureUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: LectureCreateOrConnectWithoutCourseInput | LectureCreateOrConnectWithoutCourseInput[]
    upsert?: LectureUpsertWithWhereUniqueWithoutCourseInput | LectureUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: LectureCreateManyCourseInputEnvelope
    set?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    disconnect?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    delete?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    update?: LectureUpdateWithWhereUniqueWithoutCourseInput | LectureUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: LectureUpdateManyWithWhereWithoutCourseInput | LectureUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: LectureScalarWhereInput | LectureScalarWhereInput[]
  }

  export type CardUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CardCreateWithoutCourseInput, CardUncheckedCreateWithoutCourseInput> | CardCreateWithoutCourseInput[] | CardUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CardCreateOrConnectWithoutCourseInput | CardCreateOrConnectWithoutCourseInput[]
    upsert?: CardUpsertWithWhereUniqueWithoutCourseInput | CardUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CardCreateManyCourseInputEnvelope
    set?: CardWhereUniqueInput | CardWhereUniqueInput[]
    disconnect?: CardWhereUniqueInput | CardWhereUniqueInput[]
    delete?: CardWhereUniqueInput | CardWhereUniqueInput[]
    connect?: CardWhereUniqueInput | CardWhereUniqueInput[]
    update?: CardUpdateWithWhereUniqueWithoutCourseInput | CardUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CardUpdateManyWithWhereWithoutCourseInput | CardUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CardScalarWhereInput | CardScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<ExamCreateWithoutCourseInput, ExamUncheckedCreateWithoutCourseInput> | ExamCreateWithoutCourseInput[] | ExamUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutCourseInput | ExamCreateOrConnectWithoutCourseInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutCourseInput | ExamUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: ExamCreateManyCourseInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutCourseInput | ExamUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutCourseInput | ExamUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type CoursePriorityUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CoursePriorityCreateWithoutCourseInput, CoursePriorityUncheckedCreateWithoutCourseInput> | CoursePriorityCreateWithoutCourseInput[] | CoursePriorityUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CoursePriorityCreateOrConnectWithoutCourseInput | CoursePriorityCreateOrConnectWithoutCourseInput[]
    upsert?: CoursePriorityUpsertWithWhereUniqueWithoutCourseInput | CoursePriorityUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CoursePriorityCreateManyCourseInputEnvelope
    set?: CoursePriorityWhereUniqueInput | CoursePriorityWhereUniqueInput[]
    disconnect?: CoursePriorityWhereUniqueInput | CoursePriorityWhereUniqueInput[]
    delete?: CoursePriorityWhereUniqueInput | CoursePriorityWhereUniqueInput[]
    connect?: CoursePriorityWhereUniqueInput | CoursePriorityWhereUniqueInput[]
    update?: CoursePriorityUpdateWithWhereUniqueWithoutCourseInput | CoursePriorityUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CoursePriorityUpdateManyWithWhereWithoutCourseInput | CoursePriorityUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CoursePriorityScalarWhereInput | CoursePriorityScalarWhereInput[]
  }

  export type LectureCreatetopicTagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutLecturesInput = {
    create?: XOR<UserCreateWithoutLecturesInput, UserUncheckedCreateWithoutLecturesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLecturesInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutLecturesInput = {
    create?: XOR<CourseCreateWithoutLecturesInput, CourseUncheckedCreateWithoutLecturesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutLecturesInput
    connect?: CourseWhereUniqueInput
  }

  export type ContentChunkCreateNestedManyWithoutLectureInput = {
    create?: XOR<ContentChunkCreateWithoutLectureInput, ContentChunkUncheckedCreateWithoutLectureInput> | ContentChunkCreateWithoutLectureInput[] | ContentChunkUncheckedCreateWithoutLectureInput[]
    connectOrCreate?: ContentChunkCreateOrConnectWithoutLectureInput | ContentChunkCreateOrConnectWithoutLectureInput[]
    createMany?: ContentChunkCreateManyLectureInputEnvelope
    connect?: ContentChunkWhereUniqueInput | ContentChunkWhereUniqueInput[]
  }

  export type LearningObjectiveCreateNestedManyWithoutLectureInput = {
    create?: XOR<LearningObjectiveCreateWithoutLectureInput, LearningObjectiveUncheckedCreateWithoutLectureInput> | LearningObjectiveCreateWithoutLectureInput[] | LearningObjectiveUncheckedCreateWithoutLectureInput[]
    connectOrCreate?: LearningObjectiveCreateOrConnectWithoutLectureInput | LearningObjectiveCreateOrConnectWithoutLectureInput[]
    createMany?: LearningObjectiveCreateManyLectureInputEnvelope
    connect?: LearningObjectiveWhereUniqueInput | LearningObjectiveWhereUniqueInput[]
  }

  export type CardCreateNestedManyWithoutLectureInput = {
    create?: XOR<CardCreateWithoutLectureInput, CardUncheckedCreateWithoutLectureInput> | CardCreateWithoutLectureInput[] | CardUncheckedCreateWithoutLectureInput[]
    connectOrCreate?: CardCreateOrConnectWithoutLectureInput | CardCreateOrConnectWithoutLectureInput[]
    createMany?: CardCreateManyLectureInputEnvelope
    connect?: CardWhereUniqueInput | CardWhereUniqueInput[]
  }

  export type ContentChunkUncheckedCreateNestedManyWithoutLectureInput = {
    create?: XOR<ContentChunkCreateWithoutLectureInput, ContentChunkUncheckedCreateWithoutLectureInput> | ContentChunkCreateWithoutLectureInput[] | ContentChunkUncheckedCreateWithoutLectureInput[]
    connectOrCreate?: ContentChunkCreateOrConnectWithoutLectureInput | ContentChunkCreateOrConnectWithoutLectureInput[]
    createMany?: ContentChunkCreateManyLectureInputEnvelope
    connect?: ContentChunkWhereUniqueInput | ContentChunkWhereUniqueInput[]
  }

  export type LearningObjectiveUncheckedCreateNestedManyWithoutLectureInput = {
    create?: XOR<LearningObjectiveCreateWithoutLectureInput, LearningObjectiveUncheckedCreateWithoutLectureInput> | LearningObjectiveCreateWithoutLectureInput[] | LearningObjectiveUncheckedCreateWithoutLectureInput[]
    connectOrCreate?: LearningObjectiveCreateOrConnectWithoutLectureInput | LearningObjectiveCreateOrConnectWithoutLectureInput[]
    createMany?: LearningObjectiveCreateManyLectureInputEnvelope
    connect?: LearningObjectiveWhereUniqueInput | LearningObjectiveWhereUniqueInput[]
  }

  export type CardUncheckedCreateNestedManyWithoutLectureInput = {
    create?: XOR<CardCreateWithoutLectureInput, CardUncheckedCreateWithoutLectureInput> | CardCreateWithoutLectureInput[] | CardUncheckedCreateWithoutLectureInput[]
    connectOrCreate?: CardCreateOrConnectWithoutLectureInput | CardCreateOrConnectWithoutLectureInput[]
    createMany?: CardCreateManyLectureInputEnvelope
    connect?: CardWhereUniqueInput | CardWhereUniqueInput[]
  }

  export type EnumProcessingStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProcessingStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LectureUpdatetopicTagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutLecturesNestedInput = {
    create?: XOR<UserCreateWithoutLecturesInput, UserUncheckedCreateWithoutLecturesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLecturesInput
    upsert?: UserUpsertWithoutLecturesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLecturesInput, UserUpdateWithoutLecturesInput>, UserUncheckedUpdateWithoutLecturesInput>
  }

  export type CourseUpdateOneRequiredWithoutLecturesNestedInput = {
    create?: XOR<CourseCreateWithoutLecturesInput, CourseUncheckedCreateWithoutLecturesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutLecturesInput
    upsert?: CourseUpsertWithoutLecturesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutLecturesInput, CourseUpdateWithoutLecturesInput>, CourseUncheckedUpdateWithoutLecturesInput>
  }

  export type ContentChunkUpdateManyWithoutLectureNestedInput = {
    create?: XOR<ContentChunkCreateWithoutLectureInput, ContentChunkUncheckedCreateWithoutLectureInput> | ContentChunkCreateWithoutLectureInput[] | ContentChunkUncheckedCreateWithoutLectureInput[]
    connectOrCreate?: ContentChunkCreateOrConnectWithoutLectureInput | ContentChunkCreateOrConnectWithoutLectureInput[]
    upsert?: ContentChunkUpsertWithWhereUniqueWithoutLectureInput | ContentChunkUpsertWithWhereUniqueWithoutLectureInput[]
    createMany?: ContentChunkCreateManyLectureInputEnvelope
    set?: ContentChunkWhereUniqueInput | ContentChunkWhereUniqueInput[]
    disconnect?: ContentChunkWhereUniqueInput | ContentChunkWhereUniqueInput[]
    delete?: ContentChunkWhereUniqueInput | ContentChunkWhereUniqueInput[]
    connect?: ContentChunkWhereUniqueInput | ContentChunkWhereUniqueInput[]
    update?: ContentChunkUpdateWithWhereUniqueWithoutLectureInput | ContentChunkUpdateWithWhereUniqueWithoutLectureInput[]
    updateMany?: ContentChunkUpdateManyWithWhereWithoutLectureInput | ContentChunkUpdateManyWithWhereWithoutLectureInput[]
    deleteMany?: ContentChunkScalarWhereInput | ContentChunkScalarWhereInput[]
  }

  export type LearningObjectiveUpdateManyWithoutLectureNestedInput = {
    create?: XOR<LearningObjectiveCreateWithoutLectureInput, LearningObjectiveUncheckedCreateWithoutLectureInput> | LearningObjectiveCreateWithoutLectureInput[] | LearningObjectiveUncheckedCreateWithoutLectureInput[]
    connectOrCreate?: LearningObjectiveCreateOrConnectWithoutLectureInput | LearningObjectiveCreateOrConnectWithoutLectureInput[]
    upsert?: LearningObjectiveUpsertWithWhereUniqueWithoutLectureInput | LearningObjectiveUpsertWithWhereUniqueWithoutLectureInput[]
    createMany?: LearningObjectiveCreateManyLectureInputEnvelope
    set?: LearningObjectiveWhereUniqueInput | LearningObjectiveWhereUniqueInput[]
    disconnect?: LearningObjectiveWhereUniqueInput | LearningObjectiveWhereUniqueInput[]
    delete?: LearningObjectiveWhereUniqueInput | LearningObjectiveWhereUniqueInput[]
    connect?: LearningObjectiveWhereUniqueInput | LearningObjectiveWhereUniqueInput[]
    update?: LearningObjectiveUpdateWithWhereUniqueWithoutLectureInput | LearningObjectiveUpdateWithWhereUniqueWithoutLectureInput[]
    updateMany?: LearningObjectiveUpdateManyWithWhereWithoutLectureInput | LearningObjectiveUpdateManyWithWhereWithoutLectureInput[]
    deleteMany?: LearningObjectiveScalarWhereInput | LearningObjectiveScalarWhereInput[]
  }

  export type CardUpdateManyWithoutLectureNestedInput = {
    create?: XOR<CardCreateWithoutLectureInput, CardUncheckedCreateWithoutLectureInput> | CardCreateWithoutLectureInput[] | CardUncheckedCreateWithoutLectureInput[]
    connectOrCreate?: CardCreateOrConnectWithoutLectureInput | CardCreateOrConnectWithoutLectureInput[]
    upsert?: CardUpsertWithWhereUniqueWithoutLectureInput | CardUpsertWithWhereUniqueWithoutLectureInput[]
    createMany?: CardCreateManyLectureInputEnvelope
    set?: CardWhereUniqueInput | CardWhereUniqueInput[]
    disconnect?: CardWhereUniqueInput | CardWhereUniqueInput[]
    delete?: CardWhereUniqueInput | CardWhereUniqueInput[]
    connect?: CardWhereUniqueInput | CardWhereUniqueInput[]
    update?: CardUpdateWithWhereUniqueWithoutLectureInput | CardUpdateWithWhereUniqueWithoutLectureInput[]
    updateMany?: CardUpdateManyWithWhereWithoutLectureInput | CardUpdateManyWithWhereWithoutLectureInput[]
    deleteMany?: CardScalarWhereInput | CardScalarWhereInput[]
  }

  export type ContentChunkUncheckedUpdateManyWithoutLectureNestedInput = {
    create?: XOR<ContentChunkCreateWithoutLectureInput, ContentChunkUncheckedCreateWithoutLectureInput> | ContentChunkCreateWithoutLectureInput[] | ContentChunkUncheckedCreateWithoutLectureInput[]
    connectOrCreate?: ContentChunkCreateOrConnectWithoutLectureInput | ContentChunkCreateOrConnectWithoutLectureInput[]
    upsert?: ContentChunkUpsertWithWhereUniqueWithoutLectureInput | ContentChunkUpsertWithWhereUniqueWithoutLectureInput[]
    createMany?: ContentChunkCreateManyLectureInputEnvelope
    set?: ContentChunkWhereUniqueInput | ContentChunkWhereUniqueInput[]
    disconnect?: ContentChunkWhereUniqueInput | ContentChunkWhereUniqueInput[]
    delete?: ContentChunkWhereUniqueInput | ContentChunkWhereUniqueInput[]
    connect?: ContentChunkWhereUniqueInput | ContentChunkWhereUniqueInput[]
    update?: ContentChunkUpdateWithWhereUniqueWithoutLectureInput | ContentChunkUpdateWithWhereUniqueWithoutLectureInput[]
    updateMany?: ContentChunkUpdateManyWithWhereWithoutLectureInput | ContentChunkUpdateManyWithWhereWithoutLectureInput[]
    deleteMany?: ContentChunkScalarWhereInput | ContentChunkScalarWhereInput[]
  }

  export type LearningObjectiveUncheckedUpdateManyWithoutLectureNestedInput = {
    create?: XOR<LearningObjectiveCreateWithoutLectureInput, LearningObjectiveUncheckedCreateWithoutLectureInput> | LearningObjectiveCreateWithoutLectureInput[] | LearningObjectiveUncheckedCreateWithoutLectureInput[]
    connectOrCreate?: LearningObjectiveCreateOrConnectWithoutLectureInput | LearningObjectiveCreateOrConnectWithoutLectureInput[]
    upsert?: LearningObjectiveUpsertWithWhereUniqueWithoutLectureInput | LearningObjectiveUpsertWithWhereUniqueWithoutLectureInput[]
    createMany?: LearningObjectiveCreateManyLectureInputEnvelope
    set?: LearningObjectiveWhereUniqueInput | LearningObjectiveWhereUniqueInput[]
    disconnect?: LearningObjectiveWhereUniqueInput | LearningObjectiveWhereUniqueInput[]
    delete?: LearningObjectiveWhereUniqueInput | LearningObjectiveWhereUniqueInput[]
    connect?: LearningObjectiveWhereUniqueInput | LearningObjectiveWhereUniqueInput[]
    update?: LearningObjectiveUpdateWithWhereUniqueWithoutLectureInput | LearningObjectiveUpdateWithWhereUniqueWithoutLectureInput[]
    updateMany?: LearningObjectiveUpdateManyWithWhereWithoutLectureInput | LearningObjectiveUpdateManyWithWhereWithoutLectureInput[]
    deleteMany?: LearningObjectiveScalarWhereInput | LearningObjectiveScalarWhereInput[]
  }

  export type CardUncheckedUpdateManyWithoutLectureNestedInput = {
    create?: XOR<CardCreateWithoutLectureInput, CardUncheckedCreateWithoutLectureInput> | CardCreateWithoutLectureInput[] | CardUncheckedCreateWithoutLectureInput[]
    connectOrCreate?: CardCreateOrConnectWithoutLectureInput | CardCreateOrConnectWithoutLectureInput[]
    upsert?: CardUpsertWithWhereUniqueWithoutLectureInput | CardUpsertWithWhereUniqueWithoutLectureInput[]
    createMany?: CardCreateManyLectureInputEnvelope
    set?: CardWhereUniqueInput | CardWhereUniqueInput[]
    disconnect?: CardWhereUniqueInput | CardWhereUniqueInput[]
    delete?: CardWhereUniqueInput | CardWhereUniqueInput[]
    connect?: CardWhereUniqueInput | CardWhereUniqueInput[]
    update?: CardUpdateWithWhereUniqueWithoutLectureInput | CardUpdateWithWhereUniqueWithoutLectureInput[]
    updateMany?: CardUpdateManyWithWhereWithoutLectureInput | CardUpdateManyWithWhereWithoutLectureInput[]
    deleteMany?: CardScalarWhereInput | CardScalarWhereInput[]
  }

  export type LectureCreateNestedOneWithoutContentChunksInput = {
    create?: XOR<LectureCreateWithoutContentChunksInput, LectureUncheckedCreateWithoutContentChunksInput>
    connectOrCreate?: LectureCreateOrConnectWithoutContentChunksInput
    connect?: LectureWhereUniqueInput
  }

  export type LectureUpdateOneRequiredWithoutContentChunksNestedInput = {
    create?: XOR<LectureCreateWithoutContentChunksInput, LectureUncheckedCreateWithoutContentChunksInput>
    connectOrCreate?: LectureCreateOrConnectWithoutContentChunksInput
    upsert?: LectureUpsertWithoutContentChunksInput
    connect?: LectureWhereUniqueInput
    update?: XOR<XOR<LectureUpdateToOneWithWhereWithoutContentChunksInput, LectureUpdateWithoutContentChunksInput>, LectureUncheckedUpdateWithoutContentChunksInput>
  }

  export type LearningObjectiveCreateboardExamTagsInput = {
    set: string[]
  }

  export type LectureCreateNestedOneWithoutLearningObjectivesInput = {
    create?: XOR<LectureCreateWithoutLearningObjectivesInput, LectureUncheckedCreateWithoutLearningObjectivesInput>
    connectOrCreate?: LectureCreateOrConnectWithoutLearningObjectivesInput
    connect?: LectureWhereUniqueInput
  }

  export type CardCreateNestedManyWithoutObjectiveInput = {
    create?: XOR<CardCreateWithoutObjectiveInput, CardUncheckedCreateWithoutObjectiveInput> | CardCreateWithoutObjectiveInput[] | CardUncheckedCreateWithoutObjectiveInput[]
    connectOrCreate?: CardCreateOrConnectWithoutObjectiveInput | CardCreateOrConnectWithoutObjectiveInput[]
    createMany?: CardCreateManyObjectiveInputEnvelope
    connect?: CardWhereUniqueInput | CardWhereUniqueInput[]
  }

  export type ObjectivePrerequisiteCreateNestedManyWithoutObjectiveInput = {
    create?: XOR<ObjectivePrerequisiteCreateWithoutObjectiveInput, ObjectivePrerequisiteUncheckedCreateWithoutObjectiveInput> | ObjectivePrerequisiteCreateWithoutObjectiveInput[] | ObjectivePrerequisiteUncheckedCreateWithoutObjectiveInput[]
    connectOrCreate?: ObjectivePrerequisiteCreateOrConnectWithoutObjectiveInput | ObjectivePrerequisiteCreateOrConnectWithoutObjectiveInput[]
    createMany?: ObjectivePrerequisiteCreateManyObjectiveInputEnvelope
    connect?: ObjectivePrerequisiteWhereUniqueInput | ObjectivePrerequisiteWhereUniqueInput[]
  }

  export type ObjectivePrerequisiteCreateNestedManyWithoutPrerequisiteInput = {
    create?: XOR<ObjectivePrerequisiteCreateWithoutPrerequisiteInput, ObjectivePrerequisiteUncheckedCreateWithoutPrerequisiteInput> | ObjectivePrerequisiteCreateWithoutPrerequisiteInput[] | ObjectivePrerequisiteUncheckedCreateWithoutPrerequisiteInput[]
    connectOrCreate?: ObjectivePrerequisiteCreateOrConnectWithoutPrerequisiteInput | ObjectivePrerequisiteCreateOrConnectWithoutPrerequisiteInput[]
    createMany?: ObjectivePrerequisiteCreateManyPrerequisiteInputEnvelope
    connect?: ObjectivePrerequisiteWhereUniqueInput | ObjectivePrerequisiteWhereUniqueInput[]
  }

  export type PerformanceMetricCreateNestedManyWithoutLearningObjectiveInput = {
    create?: XOR<PerformanceMetricCreateWithoutLearningObjectiveInput, PerformanceMetricUncheckedCreateWithoutLearningObjectiveInput> | PerformanceMetricCreateWithoutLearningObjectiveInput[] | PerformanceMetricUncheckedCreateWithoutLearningObjectiveInput[]
    connectOrCreate?: PerformanceMetricCreateOrConnectWithoutLearningObjectiveInput | PerformanceMetricCreateOrConnectWithoutLearningObjectiveInput[]
    createMany?: PerformanceMetricCreateManyLearningObjectiveInputEnvelope
    connect?: PerformanceMetricWhereUniqueInput | PerformanceMetricWhereUniqueInput[]
  }

  export type PriorityFeedbackCreateNestedManyWithoutLearningObjectiveInput = {
    create?: XOR<PriorityFeedbackCreateWithoutLearningObjectiveInput, PriorityFeedbackUncheckedCreateWithoutLearningObjectiveInput> | PriorityFeedbackCreateWithoutLearningObjectiveInput[] | PriorityFeedbackUncheckedCreateWithoutLearningObjectiveInput[]
    connectOrCreate?: PriorityFeedbackCreateOrConnectWithoutLearningObjectiveInput | PriorityFeedbackCreateOrConnectWithoutLearningObjectiveInput[]
    createMany?: PriorityFeedbackCreateManyLearningObjectiveInputEnvelope
    connect?: PriorityFeedbackWhereUniqueInput | PriorityFeedbackWhereUniqueInput[]
  }

  export type StrugglePredictionCreateNestedManyWithoutLearningObjectiveInput = {
    create?: XOR<StrugglePredictionCreateWithoutLearningObjectiveInput, StrugglePredictionUncheckedCreateWithoutLearningObjectiveInput> | StrugglePredictionCreateWithoutLearningObjectiveInput[] | StrugglePredictionUncheckedCreateWithoutLearningObjectiveInput[]
    connectOrCreate?: StrugglePredictionCreateOrConnectWithoutLearningObjectiveInput | StrugglePredictionCreateOrConnectWithoutLearningObjectiveInput[]
    createMany?: StrugglePredictionCreateManyLearningObjectiveInputEnvelope
    connect?: StrugglePredictionWhereUniqueInput | StrugglePredictionWhereUniqueInput[]
  }

  export type StruggleIndicatorCreateNestedManyWithoutLearningObjectiveInput = {
    create?: XOR<StruggleIndicatorCreateWithoutLearningObjectiveInput, StruggleIndicatorUncheckedCreateWithoutLearningObjectiveInput> | StruggleIndicatorCreateWithoutLearningObjectiveInput[] | StruggleIndicatorUncheckedCreateWithoutLearningObjectiveInput[]
    connectOrCreate?: StruggleIndicatorCreateOrConnectWithoutLearningObjectiveInput | StruggleIndicatorCreateOrConnectWithoutLearningObjectiveInput[]
    createMany?: StruggleIndicatorCreateManyLearningObjectiveInputEnvelope
    connect?: StruggleIndicatorWhereUniqueInput | StruggleIndicatorWhereUniqueInput[]
  }

  export type CardUncheckedCreateNestedManyWithoutObjectiveInput = {
    create?: XOR<CardCreateWithoutObjectiveInput, CardUncheckedCreateWithoutObjectiveInput> | CardCreateWithoutObjectiveInput[] | CardUncheckedCreateWithoutObjectiveInput[]
    connectOrCreate?: CardCreateOrConnectWithoutObjectiveInput | CardCreateOrConnectWithoutObjectiveInput[]
    createMany?: CardCreateManyObjectiveInputEnvelope
    connect?: CardWhereUniqueInput | CardWhereUniqueInput[]
  }

  export type ObjectivePrerequisiteUncheckedCreateNestedManyWithoutObjectiveInput = {
    create?: XOR<ObjectivePrerequisiteCreateWithoutObjectiveInput, ObjectivePrerequisiteUncheckedCreateWithoutObjectiveInput> | ObjectivePrerequisiteCreateWithoutObjectiveInput[] | ObjectivePrerequisiteUncheckedCreateWithoutObjectiveInput[]
    connectOrCreate?: ObjectivePrerequisiteCreateOrConnectWithoutObjectiveInput | ObjectivePrerequisiteCreateOrConnectWithoutObjectiveInput[]
    createMany?: ObjectivePrerequisiteCreateManyObjectiveInputEnvelope
    connect?: ObjectivePrerequisiteWhereUniqueInput | ObjectivePrerequisiteWhereUniqueInput[]
  }

  export type ObjectivePrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput = {
    create?: XOR<ObjectivePrerequisiteCreateWithoutPrerequisiteInput, ObjectivePrerequisiteUncheckedCreateWithoutPrerequisiteInput> | ObjectivePrerequisiteCreateWithoutPrerequisiteInput[] | ObjectivePrerequisiteUncheckedCreateWithoutPrerequisiteInput[]
    connectOrCreate?: ObjectivePrerequisiteCreateOrConnectWithoutPrerequisiteInput | ObjectivePrerequisiteCreateOrConnectWithoutPrerequisiteInput[]
    createMany?: ObjectivePrerequisiteCreateManyPrerequisiteInputEnvelope
    connect?: ObjectivePrerequisiteWhereUniqueInput | ObjectivePrerequisiteWhereUniqueInput[]
  }

  export type PerformanceMetricUncheckedCreateNestedManyWithoutLearningObjectiveInput = {
    create?: XOR<PerformanceMetricCreateWithoutLearningObjectiveInput, PerformanceMetricUncheckedCreateWithoutLearningObjectiveInput> | PerformanceMetricCreateWithoutLearningObjectiveInput[] | PerformanceMetricUncheckedCreateWithoutLearningObjectiveInput[]
    connectOrCreate?: PerformanceMetricCreateOrConnectWithoutLearningObjectiveInput | PerformanceMetricCreateOrConnectWithoutLearningObjectiveInput[]
    createMany?: PerformanceMetricCreateManyLearningObjectiveInputEnvelope
    connect?: PerformanceMetricWhereUniqueInput | PerformanceMetricWhereUniqueInput[]
  }

  export type PriorityFeedbackUncheckedCreateNestedManyWithoutLearningObjectiveInput = {
    create?: XOR<PriorityFeedbackCreateWithoutLearningObjectiveInput, PriorityFeedbackUncheckedCreateWithoutLearningObjectiveInput> | PriorityFeedbackCreateWithoutLearningObjectiveInput[] | PriorityFeedbackUncheckedCreateWithoutLearningObjectiveInput[]
    connectOrCreate?: PriorityFeedbackCreateOrConnectWithoutLearningObjectiveInput | PriorityFeedbackCreateOrConnectWithoutLearningObjectiveInput[]
    createMany?: PriorityFeedbackCreateManyLearningObjectiveInputEnvelope
    connect?: PriorityFeedbackWhereUniqueInput | PriorityFeedbackWhereUniqueInput[]
  }

  export type StrugglePredictionUncheckedCreateNestedManyWithoutLearningObjectiveInput = {
    create?: XOR<StrugglePredictionCreateWithoutLearningObjectiveInput, StrugglePredictionUncheckedCreateWithoutLearningObjectiveInput> | StrugglePredictionCreateWithoutLearningObjectiveInput[] | StrugglePredictionUncheckedCreateWithoutLearningObjectiveInput[]
    connectOrCreate?: StrugglePredictionCreateOrConnectWithoutLearningObjectiveInput | StrugglePredictionCreateOrConnectWithoutLearningObjectiveInput[]
    createMany?: StrugglePredictionCreateManyLearningObjectiveInputEnvelope
    connect?: StrugglePredictionWhereUniqueInput | StrugglePredictionWhereUniqueInput[]
  }

  export type StruggleIndicatorUncheckedCreateNestedManyWithoutLearningObjectiveInput = {
    create?: XOR<StruggleIndicatorCreateWithoutLearningObjectiveInput, StruggleIndicatorUncheckedCreateWithoutLearningObjectiveInput> | StruggleIndicatorCreateWithoutLearningObjectiveInput[] | StruggleIndicatorUncheckedCreateWithoutLearningObjectiveInput[]
    connectOrCreate?: StruggleIndicatorCreateOrConnectWithoutLearningObjectiveInput | StruggleIndicatorCreateOrConnectWithoutLearningObjectiveInput[]
    createMany?: StruggleIndicatorCreateManyLearningObjectiveInputEnvelope
    connect?: StruggleIndicatorWhereUniqueInput | StruggleIndicatorWhereUniqueInput[]
  }

  export type EnumObjectiveComplexityFieldUpdateOperationsInput = {
    set?: $Enums.ObjectiveComplexity
  }

  export type LearningObjectiveUpdateboardExamTagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumMasteryLevelFieldUpdateOperationsInput = {
    set?: $Enums.MasteryLevel
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LectureUpdateOneRequiredWithoutLearningObjectivesNestedInput = {
    create?: XOR<LectureCreateWithoutLearningObjectivesInput, LectureUncheckedCreateWithoutLearningObjectivesInput>
    connectOrCreate?: LectureCreateOrConnectWithoutLearningObjectivesInput
    upsert?: LectureUpsertWithoutLearningObjectivesInput
    connect?: LectureWhereUniqueInput
    update?: XOR<XOR<LectureUpdateToOneWithWhereWithoutLearningObjectivesInput, LectureUpdateWithoutLearningObjectivesInput>, LectureUncheckedUpdateWithoutLearningObjectivesInput>
  }

  export type CardUpdateManyWithoutObjectiveNestedInput = {
    create?: XOR<CardCreateWithoutObjectiveInput, CardUncheckedCreateWithoutObjectiveInput> | CardCreateWithoutObjectiveInput[] | CardUncheckedCreateWithoutObjectiveInput[]
    connectOrCreate?: CardCreateOrConnectWithoutObjectiveInput | CardCreateOrConnectWithoutObjectiveInput[]
    upsert?: CardUpsertWithWhereUniqueWithoutObjectiveInput | CardUpsertWithWhereUniqueWithoutObjectiveInput[]
    createMany?: CardCreateManyObjectiveInputEnvelope
    set?: CardWhereUniqueInput | CardWhereUniqueInput[]
    disconnect?: CardWhereUniqueInput | CardWhereUniqueInput[]
    delete?: CardWhereUniqueInput | CardWhereUniqueInput[]
    connect?: CardWhereUniqueInput | CardWhereUniqueInput[]
    update?: CardUpdateWithWhereUniqueWithoutObjectiveInput | CardUpdateWithWhereUniqueWithoutObjectiveInput[]
    updateMany?: CardUpdateManyWithWhereWithoutObjectiveInput | CardUpdateManyWithWhereWithoutObjectiveInput[]
    deleteMany?: CardScalarWhereInput | CardScalarWhereInput[]
  }

  export type ObjectivePrerequisiteUpdateManyWithoutObjectiveNestedInput = {
    create?: XOR<ObjectivePrerequisiteCreateWithoutObjectiveInput, ObjectivePrerequisiteUncheckedCreateWithoutObjectiveInput> | ObjectivePrerequisiteCreateWithoutObjectiveInput[] | ObjectivePrerequisiteUncheckedCreateWithoutObjectiveInput[]
    connectOrCreate?: ObjectivePrerequisiteCreateOrConnectWithoutObjectiveInput | ObjectivePrerequisiteCreateOrConnectWithoutObjectiveInput[]
    upsert?: ObjectivePrerequisiteUpsertWithWhereUniqueWithoutObjectiveInput | ObjectivePrerequisiteUpsertWithWhereUniqueWithoutObjectiveInput[]
    createMany?: ObjectivePrerequisiteCreateManyObjectiveInputEnvelope
    set?: ObjectivePrerequisiteWhereUniqueInput | ObjectivePrerequisiteWhereUniqueInput[]
    disconnect?: ObjectivePrerequisiteWhereUniqueInput | ObjectivePrerequisiteWhereUniqueInput[]
    delete?: ObjectivePrerequisiteWhereUniqueInput | ObjectivePrerequisiteWhereUniqueInput[]
    connect?: ObjectivePrerequisiteWhereUniqueInput | ObjectivePrerequisiteWhereUniqueInput[]
    update?: ObjectivePrerequisiteUpdateWithWhereUniqueWithoutObjectiveInput | ObjectivePrerequisiteUpdateWithWhereUniqueWithoutObjectiveInput[]
    updateMany?: ObjectivePrerequisiteUpdateManyWithWhereWithoutObjectiveInput | ObjectivePrerequisiteUpdateManyWithWhereWithoutObjectiveInput[]
    deleteMany?: ObjectivePrerequisiteScalarWhereInput | ObjectivePrerequisiteScalarWhereInput[]
  }

  export type ObjectivePrerequisiteUpdateManyWithoutPrerequisiteNestedInput = {
    create?: XOR<ObjectivePrerequisiteCreateWithoutPrerequisiteInput, ObjectivePrerequisiteUncheckedCreateWithoutPrerequisiteInput> | ObjectivePrerequisiteCreateWithoutPrerequisiteInput[] | ObjectivePrerequisiteUncheckedCreateWithoutPrerequisiteInput[]
    connectOrCreate?: ObjectivePrerequisiteCreateOrConnectWithoutPrerequisiteInput | ObjectivePrerequisiteCreateOrConnectWithoutPrerequisiteInput[]
    upsert?: ObjectivePrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput | ObjectivePrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput[]
    createMany?: ObjectivePrerequisiteCreateManyPrerequisiteInputEnvelope
    set?: ObjectivePrerequisiteWhereUniqueInput | ObjectivePrerequisiteWhereUniqueInput[]
    disconnect?: ObjectivePrerequisiteWhereUniqueInput | ObjectivePrerequisiteWhereUniqueInput[]
    delete?: ObjectivePrerequisiteWhereUniqueInput | ObjectivePrerequisiteWhereUniqueInput[]
    connect?: ObjectivePrerequisiteWhereUniqueInput | ObjectivePrerequisiteWhereUniqueInput[]
    update?: ObjectivePrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput | ObjectivePrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput[]
    updateMany?: ObjectivePrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput | ObjectivePrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput[]
    deleteMany?: ObjectivePrerequisiteScalarWhereInput | ObjectivePrerequisiteScalarWhereInput[]
  }

  export type PerformanceMetricUpdateManyWithoutLearningObjectiveNestedInput = {
    create?: XOR<PerformanceMetricCreateWithoutLearningObjectiveInput, PerformanceMetricUncheckedCreateWithoutLearningObjectiveInput> | PerformanceMetricCreateWithoutLearningObjectiveInput[] | PerformanceMetricUncheckedCreateWithoutLearningObjectiveInput[]
    connectOrCreate?: PerformanceMetricCreateOrConnectWithoutLearningObjectiveInput | PerformanceMetricCreateOrConnectWithoutLearningObjectiveInput[]
    upsert?: PerformanceMetricUpsertWithWhereUniqueWithoutLearningObjectiveInput | PerformanceMetricUpsertWithWhereUniqueWithoutLearningObjectiveInput[]
    createMany?: PerformanceMetricCreateManyLearningObjectiveInputEnvelope
    set?: PerformanceMetricWhereUniqueInput | PerformanceMetricWhereUniqueInput[]
    disconnect?: PerformanceMetricWhereUniqueInput | PerformanceMetricWhereUniqueInput[]
    delete?: PerformanceMetricWhereUniqueInput | PerformanceMetricWhereUniqueInput[]
    connect?: PerformanceMetricWhereUniqueInput | PerformanceMetricWhereUniqueInput[]
    update?: PerformanceMetricUpdateWithWhereUniqueWithoutLearningObjectiveInput | PerformanceMetricUpdateWithWhereUniqueWithoutLearningObjectiveInput[]
    updateMany?: PerformanceMetricUpdateManyWithWhereWithoutLearningObjectiveInput | PerformanceMetricUpdateManyWithWhereWithoutLearningObjectiveInput[]
    deleteMany?: PerformanceMetricScalarWhereInput | PerformanceMetricScalarWhereInput[]
  }

  export type PriorityFeedbackUpdateManyWithoutLearningObjectiveNestedInput = {
    create?: XOR<PriorityFeedbackCreateWithoutLearningObjectiveInput, PriorityFeedbackUncheckedCreateWithoutLearningObjectiveInput> | PriorityFeedbackCreateWithoutLearningObjectiveInput[] | PriorityFeedbackUncheckedCreateWithoutLearningObjectiveInput[]
    connectOrCreate?: PriorityFeedbackCreateOrConnectWithoutLearningObjectiveInput | PriorityFeedbackCreateOrConnectWithoutLearningObjectiveInput[]
    upsert?: PriorityFeedbackUpsertWithWhereUniqueWithoutLearningObjectiveInput | PriorityFeedbackUpsertWithWhereUniqueWithoutLearningObjectiveInput[]
    createMany?: PriorityFeedbackCreateManyLearningObjectiveInputEnvelope
    set?: PriorityFeedbackWhereUniqueInput | PriorityFeedbackWhereUniqueInput[]
    disconnect?: PriorityFeedbackWhereUniqueInput | PriorityFeedbackWhereUniqueInput[]
    delete?: PriorityFeedbackWhereUniqueInput | PriorityFeedbackWhereUniqueInput[]
    connect?: PriorityFeedbackWhereUniqueInput | PriorityFeedbackWhereUniqueInput[]
    update?: PriorityFeedbackUpdateWithWhereUniqueWithoutLearningObjectiveInput | PriorityFeedbackUpdateWithWhereUniqueWithoutLearningObjectiveInput[]
    updateMany?: PriorityFeedbackUpdateManyWithWhereWithoutLearningObjectiveInput | PriorityFeedbackUpdateManyWithWhereWithoutLearningObjectiveInput[]
    deleteMany?: PriorityFeedbackScalarWhereInput | PriorityFeedbackScalarWhereInput[]
  }

  export type StrugglePredictionUpdateManyWithoutLearningObjectiveNestedInput = {
    create?: XOR<StrugglePredictionCreateWithoutLearningObjectiveInput, StrugglePredictionUncheckedCreateWithoutLearningObjectiveInput> | StrugglePredictionCreateWithoutLearningObjectiveInput[] | StrugglePredictionUncheckedCreateWithoutLearningObjectiveInput[]
    connectOrCreate?: StrugglePredictionCreateOrConnectWithoutLearningObjectiveInput | StrugglePredictionCreateOrConnectWithoutLearningObjectiveInput[]
    upsert?: StrugglePredictionUpsertWithWhereUniqueWithoutLearningObjectiveInput | StrugglePredictionUpsertWithWhereUniqueWithoutLearningObjectiveInput[]
    createMany?: StrugglePredictionCreateManyLearningObjectiveInputEnvelope
    set?: StrugglePredictionWhereUniqueInput | StrugglePredictionWhereUniqueInput[]
    disconnect?: StrugglePredictionWhereUniqueInput | StrugglePredictionWhereUniqueInput[]
    delete?: StrugglePredictionWhereUniqueInput | StrugglePredictionWhereUniqueInput[]
    connect?: StrugglePredictionWhereUniqueInput | StrugglePredictionWhereUniqueInput[]
    update?: StrugglePredictionUpdateWithWhereUniqueWithoutLearningObjectiveInput | StrugglePredictionUpdateWithWhereUniqueWithoutLearningObjectiveInput[]
    updateMany?: StrugglePredictionUpdateManyWithWhereWithoutLearningObjectiveInput | StrugglePredictionUpdateManyWithWhereWithoutLearningObjectiveInput[]
    deleteMany?: StrugglePredictionScalarWhereInput | StrugglePredictionScalarWhereInput[]
  }

  export type StruggleIndicatorUpdateManyWithoutLearningObjectiveNestedInput = {
    create?: XOR<StruggleIndicatorCreateWithoutLearningObjectiveInput, StruggleIndicatorUncheckedCreateWithoutLearningObjectiveInput> | StruggleIndicatorCreateWithoutLearningObjectiveInput[] | StruggleIndicatorUncheckedCreateWithoutLearningObjectiveInput[]
    connectOrCreate?: StruggleIndicatorCreateOrConnectWithoutLearningObjectiveInput | StruggleIndicatorCreateOrConnectWithoutLearningObjectiveInput[]
    upsert?: StruggleIndicatorUpsertWithWhereUniqueWithoutLearningObjectiveInput | StruggleIndicatorUpsertWithWhereUniqueWithoutLearningObjectiveInput[]
    createMany?: StruggleIndicatorCreateManyLearningObjectiveInputEnvelope
    set?: StruggleIndicatorWhereUniqueInput | StruggleIndicatorWhereUniqueInput[]
    disconnect?: StruggleIndicatorWhereUniqueInput | StruggleIndicatorWhereUniqueInput[]
    delete?: StruggleIndicatorWhereUniqueInput | StruggleIndicatorWhereUniqueInput[]
    connect?: StruggleIndicatorWhereUniqueInput | StruggleIndicatorWhereUniqueInput[]
    update?: StruggleIndicatorUpdateWithWhereUniqueWithoutLearningObjectiveInput | StruggleIndicatorUpdateWithWhereUniqueWithoutLearningObjectiveInput[]
    updateMany?: StruggleIndicatorUpdateManyWithWhereWithoutLearningObjectiveInput | StruggleIndicatorUpdateManyWithWhereWithoutLearningObjectiveInput[]
    deleteMany?: StruggleIndicatorScalarWhereInput | StruggleIndicatorScalarWhereInput[]
  }

  export type CardUncheckedUpdateManyWithoutObjectiveNestedInput = {
    create?: XOR<CardCreateWithoutObjectiveInput, CardUncheckedCreateWithoutObjectiveInput> | CardCreateWithoutObjectiveInput[] | CardUncheckedCreateWithoutObjectiveInput[]
    connectOrCreate?: CardCreateOrConnectWithoutObjectiveInput | CardCreateOrConnectWithoutObjectiveInput[]
    upsert?: CardUpsertWithWhereUniqueWithoutObjectiveInput | CardUpsertWithWhereUniqueWithoutObjectiveInput[]
    createMany?: CardCreateManyObjectiveInputEnvelope
    set?: CardWhereUniqueInput | CardWhereUniqueInput[]
    disconnect?: CardWhereUniqueInput | CardWhereUniqueInput[]
    delete?: CardWhereUniqueInput | CardWhereUniqueInput[]
    connect?: CardWhereUniqueInput | CardWhereUniqueInput[]
    update?: CardUpdateWithWhereUniqueWithoutObjectiveInput | CardUpdateWithWhereUniqueWithoutObjectiveInput[]
    updateMany?: CardUpdateManyWithWhereWithoutObjectiveInput | CardUpdateManyWithWhereWithoutObjectiveInput[]
    deleteMany?: CardScalarWhereInput | CardScalarWhereInput[]
  }

  export type ObjectivePrerequisiteUncheckedUpdateManyWithoutObjectiveNestedInput = {
    create?: XOR<ObjectivePrerequisiteCreateWithoutObjectiveInput, ObjectivePrerequisiteUncheckedCreateWithoutObjectiveInput> | ObjectivePrerequisiteCreateWithoutObjectiveInput[] | ObjectivePrerequisiteUncheckedCreateWithoutObjectiveInput[]
    connectOrCreate?: ObjectivePrerequisiteCreateOrConnectWithoutObjectiveInput | ObjectivePrerequisiteCreateOrConnectWithoutObjectiveInput[]
    upsert?: ObjectivePrerequisiteUpsertWithWhereUniqueWithoutObjectiveInput | ObjectivePrerequisiteUpsertWithWhereUniqueWithoutObjectiveInput[]
    createMany?: ObjectivePrerequisiteCreateManyObjectiveInputEnvelope
    set?: ObjectivePrerequisiteWhereUniqueInput | ObjectivePrerequisiteWhereUniqueInput[]
    disconnect?: ObjectivePrerequisiteWhereUniqueInput | ObjectivePrerequisiteWhereUniqueInput[]
    delete?: ObjectivePrerequisiteWhereUniqueInput | ObjectivePrerequisiteWhereUniqueInput[]
    connect?: ObjectivePrerequisiteWhereUniqueInput | ObjectivePrerequisiteWhereUniqueInput[]
    update?: ObjectivePrerequisiteUpdateWithWhereUniqueWithoutObjectiveInput | ObjectivePrerequisiteUpdateWithWhereUniqueWithoutObjectiveInput[]
    updateMany?: ObjectivePrerequisiteUpdateManyWithWhereWithoutObjectiveInput | ObjectivePrerequisiteUpdateManyWithWhereWithoutObjectiveInput[]
    deleteMany?: ObjectivePrerequisiteScalarWhereInput | ObjectivePrerequisiteScalarWhereInput[]
  }

  export type ObjectivePrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput = {
    create?: XOR<ObjectivePrerequisiteCreateWithoutPrerequisiteInput, ObjectivePrerequisiteUncheckedCreateWithoutPrerequisiteInput> | ObjectivePrerequisiteCreateWithoutPrerequisiteInput[] | ObjectivePrerequisiteUncheckedCreateWithoutPrerequisiteInput[]
    connectOrCreate?: ObjectivePrerequisiteCreateOrConnectWithoutPrerequisiteInput | ObjectivePrerequisiteCreateOrConnectWithoutPrerequisiteInput[]
    upsert?: ObjectivePrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput | ObjectivePrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput[]
    createMany?: ObjectivePrerequisiteCreateManyPrerequisiteInputEnvelope
    set?: ObjectivePrerequisiteWhereUniqueInput | ObjectivePrerequisiteWhereUniqueInput[]
    disconnect?: ObjectivePrerequisiteWhereUniqueInput | ObjectivePrerequisiteWhereUniqueInput[]
    delete?: ObjectivePrerequisiteWhereUniqueInput | ObjectivePrerequisiteWhereUniqueInput[]
    connect?: ObjectivePrerequisiteWhereUniqueInput | ObjectivePrerequisiteWhereUniqueInput[]
    update?: ObjectivePrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput | ObjectivePrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput[]
    updateMany?: ObjectivePrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput | ObjectivePrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput[]
    deleteMany?: ObjectivePrerequisiteScalarWhereInput | ObjectivePrerequisiteScalarWhereInput[]
  }

  export type PerformanceMetricUncheckedUpdateManyWithoutLearningObjectiveNestedInput = {
    create?: XOR<PerformanceMetricCreateWithoutLearningObjectiveInput, PerformanceMetricUncheckedCreateWithoutLearningObjectiveInput> | PerformanceMetricCreateWithoutLearningObjectiveInput[] | PerformanceMetricUncheckedCreateWithoutLearningObjectiveInput[]
    connectOrCreate?: PerformanceMetricCreateOrConnectWithoutLearningObjectiveInput | PerformanceMetricCreateOrConnectWithoutLearningObjectiveInput[]
    upsert?: PerformanceMetricUpsertWithWhereUniqueWithoutLearningObjectiveInput | PerformanceMetricUpsertWithWhereUniqueWithoutLearningObjectiveInput[]
    createMany?: PerformanceMetricCreateManyLearningObjectiveInputEnvelope
    set?: PerformanceMetricWhereUniqueInput | PerformanceMetricWhereUniqueInput[]
    disconnect?: PerformanceMetricWhereUniqueInput | PerformanceMetricWhereUniqueInput[]
    delete?: PerformanceMetricWhereUniqueInput | PerformanceMetricWhereUniqueInput[]
    connect?: PerformanceMetricWhereUniqueInput | PerformanceMetricWhereUniqueInput[]
    update?: PerformanceMetricUpdateWithWhereUniqueWithoutLearningObjectiveInput | PerformanceMetricUpdateWithWhereUniqueWithoutLearningObjectiveInput[]
    updateMany?: PerformanceMetricUpdateManyWithWhereWithoutLearningObjectiveInput | PerformanceMetricUpdateManyWithWhereWithoutLearningObjectiveInput[]
    deleteMany?: PerformanceMetricScalarWhereInput | PerformanceMetricScalarWhereInput[]
  }

  export type PriorityFeedbackUncheckedUpdateManyWithoutLearningObjectiveNestedInput = {
    create?: XOR<PriorityFeedbackCreateWithoutLearningObjectiveInput, PriorityFeedbackUncheckedCreateWithoutLearningObjectiveInput> | PriorityFeedbackCreateWithoutLearningObjectiveInput[] | PriorityFeedbackUncheckedCreateWithoutLearningObjectiveInput[]
    connectOrCreate?: PriorityFeedbackCreateOrConnectWithoutLearningObjectiveInput | PriorityFeedbackCreateOrConnectWithoutLearningObjectiveInput[]
    upsert?: PriorityFeedbackUpsertWithWhereUniqueWithoutLearningObjectiveInput | PriorityFeedbackUpsertWithWhereUniqueWithoutLearningObjectiveInput[]
    createMany?: PriorityFeedbackCreateManyLearningObjectiveInputEnvelope
    set?: PriorityFeedbackWhereUniqueInput | PriorityFeedbackWhereUniqueInput[]
    disconnect?: PriorityFeedbackWhereUniqueInput | PriorityFeedbackWhereUniqueInput[]
    delete?: PriorityFeedbackWhereUniqueInput | PriorityFeedbackWhereUniqueInput[]
    connect?: PriorityFeedbackWhereUniqueInput | PriorityFeedbackWhereUniqueInput[]
    update?: PriorityFeedbackUpdateWithWhereUniqueWithoutLearningObjectiveInput | PriorityFeedbackUpdateWithWhereUniqueWithoutLearningObjectiveInput[]
    updateMany?: PriorityFeedbackUpdateManyWithWhereWithoutLearningObjectiveInput | PriorityFeedbackUpdateManyWithWhereWithoutLearningObjectiveInput[]
    deleteMany?: PriorityFeedbackScalarWhereInput | PriorityFeedbackScalarWhereInput[]
  }

  export type StrugglePredictionUncheckedUpdateManyWithoutLearningObjectiveNestedInput = {
    create?: XOR<StrugglePredictionCreateWithoutLearningObjectiveInput, StrugglePredictionUncheckedCreateWithoutLearningObjectiveInput> | StrugglePredictionCreateWithoutLearningObjectiveInput[] | StrugglePredictionUncheckedCreateWithoutLearningObjectiveInput[]
    connectOrCreate?: StrugglePredictionCreateOrConnectWithoutLearningObjectiveInput | StrugglePredictionCreateOrConnectWithoutLearningObjectiveInput[]
    upsert?: StrugglePredictionUpsertWithWhereUniqueWithoutLearningObjectiveInput | StrugglePredictionUpsertWithWhereUniqueWithoutLearningObjectiveInput[]
    createMany?: StrugglePredictionCreateManyLearningObjectiveInputEnvelope
    set?: StrugglePredictionWhereUniqueInput | StrugglePredictionWhereUniqueInput[]
    disconnect?: StrugglePredictionWhereUniqueInput | StrugglePredictionWhereUniqueInput[]
    delete?: StrugglePredictionWhereUniqueInput | StrugglePredictionWhereUniqueInput[]
    connect?: StrugglePredictionWhereUniqueInput | StrugglePredictionWhereUniqueInput[]
    update?: StrugglePredictionUpdateWithWhereUniqueWithoutLearningObjectiveInput | StrugglePredictionUpdateWithWhereUniqueWithoutLearningObjectiveInput[]
    updateMany?: StrugglePredictionUpdateManyWithWhereWithoutLearningObjectiveInput | StrugglePredictionUpdateManyWithWhereWithoutLearningObjectiveInput[]
    deleteMany?: StrugglePredictionScalarWhereInput | StrugglePredictionScalarWhereInput[]
  }

  export type StruggleIndicatorUncheckedUpdateManyWithoutLearningObjectiveNestedInput = {
    create?: XOR<StruggleIndicatorCreateWithoutLearningObjectiveInput, StruggleIndicatorUncheckedCreateWithoutLearningObjectiveInput> | StruggleIndicatorCreateWithoutLearningObjectiveInput[] | StruggleIndicatorUncheckedCreateWithoutLearningObjectiveInput[]
    connectOrCreate?: StruggleIndicatorCreateOrConnectWithoutLearningObjectiveInput | StruggleIndicatorCreateOrConnectWithoutLearningObjectiveInput[]
    upsert?: StruggleIndicatorUpsertWithWhereUniqueWithoutLearningObjectiveInput | StruggleIndicatorUpsertWithWhereUniqueWithoutLearningObjectiveInput[]
    createMany?: StruggleIndicatorCreateManyLearningObjectiveInputEnvelope
    set?: StruggleIndicatorWhereUniqueInput | StruggleIndicatorWhereUniqueInput[]
    disconnect?: StruggleIndicatorWhereUniqueInput | StruggleIndicatorWhereUniqueInput[]
    delete?: StruggleIndicatorWhereUniqueInput | StruggleIndicatorWhereUniqueInput[]
    connect?: StruggleIndicatorWhereUniqueInput | StruggleIndicatorWhereUniqueInput[]
    update?: StruggleIndicatorUpdateWithWhereUniqueWithoutLearningObjectiveInput | StruggleIndicatorUpdateWithWhereUniqueWithoutLearningObjectiveInput[]
    updateMany?: StruggleIndicatorUpdateManyWithWhereWithoutLearningObjectiveInput | StruggleIndicatorUpdateManyWithWhereWithoutLearningObjectiveInput[]
    deleteMany?: StruggleIndicatorScalarWhereInput | StruggleIndicatorScalarWhereInput[]
  }

  export type LearningObjectiveCreateNestedOneWithoutPrerequisitesInput = {
    create?: XOR<LearningObjectiveCreateWithoutPrerequisitesInput, LearningObjectiveUncheckedCreateWithoutPrerequisitesInput>
    connectOrCreate?: LearningObjectiveCreateOrConnectWithoutPrerequisitesInput
    connect?: LearningObjectiveWhereUniqueInput
  }

  export type LearningObjectiveCreateNestedOneWithoutDependentsInput = {
    create?: XOR<LearningObjectiveCreateWithoutDependentsInput, LearningObjectiveUncheckedCreateWithoutDependentsInput>
    connectOrCreate?: LearningObjectiveCreateOrConnectWithoutDependentsInput
    connect?: LearningObjectiveWhereUniqueInput
  }

  export type LearningObjectiveUpdateOneRequiredWithoutPrerequisitesNestedInput = {
    create?: XOR<LearningObjectiveCreateWithoutPrerequisitesInput, LearningObjectiveUncheckedCreateWithoutPrerequisitesInput>
    connectOrCreate?: LearningObjectiveCreateOrConnectWithoutPrerequisitesInput
    upsert?: LearningObjectiveUpsertWithoutPrerequisitesInput
    connect?: LearningObjectiveWhereUniqueInput
    update?: XOR<XOR<LearningObjectiveUpdateToOneWithWhereWithoutPrerequisitesInput, LearningObjectiveUpdateWithoutPrerequisitesInput>, LearningObjectiveUncheckedUpdateWithoutPrerequisitesInput>
  }

  export type LearningObjectiveUpdateOneRequiredWithoutDependentsNestedInput = {
    create?: XOR<LearningObjectiveCreateWithoutDependentsInput, LearningObjectiveUncheckedCreateWithoutDependentsInput>
    connectOrCreate?: LearningObjectiveCreateOrConnectWithoutDependentsInput
    upsert?: LearningObjectiveUpsertWithoutDependentsInput
    connect?: LearningObjectiveWhereUniqueInput
    update?: XOR<XOR<LearningObjectiveUpdateToOneWithWhereWithoutDependentsInput, LearningObjectiveUpdateWithoutDependentsInput>, LearningObjectiveUncheckedUpdateWithoutDependentsInput>
  }

  export type UserCreateNestedOneWithoutMissionsInput = {
    create?: XOR<UserCreateWithoutMissionsInput, UserUncheckedCreateWithoutMissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMissionsInput
    connect?: UserWhereUniqueInput
  }

  export type StudySessionCreateNestedManyWithoutMissionInput = {
    create?: XOR<StudySessionCreateWithoutMissionInput, StudySessionUncheckedCreateWithoutMissionInput> | StudySessionCreateWithoutMissionInput[] | StudySessionUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: StudySessionCreateOrConnectWithoutMissionInput | StudySessionCreateOrConnectWithoutMissionInput[]
    createMany?: StudySessionCreateManyMissionInputEnvelope
    connect?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
  }

  export type MissionFeedbackCreateNestedManyWithoutMissionInput = {
    create?: XOR<MissionFeedbackCreateWithoutMissionInput, MissionFeedbackUncheckedCreateWithoutMissionInput> | MissionFeedbackCreateWithoutMissionInput[] | MissionFeedbackUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: MissionFeedbackCreateOrConnectWithoutMissionInput | MissionFeedbackCreateOrConnectWithoutMissionInput[]
    createMany?: MissionFeedbackCreateManyMissionInputEnvelope
    connect?: MissionFeedbackWhereUniqueInput | MissionFeedbackWhereUniqueInput[]
  }

  export type InterventionRecommendationCreateNestedManyWithoutMissionInput = {
    create?: XOR<InterventionRecommendationCreateWithoutMissionInput, InterventionRecommendationUncheckedCreateWithoutMissionInput> | InterventionRecommendationCreateWithoutMissionInput[] | InterventionRecommendationUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: InterventionRecommendationCreateOrConnectWithoutMissionInput | InterventionRecommendationCreateOrConnectWithoutMissionInput[]
    createMany?: InterventionRecommendationCreateManyMissionInputEnvelope
    connect?: InterventionRecommendationWhereUniqueInput | InterventionRecommendationWhereUniqueInput[]
  }

  export type StudySessionUncheckedCreateNestedManyWithoutMissionInput = {
    create?: XOR<StudySessionCreateWithoutMissionInput, StudySessionUncheckedCreateWithoutMissionInput> | StudySessionCreateWithoutMissionInput[] | StudySessionUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: StudySessionCreateOrConnectWithoutMissionInput | StudySessionCreateOrConnectWithoutMissionInput[]
    createMany?: StudySessionCreateManyMissionInputEnvelope
    connect?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
  }

  export type MissionFeedbackUncheckedCreateNestedManyWithoutMissionInput = {
    create?: XOR<MissionFeedbackCreateWithoutMissionInput, MissionFeedbackUncheckedCreateWithoutMissionInput> | MissionFeedbackCreateWithoutMissionInput[] | MissionFeedbackUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: MissionFeedbackCreateOrConnectWithoutMissionInput | MissionFeedbackCreateOrConnectWithoutMissionInput[]
    createMany?: MissionFeedbackCreateManyMissionInputEnvelope
    connect?: MissionFeedbackWhereUniqueInput | MissionFeedbackWhereUniqueInput[]
  }

  export type InterventionRecommendationUncheckedCreateNestedManyWithoutMissionInput = {
    create?: XOR<InterventionRecommendationCreateWithoutMissionInput, InterventionRecommendationUncheckedCreateWithoutMissionInput> | InterventionRecommendationCreateWithoutMissionInput[] | InterventionRecommendationUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: InterventionRecommendationCreateOrConnectWithoutMissionInput | InterventionRecommendationCreateOrConnectWithoutMissionInput[]
    createMany?: InterventionRecommendationCreateManyMissionInputEnvelope
    connect?: InterventionRecommendationWhereUniqueInput | InterventionRecommendationWhereUniqueInput[]
  }

  export type EnumMissionStatusFieldUpdateOperationsInput = {
    set?: $Enums.MissionStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutMissionsNestedInput = {
    create?: XOR<UserCreateWithoutMissionsInput, UserUncheckedCreateWithoutMissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMissionsInput
    upsert?: UserUpsertWithoutMissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMissionsInput, UserUpdateWithoutMissionsInput>, UserUncheckedUpdateWithoutMissionsInput>
  }

  export type StudySessionUpdateManyWithoutMissionNestedInput = {
    create?: XOR<StudySessionCreateWithoutMissionInput, StudySessionUncheckedCreateWithoutMissionInput> | StudySessionCreateWithoutMissionInput[] | StudySessionUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: StudySessionCreateOrConnectWithoutMissionInput | StudySessionCreateOrConnectWithoutMissionInput[]
    upsert?: StudySessionUpsertWithWhereUniqueWithoutMissionInput | StudySessionUpsertWithWhereUniqueWithoutMissionInput[]
    createMany?: StudySessionCreateManyMissionInputEnvelope
    set?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    disconnect?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    delete?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    connect?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    update?: StudySessionUpdateWithWhereUniqueWithoutMissionInput | StudySessionUpdateWithWhereUniqueWithoutMissionInput[]
    updateMany?: StudySessionUpdateManyWithWhereWithoutMissionInput | StudySessionUpdateManyWithWhereWithoutMissionInput[]
    deleteMany?: StudySessionScalarWhereInput | StudySessionScalarWhereInput[]
  }

  export type MissionFeedbackUpdateManyWithoutMissionNestedInput = {
    create?: XOR<MissionFeedbackCreateWithoutMissionInput, MissionFeedbackUncheckedCreateWithoutMissionInput> | MissionFeedbackCreateWithoutMissionInput[] | MissionFeedbackUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: MissionFeedbackCreateOrConnectWithoutMissionInput | MissionFeedbackCreateOrConnectWithoutMissionInput[]
    upsert?: MissionFeedbackUpsertWithWhereUniqueWithoutMissionInput | MissionFeedbackUpsertWithWhereUniqueWithoutMissionInput[]
    createMany?: MissionFeedbackCreateManyMissionInputEnvelope
    set?: MissionFeedbackWhereUniqueInput | MissionFeedbackWhereUniqueInput[]
    disconnect?: MissionFeedbackWhereUniqueInput | MissionFeedbackWhereUniqueInput[]
    delete?: MissionFeedbackWhereUniqueInput | MissionFeedbackWhereUniqueInput[]
    connect?: MissionFeedbackWhereUniqueInput | MissionFeedbackWhereUniqueInput[]
    update?: MissionFeedbackUpdateWithWhereUniqueWithoutMissionInput | MissionFeedbackUpdateWithWhereUniqueWithoutMissionInput[]
    updateMany?: MissionFeedbackUpdateManyWithWhereWithoutMissionInput | MissionFeedbackUpdateManyWithWhereWithoutMissionInput[]
    deleteMany?: MissionFeedbackScalarWhereInput | MissionFeedbackScalarWhereInput[]
  }

  export type InterventionRecommendationUpdateManyWithoutMissionNestedInput = {
    create?: XOR<InterventionRecommendationCreateWithoutMissionInput, InterventionRecommendationUncheckedCreateWithoutMissionInput> | InterventionRecommendationCreateWithoutMissionInput[] | InterventionRecommendationUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: InterventionRecommendationCreateOrConnectWithoutMissionInput | InterventionRecommendationCreateOrConnectWithoutMissionInput[]
    upsert?: InterventionRecommendationUpsertWithWhereUniqueWithoutMissionInput | InterventionRecommendationUpsertWithWhereUniqueWithoutMissionInput[]
    createMany?: InterventionRecommendationCreateManyMissionInputEnvelope
    set?: InterventionRecommendationWhereUniqueInput | InterventionRecommendationWhereUniqueInput[]
    disconnect?: InterventionRecommendationWhereUniqueInput | InterventionRecommendationWhereUniqueInput[]
    delete?: InterventionRecommendationWhereUniqueInput | InterventionRecommendationWhereUniqueInput[]
    connect?: InterventionRecommendationWhereUniqueInput | InterventionRecommendationWhereUniqueInput[]
    update?: InterventionRecommendationUpdateWithWhereUniqueWithoutMissionInput | InterventionRecommendationUpdateWithWhereUniqueWithoutMissionInput[]
    updateMany?: InterventionRecommendationUpdateManyWithWhereWithoutMissionInput | InterventionRecommendationUpdateManyWithWhereWithoutMissionInput[]
    deleteMany?: InterventionRecommendationScalarWhereInput | InterventionRecommendationScalarWhereInput[]
  }

  export type StudySessionUncheckedUpdateManyWithoutMissionNestedInput = {
    create?: XOR<StudySessionCreateWithoutMissionInput, StudySessionUncheckedCreateWithoutMissionInput> | StudySessionCreateWithoutMissionInput[] | StudySessionUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: StudySessionCreateOrConnectWithoutMissionInput | StudySessionCreateOrConnectWithoutMissionInput[]
    upsert?: StudySessionUpsertWithWhereUniqueWithoutMissionInput | StudySessionUpsertWithWhereUniqueWithoutMissionInput[]
    createMany?: StudySessionCreateManyMissionInputEnvelope
    set?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    disconnect?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    delete?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    connect?: StudySessionWhereUniqueInput | StudySessionWhereUniqueInput[]
    update?: StudySessionUpdateWithWhereUniqueWithoutMissionInput | StudySessionUpdateWithWhereUniqueWithoutMissionInput[]
    updateMany?: StudySessionUpdateManyWithWhereWithoutMissionInput | StudySessionUpdateManyWithWhereWithoutMissionInput[]
    deleteMany?: StudySessionScalarWhereInput | StudySessionScalarWhereInput[]
  }

  export type MissionFeedbackUncheckedUpdateManyWithoutMissionNestedInput = {
    create?: XOR<MissionFeedbackCreateWithoutMissionInput, MissionFeedbackUncheckedCreateWithoutMissionInput> | MissionFeedbackCreateWithoutMissionInput[] | MissionFeedbackUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: MissionFeedbackCreateOrConnectWithoutMissionInput | MissionFeedbackCreateOrConnectWithoutMissionInput[]
    upsert?: MissionFeedbackUpsertWithWhereUniqueWithoutMissionInput | MissionFeedbackUpsertWithWhereUniqueWithoutMissionInput[]
    createMany?: MissionFeedbackCreateManyMissionInputEnvelope
    set?: MissionFeedbackWhereUniqueInput | MissionFeedbackWhereUniqueInput[]
    disconnect?: MissionFeedbackWhereUniqueInput | MissionFeedbackWhereUniqueInput[]
    delete?: MissionFeedbackWhereUniqueInput | MissionFeedbackWhereUniqueInput[]
    connect?: MissionFeedbackWhereUniqueInput | MissionFeedbackWhereUniqueInput[]
    update?: MissionFeedbackUpdateWithWhereUniqueWithoutMissionInput | MissionFeedbackUpdateWithWhereUniqueWithoutMissionInput[]
    updateMany?: MissionFeedbackUpdateManyWithWhereWithoutMissionInput | MissionFeedbackUpdateManyWithWhereWithoutMissionInput[]
    deleteMany?: MissionFeedbackScalarWhereInput | MissionFeedbackScalarWhereInput[]
  }

  export type InterventionRecommendationUncheckedUpdateManyWithoutMissionNestedInput = {
    create?: XOR<InterventionRecommendationCreateWithoutMissionInput, InterventionRecommendationUncheckedCreateWithoutMissionInput> | InterventionRecommendationCreateWithoutMissionInput[] | InterventionRecommendationUncheckedCreateWithoutMissionInput[]
    connectOrCreate?: InterventionRecommendationCreateOrConnectWithoutMissionInput | InterventionRecommendationCreateOrConnectWithoutMissionInput[]
    upsert?: InterventionRecommendationUpsertWithWhereUniqueWithoutMissionInput | InterventionRecommendationUpsertWithWhereUniqueWithoutMissionInput[]
    createMany?: InterventionRecommendationCreateManyMissionInputEnvelope
    set?: InterventionRecommendationWhereUniqueInput | InterventionRecommendationWhereUniqueInput[]
    disconnect?: InterventionRecommendationWhereUniqueInput | InterventionRecommendationWhereUniqueInput[]
    delete?: InterventionRecommendationWhereUniqueInput | InterventionRecommendationWhereUniqueInput[]
    connect?: InterventionRecommendationWhereUniqueInput | InterventionRecommendationWhereUniqueInput[]
    update?: InterventionRecommendationUpdateWithWhereUniqueWithoutMissionInput | InterventionRecommendationUpdateWithWhereUniqueWithoutMissionInput[]
    updateMany?: InterventionRecommendationUpdateManyWithWhereWithoutMissionInput | InterventionRecommendationUpdateManyWithWhereWithoutMissionInput[]
    deleteMany?: InterventionRecommendationScalarWhereInput | InterventionRecommendationScalarWhereInput[]
  }

  export type CourseCreateNestedOneWithoutCardsInput = {
    create?: XOR<CourseCreateWithoutCardsInput, CourseUncheckedCreateWithoutCardsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCardsInput
    connect?: CourseWhereUniqueInput
  }

  export type LectureCreateNestedOneWithoutCardsInput = {
    create?: XOR<LectureCreateWithoutCardsInput, LectureUncheckedCreateWithoutCardsInput>
    connectOrCreate?: LectureCreateOrConnectWithoutCardsInput
    connect?: LectureWhereUniqueInput
  }

  export type LearningObjectiveCreateNestedOneWithoutCardsInput = {
    create?: XOR<LearningObjectiveCreateWithoutCardsInput, LearningObjectiveUncheckedCreateWithoutCardsInput>
    connectOrCreate?: LearningObjectiveCreateOrConnectWithoutCardsInput
    connect?: LearningObjectiveWhereUniqueInput
  }

  export type ReviewCreateNestedManyWithoutCardInput = {
    create?: XOR<ReviewCreateWithoutCardInput, ReviewUncheckedCreateWithoutCardInput> | ReviewCreateWithoutCardInput[] | ReviewUncheckedCreateWithoutCardInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutCardInput | ReviewCreateOrConnectWithoutCardInput[]
    createMany?: ReviewCreateManyCardInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutCardInput = {
    create?: XOR<ReviewCreateWithoutCardInput, ReviewUncheckedCreateWithoutCardInput> | ReviewCreateWithoutCardInput[] | ReviewUncheckedCreateWithoutCardInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutCardInput | ReviewCreateOrConnectWithoutCardInput[]
    createMany?: ReviewCreateManyCardInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type EnumCardTypeFieldUpdateOperationsInput = {
    set?: $Enums.CardType
  }

  export type CourseUpdateOneRequiredWithoutCardsNestedInput = {
    create?: XOR<CourseCreateWithoutCardsInput, CourseUncheckedCreateWithoutCardsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCardsInput
    upsert?: CourseUpsertWithoutCardsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutCardsInput, CourseUpdateWithoutCardsInput>, CourseUncheckedUpdateWithoutCardsInput>
  }

  export type LectureUpdateOneWithoutCardsNestedInput = {
    create?: XOR<LectureCreateWithoutCardsInput, LectureUncheckedCreateWithoutCardsInput>
    connectOrCreate?: LectureCreateOrConnectWithoutCardsInput
    upsert?: LectureUpsertWithoutCardsInput
    disconnect?: LectureWhereInput | boolean
    delete?: LectureWhereInput | boolean
    connect?: LectureWhereUniqueInput
    update?: XOR<XOR<LectureUpdateToOneWithWhereWithoutCardsInput, LectureUpdateWithoutCardsInput>, LectureUncheckedUpdateWithoutCardsInput>
  }

  export type LearningObjectiveUpdateOneWithoutCardsNestedInput = {
    create?: XOR<LearningObjectiveCreateWithoutCardsInput, LearningObjectiveUncheckedCreateWithoutCardsInput>
    connectOrCreate?: LearningObjectiveCreateOrConnectWithoutCardsInput
    upsert?: LearningObjectiveUpsertWithoutCardsInput
    disconnect?: LearningObjectiveWhereInput | boolean
    delete?: LearningObjectiveWhereInput | boolean
    connect?: LearningObjectiveWhereUniqueInput
    update?: XOR<XOR<LearningObjectiveUpdateToOneWithWhereWithoutCardsInput, LearningObjectiveUpdateWithoutCardsInput>, LearningObjectiveUncheckedUpdateWithoutCardsInput>
  }

  export type ReviewUpdateManyWithoutCardNestedInput = {
    create?: XOR<ReviewCreateWithoutCardInput, ReviewUncheckedCreateWithoutCardInput> | ReviewCreateWithoutCardInput[] | ReviewUncheckedCreateWithoutCardInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutCardInput | ReviewCreateOrConnectWithoutCardInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutCardInput | ReviewUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: ReviewCreateManyCardInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutCardInput | ReviewUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutCardInput | ReviewUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutCardNestedInput = {
    create?: XOR<ReviewCreateWithoutCardInput, ReviewUncheckedCreateWithoutCardInput> | ReviewCreateWithoutCardInput[] | ReviewUncheckedCreateWithoutCardInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutCardInput | ReviewCreateOrConnectWithoutCardInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutCardInput | ReviewUpsertWithWhereUniqueWithoutCardInput[]
    createMany?: ReviewCreateManyCardInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutCardInput | ReviewUpdateWithWhereUniqueWithoutCardInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutCardInput | ReviewUpdateManyWithWhereWithoutCardInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type CardCreateNestedOneWithoutReviewsInput = {
    create?: XOR<CardCreateWithoutReviewsInput, CardUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: CardCreateOrConnectWithoutReviewsInput
    connect?: CardWhereUniqueInput
  }

  export type StudySessionCreateNestedOneWithoutReviewsInput = {
    create?: XOR<StudySessionCreateWithoutReviewsInput, StudySessionUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: StudySessionCreateOrConnectWithoutReviewsInput
    connect?: StudySessionWhereUniqueInput
  }

  export type EnumReviewRatingFieldUpdateOperationsInput = {
    set?: $Enums.ReviewRating
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type CardUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<CardCreateWithoutReviewsInput, CardUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: CardCreateOrConnectWithoutReviewsInput
    upsert?: CardUpsertWithoutReviewsInput
    connect?: CardWhereUniqueInput
    update?: XOR<XOR<CardUpdateToOneWithWhereWithoutReviewsInput, CardUpdateWithoutReviewsInput>, CardUncheckedUpdateWithoutReviewsInput>
  }

  export type StudySessionUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<StudySessionCreateWithoutReviewsInput, StudySessionUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: StudySessionCreateOrConnectWithoutReviewsInput
    upsert?: StudySessionUpsertWithoutReviewsInput
    disconnect?: StudySessionWhereInput | boolean
    delete?: StudySessionWhereInput | boolean
    connect?: StudySessionWhereUniqueInput
    update?: XOR<XOR<StudySessionUpdateToOneWithWhereWithoutReviewsInput, StudySessionUpdateWithoutReviewsInput>, StudySessionUncheckedUpdateWithoutReviewsInput>
  }

  export type UserCreateNestedOneWithoutStudySessionsInput = {
    create?: XOR<UserCreateWithoutStudySessionsInput, UserUncheckedCreateWithoutStudySessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudySessionsInput
    connect?: UserWhereUniqueInput
  }

  export type MissionCreateNestedOneWithoutStudySessionsInput = {
    create?: XOR<MissionCreateWithoutStudySessionsInput, MissionUncheckedCreateWithoutStudySessionsInput>
    connectOrCreate?: MissionCreateOrConnectWithoutStudySessionsInput
    connect?: MissionWhereUniqueInput
  }

  export type ReviewCreateNestedManyWithoutSessionInput = {
    create?: XOR<ReviewCreateWithoutSessionInput, ReviewUncheckedCreateWithoutSessionInput> | ReviewCreateWithoutSessionInput[] | ReviewUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutSessionInput | ReviewCreateOrConnectWithoutSessionInput[]
    createMany?: ReviewCreateManySessionInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ValidationResponseCreateNestedManyWithoutSessionInput = {
    create?: XOR<ValidationResponseCreateWithoutSessionInput, ValidationResponseUncheckedCreateWithoutSessionInput> | ValidationResponseCreateWithoutSessionInput[] | ValidationResponseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ValidationResponseCreateOrConnectWithoutSessionInput | ValidationResponseCreateOrConnectWithoutSessionInput[]
    createMany?: ValidationResponseCreateManySessionInputEnvelope
    connect?: ValidationResponseWhereUniqueInput | ValidationResponseWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<ReviewCreateWithoutSessionInput, ReviewUncheckedCreateWithoutSessionInput> | ReviewCreateWithoutSessionInput[] | ReviewUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutSessionInput | ReviewCreateOrConnectWithoutSessionInput[]
    createMany?: ReviewCreateManySessionInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ValidationResponseUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<ValidationResponseCreateWithoutSessionInput, ValidationResponseUncheckedCreateWithoutSessionInput> | ValidationResponseCreateWithoutSessionInput[] | ValidationResponseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ValidationResponseCreateOrConnectWithoutSessionInput | ValidationResponseCreateOrConnectWithoutSessionInput[]
    createMany?: ValidationResponseCreateManySessionInputEnvelope
    connect?: ValidationResponseWhereUniqueInput | ValidationResponseWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutStudySessionsNestedInput = {
    create?: XOR<UserCreateWithoutStudySessionsInput, UserUncheckedCreateWithoutStudySessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudySessionsInput
    upsert?: UserUpsertWithoutStudySessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudySessionsInput, UserUpdateWithoutStudySessionsInput>, UserUncheckedUpdateWithoutStudySessionsInput>
  }

  export type MissionUpdateOneWithoutStudySessionsNestedInput = {
    create?: XOR<MissionCreateWithoutStudySessionsInput, MissionUncheckedCreateWithoutStudySessionsInput>
    connectOrCreate?: MissionCreateOrConnectWithoutStudySessionsInput
    upsert?: MissionUpsertWithoutStudySessionsInput
    disconnect?: MissionWhereInput | boolean
    delete?: MissionWhereInput | boolean
    connect?: MissionWhereUniqueInput
    update?: XOR<XOR<MissionUpdateToOneWithWhereWithoutStudySessionsInput, MissionUpdateWithoutStudySessionsInput>, MissionUncheckedUpdateWithoutStudySessionsInput>
  }

  export type ReviewUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ReviewCreateWithoutSessionInput, ReviewUncheckedCreateWithoutSessionInput> | ReviewCreateWithoutSessionInput[] | ReviewUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutSessionInput | ReviewCreateOrConnectWithoutSessionInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutSessionInput | ReviewUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ReviewCreateManySessionInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutSessionInput | ReviewUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutSessionInput | ReviewUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ValidationResponseUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ValidationResponseCreateWithoutSessionInput, ValidationResponseUncheckedCreateWithoutSessionInput> | ValidationResponseCreateWithoutSessionInput[] | ValidationResponseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ValidationResponseCreateOrConnectWithoutSessionInput | ValidationResponseCreateOrConnectWithoutSessionInput[]
    upsert?: ValidationResponseUpsertWithWhereUniqueWithoutSessionInput | ValidationResponseUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ValidationResponseCreateManySessionInputEnvelope
    set?: ValidationResponseWhereUniqueInput | ValidationResponseWhereUniqueInput[]
    disconnect?: ValidationResponseWhereUniqueInput | ValidationResponseWhereUniqueInput[]
    delete?: ValidationResponseWhereUniqueInput | ValidationResponseWhereUniqueInput[]
    connect?: ValidationResponseWhereUniqueInput | ValidationResponseWhereUniqueInput[]
    update?: ValidationResponseUpdateWithWhereUniqueWithoutSessionInput | ValidationResponseUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ValidationResponseUpdateManyWithWhereWithoutSessionInput | ValidationResponseUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ValidationResponseScalarWhereInput | ValidationResponseScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ReviewCreateWithoutSessionInput, ReviewUncheckedCreateWithoutSessionInput> | ReviewCreateWithoutSessionInput[] | ReviewUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutSessionInput | ReviewCreateOrConnectWithoutSessionInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutSessionInput | ReviewUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ReviewCreateManySessionInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutSessionInput | ReviewUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutSessionInput | ReviewUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ValidationResponseUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ValidationResponseCreateWithoutSessionInput, ValidationResponseUncheckedCreateWithoutSessionInput> | ValidationResponseCreateWithoutSessionInput[] | ValidationResponseUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ValidationResponseCreateOrConnectWithoutSessionInput | ValidationResponseCreateOrConnectWithoutSessionInput[]
    upsert?: ValidationResponseUpsertWithWhereUniqueWithoutSessionInput | ValidationResponseUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ValidationResponseCreateManySessionInputEnvelope
    set?: ValidationResponseWhereUniqueInput | ValidationResponseWhereUniqueInput[]
    disconnect?: ValidationResponseWhereUniqueInput | ValidationResponseWhereUniqueInput[]
    delete?: ValidationResponseWhereUniqueInput | ValidationResponseWhereUniqueInput[]
    connect?: ValidationResponseWhereUniqueInput | ValidationResponseWhereUniqueInput[]
    update?: ValidationResponseUpdateWithWhereUniqueWithoutSessionInput | ValidationResponseUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ValidationResponseUpdateManyWithWhereWithoutSessionInput | ValidationResponseUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ValidationResponseScalarWhereInput | ValidationResponseScalarWhereInput[]
  }

  export type ConceptRelationshipCreateNestedManyWithoutFromConceptInput = {
    create?: XOR<ConceptRelationshipCreateWithoutFromConceptInput, ConceptRelationshipUncheckedCreateWithoutFromConceptInput> | ConceptRelationshipCreateWithoutFromConceptInput[] | ConceptRelationshipUncheckedCreateWithoutFromConceptInput[]
    connectOrCreate?: ConceptRelationshipCreateOrConnectWithoutFromConceptInput | ConceptRelationshipCreateOrConnectWithoutFromConceptInput[]
    createMany?: ConceptRelationshipCreateManyFromConceptInputEnvelope
    connect?: ConceptRelationshipWhereUniqueInput | ConceptRelationshipWhereUniqueInput[]
  }

  export type ConceptRelationshipCreateNestedManyWithoutToConceptInput = {
    create?: XOR<ConceptRelationshipCreateWithoutToConceptInput, ConceptRelationshipUncheckedCreateWithoutToConceptInput> | ConceptRelationshipCreateWithoutToConceptInput[] | ConceptRelationshipUncheckedCreateWithoutToConceptInput[]
    connectOrCreate?: ConceptRelationshipCreateOrConnectWithoutToConceptInput | ConceptRelationshipCreateOrConnectWithoutToConceptInput[]
    createMany?: ConceptRelationshipCreateManyToConceptInputEnvelope
    connect?: ConceptRelationshipWhereUniqueInput | ConceptRelationshipWhereUniqueInput[]
  }

  export type ConceptRelationshipUncheckedCreateNestedManyWithoutFromConceptInput = {
    create?: XOR<ConceptRelationshipCreateWithoutFromConceptInput, ConceptRelationshipUncheckedCreateWithoutFromConceptInput> | ConceptRelationshipCreateWithoutFromConceptInput[] | ConceptRelationshipUncheckedCreateWithoutFromConceptInput[]
    connectOrCreate?: ConceptRelationshipCreateOrConnectWithoutFromConceptInput | ConceptRelationshipCreateOrConnectWithoutFromConceptInput[]
    createMany?: ConceptRelationshipCreateManyFromConceptInputEnvelope
    connect?: ConceptRelationshipWhereUniqueInput | ConceptRelationshipWhereUniqueInput[]
  }

  export type ConceptRelationshipUncheckedCreateNestedManyWithoutToConceptInput = {
    create?: XOR<ConceptRelationshipCreateWithoutToConceptInput, ConceptRelationshipUncheckedCreateWithoutToConceptInput> | ConceptRelationshipCreateWithoutToConceptInput[] | ConceptRelationshipUncheckedCreateWithoutToConceptInput[]
    connectOrCreate?: ConceptRelationshipCreateOrConnectWithoutToConceptInput | ConceptRelationshipCreateOrConnectWithoutToConceptInput[]
    createMany?: ConceptRelationshipCreateManyToConceptInputEnvelope
    connect?: ConceptRelationshipWhereUniqueInput | ConceptRelationshipWhereUniqueInput[]
  }

  export type ConceptRelationshipUpdateManyWithoutFromConceptNestedInput = {
    create?: XOR<ConceptRelationshipCreateWithoutFromConceptInput, ConceptRelationshipUncheckedCreateWithoutFromConceptInput> | ConceptRelationshipCreateWithoutFromConceptInput[] | ConceptRelationshipUncheckedCreateWithoutFromConceptInput[]
    connectOrCreate?: ConceptRelationshipCreateOrConnectWithoutFromConceptInput | ConceptRelationshipCreateOrConnectWithoutFromConceptInput[]
    upsert?: ConceptRelationshipUpsertWithWhereUniqueWithoutFromConceptInput | ConceptRelationshipUpsertWithWhereUniqueWithoutFromConceptInput[]
    createMany?: ConceptRelationshipCreateManyFromConceptInputEnvelope
    set?: ConceptRelationshipWhereUniqueInput | ConceptRelationshipWhereUniqueInput[]
    disconnect?: ConceptRelationshipWhereUniqueInput | ConceptRelationshipWhereUniqueInput[]
    delete?: ConceptRelationshipWhereUniqueInput | ConceptRelationshipWhereUniqueInput[]
    connect?: ConceptRelationshipWhereUniqueInput | ConceptRelationshipWhereUniqueInput[]
    update?: ConceptRelationshipUpdateWithWhereUniqueWithoutFromConceptInput | ConceptRelationshipUpdateWithWhereUniqueWithoutFromConceptInput[]
    updateMany?: ConceptRelationshipUpdateManyWithWhereWithoutFromConceptInput | ConceptRelationshipUpdateManyWithWhereWithoutFromConceptInput[]
    deleteMany?: ConceptRelationshipScalarWhereInput | ConceptRelationshipScalarWhereInput[]
  }

  export type ConceptRelationshipUpdateManyWithoutToConceptNestedInput = {
    create?: XOR<ConceptRelationshipCreateWithoutToConceptInput, ConceptRelationshipUncheckedCreateWithoutToConceptInput> | ConceptRelationshipCreateWithoutToConceptInput[] | ConceptRelationshipUncheckedCreateWithoutToConceptInput[]
    connectOrCreate?: ConceptRelationshipCreateOrConnectWithoutToConceptInput | ConceptRelationshipCreateOrConnectWithoutToConceptInput[]
    upsert?: ConceptRelationshipUpsertWithWhereUniqueWithoutToConceptInput | ConceptRelationshipUpsertWithWhereUniqueWithoutToConceptInput[]
    createMany?: ConceptRelationshipCreateManyToConceptInputEnvelope
    set?: ConceptRelationshipWhereUniqueInput | ConceptRelationshipWhereUniqueInput[]
    disconnect?: ConceptRelationshipWhereUniqueInput | ConceptRelationshipWhereUniqueInput[]
    delete?: ConceptRelationshipWhereUniqueInput | ConceptRelationshipWhereUniqueInput[]
    connect?: ConceptRelationshipWhereUniqueInput | ConceptRelationshipWhereUniqueInput[]
    update?: ConceptRelationshipUpdateWithWhereUniqueWithoutToConceptInput | ConceptRelationshipUpdateWithWhereUniqueWithoutToConceptInput[]
    updateMany?: ConceptRelationshipUpdateManyWithWhereWithoutToConceptInput | ConceptRelationshipUpdateManyWithWhereWithoutToConceptInput[]
    deleteMany?: ConceptRelationshipScalarWhereInput | ConceptRelationshipScalarWhereInput[]
  }

  export type ConceptRelationshipUncheckedUpdateManyWithoutFromConceptNestedInput = {
    create?: XOR<ConceptRelationshipCreateWithoutFromConceptInput, ConceptRelationshipUncheckedCreateWithoutFromConceptInput> | ConceptRelationshipCreateWithoutFromConceptInput[] | ConceptRelationshipUncheckedCreateWithoutFromConceptInput[]
    connectOrCreate?: ConceptRelationshipCreateOrConnectWithoutFromConceptInput | ConceptRelationshipCreateOrConnectWithoutFromConceptInput[]
    upsert?: ConceptRelationshipUpsertWithWhereUniqueWithoutFromConceptInput | ConceptRelationshipUpsertWithWhereUniqueWithoutFromConceptInput[]
    createMany?: ConceptRelationshipCreateManyFromConceptInputEnvelope
    set?: ConceptRelationshipWhereUniqueInput | ConceptRelationshipWhereUniqueInput[]
    disconnect?: ConceptRelationshipWhereUniqueInput | ConceptRelationshipWhereUniqueInput[]
    delete?: ConceptRelationshipWhereUniqueInput | ConceptRelationshipWhereUniqueInput[]
    connect?: ConceptRelationshipWhereUniqueInput | ConceptRelationshipWhereUniqueInput[]
    update?: ConceptRelationshipUpdateWithWhereUniqueWithoutFromConceptInput | ConceptRelationshipUpdateWithWhereUniqueWithoutFromConceptInput[]
    updateMany?: ConceptRelationshipUpdateManyWithWhereWithoutFromConceptInput | ConceptRelationshipUpdateManyWithWhereWithoutFromConceptInput[]
    deleteMany?: ConceptRelationshipScalarWhereInput | ConceptRelationshipScalarWhereInput[]
  }

  export type ConceptRelationshipUncheckedUpdateManyWithoutToConceptNestedInput = {
    create?: XOR<ConceptRelationshipCreateWithoutToConceptInput, ConceptRelationshipUncheckedCreateWithoutToConceptInput> | ConceptRelationshipCreateWithoutToConceptInput[] | ConceptRelationshipUncheckedCreateWithoutToConceptInput[]
    connectOrCreate?: ConceptRelationshipCreateOrConnectWithoutToConceptInput | ConceptRelationshipCreateOrConnectWithoutToConceptInput[]
    upsert?: ConceptRelationshipUpsertWithWhereUniqueWithoutToConceptInput | ConceptRelationshipUpsertWithWhereUniqueWithoutToConceptInput[]
    createMany?: ConceptRelationshipCreateManyToConceptInputEnvelope
    set?: ConceptRelationshipWhereUniqueInput | ConceptRelationshipWhereUniqueInput[]
    disconnect?: ConceptRelationshipWhereUniqueInput | ConceptRelationshipWhereUniqueInput[]
    delete?: ConceptRelationshipWhereUniqueInput | ConceptRelationshipWhereUniqueInput[]
    connect?: ConceptRelationshipWhereUniqueInput | ConceptRelationshipWhereUniqueInput[]
    update?: ConceptRelationshipUpdateWithWhereUniqueWithoutToConceptInput | ConceptRelationshipUpdateWithWhereUniqueWithoutToConceptInput[]
    updateMany?: ConceptRelationshipUpdateManyWithWhereWithoutToConceptInput | ConceptRelationshipUpdateManyWithWhereWithoutToConceptInput[]
    deleteMany?: ConceptRelationshipScalarWhereInput | ConceptRelationshipScalarWhereInput[]
  }

  export type ConceptCreateNestedOneWithoutRelatedFromInput = {
    create?: XOR<ConceptCreateWithoutRelatedFromInput, ConceptUncheckedCreateWithoutRelatedFromInput>
    connectOrCreate?: ConceptCreateOrConnectWithoutRelatedFromInput
    connect?: ConceptWhereUniqueInput
  }

  export type ConceptCreateNestedOneWithoutRelatedToInput = {
    create?: XOR<ConceptCreateWithoutRelatedToInput, ConceptUncheckedCreateWithoutRelatedToInput>
    connectOrCreate?: ConceptCreateOrConnectWithoutRelatedToInput
    connect?: ConceptWhereUniqueInput
  }

  export type EnumRelationshipTypeFieldUpdateOperationsInput = {
    set?: $Enums.RelationshipType
  }

  export type ConceptUpdateOneRequiredWithoutRelatedFromNestedInput = {
    create?: XOR<ConceptCreateWithoutRelatedFromInput, ConceptUncheckedCreateWithoutRelatedFromInput>
    connectOrCreate?: ConceptCreateOrConnectWithoutRelatedFromInput
    upsert?: ConceptUpsertWithoutRelatedFromInput
    connect?: ConceptWhereUniqueInput
    update?: XOR<XOR<ConceptUpdateToOneWithWhereWithoutRelatedFromInput, ConceptUpdateWithoutRelatedFromInput>, ConceptUncheckedUpdateWithoutRelatedFromInput>
  }

  export type ConceptUpdateOneRequiredWithoutRelatedToNestedInput = {
    create?: XOR<ConceptCreateWithoutRelatedToInput, ConceptUncheckedCreateWithoutRelatedToInput>
    connectOrCreate?: ConceptCreateOrConnectWithoutRelatedToInput
    upsert?: ConceptUpsertWithoutRelatedToInput
    connect?: ConceptWhereUniqueInput
    update?: XOR<XOR<ConceptUpdateToOneWithWhereWithoutRelatedToInput, ConceptUpdateWithoutRelatedToInput>, ConceptUncheckedUpdateWithoutRelatedToInput>
  }

  export type ValidationPromptCreateexpectedCriteriaInput = {
    set: string[]
  }

  export type ValidationResponseCreateNestedManyWithoutPromptInput = {
    create?: XOR<ValidationResponseCreateWithoutPromptInput, ValidationResponseUncheckedCreateWithoutPromptInput> | ValidationResponseCreateWithoutPromptInput[] | ValidationResponseUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: ValidationResponseCreateOrConnectWithoutPromptInput | ValidationResponseCreateOrConnectWithoutPromptInput[]
    createMany?: ValidationResponseCreateManyPromptInputEnvelope
    connect?: ValidationResponseWhereUniqueInput | ValidationResponseWhereUniqueInput[]
  }

  export type ValidationResponseUncheckedCreateNestedManyWithoutPromptInput = {
    create?: XOR<ValidationResponseCreateWithoutPromptInput, ValidationResponseUncheckedCreateWithoutPromptInput> | ValidationResponseCreateWithoutPromptInput[] | ValidationResponseUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: ValidationResponseCreateOrConnectWithoutPromptInput | ValidationResponseCreateOrConnectWithoutPromptInput[]
    createMany?: ValidationResponseCreateManyPromptInputEnvelope
    connect?: ValidationResponseWhereUniqueInput | ValidationResponseWhereUniqueInput[]
  }

  export type EnumPromptTypeFieldUpdateOperationsInput = {
    set?: $Enums.PromptType
  }

  export type ValidationPromptUpdateexpectedCriteriaInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ValidationResponseUpdateManyWithoutPromptNestedInput = {
    create?: XOR<ValidationResponseCreateWithoutPromptInput, ValidationResponseUncheckedCreateWithoutPromptInput> | ValidationResponseCreateWithoutPromptInput[] | ValidationResponseUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: ValidationResponseCreateOrConnectWithoutPromptInput | ValidationResponseCreateOrConnectWithoutPromptInput[]
    upsert?: ValidationResponseUpsertWithWhereUniqueWithoutPromptInput | ValidationResponseUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: ValidationResponseCreateManyPromptInputEnvelope
    set?: ValidationResponseWhereUniqueInput | ValidationResponseWhereUniqueInput[]
    disconnect?: ValidationResponseWhereUniqueInput | ValidationResponseWhereUniqueInput[]
    delete?: ValidationResponseWhereUniqueInput | ValidationResponseWhereUniqueInput[]
    connect?: ValidationResponseWhereUniqueInput | ValidationResponseWhereUniqueInput[]
    update?: ValidationResponseUpdateWithWhereUniqueWithoutPromptInput | ValidationResponseUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: ValidationResponseUpdateManyWithWhereWithoutPromptInput | ValidationResponseUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: ValidationResponseScalarWhereInput | ValidationResponseScalarWhereInput[]
  }

  export type ValidationResponseUncheckedUpdateManyWithoutPromptNestedInput = {
    create?: XOR<ValidationResponseCreateWithoutPromptInput, ValidationResponseUncheckedCreateWithoutPromptInput> | ValidationResponseCreateWithoutPromptInput[] | ValidationResponseUncheckedCreateWithoutPromptInput[]
    connectOrCreate?: ValidationResponseCreateOrConnectWithoutPromptInput | ValidationResponseCreateOrConnectWithoutPromptInput[]
    upsert?: ValidationResponseUpsertWithWhereUniqueWithoutPromptInput | ValidationResponseUpsertWithWhereUniqueWithoutPromptInput[]
    createMany?: ValidationResponseCreateManyPromptInputEnvelope
    set?: ValidationResponseWhereUniqueInput | ValidationResponseWhereUniqueInput[]
    disconnect?: ValidationResponseWhereUniqueInput | ValidationResponseWhereUniqueInput[]
    delete?: ValidationResponseWhereUniqueInput | ValidationResponseWhereUniqueInput[]
    connect?: ValidationResponseWhereUniqueInput | ValidationResponseWhereUniqueInput[]
    update?: ValidationResponseUpdateWithWhereUniqueWithoutPromptInput | ValidationResponseUpdateWithWhereUniqueWithoutPromptInput[]
    updateMany?: ValidationResponseUpdateManyWithWhereWithoutPromptInput | ValidationResponseUpdateManyWithWhereWithoutPromptInput[]
    deleteMany?: ValidationResponseScalarWhereInput | ValidationResponseScalarWhereInput[]
  }

  export type ValidationPromptCreateNestedOneWithoutResponsesInput = {
    create?: XOR<ValidationPromptCreateWithoutResponsesInput, ValidationPromptUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: ValidationPromptCreateOrConnectWithoutResponsesInput
    connect?: ValidationPromptWhereUniqueInput
  }

  export type StudySessionCreateNestedOneWithoutValidationResponsesInput = {
    create?: XOR<StudySessionCreateWithoutValidationResponsesInput, StudySessionUncheckedCreateWithoutValidationResponsesInput>
    connectOrCreate?: StudySessionCreateOrConnectWithoutValidationResponsesInput
    connect?: StudySessionWhereUniqueInput
  }

  export type ValidationPromptUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<ValidationPromptCreateWithoutResponsesInput, ValidationPromptUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: ValidationPromptCreateOrConnectWithoutResponsesInput
    upsert?: ValidationPromptUpsertWithoutResponsesInput
    connect?: ValidationPromptWhereUniqueInput
    update?: XOR<XOR<ValidationPromptUpdateToOneWithWhereWithoutResponsesInput, ValidationPromptUpdateWithoutResponsesInput>, ValidationPromptUncheckedUpdateWithoutResponsesInput>
  }

  export type StudySessionUpdateOneWithoutValidationResponsesNestedInput = {
    create?: XOR<StudySessionCreateWithoutValidationResponsesInput, StudySessionUncheckedCreateWithoutValidationResponsesInput>
    connectOrCreate?: StudySessionCreateOrConnectWithoutValidationResponsesInput
    upsert?: StudySessionUpsertWithoutValidationResponsesInput
    disconnect?: StudySessionWhereInput | boolean
    delete?: StudySessionWhereInput | boolean
    connect?: StudySessionWhereUniqueInput
    update?: XOR<XOR<StudySessionUpdateToOneWithWhereWithoutValidationResponsesInput, StudySessionUpdateWithoutValidationResponsesInput>, StudySessionUncheckedUpdateWithoutValidationResponsesInput>
  }

  export type EnumEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.EventType
  }

  export type NullableEnumEngagementLevelFieldUpdateOperationsInput = {
    set?: $Enums.EngagementLevel | null
  }

  export type NullableEnumCompletionQualityFieldUpdateOperationsInput = {
    set?: $Enums.CompletionQuality | null
  }

  export type InsightPatternCreateNestedManyWithoutPatternInput = {
    create?: XOR<InsightPatternCreateWithoutPatternInput, InsightPatternUncheckedCreateWithoutPatternInput> | InsightPatternCreateWithoutPatternInput[] | InsightPatternUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: InsightPatternCreateOrConnectWithoutPatternInput | InsightPatternCreateOrConnectWithoutPatternInput[]
    createMany?: InsightPatternCreateManyPatternInputEnvelope
    connect?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
  }

  export type InsightPatternUncheckedCreateNestedManyWithoutPatternInput = {
    create?: XOR<InsightPatternCreateWithoutPatternInput, InsightPatternUncheckedCreateWithoutPatternInput> | InsightPatternCreateWithoutPatternInput[] | InsightPatternUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: InsightPatternCreateOrConnectWithoutPatternInput | InsightPatternCreateOrConnectWithoutPatternInput[]
    createMany?: InsightPatternCreateManyPatternInputEnvelope
    connect?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
  }

  export type EnumBehavioralPatternTypeFieldUpdateOperationsInput = {
    set?: $Enums.BehavioralPatternType
  }

  export type InsightPatternUpdateManyWithoutPatternNestedInput = {
    create?: XOR<InsightPatternCreateWithoutPatternInput, InsightPatternUncheckedCreateWithoutPatternInput> | InsightPatternCreateWithoutPatternInput[] | InsightPatternUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: InsightPatternCreateOrConnectWithoutPatternInput | InsightPatternCreateOrConnectWithoutPatternInput[]
    upsert?: InsightPatternUpsertWithWhereUniqueWithoutPatternInput | InsightPatternUpsertWithWhereUniqueWithoutPatternInput[]
    createMany?: InsightPatternCreateManyPatternInputEnvelope
    set?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    disconnect?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    delete?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    connect?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    update?: InsightPatternUpdateWithWhereUniqueWithoutPatternInput | InsightPatternUpdateWithWhereUniqueWithoutPatternInput[]
    updateMany?: InsightPatternUpdateManyWithWhereWithoutPatternInput | InsightPatternUpdateManyWithWhereWithoutPatternInput[]
    deleteMany?: InsightPatternScalarWhereInput | InsightPatternScalarWhereInput[]
  }

  export type InsightPatternUncheckedUpdateManyWithoutPatternNestedInput = {
    create?: XOR<InsightPatternCreateWithoutPatternInput, InsightPatternUncheckedCreateWithoutPatternInput> | InsightPatternCreateWithoutPatternInput[] | InsightPatternUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: InsightPatternCreateOrConnectWithoutPatternInput | InsightPatternCreateOrConnectWithoutPatternInput[]
    upsert?: InsightPatternUpsertWithWhereUniqueWithoutPatternInput | InsightPatternUpsertWithWhereUniqueWithoutPatternInput[]
    createMany?: InsightPatternCreateManyPatternInputEnvelope
    set?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    disconnect?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    delete?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    connect?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    update?: InsightPatternUpdateWithWhereUniqueWithoutPatternInput | InsightPatternUpdateWithWhereUniqueWithoutPatternInput[]
    updateMany?: InsightPatternUpdateManyWithWhereWithoutPatternInput | InsightPatternUpdateManyWithWhereWithoutPatternInput[]
    deleteMany?: InsightPatternScalarWhereInput | InsightPatternScalarWhereInput[]
  }

  export type InsightPatternCreateNestedManyWithoutInsightInput = {
    create?: XOR<InsightPatternCreateWithoutInsightInput, InsightPatternUncheckedCreateWithoutInsightInput> | InsightPatternCreateWithoutInsightInput[] | InsightPatternUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: InsightPatternCreateOrConnectWithoutInsightInput | InsightPatternCreateOrConnectWithoutInsightInput[]
    createMany?: InsightPatternCreateManyInsightInputEnvelope
    connect?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
  }

  export type InsightPatternUncheckedCreateNestedManyWithoutInsightInput = {
    create?: XOR<InsightPatternCreateWithoutInsightInput, InsightPatternUncheckedCreateWithoutInsightInput> | InsightPatternCreateWithoutInsightInput[] | InsightPatternUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: InsightPatternCreateOrConnectWithoutInsightInput | InsightPatternCreateOrConnectWithoutInsightInput[]
    createMany?: InsightPatternCreateManyInsightInputEnvelope
    connect?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
  }

  export type EnumInsightTypeFieldUpdateOperationsInput = {
    set?: $Enums.InsightType
  }

  export type InsightPatternUpdateManyWithoutInsightNestedInput = {
    create?: XOR<InsightPatternCreateWithoutInsightInput, InsightPatternUncheckedCreateWithoutInsightInput> | InsightPatternCreateWithoutInsightInput[] | InsightPatternUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: InsightPatternCreateOrConnectWithoutInsightInput | InsightPatternCreateOrConnectWithoutInsightInput[]
    upsert?: InsightPatternUpsertWithWhereUniqueWithoutInsightInput | InsightPatternUpsertWithWhereUniqueWithoutInsightInput[]
    createMany?: InsightPatternCreateManyInsightInputEnvelope
    set?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    disconnect?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    delete?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    connect?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    update?: InsightPatternUpdateWithWhereUniqueWithoutInsightInput | InsightPatternUpdateWithWhereUniqueWithoutInsightInput[]
    updateMany?: InsightPatternUpdateManyWithWhereWithoutInsightInput | InsightPatternUpdateManyWithWhereWithoutInsightInput[]
    deleteMany?: InsightPatternScalarWhereInput | InsightPatternScalarWhereInput[]
  }

  export type InsightPatternUncheckedUpdateManyWithoutInsightNestedInput = {
    create?: XOR<InsightPatternCreateWithoutInsightInput, InsightPatternUncheckedCreateWithoutInsightInput> | InsightPatternCreateWithoutInsightInput[] | InsightPatternUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: InsightPatternCreateOrConnectWithoutInsightInput | InsightPatternCreateOrConnectWithoutInsightInput[]
    upsert?: InsightPatternUpsertWithWhereUniqueWithoutInsightInput | InsightPatternUpsertWithWhereUniqueWithoutInsightInput[]
    createMany?: InsightPatternCreateManyInsightInputEnvelope
    set?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    disconnect?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    delete?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    connect?: InsightPatternWhereUniqueInput | InsightPatternWhereUniqueInput[]
    update?: InsightPatternUpdateWithWhereUniqueWithoutInsightInput | InsightPatternUpdateWithWhereUniqueWithoutInsightInput[]
    updateMany?: InsightPatternUpdateManyWithWhereWithoutInsightInput | InsightPatternUpdateManyWithWhereWithoutInsightInput[]
    deleteMany?: InsightPatternScalarWhereInput | InsightPatternScalarWhereInput[]
  }

  export type BehavioralInsightCreateNestedOneWithoutPatternsInput = {
    create?: XOR<BehavioralInsightCreateWithoutPatternsInput, BehavioralInsightUncheckedCreateWithoutPatternsInput>
    connectOrCreate?: BehavioralInsightCreateOrConnectWithoutPatternsInput
    connect?: BehavioralInsightWhereUniqueInput
  }

  export type BehavioralPatternCreateNestedOneWithoutInsightsInput = {
    create?: XOR<BehavioralPatternCreateWithoutInsightsInput, BehavioralPatternUncheckedCreateWithoutInsightsInput>
    connectOrCreate?: BehavioralPatternCreateOrConnectWithoutInsightsInput
    connect?: BehavioralPatternWhereUniqueInput
  }

  export type BehavioralInsightUpdateOneRequiredWithoutPatternsNestedInput = {
    create?: XOR<BehavioralInsightCreateWithoutPatternsInput, BehavioralInsightUncheckedCreateWithoutPatternsInput>
    connectOrCreate?: BehavioralInsightCreateOrConnectWithoutPatternsInput
    upsert?: BehavioralInsightUpsertWithoutPatternsInput
    connect?: BehavioralInsightWhereUniqueInput
    update?: XOR<XOR<BehavioralInsightUpdateToOneWithWhereWithoutPatternsInput, BehavioralInsightUpdateWithoutPatternsInput>, BehavioralInsightUncheckedUpdateWithoutPatternsInput>
  }

  export type BehavioralPatternUpdateOneRequiredWithoutInsightsNestedInput = {
    create?: XOR<BehavioralPatternCreateWithoutInsightsInput, BehavioralPatternUncheckedCreateWithoutInsightsInput>
    connectOrCreate?: BehavioralPatternCreateOrConnectWithoutInsightsInput
    upsert?: BehavioralPatternUpsertWithoutInsightsInput
    connect?: BehavioralPatternWhereUniqueInput
    update?: XOR<XOR<BehavioralPatternUpdateToOneWithWhereWithoutInsightsInput, BehavioralPatternUpdateWithoutInsightsInput>, BehavioralPatternUncheckedUpdateWithoutInsightsInput>
  }

  export type EnumPatternTypeFieldUpdateOperationsInput = {
    set?: $Enums.PatternType
  }

  export type LearningObjectiveCreateNestedOneWithoutStrugglePredictionsInput = {
    create?: XOR<LearningObjectiveCreateWithoutStrugglePredictionsInput, LearningObjectiveUncheckedCreateWithoutStrugglePredictionsInput>
    connectOrCreate?: LearningObjectiveCreateOrConnectWithoutStrugglePredictionsInput
    connect?: LearningObjectiveWhereUniqueInput
  }

  export type StruggleIndicatorCreateNestedManyWithoutPredictionInput = {
    create?: XOR<StruggleIndicatorCreateWithoutPredictionInput, StruggleIndicatorUncheckedCreateWithoutPredictionInput> | StruggleIndicatorCreateWithoutPredictionInput[] | StruggleIndicatorUncheckedCreateWithoutPredictionInput[]
    connectOrCreate?: StruggleIndicatorCreateOrConnectWithoutPredictionInput | StruggleIndicatorCreateOrConnectWithoutPredictionInput[]
    createMany?: StruggleIndicatorCreateManyPredictionInputEnvelope
    connect?: StruggleIndicatorWhereUniqueInput | StruggleIndicatorWhereUniqueInput[]
  }

  export type InterventionRecommendationCreateNestedManyWithoutPredictionInput = {
    create?: XOR<InterventionRecommendationCreateWithoutPredictionInput, InterventionRecommendationUncheckedCreateWithoutPredictionInput> | InterventionRecommendationCreateWithoutPredictionInput[] | InterventionRecommendationUncheckedCreateWithoutPredictionInput[]
    connectOrCreate?: InterventionRecommendationCreateOrConnectWithoutPredictionInput | InterventionRecommendationCreateOrConnectWithoutPredictionInput[]
    createMany?: InterventionRecommendationCreateManyPredictionInputEnvelope
    connect?: InterventionRecommendationWhereUniqueInput | InterventionRecommendationWhereUniqueInput[]
  }

  export type PredictionFeedbackCreateNestedManyWithoutPredictionInput = {
    create?: XOR<PredictionFeedbackCreateWithoutPredictionInput, PredictionFeedbackUncheckedCreateWithoutPredictionInput> | PredictionFeedbackCreateWithoutPredictionInput[] | PredictionFeedbackUncheckedCreateWithoutPredictionInput[]
    connectOrCreate?: PredictionFeedbackCreateOrConnectWithoutPredictionInput | PredictionFeedbackCreateOrConnectWithoutPredictionInput[]
    createMany?: PredictionFeedbackCreateManyPredictionInputEnvelope
    connect?: PredictionFeedbackWhereUniqueInput | PredictionFeedbackWhereUniqueInput[]
  }

  export type StruggleIndicatorUncheckedCreateNestedManyWithoutPredictionInput = {
    create?: XOR<StruggleIndicatorCreateWithoutPredictionInput, StruggleIndicatorUncheckedCreateWithoutPredictionInput> | StruggleIndicatorCreateWithoutPredictionInput[] | StruggleIndicatorUncheckedCreateWithoutPredictionInput[]
    connectOrCreate?: StruggleIndicatorCreateOrConnectWithoutPredictionInput | StruggleIndicatorCreateOrConnectWithoutPredictionInput[]
    createMany?: StruggleIndicatorCreateManyPredictionInputEnvelope
    connect?: StruggleIndicatorWhereUniqueInput | StruggleIndicatorWhereUniqueInput[]
  }

  export type InterventionRecommendationUncheckedCreateNestedManyWithoutPredictionInput = {
    create?: XOR<InterventionRecommendationCreateWithoutPredictionInput, InterventionRecommendationUncheckedCreateWithoutPredictionInput> | InterventionRecommendationCreateWithoutPredictionInput[] | InterventionRecommendationUncheckedCreateWithoutPredictionInput[]
    connectOrCreate?: InterventionRecommendationCreateOrConnectWithoutPredictionInput | InterventionRecommendationCreateOrConnectWithoutPredictionInput[]
    createMany?: InterventionRecommendationCreateManyPredictionInputEnvelope
    connect?: InterventionRecommendationWhereUniqueInput | InterventionRecommendationWhereUniqueInput[]
  }

  export type PredictionFeedbackUncheckedCreateNestedManyWithoutPredictionInput = {
    create?: XOR<PredictionFeedbackCreateWithoutPredictionInput, PredictionFeedbackUncheckedCreateWithoutPredictionInput> | PredictionFeedbackCreateWithoutPredictionInput[] | PredictionFeedbackUncheckedCreateWithoutPredictionInput[]
    connectOrCreate?: PredictionFeedbackCreateOrConnectWithoutPredictionInput | PredictionFeedbackCreateOrConnectWithoutPredictionInput[]
    createMany?: PredictionFeedbackCreateManyPredictionInputEnvelope
    connect?: PredictionFeedbackWhereUniqueInput | PredictionFeedbackWhereUniqueInput[]
  }

  export type EnumPredictionStatusFieldUpdateOperationsInput = {
    set?: $Enums.PredictionStatus
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type LearningObjectiveUpdateOneWithoutStrugglePredictionsNestedInput = {
    create?: XOR<LearningObjectiveCreateWithoutStrugglePredictionsInput, LearningObjectiveUncheckedCreateWithoutStrugglePredictionsInput>
    connectOrCreate?: LearningObjectiveCreateOrConnectWithoutStrugglePredictionsInput
    upsert?: LearningObjectiveUpsertWithoutStrugglePredictionsInput
    disconnect?: LearningObjectiveWhereInput | boolean
    delete?: LearningObjectiveWhereInput | boolean
    connect?: LearningObjectiveWhereUniqueInput
    update?: XOR<XOR<LearningObjectiveUpdateToOneWithWhereWithoutStrugglePredictionsInput, LearningObjectiveUpdateWithoutStrugglePredictionsInput>, LearningObjectiveUncheckedUpdateWithoutStrugglePredictionsInput>
  }

  export type StruggleIndicatorUpdateManyWithoutPredictionNestedInput = {
    create?: XOR<StruggleIndicatorCreateWithoutPredictionInput, StruggleIndicatorUncheckedCreateWithoutPredictionInput> | StruggleIndicatorCreateWithoutPredictionInput[] | StruggleIndicatorUncheckedCreateWithoutPredictionInput[]
    connectOrCreate?: StruggleIndicatorCreateOrConnectWithoutPredictionInput | StruggleIndicatorCreateOrConnectWithoutPredictionInput[]
    upsert?: StruggleIndicatorUpsertWithWhereUniqueWithoutPredictionInput | StruggleIndicatorUpsertWithWhereUniqueWithoutPredictionInput[]
    createMany?: StruggleIndicatorCreateManyPredictionInputEnvelope
    set?: StruggleIndicatorWhereUniqueInput | StruggleIndicatorWhereUniqueInput[]
    disconnect?: StruggleIndicatorWhereUniqueInput | StruggleIndicatorWhereUniqueInput[]
    delete?: StruggleIndicatorWhereUniqueInput | StruggleIndicatorWhereUniqueInput[]
    connect?: StruggleIndicatorWhereUniqueInput | StruggleIndicatorWhereUniqueInput[]
    update?: StruggleIndicatorUpdateWithWhereUniqueWithoutPredictionInput | StruggleIndicatorUpdateWithWhereUniqueWithoutPredictionInput[]
    updateMany?: StruggleIndicatorUpdateManyWithWhereWithoutPredictionInput | StruggleIndicatorUpdateManyWithWhereWithoutPredictionInput[]
    deleteMany?: StruggleIndicatorScalarWhereInput | StruggleIndicatorScalarWhereInput[]
  }

  export type InterventionRecommendationUpdateManyWithoutPredictionNestedInput = {
    create?: XOR<InterventionRecommendationCreateWithoutPredictionInput, InterventionRecommendationUncheckedCreateWithoutPredictionInput> | InterventionRecommendationCreateWithoutPredictionInput[] | InterventionRecommendationUncheckedCreateWithoutPredictionInput[]
    connectOrCreate?: InterventionRecommendationCreateOrConnectWithoutPredictionInput | InterventionRecommendationCreateOrConnectWithoutPredictionInput[]
    upsert?: InterventionRecommendationUpsertWithWhereUniqueWithoutPredictionInput | InterventionRecommendationUpsertWithWhereUniqueWithoutPredictionInput[]
    createMany?: InterventionRecommendationCreateManyPredictionInputEnvelope
    set?: InterventionRecommendationWhereUniqueInput | InterventionRecommendationWhereUniqueInput[]
    disconnect?: InterventionRecommendationWhereUniqueInput | InterventionRecommendationWhereUniqueInput[]
    delete?: InterventionRecommendationWhereUniqueInput | InterventionRecommendationWhereUniqueInput[]
    connect?: InterventionRecommendationWhereUniqueInput | InterventionRecommendationWhereUniqueInput[]
    update?: InterventionRecommendationUpdateWithWhereUniqueWithoutPredictionInput | InterventionRecommendationUpdateWithWhereUniqueWithoutPredictionInput[]
    updateMany?: InterventionRecommendationUpdateManyWithWhereWithoutPredictionInput | InterventionRecommendationUpdateManyWithWhereWithoutPredictionInput[]
    deleteMany?: InterventionRecommendationScalarWhereInput | InterventionRecommendationScalarWhereInput[]
  }

  export type PredictionFeedbackUpdateManyWithoutPredictionNestedInput = {
    create?: XOR<PredictionFeedbackCreateWithoutPredictionInput, PredictionFeedbackUncheckedCreateWithoutPredictionInput> | PredictionFeedbackCreateWithoutPredictionInput[] | PredictionFeedbackUncheckedCreateWithoutPredictionInput[]
    connectOrCreate?: PredictionFeedbackCreateOrConnectWithoutPredictionInput | PredictionFeedbackCreateOrConnectWithoutPredictionInput[]
    upsert?: PredictionFeedbackUpsertWithWhereUniqueWithoutPredictionInput | PredictionFeedbackUpsertWithWhereUniqueWithoutPredictionInput[]
    createMany?: PredictionFeedbackCreateManyPredictionInputEnvelope
    set?: PredictionFeedbackWhereUniqueInput | PredictionFeedbackWhereUniqueInput[]
    disconnect?: PredictionFeedbackWhereUniqueInput | PredictionFeedbackWhereUniqueInput[]
    delete?: PredictionFeedbackWhereUniqueInput | PredictionFeedbackWhereUniqueInput[]
    connect?: PredictionFeedbackWhereUniqueInput | PredictionFeedbackWhereUniqueInput[]
    update?: PredictionFeedbackUpdateWithWhereUniqueWithoutPredictionInput | PredictionFeedbackUpdateWithWhereUniqueWithoutPredictionInput[]
    updateMany?: PredictionFeedbackUpdateManyWithWhereWithoutPredictionInput | PredictionFeedbackUpdateManyWithWhereWithoutPredictionInput[]
    deleteMany?: PredictionFeedbackScalarWhereInput | PredictionFeedbackScalarWhereInput[]
  }

  export type StruggleIndicatorUncheckedUpdateManyWithoutPredictionNestedInput = {
    create?: XOR<StruggleIndicatorCreateWithoutPredictionInput, StruggleIndicatorUncheckedCreateWithoutPredictionInput> | StruggleIndicatorCreateWithoutPredictionInput[] | StruggleIndicatorUncheckedCreateWithoutPredictionInput[]
    connectOrCreate?: StruggleIndicatorCreateOrConnectWithoutPredictionInput | StruggleIndicatorCreateOrConnectWithoutPredictionInput[]
    upsert?: StruggleIndicatorUpsertWithWhereUniqueWithoutPredictionInput | StruggleIndicatorUpsertWithWhereUniqueWithoutPredictionInput[]
    createMany?: StruggleIndicatorCreateManyPredictionInputEnvelope
    set?: StruggleIndicatorWhereUniqueInput | StruggleIndicatorWhereUniqueInput[]
    disconnect?: StruggleIndicatorWhereUniqueInput | StruggleIndicatorWhereUniqueInput[]
    delete?: StruggleIndicatorWhereUniqueInput | StruggleIndicatorWhereUniqueInput[]
    connect?: StruggleIndicatorWhereUniqueInput | StruggleIndicatorWhereUniqueInput[]
    update?: StruggleIndicatorUpdateWithWhereUniqueWithoutPredictionInput | StruggleIndicatorUpdateWithWhereUniqueWithoutPredictionInput[]
    updateMany?: StruggleIndicatorUpdateManyWithWhereWithoutPredictionInput | StruggleIndicatorUpdateManyWithWhereWithoutPredictionInput[]
    deleteMany?: StruggleIndicatorScalarWhereInput | StruggleIndicatorScalarWhereInput[]
  }

  export type InterventionRecommendationUncheckedUpdateManyWithoutPredictionNestedInput = {
    create?: XOR<InterventionRecommendationCreateWithoutPredictionInput, InterventionRecommendationUncheckedCreateWithoutPredictionInput> | InterventionRecommendationCreateWithoutPredictionInput[] | InterventionRecommendationUncheckedCreateWithoutPredictionInput[]
    connectOrCreate?: InterventionRecommendationCreateOrConnectWithoutPredictionInput | InterventionRecommendationCreateOrConnectWithoutPredictionInput[]
    upsert?: InterventionRecommendationUpsertWithWhereUniqueWithoutPredictionInput | InterventionRecommendationUpsertWithWhereUniqueWithoutPredictionInput[]
    createMany?: InterventionRecommendationCreateManyPredictionInputEnvelope
    set?: InterventionRecommendationWhereUniqueInput | InterventionRecommendationWhereUniqueInput[]
    disconnect?: InterventionRecommendationWhereUniqueInput | InterventionRecommendationWhereUniqueInput[]
    delete?: InterventionRecommendationWhereUniqueInput | InterventionRecommendationWhereUniqueInput[]
    connect?: InterventionRecommendationWhereUniqueInput | InterventionRecommendationWhereUniqueInput[]
    update?: InterventionRecommendationUpdateWithWhereUniqueWithoutPredictionInput | InterventionRecommendationUpdateWithWhereUniqueWithoutPredictionInput[]
    updateMany?: InterventionRecommendationUpdateManyWithWhereWithoutPredictionInput | InterventionRecommendationUpdateManyWithWhereWithoutPredictionInput[]
    deleteMany?: InterventionRecommendationScalarWhereInput | InterventionRecommendationScalarWhereInput[]
  }

  export type PredictionFeedbackUncheckedUpdateManyWithoutPredictionNestedInput = {
    create?: XOR<PredictionFeedbackCreateWithoutPredictionInput, PredictionFeedbackUncheckedCreateWithoutPredictionInput> | PredictionFeedbackCreateWithoutPredictionInput[] | PredictionFeedbackUncheckedCreateWithoutPredictionInput[]
    connectOrCreate?: PredictionFeedbackCreateOrConnectWithoutPredictionInput | PredictionFeedbackCreateOrConnectWithoutPredictionInput[]
    upsert?: PredictionFeedbackUpsertWithWhereUniqueWithoutPredictionInput | PredictionFeedbackUpsertWithWhereUniqueWithoutPredictionInput[]
    createMany?: PredictionFeedbackCreateManyPredictionInputEnvelope
    set?: PredictionFeedbackWhereUniqueInput | PredictionFeedbackWhereUniqueInput[]
    disconnect?: PredictionFeedbackWhereUniqueInput | PredictionFeedbackWhereUniqueInput[]
    delete?: PredictionFeedbackWhereUniqueInput | PredictionFeedbackWhereUniqueInput[]
    connect?: PredictionFeedbackWhereUniqueInput | PredictionFeedbackWhereUniqueInput[]
    update?: PredictionFeedbackUpdateWithWhereUniqueWithoutPredictionInput | PredictionFeedbackUpdateWithWhereUniqueWithoutPredictionInput[]
    updateMany?: PredictionFeedbackUpdateManyWithWhereWithoutPredictionInput | PredictionFeedbackUpdateManyWithWhereWithoutPredictionInput[]
    deleteMany?: PredictionFeedbackScalarWhereInput | PredictionFeedbackScalarWhereInput[]
  }

  export type StrugglePredictionCreateNestedOneWithoutIndicatorsInput = {
    create?: XOR<StrugglePredictionCreateWithoutIndicatorsInput, StrugglePredictionUncheckedCreateWithoutIndicatorsInput>
    connectOrCreate?: StrugglePredictionCreateOrConnectWithoutIndicatorsInput
    connect?: StrugglePredictionWhereUniqueInput
  }

  export type LearningObjectiveCreateNestedOneWithoutStruggleIndicatorsInput = {
    create?: XOR<LearningObjectiveCreateWithoutStruggleIndicatorsInput, LearningObjectiveUncheckedCreateWithoutStruggleIndicatorsInput>
    connectOrCreate?: LearningObjectiveCreateOrConnectWithoutStruggleIndicatorsInput
    connect?: LearningObjectiveWhereUniqueInput
  }

  export type EnumIndicatorTypeFieldUpdateOperationsInput = {
    set?: $Enums.IndicatorType
  }

  export type EnumSeverityFieldUpdateOperationsInput = {
    set?: $Enums.Severity
  }

  export type StrugglePredictionUpdateOneWithoutIndicatorsNestedInput = {
    create?: XOR<StrugglePredictionCreateWithoutIndicatorsInput, StrugglePredictionUncheckedCreateWithoutIndicatorsInput>
    connectOrCreate?: StrugglePredictionCreateOrConnectWithoutIndicatorsInput
    upsert?: StrugglePredictionUpsertWithoutIndicatorsInput
    disconnect?: StrugglePredictionWhereInput | boolean
    delete?: StrugglePredictionWhereInput | boolean
    connect?: StrugglePredictionWhereUniqueInput
    update?: XOR<XOR<StrugglePredictionUpdateToOneWithWhereWithoutIndicatorsInput, StrugglePredictionUpdateWithoutIndicatorsInput>, StrugglePredictionUncheckedUpdateWithoutIndicatorsInput>
  }

  export type LearningObjectiveUpdateOneRequiredWithoutStruggleIndicatorsNestedInput = {
    create?: XOR<LearningObjectiveCreateWithoutStruggleIndicatorsInput, LearningObjectiveUncheckedCreateWithoutStruggleIndicatorsInput>
    connectOrCreate?: LearningObjectiveCreateOrConnectWithoutStruggleIndicatorsInput
    upsert?: LearningObjectiveUpsertWithoutStruggleIndicatorsInput
    connect?: LearningObjectiveWhereUniqueInput
    update?: XOR<XOR<LearningObjectiveUpdateToOneWithWhereWithoutStruggleIndicatorsInput, LearningObjectiveUpdateWithoutStruggleIndicatorsInput>, LearningObjectiveUncheckedUpdateWithoutStruggleIndicatorsInput>
  }

  export type StrugglePredictionCreateNestedOneWithoutInterventionsInput = {
    create?: XOR<StrugglePredictionCreateWithoutInterventionsInput, StrugglePredictionUncheckedCreateWithoutInterventionsInput>
    connectOrCreate?: StrugglePredictionCreateOrConnectWithoutInterventionsInput
    connect?: StrugglePredictionWhereUniqueInput
  }

  export type MissionCreateNestedOneWithoutInterventionsInput = {
    create?: XOR<MissionCreateWithoutInterventionsInput, MissionUncheckedCreateWithoutInterventionsInput>
    connectOrCreate?: MissionCreateOrConnectWithoutInterventionsInput
    connect?: MissionWhereUniqueInput
  }

  export type EnumInterventionTypeFieldUpdateOperationsInput = {
    set?: $Enums.InterventionType
  }

  export type EnumInterventionStatusFieldUpdateOperationsInput = {
    set?: $Enums.InterventionStatus
  }

  export type StrugglePredictionUpdateOneRequiredWithoutInterventionsNestedInput = {
    create?: XOR<StrugglePredictionCreateWithoutInterventionsInput, StrugglePredictionUncheckedCreateWithoutInterventionsInput>
    connectOrCreate?: StrugglePredictionCreateOrConnectWithoutInterventionsInput
    upsert?: StrugglePredictionUpsertWithoutInterventionsInput
    connect?: StrugglePredictionWhereUniqueInput
    update?: XOR<XOR<StrugglePredictionUpdateToOneWithWhereWithoutInterventionsInput, StrugglePredictionUpdateWithoutInterventionsInput>, StrugglePredictionUncheckedUpdateWithoutInterventionsInput>
  }

  export type MissionUpdateOneWithoutInterventionsNestedInput = {
    create?: XOR<MissionCreateWithoutInterventionsInput, MissionUncheckedCreateWithoutInterventionsInput>
    connectOrCreate?: MissionCreateOrConnectWithoutInterventionsInput
    upsert?: MissionUpsertWithoutInterventionsInput
    disconnect?: MissionWhereInput | boolean
    delete?: MissionWhereInput | boolean
    connect?: MissionWhereUniqueInput
    update?: XOR<XOR<MissionUpdateToOneWithWhereWithoutInterventionsInput, MissionUpdateWithoutInterventionsInput>, MissionUncheckedUpdateWithoutInterventionsInput>
  }

  export type StrugglePredictionCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<StrugglePredictionCreateWithoutFeedbacksInput, StrugglePredictionUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: StrugglePredictionCreateOrConnectWithoutFeedbacksInput
    connect?: StrugglePredictionWhereUniqueInput
  }

  export type EnumFeedbackTypeFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackType
  }

  export type StrugglePredictionUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<StrugglePredictionCreateWithoutFeedbacksInput, StrugglePredictionUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: StrugglePredictionCreateOrConnectWithoutFeedbacksInput
    upsert?: StrugglePredictionUpsertWithoutFeedbacksInput
    connect?: StrugglePredictionWhereUniqueInput
    update?: XOR<XOR<StrugglePredictionUpdateToOneWithWhereWithoutFeedbacksInput, StrugglePredictionUpdateWithoutFeedbacksInput>, StrugglePredictionUncheckedUpdateWithoutFeedbacksInput>
  }

  export type LearningObjectiveCreateNestedOneWithoutPerformanceMetricsInput = {
    create?: XOR<LearningObjectiveCreateWithoutPerformanceMetricsInput, LearningObjectiveUncheckedCreateWithoutPerformanceMetricsInput>
    connectOrCreate?: LearningObjectiveCreateOrConnectWithoutPerformanceMetricsInput
    connect?: LearningObjectiveWhereUniqueInput
  }

  export type LearningObjectiveUpdateOneRequiredWithoutPerformanceMetricsNestedInput = {
    create?: XOR<LearningObjectiveCreateWithoutPerformanceMetricsInput, LearningObjectiveUncheckedCreateWithoutPerformanceMetricsInput>
    connectOrCreate?: LearningObjectiveCreateOrConnectWithoutPerformanceMetricsInput
    upsert?: LearningObjectiveUpsertWithoutPerformanceMetricsInput
    connect?: LearningObjectiveWhereUniqueInput
    update?: XOR<XOR<LearningObjectiveUpdateToOneWithWhereWithoutPerformanceMetricsInput, LearningObjectiveUpdateWithoutPerformanceMetricsInput>, LearningObjectiveUncheckedUpdateWithoutPerformanceMetricsInput>
  }

  export type ExamCreatecoverageTopicsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutExamsInput = {
    create?: XOR<UserCreateWithoutExamsInput, UserUncheckedCreateWithoutExamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExamsInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutExamsInput = {
    create?: XOR<CourseCreateWithoutExamsInput, CourseUncheckedCreateWithoutExamsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutExamsInput
    connect?: CourseWhereUniqueInput
  }

  export type ExamUpdatecoverageTopicsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutExamsNestedInput = {
    create?: XOR<UserCreateWithoutExamsInput, UserUncheckedCreateWithoutExamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExamsInput
    upsert?: UserUpsertWithoutExamsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExamsInput, UserUpdateWithoutExamsInput>, UserUncheckedUpdateWithoutExamsInput>
  }

  export type CourseUpdateOneRequiredWithoutExamsNestedInput = {
    create?: XOR<CourseCreateWithoutExamsInput, CourseUncheckedCreateWithoutExamsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutExamsInput
    upsert?: CourseUpsertWithoutExamsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutExamsInput, CourseUpdateWithoutExamsInput>, CourseUncheckedUpdateWithoutExamsInput>
  }

  export type UserCreateNestedOneWithoutCoursePrioritiesInput = {
    create?: XOR<UserCreateWithoutCoursePrioritiesInput, UserUncheckedCreateWithoutCoursePrioritiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoursePrioritiesInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutCoursePrioritiesInput = {
    create?: XOR<CourseCreateWithoutCoursePrioritiesInput, CourseUncheckedCreateWithoutCoursePrioritiesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCoursePrioritiesInput
    connect?: CourseWhereUniqueInput
  }

  export type EnumPriorityLevelFieldUpdateOperationsInput = {
    set?: $Enums.PriorityLevel
  }

  export type UserUpdateOneRequiredWithoutCoursePrioritiesNestedInput = {
    create?: XOR<UserCreateWithoutCoursePrioritiesInput, UserUncheckedCreateWithoutCoursePrioritiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoursePrioritiesInput
    upsert?: UserUpsertWithoutCoursePrioritiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCoursePrioritiesInput, UserUpdateWithoutCoursePrioritiesInput>, UserUncheckedUpdateWithoutCoursePrioritiesInput>
  }

  export type CourseUpdateOneRequiredWithoutCoursePrioritiesNestedInput = {
    create?: XOR<CourseCreateWithoutCoursePrioritiesInput, CourseUncheckedCreateWithoutCoursePrioritiesInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCoursePrioritiesInput
    upsert?: CourseUpsertWithoutCoursePrioritiesInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutCoursePrioritiesInput, CourseUpdateWithoutCoursePrioritiesInput>, CourseUncheckedUpdateWithoutCoursePrioritiesInput>
  }

  export type LearningObjectiveCreateNestedOneWithoutPriorityFeedbackInput = {
    create?: XOR<LearningObjectiveCreateWithoutPriorityFeedbackInput, LearningObjectiveUncheckedCreateWithoutPriorityFeedbackInput>
    connectOrCreate?: LearningObjectiveCreateOrConnectWithoutPriorityFeedbackInput
    connect?: LearningObjectiveWhereUniqueInput
  }

  export type EnumFeedbackRatingFieldUpdateOperationsInput = {
    set?: $Enums.FeedbackRating
  }

  export type LearningObjectiveUpdateOneRequiredWithoutPriorityFeedbackNestedInput = {
    create?: XOR<LearningObjectiveCreateWithoutPriorityFeedbackInput, LearningObjectiveUncheckedCreateWithoutPriorityFeedbackInput>
    connectOrCreate?: LearningObjectiveCreateOrConnectWithoutPriorityFeedbackInput
    upsert?: LearningObjectiveUpsertWithoutPriorityFeedbackInput
    connect?: LearningObjectiveWhereUniqueInput
    update?: XOR<XOR<LearningObjectiveUpdateToOneWithWhereWithoutPriorityFeedbackInput, LearningObjectiveUpdateWithoutPriorityFeedbackInput>, LearningObjectiveUncheckedUpdateWithoutPriorityFeedbackInput>
  }

  export type StreakCreatefreezeUsedDatesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutStreakInput = {
    create?: XOR<UserCreateWithoutStreakInput, UserUncheckedCreateWithoutStreakInput>
    connectOrCreate?: UserCreateOrConnectWithoutStreakInput
    connect?: UserWhereUniqueInput
  }

  export type StreakUpdatefreezeUsedDatesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutStreakNestedInput = {
    create?: XOR<UserCreateWithoutStreakInput, UserUncheckedCreateWithoutStreakInput>
    connectOrCreate?: UserCreateOrConnectWithoutStreakInput
    upsert?: UserUpsertWithoutStreakInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStreakInput, UserUpdateWithoutStreakInput>, UserUncheckedUpdateWithoutStreakInput>
  }

  export type UserCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAchievementTypeFieldUpdateOperationsInput = {
    set?: $Enums.AchievementType
  }

  export type EnumAchievementTierFieldUpdateOperationsInput = {
    set?: $Enums.AchievementTier
  }

  export type UserUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    upsert?: UserUpsertWithoutAchievementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAchievementsInput, UserUpdateWithoutAchievementsInput>, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserCreateNestedOneWithoutStudyGoalsInput = {
    create?: XOR<UserCreateWithoutStudyGoalsInput, UserUncheckedCreateWithoutStudyGoalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudyGoalsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumGoalTypeFieldUpdateOperationsInput = {
    set?: $Enums.GoalType
  }

  export type EnumGoalPeriodFieldUpdateOperationsInput = {
    set?: $Enums.GoalPeriod
  }

  export type UserUpdateOneRequiredWithoutStudyGoalsNestedInput = {
    create?: XOR<UserCreateWithoutStudyGoalsInput, UserUncheckedCreateWithoutStudyGoalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudyGoalsInput
    upsert?: UserUpsertWithoutStudyGoalsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudyGoalsInput, UserUpdateWithoutStudyGoalsInput>, UserUncheckedUpdateWithoutStudyGoalsInput>
  }

  export type EnumAnalyticsPeriodFieldUpdateOperationsInput = {
    set?: $Enums.AnalyticsPeriod
  }

  export type MissionCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<MissionCreateWithoutFeedbackInput, MissionUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: MissionCreateOrConnectWithoutFeedbackInput
    connect?: MissionWhereUniqueInput
  }

  export type EnumPaceRatingFieldUpdateOperationsInput = {
    set?: $Enums.PaceRating
  }

  export type MissionUpdateOneRequiredWithoutFeedbackNestedInput = {
    create?: XOR<MissionCreateWithoutFeedbackInput, MissionUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: MissionCreateOrConnectWithoutFeedbackInput
    upsert?: MissionUpsertWithoutFeedbackInput
    connect?: MissionWhereUniqueInput
    update?: XOR<XOR<MissionUpdateToOneWithWhereWithoutFeedbackInput, MissionUpdateWithoutFeedbackInput>, MissionUncheckedUpdateWithoutFeedbackInput>
  }

  export type UserCreateNestedOneWithoutMissionStreakInput = {
    create?: XOR<UserCreateWithoutMissionStreakInput, UserUncheckedCreateWithoutMissionStreakInput>
    connectOrCreate?: UserCreateOrConnectWithoutMissionStreakInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMissionStreakNestedInput = {
    create?: XOR<UserCreateWithoutMissionStreakInput, UserUncheckedCreateWithoutMissionStreakInput>
    connectOrCreate?: UserCreateOrConnectWithoutMissionStreakInput
    upsert?: UserUpsertWithoutMissionStreakInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMissionStreakInput, UserUpdateWithoutMissionStreakInput>, UserUncheckedUpdateWithoutMissionStreakInput>
  }

  export type UserCreateNestedOneWithoutMissionReviewsInput = {
    create?: XOR<UserCreateWithoutMissionReviewsInput, UserUncheckedCreateWithoutMissionReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMissionReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReviewPeriodFieldUpdateOperationsInput = {
    set?: $Enums.ReviewPeriod
  }

  export type UserUpdateOneRequiredWithoutMissionReviewsNestedInput = {
    create?: XOR<UserCreateWithoutMissionReviewsInput, UserUncheckedCreateWithoutMissionReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMissionReviewsInput
    upsert?: UserUpsertWithoutMissionReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMissionReviewsInput, UserUpdateWithoutMissionReviewsInput>, UserUncheckedUpdateWithoutMissionReviewsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumProcessingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusFilter<$PrismaModel> | $Enums.ProcessingStatus
  }

  export type NestedEnumProcessingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcessingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessingStatusFilter<$PrismaModel>
    _max?: NestedEnumProcessingStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumObjectiveComplexityFilter<$PrismaModel = never> = {
    equals?: $Enums.ObjectiveComplexity | EnumObjectiveComplexityFieldRefInput<$PrismaModel>
    in?: $Enums.ObjectiveComplexity[] | ListEnumObjectiveComplexityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ObjectiveComplexity[] | ListEnumObjectiveComplexityFieldRefInput<$PrismaModel>
    not?: NestedEnumObjectiveComplexityFilter<$PrismaModel> | $Enums.ObjectiveComplexity
  }

  export type NestedEnumMasteryLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.MasteryLevel | EnumMasteryLevelFieldRefInput<$PrismaModel>
    in?: $Enums.MasteryLevel[] | ListEnumMasteryLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.MasteryLevel[] | ListEnumMasteryLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumMasteryLevelFilter<$PrismaModel> | $Enums.MasteryLevel
  }

  export type NestedEnumObjectiveComplexityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ObjectiveComplexity | EnumObjectiveComplexityFieldRefInput<$PrismaModel>
    in?: $Enums.ObjectiveComplexity[] | ListEnumObjectiveComplexityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ObjectiveComplexity[] | ListEnumObjectiveComplexityFieldRefInput<$PrismaModel>
    not?: NestedEnumObjectiveComplexityWithAggregatesFilter<$PrismaModel> | $Enums.ObjectiveComplexity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumObjectiveComplexityFilter<$PrismaModel>
    _max?: NestedEnumObjectiveComplexityFilter<$PrismaModel>
  }

  export type NestedEnumMasteryLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MasteryLevel | EnumMasteryLevelFieldRefInput<$PrismaModel>
    in?: $Enums.MasteryLevel[] | ListEnumMasteryLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.MasteryLevel[] | ListEnumMasteryLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumMasteryLevelWithAggregatesFilter<$PrismaModel> | $Enums.MasteryLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMasteryLevelFilter<$PrismaModel>
    _max?: NestedEnumMasteryLevelFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumMissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MissionStatus | EnumMissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MissionStatus[] | ListEnumMissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MissionStatus[] | ListEnumMissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMissionStatusFilter<$PrismaModel> | $Enums.MissionStatus
  }

  export type NestedEnumMissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MissionStatus | EnumMissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MissionStatus[] | ListEnumMissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MissionStatus[] | ListEnumMissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.MissionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMissionStatusFilter<$PrismaModel>
    _max?: NestedEnumMissionStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumCardTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CardType | EnumCardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CardType[] | ListEnumCardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CardType[] | ListEnumCardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCardTypeFilter<$PrismaModel> | $Enums.CardType
  }

  export type NestedEnumCardTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CardType | EnumCardTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CardType[] | ListEnumCardTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CardType[] | ListEnumCardTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCardTypeWithAggregatesFilter<$PrismaModel> | $Enums.CardType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCardTypeFilter<$PrismaModel>
    _max?: NestedEnumCardTypeFilter<$PrismaModel>
  }

  export type NestedEnumReviewRatingFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewRating | EnumReviewRatingFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewRating[] | ListEnumReviewRatingFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewRating[] | ListEnumReviewRatingFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewRatingFilter<$PrismaModel> | $Enums.ReviewRating
  }

  export type NestedEnumReviewRatingWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewRating | EnumReviewRatingFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewRating[] | ListEnumReviewRatingFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewRating[] | ListEnumReviewRatingFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewRatingWithAggregatesFilter<$PrismaModel> | $Enums.ReviewRating
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewRatingFilter<$PrismaModel>
    _max?: NestedEnumReviewRatingFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumRelationshipTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationshipType | EnumRelationshipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationshipType[] | ListEnumRelationshipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationshipType[] | ListEnumRelationshipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationshipTypeFilter<$PrismaModel> | $Enums.RelationshipType
  }

  export type NestedEnumRelationshipTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationshipType | EnumRelationshipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationshipType[] | ListEnumRelationshipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationshipType[] | ListEnumRelationshipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationshipTypeWithAggregatesFilter<$PrismaModel> | $Enums.RelationshipType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRelationshipTypeFilter<$PrismaModel>
    _max?: NestedEnumRelationshipTypeFilter<$PrismaModel>
  }

  export type NestedEnumPromptTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PromptType | EnumPromptTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PromptType[] | ListEnumPromptTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromptType[] | ListEnumPromptTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPromptTypeFilter<$PrismaModel> | $Enums.PromptType
  }

  export type NestedEnumPromptTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PromptType | EnumPromptTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PromptType[] | ListEnumPromptTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PromptType[] | ListEnumPromptTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPromptTypeWithAggregatesFilter<$PrismaModel> | $Enums.PromptType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPromptTypeFilter<$PrismaModel>
    _max?: NestedEnumPromptTypeFilter<$PrismaModel>
  }

  export type NestedEnumEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeFilter<$PrismaModel> | $Enums.EventType
  }

  export type NestedEnumEngagementLevelNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.EngagementLevel | EnumEngagementLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.EngagementLevel[] | ListEnumEngagementLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EngagementLevel[] | ListEnumEngagementLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEngagementLevelNullableFilter<$PrismaModel> | $Enums.EngagementLevel | null
  }

  export type NestedEnumCompletionQualityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CompletionQuality | EnumCompletionQualityFieldRefInput<$PrismaModel> | null
    in?: $Enums.CompletionQuality[] | ListEnumCompletionQualityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CompletionQuality[] | ListEnumCompletionQualityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCompletionQualityNullableFilter<$PrismaModel> | $Enums.CompletionQuality | null
  }

  export type NestedEnumEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EventType | EnumEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EventType[] | ListEnumEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumEngagementLevelNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EngagementLevel | EnumEngagementLevelFieldRefInput<$PrismaModel> | null
    in?: $Enums.EngagementLevel[] | ListEnumEngagementLevelFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.EngagementLevel[] | ListEnumEngagementLevelFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEngagementLevelNullableWithAggregatesFilter<$PrismaModel> | $Enums.EngagementLevel | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEngagementLevelNullableFilter<$PrismaModel>
    _max?: NestedEnumEngagementLevelNullableFilter<$PrismaModel>
  }

  export type NestedEnumCompletionQualityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompletionQuality | EnumCompletionQualityFieldRefInput<$PrismaModel> | null
    in?: $Enums.CompletionQuality[] | ListEnumCompletionQualityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CompletionQuality[] | ListEnumCompletionQualityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCompletionQualityNullableWithAggregatesFilter<$PrismaModel> | $Enums.CompletionQuality | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCompletionQualityNullableFilter<$PrismaModel>
    _max?: NestedEnumCompletionQualityNullableFilter<$PrismaModel>
  }

  export type NestedEnumBehavioralPatternTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BehavioralPatternType | EnumBehavioralPatternTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BehavioralPatternType[] | ListEnumBehavioralPatternTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BehavioralPatternType[] | ListEnumBehavioralPatternTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBehavioralPatternTypeFilter<$PrismaModel> | $Enums.BehavioralPatternType
  }

  export type NestedEnumBehavioralPatternTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BehavioralPatternType | EnumBehavioralPatternTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BehavioralPatternType[] | ListEnumBehavioralPatternTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BehavioralPatternType[] | ListEnumBehavioralPatternTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBehavioralPatternTypeWithAggregatesFilter<$PrismaModel> | $Enums.BehavioralPatternType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBehavioralPatternTypeFilter<$PrismaModel>
    _max?: NestedEnumBehavioralPatternTypeFilter<$PrismaModel>
  }

  export type NestedEnumInsightTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightType | EnumInsightTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InsightType[] | ListEnumInsightTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightType[] | ListEnumInsightTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightTypeFilter<$PrismaModel> | $Enums.InsightType
  }

  export type NestedEnumInsightTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightType | EnumInsightTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InsightType[] | ListEnumInsightTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightType[] | ListEnumInsightTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightTypeWithAggregatesFilter<$PrismaModel> | $Enums.InsightType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsightTypeFilter<$PrismaModel>
    _max?: NestedEnumInsightTypeFilter<$PrismaModel>
  }

  export type NestedEnumPatternTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PatternType | EnumPatternTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PatternType[] | ListEnumPatternTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PatternType[] | ListEnumPatternTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPatternTypeFilter<$PrismaModel> | $Enums.PatternType
  }

  export type NestedEnumPatternTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PatternType | EnumPatternTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PatternType[] | ListEnumPatternTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PatternType[] | ListEnumPatternTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPatternTypeWithAggregatesFilter<$PrismaModel> | $Enums.PatternType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPatternTypeFilter<$PrismaModel>
    _max?: NestedEnumPatternTypeFilter<$PrismaModel>
  }

  export type NestedEnumPredictionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PredictionStatus | EnumPredictionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PredictionStatus[] | ListEnumPredictionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PredictionStatus[] | ListEnumPredictionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPredictionStatusFilter<$PrismaModel> | $Enums.PredictionStatus
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedEnumPredictionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PredictionStatus | EnumPredictionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PredictionStatus[] | ListEnumPredictionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PredictionStatus[] | ListEnumPredictionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPredictionStatusWithAggregatesFilter<$PrismaModel> | $Enums.PredictionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPredictionStatusFilter<$PrismaModel>
    _max?: NestedEnumPredictionStatusFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumIndicatorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IndicatorType | EnumIndicatorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IndicatorType[] | ListEnumIndicatorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IndicatorType[] | ListEnumIndicatorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIndicatorTypeFilter<$PrismaModel> | $Enums.IndicatorType
  }

  export type NestedEnumSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSeverityFilter<$PrismaModel> | $Enums.Severity
  }

  export type NestedEnumIndicatorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IndicatorType | EnumIndicatorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IndicatorType[] | ListEnumIndicatorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IndicatorType[] | ListEnumIndicatorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIndicatorTypeWithAggregatesFilter<$PrismaModel> | $Enums.IndicatorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIndicatorTypeFilter<$PrismaModel>
    _max?: NestedEnumIndicatorTypeFilter<$PrismaModel>
  }

  export type NestedEnumSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Severity | EnumSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Severity[] | ListEnumSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumSeverityWithAggregatesFilter<$PrismaModel> | $Enums.Severity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSeverityFilter<$PrismaModel>
    _max?: NestedEnumSeverityFilter<$PrismaModel>
  }

  export type NestedEnumInterventionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InterventionType | EnumInterventionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InterventionType[] | ListEnumInterventionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterventionType[] | ListEnumInterventionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInterventionTypeFilter<$PrismaModel> | $Enums.InterventionType
  }

  export type NestedEnumInterventionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InterventionStatus | EnumInterventionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InterventionStatus[] | ListEnumInterventionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterventionStatus[] | ListEnumInterventionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInterventionStatusFilter<$PrismaModel> | $Enums.InterventionStatus
  }

  export type NestedEnumInterventionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterventionType | EnumInterventionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InterventionType[] | ListEnumInterventionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterventionType[] | ListEnumInterventionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInterventionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InterventionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInterventionTypeFilter<$PrismaModel>
    _max?: NestedEnumInterventionTypeFilter<$PrismaModel>
  }

  export type NestedEnumInterventionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InterventionStatus | EnumInterventionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InterventionStatus[] | ListEnumInterventionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InterventionStatus[] | ListEnumInterventionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInterventionStatusWithAggregatesFilter<$PrismaModel> | $Enums.InterventionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInterventionStatusFilter<$PrismaModel>
    _max?: NestedEnumInterventionStatusFilter<$PrismaModel>
  }

  export type NestedEnumFeedbackTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeFilter<$PrismaModel> | $Enums.FeedbackType
  }

  export type NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackType | EnumFeedbackTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackType[] | ListEnumFeedbackTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackTypeFilter<$PrismaModel>
    _max?: NestedEnumFeedbackTypeFilter<$PrismaModel>
  }

  export type NestedEnumPriorityLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.PriorityLevel | EnumPriorityLevelFieldRefInput<$PrismaModel>
    in?: $Enums.PriorityLevel[] | ListEnumPriorityLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PriorityLevel[] | ListEnumPriorityLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityLevelFilter<$PrismaModel> | $Enums.PriorityLevel
  }

  export type NestedEnumPriorityLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PriorityLevel | EnumPriorityLevelFieldRefInput<$PrismaModel>
    in?: $Enums.PriorityLevel[] | ListEnumPriorityLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PriorityLevel[] | ListEnumPriorityLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityLevelWithAggregatesFilter<$PrismaModel> | $Enums.PriorityLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityLevelFilter<$PrismaModel>
    _max?: NestedEnumPriorityLevelFilter<$PrismaModel>
  }

  export type NestedEnumFeedbackRatingFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackRating | EnumFeedbackRatingFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackRating[] | ListEnumFeedbackRatingFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackRating[] | ListEnumFeedbackRatingFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackRatingFilter<$PrismaModel> | $Enums.FeedbackRating
  }

  export type NestedEnumFeedbackRatingWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeedbackRating | EnumFeedbackRatingFieldRefInput<$PrismaModel>
    in?: $Enums.FeedbackRating[] | ListEnumFeedbackRatingFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeedbackRating[] | ListEnumFeedbackRatingFieldRefInput<$PrismaModel>
    not?: NestedEnumFeedbackRatingWithAggregatesFilter<$PrismaModel> | $Enums.FeedbackRating
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeedbackRatingFilter<$PrismaModel>
    _max?: NestedEnumFeedbackRatingFilter<$PrismaModel>
  }

  export type NestedEnumAchievementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementType | EnumAchievementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementType[] | ListEnumAchievementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementType[] | ListEnumAchievementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementTypeFilter<$PrismaModel> | $Enums.AchievementType
  }

  export type NestedEnumAchievementTierFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementTier | EnumAchievementTierFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementTier[] | ListEnumAchievementTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementTier[] | ListEnumAchievementTierFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementTierFilter<$PrismaModel> | $Enums.AchievementTier
  }

  export type NestedEnumAchievementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementType | EnumAchievementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementType[] | ListEnumAchievementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementType[] | ListEnumAchievementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementTypeWithAggregatesFilter<$PrismaModel> | $Enums.AchievementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAchievementTypeFilter<$PrismaModel>
    _max?: NestedEnumAchievementTypeFilter<$PrismaModel>
  }

  export type NestedEnumAchievementTierWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AchievementTier | EnumAchievementTierFieldRefInput<$PrismaModel>
    in?: $Enums.AchievementTier[] | ListEnumAchievementTierFieldRefInput<$PrismaModel>
    notIn?: $Enums.AchievementTier[] | ListEnumAchievementTierFieldRefInput<$PrismaModel>
    not?: NestedEnumAchievementTierWithAggregatesFilter<$PrismaModel> | $Enums.AchievementTier
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAchievementTierFilter<$PrismaModel>
    _max?: NestedEnumAchievementTierFilter<$PrismaModel>
  }

  export type NestedEnumGoalTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalType | EnumGoalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GoalType[] | ListEnumGoalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GoalType[] | ListEnumGoalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGoalTypeFilter<$PrismaModel> | $Enums.GoalType
  }

  export type NestedEnumGoalPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalPeriod | EnumGoalPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.GoalPeriod[] | ListEnumGoalPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.GoalPeriod[] | ListEnumGoalPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumGoalPeriodFilter<$PrismaModel> | $Enums.GoalPeriod
  }

  export type NestedEnumGoalTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalType | EnumGoalTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GoalType[] | ListEnumGoalTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GoalType[] | ListEnumGoalTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGoalTypeWithAggregatesFilter<$PrismaModel> | $Enums.GoalType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGoalTypeFilter<$PrismaModel>
    _max?: NestedEnumGoalTypeFilter<$PrismaModel>
  }

  export type NestedEnumGoalPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GoalPeriod | EnumGoalPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.GoalPeriod[] | ListEnumGoalPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.GoalPeriod[] | ListEnumGoalPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumGoalPeriodWithAggregatesFilter<$PrismaModel> | $Enums.GoalPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGoalPeriodFilter<$PrismaModel>
    _max?: NestedEnumGoalPeriodFilter<$PrismaModel>
  }

  export type NestedEnumAnalyticsPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalyticsPeriod | EnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.AnalyticsPeriod[] | ListEnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalyticsPeriod[] | ListEnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalyticsPeriodFilter<$PrismaModel> | $Enums.AnalyticsPeriod
  }

  export type NestedEnumAnalyticsPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalyticsPeriod | EnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.AnalyticsPeriod[] | ListEnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.AnalyticsPeriod[] | ListEnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumAnalyticsPeriodWithAggregatesFilter<$PrismaModel> | $Enums.AnalyticsPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnalyticsPeriodFilter<$PrismaModel>
    _max?: NestedEnumAnalyticsPeriodFilter<$PrismaModel>
  }

  export type NestedEnumPaceRatingFilter<$PrismaModel = never> = {
    equals?: $Enums.PaceRating | EnumPaceRatingFieldRefInput<$PrismaModel>
    in?: $Enums.PaceRating[] | ListEnumPaceRatingFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaceRating[] | ListEnumPaceRatingFieldRefInput<$PrismaModel>
    not?: NestedEnumPaceRatingFilter<$PrismaModel> | $Enums.PaceRating
  }

  export type NestedEnumPaceRatingWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaceRating | EnumPaceRatingFieldRefInput<$PrismaModel>
    in?: $Enums.PaceRating[] | ListEnumPaceRatingFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaceRating[] | ListEnumPaceRatingFieldRefInput<$PrismaModel>
    not?: NestedEnumPaceRatingWithAggregatesFilter<$PrismaModel> | $Enums.PaceRating
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaceRatingFilter<$PrismaModel>
    _max?: NestedEnumPaceRatingFilter<$PrismaModel>
  }

  export type NestedEnumReviewPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewPeriod | EnumReviewPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewPeriod[] | ListEnumReviewPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewPeriod[] | ListEnumReviewPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewPeriodFilter<$PrismaModel> | $Enums.ReviewPeriod
  }

  export type NestedEnumReviewPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewPeriod | EnumReviewPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewPeriod[] | ListEnumReviewPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewPeriod[] | ListEnumReviewPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewPeriodWithAggregatesFilter<$PrismaModel> | $Enums.ReviewPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewPeriodFilter<$PrismaModel>
    _max?: NestedEnumReviewPeriodFilter<$PrismaModel>
  }

  export type CourseCreateWithoutUserInput = {
    id?: string
    name: string
    code?: string | null
    term?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lectures?: LectureCreateNestedManyWithoutCourseInput
    cards?: CardCreateNestedManyWithoutCourseInput
    exams?: ExamCreateNestedManyWithoutCourseInput
    coursePriorities?: CoursePriorityCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    code?: string | null
    term?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lectures?: LectureUncheckedCreateNestedManyWithoutCourseInput
    cards?: CardUncheckedCreateNestedManyWithoutCourseInput
    exams?: ExamUncheckedCreateNestedManyWithoutCourseInput
    coursePriorities?: CoursePriorityUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutUserInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutUserInput, CourseUncheckedCreateWithoutUserInput>
  }

  export type CourseCreateManyUserInputEnvelope = {
    data: CourseCreateManyUserInput | CourseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LectureCreateWithoutUserInput = {
    id?: string
    title: string
    fileName: string
    fileUrl: string
    fileSize: number
    processingStatus?: $Enums.ProcessingStatus
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    processingProgress?: number
    totalPages?: number | null
    processedPages?: number
    processingStartedAt?: Date | string | null
    estimatedCompletionAt?: Date | string | null
    weekNumber?: number | null
    topicTags?: LectureCreatetopicTagsInput | string[]
    course: CourseCreateNestedOneWithoutLecturesInput
    contentChunks?: ContentChunkCreateNestedManyWithoutLectureInput
    learningObjectives?: LearningObjectiveCreateNestedManyWithoutLectureInput
    cards?: CardCreateNestedManyWithoutLectureInput
  }

  export type LectureUncheckedCreateWithoutUserInput = {
    id?: string
    courseId: string
    title: string
    fileName: string
    fileUrl: string
    fileSize: number
    processingStatus?: $Enums.ProcessingStatus
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    processingProgress?: number
    totalPages?: number | null
    processedPages?: number
    processingStartedAt?: Date | string | null
    estimatedCompletionAt?: Date | string | null
    weekNumber?: number | null
    topicTags?: LectureCreatetopicTagsInput | string[]
    contentChunks?: ContentChunkUncheckedCreateNestedManyWithoutLectureInput
    learningObjectives?: LearningObjectiveUncheckedCreateNestedManyWithoutLectureInput
    cards?: CardUncheckedCreateNestedManyWithoutLectureInput
  }

  export type LectureCreateOrConnectWithoutUserInput = {
    where: LectureWhereUniqueInput
    create: XOR<LectureCreateWithoutUserInput, LectureUncheckedCreateWithoutUserInput>
  }

  export type LectureCreateManyUserInputEnvelope = {
    data: LectureCreateManyUserInput | LectureCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StudySessionCreateWithoutUserInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    reviewsCompleted?: number
    newCardsStudied?: number
    sessionNotes?: string | null
    currentObjectiveIndex?: number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
    mission?: MissionCreateNestedOneWithoutStudySessionsInput
    reviews?: ReviewCreateNestedManyWithoutSessionInput
    validationResponses?: ValidationResponseCreateNestedManyWithoutSessionInput
  }

  export type StudySessionUncheckedCreateWithoutUserInput = {
    id?: string
    missionId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    reviewsCompleted?: number
    newCardsStudied?: number
    sessionNotes?: string | null
    currentObjectiveIndex?: number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
    reviews?: ReviewUncheckedCreateNestedManyWithoutSessionInput
    validationResponses?: ValidationResponseUncheckedCreateNestedManyWithoutSessionInput
  }

  export type StudySessionCreateOrConnectWithoutUserInput = {
    where: StudySessionWhereUniqueInput
    create: XOR<StudySessionCreateWithoutUserInput, StudySessionUncheckedCreateWithoutUserInput>
  }

  export type StudySessionCreateManyUserInputEnvelope = {
    data: StudySessionCreateManyUserInput | StudySessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MissionCreateWithoutUserInput = {
    id?: string
    date?: Date | string
    status?: $Enums.MissionStatus
    estimatedMinutes: number
    completedAt?: Date | string | null
    actualMinutes?: number | null
    completedObjectivesCount?: number
    objectives: JsonNullValueInput | InputJsonValue
    reviewCardCount?: number
    newContentCount?: number
    successScore?: number | null
    difficultyRating?: number | null
    studySessions?: StudySessionCreateNestedManyWithoutMissionInput
    feedback?: MissionFeedbackCreateNestedManyWithoutMissionInput
    interventions?: InterventionRecommendationCreateNestedManyWithoutMissionInput
  }

  export type MissionUncheckedCreateWithoutUserInput = {
    id?: string
    date?: Date | string
    status?: $Enums.MissionStatus
    estimatedMinutes: number
    completedAt?: Date | string | null
    actualMinutes?: number | null
    completedObjectivesCount?: number
    objectives: JsonNullValueInput | InputJsonValue
    reviewCardCount?: number
    newContentCount?: number
    successScore?: number | null
    difficultyRating?: number | null
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutMissionInput
    feedback?: MissionFeedbackUncheckedCreateNestedManyWithoutMissionInput
    interventions?: InterventionRecommendationUncheckedCreateNestedManyWithoutMissionInput
  }

  export type MissionCreateOrConnectWithoutUserInput = {
    where: MissionWhereUniqueInput
    create: XOR<MissionCreateWithoutUserInput, MissionUncheckedCreateWithoutUserInput>
  }

  export type MissionCreateManyUserInputEnvelope = {
    data: MissionCreateManyUserInput | MissionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutUserInput = {
    id?: string
    rating: $Enums.ReviewRating
    timeSpentMs: number
    reviewedAt?: Date | string
    difficultyBefore: number
    stabilityBefore: number
    difficultyAfter: number
    stabilityAfter: number
    card: CardCreateNestedOneWithoutReviewsInput
    session?: StudySessionCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: string
    cardId: string
    sessionId?: string | null
    rating: $Enums.ReviewRating
    timeSpentMs: number
    reviewedAt?: Date | string
    difficultyBefore: number
    stabilityBefore: number
    difficultyAfter: number
    stabilityAfter: number
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExamCreateWithoutUserInput = {
    id?: string
    name: string
    date: Date | string
    coverageTopics?: ExamCreatecoverageTopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutExamsInput
  }

  export type ExamUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    date: Date | string
    courseId: string
    coverageTopics?: ExamCreatecoverageTopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamCreateOrConnectWithoutUserInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutUserInput, ExamUncheckedCreateWithoutUserInput>
  }

  export type ExamCreateManyUserInputEnvelope = {
    data: ExamCreateManyUserInput | ExamCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CoursePriorityCreateWithoutUserInput = {
    id?: string
    priorityLevel?: $Enums.PriorityLevel
    createdAt?: Date | string
    updatedAt?: Date | string
    course: CourseCreateNestedOneWithoutCoursePrioritiesInput
  }

  export type CoursePriorityUncheckedCreateWithoutUserInput = {
    id?: string
    courseId: string
    priorityLevel?: $Enums.PriorityLevel
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoursePriorityCreateOrConnectWithoutUserInput = {
    where: CoursePriorityWhereUniqueInput
    create: XOR<CoursePriorityCreateWithoutUserInput, CoursePriorityUncheckedCreateWithoutUserInput>
  }

  export type CoursePriorityCreateManyUserInputEnvelope = {
    data: CoursePriorityCreateManyUserInput | CoursePriorityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StreakCreateWithoutUserInput = {
    id?: string
    currentStreak?: number
    longestStreak?: number
    lastStudyDate?: Date | string | null
    freezesRemaining?: number
    freezeUsedDates?: StreakCreatefreezeUsedDatesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StreakUncheckedCreateWithoutUserInput = {
    id?: string
    currentStreak?: number
    longestStreak?: number
    lastStudyDate?: Date | string | null
    freezesRemaining?: number
    freezeUsedDates?: StreakCreatefreezeUsedDatesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StreakCreateOrConnectWithoutUserInput = {
    where: StreakWhereUniqueInput
    create: XOR<StreakCreateWithoutUserInput, StreakUncheckedCreateWithoutUserInput>
  }

  export type AchievementCreateWithoutUserInput = {
    id?: string
    type: $Enums.AchievementType
    name: string
    description: string
    tier?: $Enums.AchievementTier
    earnedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AchievementUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.AchievementType
    name: string
    description: string
    tier?: $Enums.AchievementTier
    earnedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AchievementCreateOrConnectWithoutUserInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput>
  }

  export type AchievementCreateManyUserInputEnvelope = {
    data: AchievementCreateManyUserInput | AchievementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StudyGoalCreateWithoutUserInput = {
    id?: string
    goalType: $Enums.GoalType
    targetValue: number
    currentProgress?: number
    period: $Enums.GoalPeriod
    startDate: Date | string
    endDate: Date | string
    isCompleted?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type StudyGoalUncheckedCreateWithoutUserInput = {
    id?: string
    goalType: $Enums.GoalType
    targetValue: number
    currentProgress?: number
    period: $Enums.GoalPeriod
    startDate: Date | string
    endDate: Date | string
    isCompleted?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type StudyGoalCreateOrConnectWithoutUserInput = {
    where: StudyGoalWhereUniqueInput
    create: XOR<StudyGoalCreateWithoutUserInput, StudyGoalUncheckedCreateWithoutUserInput>
  }

  export type StudyGoalCreateManyUserInputEnvelope = {
    data: StudyGoalCreateManyUserInput | StudyGoalCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MissionStreakCreateWithoutUserInput = {
    id?: string
    currentStreak?: number
    longestStreak?: number
    lastCompletedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MissionStreakUncheckedCreateWithoutUserInput = {
    id?: string
    currentStreak?: number
    longestStreak?: number
    lastCompletedDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MissionStreakCreateOrConnectWithoutUserInput = {
    where: MissionStreakWhereUniqueInput
    create: XOR<MissionStreakCreateWithoutUserInput, MissionStreakUncheckedCreateWithoutUserInput>
  }

  export type MissionReviewCreateWithoutUserInput = {
    id?: string
    period: $Enums.ReviewPeriod
    startDate: Date | string
    endDate: Date | string
    summary: JsonNullValueInput | InputJsonValue
    highlights: JsonNullValueInput | InputJsonValue
    insights: JsonNullValueInput | InputJsonValue
    recommendations: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
  }

  export type MissionReviewUncheckedCreateWithoutUserInput = {
    id?: string
    period: $Enums.ReviewPeriod
    startDate: Date | string
    endDate: Date | string
    summary: JsonNullValueInput | InputJsonValue
    highlights: JsonNullValueInput | InputJsonValue
    insights: JsonNullValueInput | InputJsonValue
    recommendations: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
  }

  export type MissionReviewCreateOrConnectWithoutUserInput = {
    where: MissionReviewWhereUniqueInput
    create: XOR<MissionReviewCreateWithoutUserInput, MissionReviewUncheckedCreateWithoutUserInput>
  }

  export type MissionReviewCreateManyUserInputEnvelope = {
    data: MissionReviewCreateManyUserInput | MissionReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithWhereUniqueWithoutUserInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutUserInput, CourseUncheckedUpdateWithoutUserInput>
    create: XOR<CourseCreateWithoutUserInput, CourseUncheckedCreateWithoutUserInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutUserInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutUserInput, CourseUncheckedUpdateWithoutUserInput>
  }

  export type CourseUpdateManyWithWhereWithoutUserInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutUserInput>
  }

  export type CourseScalarWhereInput = {
    AND?: CourseScalarWhereInput | CourseScalarWhereInput[]
    OR?: CourseScalarWhereInput[]
    NOT?: CourseScalarWhereInput | CourseScalarWhereInput[]
    id?: StringFilter<"Course"> | string
    userId?: StringFilter<"Course"> | string
    name?: StringFilter<"Course"> | string
    code?: StringNullableFilter<"Course"> | string | null
    term?: StringNullableFilter<"Course"> | string | null
    color?: StringNullableFilter<"Course"> | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    updatedAt?: DateTimeFilter<"Course"> | Date | string
  }

  export type LectureUpsertWithWhereUniqueWithoutUserInput = {
    where: LectureWhereUniqueInput
    update: XOR<LectureUpdateWithoutUserInput, LectureUncheckedUpdateWithoutUserInput>
    create: XOR<LectureCreateWithoutUserInput, LectureUncheckedCreateWithoutUserInput>
  }

  export type LectureUpdateWithWhereUniqueWithoutUserInput = {
    where: LectureWhereUniqueInput
    data: XOR<LectureUpdateWithoutUserInput, LectureUncheckedUpdateWithoutUserInput>
  }

  export type LectureUpdateManyWithWhereWithoutUserInput = {
    where: LectureScalarWhereInput
    data: XOR<LectureUpdateManyMutationInput, LectureUncheckedUpdateManyWithoutUserInput>
  }

  export type LectureScalarWhereInput = {
    AND?: LectureScalarWhereInput | LectureScalarWhereInput[]
    OR?: LectureScalarWhereInput[]
    NOT?: LectureScalarWhereInput | LectureScalarWhereInput[]
    id?: StringFilter<"Lecture"> | string
    userId?: StringFilter<"Lecture"> | string
    courseId?: StringFilter<"Lecture"> | string
    title?: StringFilter<"Lecture"> | string
    fileName?: StringFilter<"Lecture"> | string
    fileUrl?: StringFilter<"Lecture"> | string
    fileSize?: IntFilter<"Lecture"> | number
    processingStatus?: EnumProcessingStatusFilter<"Lecture"> | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFilter<"Lecture"> | Date | string
    processedAt?: DateTimeNullableFilter<"Lecture"> | Date | string | null
    processingProgress?: IntFilter<"Lecture"> | number
    totalPages?: IntNullableFilter<"Lecture"> | number | null
    processedPages?: IntFilter<"Lecture"> | number
    processingStartedAt?: DateTimeNullableFilter<"Lecture"> | Date | string | null
    estimatedCompletionAt?: DateTimeNullableFilter<"Lecture"> | Date | string | null
    weekNumber?: IntNullableFilter<"Lecture"> | number | null
    topicTags?: StringNullableListFilter<"Lecture">
  }

  export type StudySessionUpsertWithWhereUniqueWithoutUserInput = {
    where: StudySessionWhereUniqueInput
    update: XOR<StudySessionUpdateWithoutUserInput, StudySessionUncheckedUpdateWithoutUserInput>
    create: XOR<StudySessionCreateWithoutUserInput, StudySessionUncheckedCreateWithoutUserInput>
  }

  export type StudySessionUpdateWithWhereUniqueWithoutUserInput = {
    where: StudySessionWhereUniqueInput
    data: XOR<StudySessionUpdateWithoutUserInput, StudySessionUncheckedUpdateWithoutUserInput>
  }

  export type StudySessionUpdateManyWithWhereWithoutUserInput = {
    where: StudySessionScalarWhereInput
    data: XOR<StudySessionUpdateManyMutationInput, StudySessionUncheckedUpdateManyWithoutUserInput>
  }

  export type StudySessionScalarWhereInput = {
    AND?: StudySessionScalarWhereInput | StudySessionScalarWhereInput[]
    OR?: StudySessionScalarWhereInput[]
    NOT?: StudySessionScalarWhereInput | StudySessionScalarWhereInput[]
    id?: StringFilter<"StudySession"> | string
    userId?: StringFilter<"StudySession"> | string
    missionId?: StringNullableFilter<"StudySession"> | string | null
    startedAt?: DateTimeFilter<"StudySession"> | Date | string
    completedAt?: DateTimeNullableFilter<"StudySession"> | Date | string | null
    durationMs?: IntNullableFilter<"StudySession"> | number | null
    reviewsCompleted?: IntFilter<"StudySession"> | number
    newCardsStudied?: IntFilter<"StudySession"> | number
    sessionNotes?: StringNullableFilter<"StudySession"> | string | null
    currentObjectiveIndex?: IntFilter<"StudySession"> | number
    missionObjectives?: JsonNullableFilter<"StudySession">
    objectiveCompletions?: JsonNullableFilter<"StudySession">
  }

  export type MissionUpsertWithWhereUniqueWithoutUserInput = {
    where: MissionWhereUniqueInput
    update: XOR<MissionUpdateWithoutUserInput, MissionUncheckedUpdateWithoutUserInput>
    create: XOR<MissionCreateWithoutUserInput, MissionUncheckedCreateWithoutUserInput>
  }

  export type MissionUpdateWithWhereUniqueWithoutUserInput = {
    where: MissionWhereUniqueInput
    data: XOR<MissionUpdateWithoutUserInput, MissionUncheckedUpdateWithoutUserInput>
  }

  export type MissionUpdateManyWithWhereWithoutUserInput = {
    where: MissionScalarWhereInput
    data: XOR<MissionUpdateManyMutationInput, MissionUncheckedUpdateManyWithoutUserInput>
  }

  export type MissionScalarWhereInput = {
    AND?: MissionScalarWhereInput | MissionScalarWhereInput[]
    OR?: MissionScalarWhereInput[]
    NOT?: MissionScalarWhereInput | MissionScalarWhereInput[]
    id?: StringFilter<"Mission"> | string
    userId?: StringFilter<"Mission"> | string
    date?: DateTimeFilter<"Mission"> | Date | string
    status?: EnumMissionStatusFilter<"Mission"> | $Enums.MissionStatus
    estimatedMinutes?: IntFilter<"Mission"> | number
    completedAt?: DateTimeNullableFilter<"Mission"> | Date | string | null
    actualMinutes?: IntNullableFilter<"Mission"> | number | null
    completedObjectivesCount?: IntFilter<"Mission"> | number
    objectives?: JsonFilter<"Mission">
    reviewCardCount?: IntFilter<"Mission"> | number
    newContentCount?: IntFilter<"Mission"> | number
    successScore?: FloatNullableFilter<"Mission"> | number | null
    difficultyRating?: IntNullableFilter<"Mission"> | number | null
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    cardId?: StringFilter<"Review"> | string
    sessionId?: StringNullableFilter<"Review"> | string | null
    rating?: EnumReviewRatingFilter<"Review"> | $Enums.ReviewRating
    timeSpentMs?: IntFilter<"Review"> | number
    reviewedAt?: DateTimeFilter<"Review"> | Date | string
    difficultyBefore?: FloatFilter<"Review"> | number
    stabilityBefore?: FloatFilter<"Review"> | number
    difficultyAfter?: FloatFilter<"Review"> | number
    stabilityAfter?: FloatFilter<"Review"> | number
  }

  export type ExamUpsertWithWhereUniqueWithoutUserInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutUserInput, ExamUncheckedUpdateWithoutUserInput>
    create: XOR<ExamCreateWithoutUserInput, ExamUncheckedCreateWithoutUserInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutUserInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutUserInput, ExamUncheckedUpdateWithoutUserInput>
  }

  export type ExamUpdateManyWithWhereWithoutUserInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutUserInput>
  }

  export type ExamScalarWhereInput = {
    AND?: ExamScalarWhereInput | ExamScalarWhereInput[]
    OR?: ExamScalarWhereInput[]
    NOT?: ExamScalarWhereInput | ExamScalarWhereInput[]
    id?: StringFilter<"Exam"> | string
    userId?: StringFilter<"Exam"> | string
    name?: StringFilter<"Exam"> | string
    date?: DateTimeFilter<"Exam"> | Date | string
    courseId?: StringFilter<"Exam"> | string
    coverageTopics?: StringNullableListFilter<"Exam">
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
  }

  export type CoursePriorityUpsertWithWhereUniqueWithoutUserInput = {
    where: CoursePriorityWhereUniqueInput
    update: XOR<CoursePriorityUpdateWithoutUserInput, CoursePriorityUncheckedUpdateWithoutUserInput>
    create: XOR<CoursePriorityCreateWithoutUserInput, CoursePriorityUncheckedCreateWithoutUserInput>
  }

  export type CoursePriorityUpdateWithWhereUniqueWithoutUserInput = {
    where: CoursePriorityWhereUniqueInput
    data: XOR<CoursePriorityUpdateWithoutUserInput, CoursePriorityUncheckedUpdateWithoutUserInput>
  }

  export type CoursePriorityUpdateManyWithWhereWithoutUserInput = {
    where: CoursePriorityScalarWhereInput
    data: XOR<CoursePriorityUpdateManyMutationInput, CoursePriorityUncheckedUpdateManyWithoutUserInput>
  }

  export type CoursePriorityScalarWhereInput = {
    AND?: CoursePriorityScalarWhereInput | CoursePriorityScalarWhereInput[]
    OR?: CoursePriorityScalarWhereInput[]
    NOT?: CoursePriorityScalarWhereInput | CoursePriorityScalarWhereInput[]
    id?: StringFilter<"CoursePriority"> | string
    userId?: StringFilter<"CoursePriority"> | string
    courseId?: StringFilter<"CoursePriority"> | string
    priorityLevel?: EnumPriorityLevelFilter<"CoursePriority"> | $Enums.PriorityLevel
    createdAt?: DateTimeFilter<"CoursePriority"> | Date | string
    updatedAt?: DateTimeFilter<"CoursePriority"> | Date | string
  }

  export type StreakUpsertWithoutUserInput = {
    update: XOR<StreakUpdateWithoutUserInput, StreakUncheckedUpdateWithoutUserInput>
    create: XOR<StreakCreateWithoutUserInput, StreakUncheckedCreateWithoutUserInput>
    where?: StreakWhereInput
  }

  export type StreakUpdateToOneWithWhereWithoutUserInput = {
    where?: StreakWhereInput
    data: XOR<StreakUpdateWithoutUserInput, StreakUncheckedUpdateWithoutUserInput>
  }

  export type StreakUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastStudyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    freezesRemaining?: IntFieldUpdateOperationsInput | number
    freezeUsedDates?: StreakUpdatefreezeUsedDatesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StreakUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastStudyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    freezesRemaining?: IntFieldUpdateOperationsInput | number
    freezeUsedDates?: StreakUpdatefreezeUsedDatesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUpsertWithWhereUniqueWithoutUserInput = {
    where: AchievementWhereUniqueInput
    update: XOR<AchievementUpdateWithoutUserInput, AchievementUncheckedUpdateWithoutUserInput>
    create: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput>
  }

  export type AchievementUpdateWithWhereUniqueWithoutUserInput = {
    where: AchievementWhereUniqueInput
    data: XOR<AchievementUpdateWithoutUserInput, AchievementUncheckedUpdateWithoutUserInput>
  }

  export type AchievementUpdateManyWithWhereWithoutUserInput = {
    where: AchievementScalarWhereInput
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyWithoutUserInput>
  }

  export type AchievementScalarWhereInput = {
    AND?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
    OR?: AchievementScalarWhereInput[]
    NOT?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
    id?: StringFilter<"Achievement"> | string
    userId?: StringFilter<"Achievement"> | string
    type?: EnumAchievementTypeFilter<"Achievement"> | $Enums.AchievementType
    name?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    tier?: EnumAchievementTierFilter<"Achievement"> | $Enums.AchievementTier
    earnedAt?: DateTimeFilter<"Achievement"> | Date | string
    metadata?: JsonNullableFilter<"Achievement">
  }

  export type StudyGoalUpsertWithWhereUniqueWithoutUserInput = {
    where: StudyGoalWhereUniqueInput
    update: XOR<StudyGoalUpdateWithoutUserInput, StudyGoalUncheckedUpdateWithoutUserInput>
    create: XOR<StudyGoalCreateWithoutUserInput, StudyGoalUncheckedCreateWithoutUserInput>
  }

  export type StudyGoalUpdateWithWhereUniqueWithoutUserInput = {
    where: StudyGoalWhereUniqueInput
    data: XOR<StudyGoalUpdateWithoutUserInput, StudyGoalUncheckedUpdateWithoutUserInput>
  }

  export type StudyGoalUpdateManyWithWhereWithoutUserInput = {
    where: StudyGoalScalarWhereInput
    data: XOR<StudyGoalUpdateManyMutationInput, StudyGoalUncheckedUpdateManyWithoutUserInput>
  }

  export type StudyGoalScalarWhereInput = {
    AND?: StudyGoalScalarWhereInput | StudyGoalScalarWhereInput[]
    OR?: StudyGoalScalarWhereInput[]
    NOT?: StudyGoalScalarWhereInput | StudyGoalScalarWhereInput[]
    id?: StringFilter<"StudyGoal"> | string
    userId?: StringFilter<"StudyGoal"> | string
    goalType?: EnumGoalTypeFilter<"StudyGoal"> | $Enums.GoalType
    targetValue?: IntFilter<"StudyGoal"> | number
    currentProgress?: IntFilter<"StudyGoal"> | number
    period?: EnumGoalPeriodFilter<"StudyGoal"> | $Enums.GoalPeriod
    startDate?: DateTimeFilter<"StudyGoal"> | Date | string
    endDate?: DateTimeFilter<"StudyGoal"> | Date | string
    isCompleted?: BoolFilter<"StudyGoal"> | boolean
    completedAt?: DateTimeNullableFilter<"StudyGoal"> | Date | string | null
    createdAt?: DateTimeFilter<"StudyGoal"> | Date | string
  }

  export type MissionStreakUpsertWithoutUserInput = {
    update: XOR<MissionStreakUpdateWithoutUserInput, MissionStreakUncheckedUpdateWithoutUserInput>
    create: XOR<MissionStreakCreateWithoutUserInput, MissionStreakUncheckedCreateWithoutUserInput>
    where?: MissionStreakWhereInput
  }

  export type MissionStreakUpdateToOneWithWhereWithoutUserInput = {
    where?: MissionStreakWhereInput
    data: XOR<MissionStreakUpdateWithoutUserInput, MissionStreakUncheckedUpdateWithoutUserInput>
  }

  export type MissionStreakUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionStreakUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: MissionReviewWhereUniqueInput
    update: XOR<MissionReviewUpdateWithoutUserInput, MissionReviewUncheckedUpdateWithoutUserInput>
    create: XOR<MissionReviewCreateWithoutUserInput, MissionReviewUncheckedCreateWithoutUserInput>
  }

  export type MissionReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: MissionReviewWhereUniqueInput
    data: XOR<MissionReviewUpdateWithoutUserInput, MissionReviewUncheckedUpdateWithoutUserInput>
  }

  export type MissionReviewUpdateManyWithWhereWithoutUserInput = {
    where: MissionReviewScalarWhereInput
    data: XOR<MissionReviewUpdateManyMutationInput, MissionReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type MissionReviewScalarWhereInput = {
    AND?: MissionReviewScalarWhereInput | MissionReviewScalarWhereInput[]
    OR?: MissionReviewScalarWhereInput[]
    NOT?: MissionReviewScalarWhereInput | MissionReviewScalarWhereInput[]
    id?: StringFilter<"MissionReview"> | string
    userId?: StringFilter<"MissionReview"> | string
    period?: EnumReviewPeriodFilter<"MissionReview"> | $Enums.ReviewPeriod
    startDate?: DateTimeFilter<"MissionReview"> | Date | string
    endDate?: DateTimeFilter<"MissionReview"> | Date | string
    summary?: JsonFilter<"MissionReview">
    highlights?: JsonFilter<"MissionReview">
    insights?: JsonFilter<"MissionReview">
    recommendations?: JsonFilter<"MissionReview">
    generatedAt?: DateTimeFilter<"MissionReview"> | Date | string
  }

  export type UserCreateWithoutCoursesInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    lectures?: LectureCreateNestedManyWithoutUserInput
    studySessions?: StudySessionCreateNestedManyWithoutUserInput
    missions?: MissionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    exams?: ExamCreateNestedManyWithoutUserInput
    coursePriorities?: CoursePriorityCreateNestedManyWithoutUserInput
    streak?: StreakCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    studyGoals?: StudyGoalCreateNestedManyWithoutUserInput
    missionStreak?: MissionStreakCreateNestedOneWithoutUserInput
    missionReviews?: MissionReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCoursesInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    lectures?: LectureUncheckedCreateNestedManyWithoutUserInput
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutUserInput
    missions?: MissionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamUncheckedCreateNestedManyWithoutUserInput
    coursePriorities?: CoursePriorityUncheckedCreateNestedManyWithoutUserInput
    streak?: StreakUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    studyGoals?: StudyGoalUncheckedCreateNestedManyWithoutUserInput
    missionStreak?: MissionStreakUncheckedCreateNestedOneWithoutUserInput
    missionReviews?: MissionReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCoursesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
  }

  export type LectureCreateWithoutCourseInput = {
    id?: string
    title: string
    fileName: string
    fileUrl: string
    fileSize: number
    processingStatus?: $Enums.ProcessingStatus
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    processingProgress?: number
    totalPages?: number | null
    processedPages?: number
    processingStartedAt?: Date | string | null
    estimatedCompletionAt?: Date | string | null
    weekNumber?: number | null
    topicTags?: LectureCreatetopicTagsInput | string[]
    user: UserCreateNestedOneWithoutLecturesInput
    contentChunks?: ContentChunkCreateNestedManyWithoutLectureInput
    learningObjectives?: LearningObjectiveCreateNestedManyWithoutLectureInput
    cards?: CardCreateNestedManyWithoutLectureInput
  }

  export type LectureUncheckedCreateWithoutCourseInput = {
    id?: string
    userId: string
    title: string
    fileName: string
    fileUrl: string
    fileSize: number
    processingStatus?: $Enums.ProcessingStatus
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    processingProgress?: number
    totalPages?: number | null
    processedPages?: number
    processingStartedAt?: Date | string | null
    estimatedCompletionAt?: Date | string | null
    weekNumber?: number | null
    topicTags?: LectureCreatetopicTagsInput | string[]
    contentChunks?: ContentChunkUncheckedCreateNestedManyWithoutLectureInput
    learningObjectives?: LearningObjectiveUncheckedCreateNestedManyWithoutLectureInput
    cards?: CardUncheckedCreateNestedManyWithoutLectureInput
  }

  export type LectureCreateOrConnectWithoutCourseInput = {
    where: LectureWhereUniqueInput
    create: XOR<LectureCreateWithoutCourseInput, LectureUncheckedCreateWithoutCourseInput>
  }

  export type LectureCreateManyCourseInputEnvelope = {
    data: LectureCreateManyCourseInput | LectureCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CardCreateWithoutCourseInput = {
    id?: string
    front: string
    back: string
    cardType?: $Enums.CardType
    createdAt?: Date | string
    difficulty?: number
    stability?: number
    retrievability?: number
    lastReviewedAt?: Date | string | null
    nextReviewAt?: Date | string | null
    reviewCount?: number
    lapseCount?: number
    lecture?: LectureCreateNestedOneWithoutCardsInput
    objective?: LearningObjectiveCreateNestedOneWithoutCardsInput
    reviews?: ReviewCreateNestedManyWithoutCardInput
  }

  export type CardUncheckedCreateWithoutCourseInput = {
    id?: string
    lectureId?: string | null
    objectiveId?: string | null
    front: string
    back: string
    cardType?: $Enums.CardType
    createdAt?: Date | string
    difficulty?: number
    stability?: number
    retrievability?: number
    lastReviewedAt?: Date | string | null
    nextReviewAt?: Date | string | null
    reviewCount?: number
    lapseCount?: number
    reviews?: ReviewUncheckedCreateNestedManyWithoutCardInput
  }

  export type CardCreateOrConnectWithoutCourseInput = {
    where: CardWhereUniqueInput
    create: XOR<CardCreateWithoutCourseInput, CardUncheckedCreateWithoutCourseInput>
  }

  export type CardCreateManyCourseInputEnvelope = {
    data: CardCreateManyCourseInput | CardCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type ExamCreateWithoutCourseInput = {
    id?: string
    name: string
    date: Date | string
    coverageTopics?: ExamCreatecoverageTopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutExamsInput
  }

  export type ExamUncheckedCreateWithoutCourseInput = {
    id?: string
    userId: string
    name: string
    date: Date | string
    coverageTopics?: ExamCreatecoverageTopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamCreateOrConnectWithoutCourseInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutCourseInput, ExamUncheckedCreateWithoutCourseInput>
  }

  export type ExamCreateManyCourseInputEnvelope = {
    data: ExamCreateManyCourseInput | ExamCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type CoursePriorityCreateWithoutCourseInput = {
    id?: string
    priorityLevel?: $Enums.PriorityLevel
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCoursePrioritiesInput
  }

  export type CoursePriorityUncheckedCreateWithoutCourseInput = {
    id?: string
    userId: string
    priorityLevel?: $Enums.PriorityLevel
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoursePriorityCreateOrConnectWithoutCourseInput = {
    where: CoursePriorityWhereUniqueInput
    create: XOR<CoursePriorityCreateWithoutCourseInput, CoursePriorityUncheckedCreateWithoutCourseInput>
  }

  export type CoursePriorityCreateManyCourseInputEnvelope = {
    data: CoursePriorityCreateManyCourseInput | CoursePriorityCreateManyCourseInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCoursesInput = {
    update: XOR<UserUpdateWithoutCoursesInput, UserUncheckedUpdateWithoutCoursesInput>
    create: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCoursesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCoursesInput, UserUncheckedUpdateWithoutCoursesInput>
  }

  export type UserUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    lectures?: LectureUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUpdateManyWithoutUserNestedInput
    missions?: MissionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    exams?: ExamUpdateManyWithoutUserNestedInput
    coursePriorities?: CoursePriorityUpdateManyWithoutUserNestedInput
    streak?: StreakUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    studyGoals?: StudyGoalUpdateManyWithoutUserNestedInput
    missionStreak?: MissionStreakUpdateOneWithoutUserNestedInput
    missionReviews?: MissionReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    lectures?: LectureUncheckedUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUncheckedUpdateManyWithoutUserNestedInput
    missions?: MissionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUserNestedInput
    coursePriorities?: CoursePriorityUncheckedUpdateManyWithoutUserNestedInput
    streak?: StreakUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    studyGoals?: StudyGoalUncheckedUpdateManyWithoutUserNestedInput
    missionStreak?: MissionStreakUncheckedUpdateOneWithoutUserNestedInput
    missionReviews?: MissionReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LectureUpsertWithWhereUniqueWithoutCourseInput = {
    where: LectureWhereUniqueInput
    update: XOR<LectureUpdateWithoutCourseInput, LectureUncheckedUpdateWithoutCourseInput>
    create: XOR<LectureCreateWithoutCourseInput, LectureUncheckedCreateWithoutCourseInput>
  }

  export type LectureUpdateWithWhereUniqueWithoutCourseInput = {
    where: LectureWhereUniqueInput
    data: XOR<LectureUpdateWithoutCourseInput, LectureUncheckedUpdateWithoutCourseInput>
  }

  export type LectureUpdateManyWithWhereWithoutCourseInput = {
    where: LectureScalarWhereInput
    data: XOR<LectureUpdateManyMutationInput, LectureUncheckedUpdateManyWithoutCourseInput>
  }

  export type CardUpsertWithWhereUniqueWithoutCourseInput = {
    where: CardWhereUniqueInput
    update: XOR<CardUpdateWithoutCourseInput, CardUncheckedUpdateWithoutCourseInput>
    create: XOR<CardCreateWithoutCourseInput, CardUncheckedCreateWithoutCourseInput>
  }

  export type CardUpdateWithWhereUniqueWithoutCourseInput = {
    where: CardWhereUniqueInput
    data: XOR<CardUpdateWithoutCourseInput, CardUncheckedUpdateWithoutCourseInput>
  }

  export type CardUpdateManyWithWhereWithoutCourseInput = {
    where: CardScalarWhereInput
    data: XOR<CardUpdateManyMutationInput, CardUncheckedUpdateManyWithoutCourseInput>
  }

  export type CardScalarWhereInput = {
    AND?: CardScalarWhereInput | CardScalarWhereInput[]
    OR?: CardScalarWhereInput[]
    NOT?: CardScalarWhereInput | CardScalarWhereInput[]
    id?: StringFilter<"Card"> | string
    courseId?: StringFilter<"Card"> | string
    lectureId?: StringNullableFilter<"Card"> | string | null
    objectiveId?: StringNullableFilter<"Card"> | string | null
    front?: StringFilter<"Card"> | string
    back?: StringFilter<"Card"> | string
    cardType?: EnumCardTypeFilter<"Card"> | $Enums.CardType
    createdAt?: DateTimeFilter<"Card"> | Date | string
    difficulty?: FloatFilter<"Card"> | number
    stability?: FloatFilter<"Card"> | number
    retrievability?: FloatFilter<"Card"> | number
    lastReviewedAt?: DateTimeNullableFilter<"Card"> | Date | string | null
    nextReviewAt?: DateTimeNullableFilter<"Card"> | Date | string | null
    reviewCount?: IntFilter<"Card"> | number
    lapseCount?: IntFilter<"Card"> | number
  }

  export type ExamUpsertWithWhereUniqueWithoutCourseInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutCourseInput, ExamUncheckedUpdateWithoutCourseInput>
    create: XOR<ExamCreateWithoutCourseInput, ExamUncheckedCreateWithoutCourseInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutCourseInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutCourseInput, ExamUncheckedUpdateWithoutCourseInput>
  }

  export type ExamUpdateManyWithWhereWithoutCourseInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutCourseInput>
  }

  export type CoursePriorityUpsertWithWhereUniqueWithoutCourseInput = {
    where: CoursePriorityWhereUniqueInput
    update: XOR<CoursePriorityUpdateWithoutCourseInput, CoursePriorityUncheckedUpdateWithoutCourseInput>
    create: XOR<CoursePriorityCreateWithoutCourseInput, CoursePriorityUncheckedCreateWithoutCourseInput>
  }

  export type CoursePriorityUpdateWithWhereUniqueWithoutCourseInput = {
    where: CoursePriorityWhereUniqueInput
    data: XOR<CoursePriorityUpdateWithoutCourseInput, CoursePriorityUncheckedUpdateWithoutCourseInput>
  }

  export type CoursePriorityUpdateManyWithWhereWithoutCourseInput = {
    where: CoursePriorityScalarWhereInput
    data: XOR<CoursePriorityUpdateManyMutationInput, CoursePriorityUncheckedUpdateManyWithoutCourseInput>
  }

  export type UserCreateWithoutLecturesInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: CourseCreateNestedManyWithoutUserInput
    studySessions?: StudySessionCreateNestedManyWithoutUserInput
    missions?: MissionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    exams?: ExamCreateNestedManyWithoutUserInput
    coursePriorities?: CoursePriorityCreateNestedManyWithoutUserInput
    streak?: StreakCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    studyGoals?: StudyGoalCreateNestedManyWithoutUserInput
    missionStreak?: MissionStreakCreateNestedOneWithoutUserInput
    missionReviews?: MissionReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLecturesInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutUserInput
    missions?: MissionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamUncheckedCreateNestedManyWithoutUserInput
    coursePriorities?: CoursePriorityUncheckedCreateNestedManyWithoutUserInput
    streak?: StreakUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    studyGoals?: StudyGoalUncheckedCreateNestedManyWithoutUserInput
    missionStreak?: MissionStreakUncheckedCreateNestedOneWithoutUserInput
    missionReviews?: MissionReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLecturesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLecturesInput, UserUncheckedCreateWithoutLecturesInput>
  }

  export type CourseCreateWithoutLecturesInput = {
    id?: string
    name: string
    code?: string | null
    term?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCoursesInput
    cards?: CardCreateNestedManyWithoutCourseInput
    exams?: ExamCreateNestedManyWithoutCourseInput
    coursePriorities?: CoursePriorityCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutLecturesInput = {
    id?: string
    userId: string
    name: string
    code?: string | null
    term?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cards?: CardUncheckedCreateNestedManyWithoutCourseInput
    exams?: ExamUncheckedCreateNestedManyWithoutCourseInput
    coursePriorities?: CoursePriorityUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutLecturesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutLecturesInput, CourseUncheckedCreateWithoutLecturesInput>
  }

  export type ContentChunkCreateWithoutLectureInput = {
    id?: string
    content: string
    chunkIndex: number
    pageNumber?: number | null
    createdAt?: Date | string
  }

  export type ContentChunkUncheckedCreateWithoutLectureInput = {
    id?: string
    content: string
    chunkIndex: number
    pageNumber?: number | null
    createdAt?: Date | string
  }

  export type ContentChunkCreateOrConnectWithoutLectureInput = {
    where: ContentChunkWhereUniqueInput
    create: XOR<ContentChunkCreateWithoutLectureInput, ContentChunkUncheckedCreateWithoutLectureInput>
  }

  export type ContentChunkCreateManyLectureInputEnvelope = {
    data: ContentChunkCreateManyLectureInput | ContentChunkCreateManyLectureInput[]
    skipDuplicates?: boolean
  }

  export type LearningObjectiveCreateWithoutLectureInput = {
    id?: string
    objective: string
    complexity?: $Enums.ObjectiveComplexity
    pageStart?: number | null
    pageEnd?: number | null
    isHighYield?: boolean
    boardExamTags?: LearningObjectiveCreateboardExamTagsInput | string[]
    extractedBy?: string
    createdAt?: Date | string
    masteryLevel?: $Enums.MasteryLevel
    totalStudyTimeMs?: number
    lastStudiedAt?: Date | string | null
    weaknessScore?: number
    cards?: CardCreateNestedManyWithoutObjectiveInput
    prerequisites?: ObjectivePrerequisiteCreateNestedManyWithoutObjectiveInput
    dependents?: ObjectivePrerequisiteCreateNestedManyWithoutPrerequisiteInput
    performanceMetrics?: PerformanceMetricCreateNestedManyWithoutLearningObjectiveInput
    priorityFeedback?: PriorityFeedbackCreateNestedManyWithoutLearningObjectiveInput
    strugglePredictions?: StrugglePredictionCreateNestedManyWithoutLearningObjectiveInput
    struggleIndicators?: StruggleIndicatorCreateNestedManyWithoutLearningObjectiveInput
  }

  export type LearningObjectiveUncheckedCreateWithoutLectureInput = {
    id?: string
    objective: string
    complexity?: $Enums.ObjectiveComplexity
    pageStart?: number | null
    pageEnd?: number | null
    isHighYield?: boolean
    boardExamTags?: LearningObjectiveCreateboardExamTagsInput | string[]
    extractedBy?: string
    createdAt?: Date | string
    masteryLevel?: $Enums.MasteryLevel
    totalStudyTimeMs?: number
    lastStudiedAt?: Date | string | null
    weaknessScore?: number
    cards?: CardUncheckedCreateNestedManyWithoutObjectiveInput
    prerequisites?: ObjectivePrerequisiteUncheckedCreateNestedManyWithoutObjectiveInput
    dependents?: ObjectivePrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput
    performanceMetrics?: PerformanceMetricUncheckedCreateNestedManyWithoutLearningObjectiveInput
    priorityFeedback?: PriorityFeedbackUncheckedCreateNestedManyWithoutLearningObjectiveInput
    strugglePredictions?: StrugglePredictionUncheckedCreateNestedManyWithoutLearningObjectiveInput
    struggleIndicators?: StruggleIndicatorUncheckedCreateNestedManyWithoutLearningObjectiveInput
  }

  export type LearningObjectiveCreateOrConnectWithoutLectureInput = {
    where: LearningObjectiveWhereUniqueInput
    create: XOR<LearningObjectiveCreateWithoutLectureInput, LearningObjectiveUncheckedCreateWithoutLectureInput>
  }

  export type LearningObjectiveCreateManyLectureInputEnvelope = {
    data: LearningObjectiveCreateManyLectureInput | LearningObjectiveCreateManyLectureInput[]
    skipDuplicates?: boolean
  }

  export type CardCreateWithoutLectureInput = {
    id?: string
    front: string
    back: string
    cardType?: $Enums.CardType
    createdAt?: Date | string
    difficulty?: number
    stability?: number
    retrievability?: number
    lastReviewedAt?: Date | string | null
    nextReviewAt?: Date | string | null
    reviewCount?: number
    lapseCount?: number
    course: CourseCreateNestedOneWithoutCardsInput
    objective?: LearningObjectiveCreateNestedOneWithoutCardsInput
    reviews?: ReviewCreateNestedManyWithoutCardInput
  }

  export type CardUncheckedCreateWithoutLectureInput = {
    id?: string
    courseId: string
    objectiveId?: string | null
    front: string
    back: string
    cardType?: $Enums.CardType
    createdAt?: Date | string
    difficulty?: number
    stability?: number
    retrievability?: number
    lastReviewedAt?: Date | string | null
    nextReviewAt?: Date | string | null
    reviewCount?: number
    lapseCount?: number
    reviews?: ReviewUncheckedCreateNestedManyWithoutCardInput
  }

  export type CardCreateOrConnectWithoutLectureInput = {
    where: CardWhereUniqueInput
    create: XOR<CardCreateWithoutLectureInput, CardUncheckedCreateWithoutLectureInput>
  }

  export type CardCreateManyLectureInputEnvelope = {
    data: CardCreateManyLectureInput | CardCreateManyLectureInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLecturesInput = {
    update: XOR<UserUpdateWithoutLecturesInput, UserUncheckedUpdateWithoutLecturesInput>
    create: XOR<UserCreateWithoutLecturesInput, UserUncheckedCreateWithoutLecturesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLecturesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLecturesInput, UserUncheckedUpdateWithoutLecturesInput>
  }

  export type UserUpdateWithoutLecturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUpdateManyWithoutUserNestedInput
    missions?: MissionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    exams?: ExamUpdateManyWithoutUserNestedInput
    coursePriorities?: CoursePriorityUpdateManyWithoutUserNestedInput
    streak?: StreakUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    studyGoals?: StudyGoalUpdateManyWithoutUserNestedInput
    missionStreak?: MissionStreakUpdateOneWithoutUserNestedInput
    missionReviews?: MissionReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLecturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUncheckedUpdateManyWithoutUserNestedInput
    missions?: MissionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUserNestedInput
    coursePriorities?: CoursePriorityUncheckedUpdateManyWithoutUserNestedInput
    streak?: StreakUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    studyGoals?: StudyGoalUncheckedUpdateManyWithoutUserNestedInput
    missionStreak?: MissionStreakUncheckedUpdateOneWithoutUserNestedInput
    missionReviews?: MissionReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutLecturesInput = {
    update: XOR<CourseUpdateWithoutLecturesInput, CourseUncheckedUpdateWithoutLecturesInput>
    create: XOR<CourseCreateWithoutLecturesInput, CourseUncheckedCreateWithoutLecturesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutLecturesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutLecturesInput, CourseUncheckedUpdateWithoutLecturesInput>
  }

  export type CourseUpdateWithoutLecturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoursesNestedInput
    cards?: CardUpdateManyWithoutCourseNestedInput
    exams?: ExamUpdateManyWithoutCourseNestedInput
    coursePriorities?: CoursePriorityUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutLecturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cards?: CardUncheckedUpdateManyWithoutCourseNestedInput
    exams?: ExamUncheckedUpdateManyWithoutCourseNestedInput
    coursePriorities?: CoursePriorityUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type ContentChunkUpsertWithWhereUniqueWithoutLectureInput = {
    where: ContentChunkWhereUniqueInput
    update: XOR<ContentChunkUpdateWithoutLectureInput, ContentChunkUncheckedUpdateWithoutLectureInput>
    create: XOR<ContentChunkCreateWithoutLectureInput, ContentChunkUncheckedCreateWithoutLectureInput>
  }

  export type ContentChunkUpdateWithWhereUniqueWithoutLectureInput = {
    where: ContentChunkWhereUniqueInput
    data: XOR<ContentChunkUpdateWithoutLectureInput, ContentChunkUncheckedUpdateWithoutLectureInput>
  }

  export type ContentChunkUpdateManyWithWhereWithoutLectureInput = {
    where: ContentChunkScalarWhereInput
    data: XOR<ContentChunkUpdateManyMutationInput, ContentChunkUncheckedUpdateManyWithoutLectureInput>
  }

  export type ContentChunkScalarWhereInput = {
    AND?: ContentChunkScalarWhereInput | ContentChunkScalarWhereInput[]
    OR?: ContentChunkScalarWhereInput[]
    NOT?: ContentChunkScalarWhereInput | ContentChunkScalarWhereInput[]
    id?: StringFilter<"ContentChunk"> | string
    lectureId?: StringFilter<"ContentChunk"> | string
    content?: StringFilter<"ContentChunk"> | string
    chunkIndex?: IntFilter<"ContentChunk"> | number
    pageNumber?: IntNullableFilter<"ContentChunk"> | number | null
    createdAt?: DateTimeFilter<"ContentChunk"> | Date | string
  }

  export type LearningObjectiveUpsertWithWhereUniqueWithoutLectureInput = {
    where: LearningObjectiveWhereUniqueInput
    update: XOR<LearningObjectiveUpdateWithoutLectureInput, LearningObjectiveUncheckedUpdateWithoutLectureInput>
    create: XOR<LearningObjectiveCreateWithoutLectureInput, LearningObjectiveUncheckedCreateWithoutLectureInput>
  }

  export type LearningObjectiveUpdateWithWhereUniqueWithoutLectureInput = {
    where: LearningObjectiveWhereUniqueInput
    data: XOR<LearningObjectiveUpdateWithoutLectureInput, LearningObjectiveUncheckedUpdateWithoutLectureInput>
  }

  export type LearningObjectiveUpdateManyWithWhereWithoutLectureInput = {
    where: LearningObjectiveScalarWhereInput
    data: XOR<LearningObjectiveUpdateManyMutationInput, LearningObjectiveUncheckedUpdateManyWithoutLectureInput>
  }

  export type LearningObjectiveScalarWhereInput = {
    AND?: LearningObjectiveScalarWhereInput | LearningObjectiveScalarWhereInput[]
    OR?: LearningObjectiveScalarWhereInput[]
    NOT?: LearningObjectiveScalarWhereInput | LearningObjectiveScalarWhereInput[]
    id?: StringFilter<"LearningObjective"> | string
    lectureId?: StringFilter<"LearningObjective"> | string
    objective?: StringFilter<"LearningObjective"> | string
    complexity?: EnumObjectiveComplexityFilter<"LearningObjective"> | $Enums.ObjectiveComplexity
    pageStart?: IntNullableFilter<"LearningObjective"> | number | null
    pageEnd?: IntNullableFilter<"LearningObjective"> | number | null
    isHighYield?: BoolFilter<"LearningObjective"> | boolean
    boardExamTags?: StringNullableListFilter<"LearningObjective">
    extractedBy?: StringFilter<"LearningObjective"> | string
    createdAt?: DateTimeFilter<"LearningObjective"> | Date | string
    masteryLevel?: EnumMasteryLevelFilter<"LearningObjective"> | $Enums.MasteryLevel
    totalStudyTimeMs?: IntFilter<"LearningObjective"> | number
    lastStudiedAt?: DateTimeNullableFilter<"LearningObjective"> | Date | string | null
    weaknessScore?: FloatFilter<"LearningObjective"> | number
  }

  export type CardUpsertWithWhereUniqueWithoutLectureInput = {
    where: CardWhereUniqueInput
    update: XOR<CardUpdateWithoutLectureInput, CardUncheckedUpdateWithoutLectureInput>
    create: XOR<CardCreateWithoutLectureInput, CardUncheckedCreateWithoutLectureInput>
  }

  export type CardUpdateWithWhereUniqueWithoutLectureInput = {
    where: CardWhereUniqueInput
    data: XOR<CardUpdateWithoutLectureInput, CardUncheckedUpdateWithoutLectureInput>
  }

  export type CardUpdateManyWithWhereWithoutLectureInput = {
    where: CardScalarWhereInput
    data: XOR<CardUpdateManyMutationInput, CardUncheckedUpdateManyWithoutLectureInput>
  }

  export type LectureCreateWithoutContentChunksInput = {
    id?: string
    title: string
    fileName: string
    fileUrl: string
    fileSize: number
    processingStatus?: $Enums.ProcessingStatus
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    processingProgress?: number
    totalPages?: number | null
    processedPages?: number
    processingStartedAt?: Date | string | null
    estimatedCompletionAt?: Date | string | null
    weekNumber?: number | null
    topicTags?: LectureCreatetopicTagsInput | string[]
    user: UserCreateNestedOneWithoutLecturesInput
    course: CourseCreateNestedOneWithoutLecturesInput
    learningObjectives?: LearningObjectiveCreateNestedManyWithoutLectureInput
    cards?: CardCreateNestedManyWithoutLectureInput
  }

  export type LectureUncheckedCreateWithoutContentChunksInput = {
    id?: string
    userId: string
    courseId: string
    title: string
    fileName: string
    fileUrl: string
    fileSize: number
    processingStatus?: $Enums.ProcessingStatus
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    processingProgress?: number
    totalPages?: number | null
    processedPages?: number
    processingStartedAt?: Date | string | null
    estimatedCompletionAt?: Date | string | null
    weekNumber?: number | null
    topicTags?: LectureCreatetopicTagsInput | string[]
    learningObjectives?: LearningObjectiveUncheckedCreateNestedManyWithoutLectureInput
    cards?: CardUncheckedCreateNestedManyWithoutLectureInput
  }

  export type LectureCreateOrConnectWithoutContentChunksInput = {
    where: LectureWhereUniqueInput
    create: XOR<LectureCreateWithoutContentChunksInput, LectureUncheckedCreateWithoutContentChunksInput>
  }

  export type LectureUpsertWithoutContentChunksInput = {
    update: XOR<LectureUpdateWithoutContentChunksInput, LectureUncheckedUpdateWithoutContentChunksInput>
    create: XOR<LectureCreateWithoutContentChunksInput, LectureUncheckedCreateWithoutContentChunksInput>
    where?: LectureWhereInput
  }

  export type LectureUpdateToOneWithWhereWithoutContentChunksInput = {
    where?: LectureWhereInput
    data: XOR<LectureUpdateWithoutContentChunksInput, LectureUncheckedUpdateWithoutContentChunksInput>
  }

  export type LectureUpdateWithoutContentChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingProgress?: IntFieldUpdateOperationsInput | number
    totalPages?: NullableIntFieldUpdateOperationsInput | number | null
    processedPages?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weekNumber?: NullableIntFieldUpdateOperationsInput | number | null
    topicTags?: LectureUpdatetopicTagsInput | string[]
    user?: UserUpdateOneRequiredWithoutLecturesNestedInput
    course?: CourseUpdateOneRequiredWithoutLecturesNestedInput
    learningObjectives?: LearningObjectiveUpdateManyWithoutLectureNestedInput
    cards?: CardUpdateManyWithoutLectureNestedInput
  }

  export type LectureUncheckedUpdateWithoutContentChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingProgress?: IntFieldUpdateOperationsInput | number
    totalPages?: NullableIntFieldUpdateOperationsInput | number | null
    processedPages?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weekNumber?: NullableIntFieldUpdateOperationsInput | number | null
    topicTags?: LectureUpdatetopicTagsInput | string[]
    learningObjectives?: LearningObjectiveUncheckedUpdateManyWithoutLectureNestedInput
    cards?: CardUncheckedUpdateManyWithoutLectureNestedInput
  }

  export type LectureCreateWithoutLearningObjectivesInput = {
    id?: string
    title: string
    fileName: string
    fileUrl: string
    fileSize: number
    processingStatus?: $Enums.ProcessingStatus
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    processingProgress?: number
    totalPages?: number | null
    processedPages?: number
    processingStartedAt?: Date | string | null
    estimatedCompletionAt?: Date | string | null
    weekNumber?: number | null
    topicTags?: LectureCreatetopicTagsInput | string[]
    user: UserCreateNestedOneWithoutLecturesInput
    course: CourseCreateNestedOneWithoutLecturesInput
    contentChunks?: ContentChunkCreateNestedManyWithoutLectureInput
    cards?: CardCreateNestedManyWithoutLectureInput
  }

  export type LectureUncheckedCreateWithoutLearningObjectivesInput = {
    id?: string
    userId: string
    courseId: string
    title: string
    fileName: string
    fileUrl: string
    fileSize: number
    processingStatus?: $Enums.ProcessingStatus
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    processingProgress?: number
    totalPages?: number | null
    processedPages?: number
    processingStartedAt?: Date | string | null
    estimatedCompletionAt?: Date | string | null
    weekNumber?: number | null
    topicTags?: LectureCreatetopicTagsInput | string[]
    contentChunks?: ContentChunkUncheckedCreateNestedManyWithoutLectureInput
    cards?: CardUncheckedCreateNestedManyWithoutLectureInput
  }

  export type LectureCreateOrConnectWithoutLearningObjectivesInput = {
    where: LectureWhereUniqueInput
    create: XOR<LectureCreateWithoutLearningObjectivesInput, LectureUncheckedCreateWithoutLearningObjectivesInput>
  }

  export type CardCreateWithoutObjectiveInput = {
    id?: string
    front: string
    back: string
    cardType?: $Enums.CardType
    createdAt?: Date | string
    difficulty?: number
    stability?: number
    retrievability?: number
    lastReviewedAt?: Date | string | null
    nextReviewAt?: Date | string | null
    reviewCount?: number
    lapseCount?: number
    course: CourseCreateNestedOneWithoutCardsInput
    lecture?: LectureCreateNestedOneWithoutCardsInput
    reviews?: ReviewCreateNestedManyWithoutCardInput
  }

  export type CardUncheckedCreateWithoutObjectiveInput = {
    id?: string
    courseId: string
    lectureId?: string | null
    front: string
    back: string
    cardType?: $Enums.CardType
    createdAt?: Date | string
    difficulty?: number
    stability?: number
    retrievability?: number
    lastReviewedAt?: Date | string | null
    nextReviewAt?: Date | string | null
    reviewCount?: number
    lapseCount?: number
    reviews?: ReviewUncheckedCreateNestedManyWithoutCardInput
  }

  export type CardCreateOrConnectWithoutObjectiveInput = {
    where: CardWhereUniqueInput
    create: XOR<CardCreateWithoutObjectiveInput, CardUncheckedCreateWithoutObjectiveInput>
  }

  export type CardCreateManyObjectiveInputEnvelope = {
    data: CardCreateManyObjectiveInput | CardCreateManyObjectiveInput[]
    skipDuplicates?: boolean
  }

  export type ObjectivePrerequisiteCreateWithoutObjectiveInput = {
    id?: string
    strength?: number
    prerequisite: LearningObjectiveCreateNestedOneWithoutDependentsInput
  }

  export type ObjectivePrerequisiteUncheckedCreateWithoutObjectiveInput = {
    id?: string
    prerequisiteId: string
    strength?: number
  }

  export type ObjectivePrerequisiteCreateOrConnectWithoutObjectiveInput = {
    where: ObjectivePrerequisiteWhereUniqueInput
    create: XOR<ObjectivePrerequisiteCreateWithoutObjectiveInput, ObjectivePrerequisiteUncheckedCreateWithoutObjectiveInput>
  }

  export type ObjectivePrerequisiteCreateManyObjectiveInputEnvelope = {
    data: ObjectivePrerequisiteCreateManyObjectiveInput | ObjectivePrerequisiteCreateManyObjectiveInput[]
    skipDuplicates?: boolean
  }

  export type ObjectivePrerequisiteCreateWithoutPrerequisiteInput = {
    id?: string
    strength?: number
    objective: LearningObjectiveCreateNestedOneWithoutPrerequisitesInput
  }

  export type ObjectivePrerequisiteUncheckedCreateWithoutPrerequisiteInput = {
    id?: string
    objectiveId: string
    strength?: number
  }

  export type ObjectivePrerequisiteCreateOrConnectWithoutPrerequisiteInput = {
    where: ObjectivePrerequisiteWhereUniqueInput
    create: XOR<ObjectivePrerequisiteCreateWithoutPrerequisiteInput, ObjectivePrerequisiteUncheckedCreateWithoutPrerequisiteInput>
  }

  export type ObjectivePrerequisiteCreateManyPrerequisiteInputEnvelope = {
    data: ObjectivePrerequisiteCreateManyPrerequisiteInput | ObjectivePrerequisiteCreateManyPrerequisiteInput[]
    skipDuplicates?: boolean
  }

  export type PerformanceMetricCreateWithoutLearningObjectiveInput = {
    id?: string
    userId: string
    date?: Date | string
    retentionScore: number
    studyTimeMs: number
    reviewCount: number
    correctReviews: number
    incorrectReviews: number
    createdAt?: Date | string
  }

  export type PerformanceMetricUncheckedCreateWithoutLearningObjectiveInput = {
    id?: string
    userId: string
    date?: Date | string
    retentionScore: number
    studyTimeMs: number
    reviewCount: number
    correctReviews: number
    incorrectReviews: number
    createdAt?: Date | string
  }

  export type PerformanceMetricCreateOrConnectWithoutLearningObjectiveInput = {
    where: PerformanceMetricWhereUniqueInput
    create: XOR<PerformanceMetricCreateWithoutLearningObjectiveInput, PerformanceMetricUncheckedCreateWithoutLearningObjectiveInput>
  }

  export type PerformanceMetricCreateManyLearningObjectiveInputEnvelope = {
    data: PerformanceMetricCreateManyLearningObjectiveInput | PerformanceMetricCreateManyLearningObjectiveInput[]
    skipDuplicates?: boolean
  }

  export type PriorityFeedbackCreateWithoutLearningObjectiveInput = {
    id?: string
    userId: string
    suggestedPriority: number
    userFeedback: $Enums.FeedbackRating
    notes?: string | null
    createdAt?: Date | string
  }

  export type PriorityFeedbackUncheckedCreateWithoutLearningObjectiveInput = {
    id?: string
    userId: string
    suggestedPriority: number
    userFeedback: $Enums.FeedbackRating
    notes?: string | null
    createdAt?: Date | string
  }

  export type PriorityFeedbackCreateOrConnectWithoutLearningObjectiveInput = {
    where: PriorityFeedbackWhereUniqueInput
    create: XOR<PriorityFeedbackCreateWithoutLearningObjectiveInput, PriorityFeedbackUncheckedCreateWithoutLearningObjectiveInput>
  }

  export type PriorityFeedbackCreateManyLearningObjectiveInputEnvelope = {
    data: PriorityFeedbackCreateManyLearningObjectiveInput | PriorityFeedbackCreateManyLearningObjectiveInput[]
    skipDuplicates?: boolean
  }

  export type StrugglePredictionCreateWithoutLearningObjectiveInput = {
    id?: string
    userId: string
    topicId?: string | null
    predictionDate?: Date | string
    predictedStruggleProbability: number
    predictionConfidence: number
    predictionStatus?: $Enums.PredictionStatus
    actualOutcome?: boolean | null
    outcomeRecordedAt?: Date | string | null
    featureVector: JsonNullValueInput | InputJsonValue
    indicators?: StruggleIndicatorCreateNestedManyWithoutPredictionInput
    interventions?: InterventionRecommendationCreateNestedManyWithoutPredictionInput
    feedbacks?: PredictionFeedbackCreateNestedManyWithoutPredictionInput
  }

  export type StrugglePredictionUncheckedCreateWithoutLearningObjectiveInput = {
    id?: string
    userId: string
    topicId?: string | null
    predictionDate?: Date | string
    predictedStruggleProbability: number
    predictionConfidence: number
    predictionStatus?: $Enums.PredictionStatus
    actualOutcome?: boolean | null
    outcomeRecordedAt?: Date | string | null
    featureVector: JsonNullValueInput | InputJsonValue
    indicators?: StruggleIndicatorUncheckedCreateNestedManyWithoutPredictionInput
    interventions?: InterventionRecommendationUncheckedCreateNestedManyWithoutPredictionInput
    feedbacks?: PredictionFeedbackUncheckedCreateNestedManyWithoutPredictionInput
  }

  export type StrugglePredictionCreateOrConnectWithoutLearningObjectiveInput = {
    where: StrugglePredictionWhereUniqueInput
    create: XOR<StrugglePredictionCreateWithoutLearningObjectiveInput, StrugglePredictionUncheckedCreateWithoutLearningObjectiveInput>
  }

  export type StrugglePredictionCreateManyLearningObjectiveInputEnvelope = {
    data: StrugglePredictionCreateManyLearningObjectiveInput | StrugglePredictionCreateManyLearningObjectiveInput[]
    skipDuplicates?: boolean
  }

  export type StruggleIndicatorCreateWithoutLearningObjectiveInput = {
    id?: string
    userId: string
    indicatorType: $Enums.IndicatorType
    severity?: $Enums.Severity
    detectedAt?: Date | string
    context: JsonNullValueInput | InputJsonValue
    prediction?: StrugglePredictionCreateNestedOneWithoutIndicatorsInput
  }

  export type StruggleIndicatorUncheckedCreateWithoutLearningObjectiveInput = {
    id?: string
    userId: string
    predictionId?: string | null
    indicatorType: $Enums.IndicatorType
    severity?: $Enums.Severity
    detectedAt?: Date | string
    context: JsonNullValueInput | InputJsonValue
  }

  export type StruggleIndicatorCreateOrConnectWithoutLearningObjectiveInput = {
    where: StruggleIndicatorWhereUniqueInput
    create: XOR<StruggleIndicatorCreateWithoutLearningObjectiveInput, StruggleIndicatorUncheckedCreateWithoutLearningObjectiveInput>
  }

  export type StruggleIndicatorCreateManyLearningObjectiveInputEnvelope = {
    data: StruggleIndicatorCreateManyLearningObjectiveInput | StruggleIndicatorCreateManyLearningObjectiveInput[]
    skipDuplicates?: boolean
  }

  export type LectureUpsertWithoutLearningObjectivesInput = {
    update: XOR<LectureUpdateWithoutLearningObjectivesInput, LectureUncheckedUpdateWithoutLearningObjectivesInput>
    create: XOR<LectureCreateWithoutLearningObjectivesInput, LectureUncheckedCreateWithoutLearningObjectivesInput>
    where?: LectureWhereInput
  }

  export type LectureUpdateToOneWithWhereWithoutLearningObjectivesInput = {
    where?: LectureWhereInput
    data: XOR<LectureUpdateWithoutLearningObjectivesInput, LectureUncheckedUpdateWithoutLearningObjectivesInput>
  }

  export type LectureUpdateWithoutLearningObjectivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingProgress?: IntFieldUpdateOperationsInput | number
    totalPages?: NullableIntFieldUpdateOperationsInput | number | null
    processedPages?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weekNumber?: NullableIntFieldUpdateOperationsInput | number | null
    topicTags?: LectureUpdatetopicTagsInput | string[]
    user?: UserUpdateOneRequiredWithoutLecturesNestedInput
    course?: CourseUpdateOneRequiredWithoutLecturesNestedInput
    contentChunks?: ContentChunkUpdateManyWithoutLectureNestedInput
    cards?: CardUpdateManyWithoutLectureNestedInput
  }

  export type LectureUncheckedUpdateWithoutLearningObjectivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingProgress?: IntFieldUpdateOperationsInput | number
    totalPages?: NullableIntFieldUpdateOperationsInput | number | null
    processedPages?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weekNumber?: NullableIntFieldUpdateOperationsInput | number | null
    topicTags?: LectureUpdatetopicTagsInput | string[]
    contentChunks?: ContentChunkUncheckedUpdateManyWithoutLectureNestedInput
    cards?: CardUncheckedUpdateManyWithoutLectureNestedInput
  }

  export type CardUpsertWithWhereUniqueWithoutObjectiveInput = {
    where: CardWhereUniqueInput
    update: XOR<CardUpdateWithoutObjectiveInput, CardUncheckedUpdateWithoutObjectiveInput>
    create: XOR<CardCreateWithoutObjectiveInput, CardUncheckedCreateWithoutObjectiveInput>
  }

  export type CardUpdateWithWhereUniqueWithoutObjectiveInput = {
    where: CardWhereUniqueInput
    data: XOR<CardUpdateWithoutObjectiveInput, CardUncheckedUpdateWithoutObjectiveInput>
  }

  export type CardUpdateManyWithWhereWithoutObjectiveInput = {
    where: CardScalarWhereInput
    data: XOR<CardUpdateManyMutationInput, CardUncheckedUpdateManyWithoutObjectiveInput>
  }

  export type ObjectivePrerequisiteUpsertWithWhereUniqueWithoutObjectiveInput = {
    where: ObjectivePrerequisiteWhereUniqueInput
    update: XOR<ObjectivePrerequisiteUpdateWithoutObjectiveInput, ObjectivePrerequisiteUncheckedUpdateWithoutObjectiveInput>
    create: XOR<ObjectivePrerequisiteCreateWithoutObjectiveInput, ObjectivePrerequisiteUncheckedCreateWithoutObjectiveInput>
  }

  export type ObjectivePrerequisiteUpdateWithWhereUniqueWithoutObjectiveInput = {
    where: ObjectivePrerequisiteWhereUniqueInput
    data: XOR<ObjectivePrerequisiteUpdateWithoutObjectiveInput, ObjectivePrerequisiteUncheckedUpdateWithoutObjectiveInput>
  }

  export type ObjectivePrerequisiteUpdateManyWithWhereWithoutObjectiveInput = {
    where: ObjectivePrerequisiteScalarWhereInput
    data: XOR<ObjectivePrerequisiteUpdateManyMutationInput, ObjectivePrerequisiteUncheckedUpdateManyWithoutObjectiveInput>
  }

  export type ObjectivePrerequisiteScalarWhereInput = {
    AND?: ObjectivePrerequisiteScalarWhereInput | ObjectivePrerequisiteScalarWhereInput[]
    OR?: ObjectivePrerequisiteScalarWhereInput[]
    NOT?: ObjectivePrerequisiteScalarWhereInput | ObjectivePrerequisiteScalarWhereInput[]
    id?: StringFilter<"ObjectivePrerequisite"> | string
    objectiveId?: StringFilter<"ObjectivePrerequisite"> | string
    prerequisiteId?: StringFilter<"ObjectivePrerequisite"> | string
    strength?: FloatFilter<"ObjectivePrerequisite"> | number
  }

  export type ObjectivePrerequisiteUpsertWithWhereUniqueWithoutPrerequisiteInput = {
    where: ObjectivePrerequisiteWhereUniqueInput
    update: XOR<ObjectivePrerequisiteUpdateWithoutPrerequisiteInput, ObjectivePrerequisiteUncheckedUpdateWithoutPrerequisiteInput>
    create: XOR<ObjectivePrerequisiteCreateWithoutPrerequisiteInput, ObjectivePrerequisiteUncheckedCreateWithoutPrerequisiteInput>
  }

  export type ObjectivePrerequisiteUpdateWithWhereUniqueWithoutPrerequisiteInput = {
    where: ObjectivePrerequisiteWhereUniqueInput
    data: XOR<ObjectivePrerequisiteUpdateWithoutPrerequisiteInput, ObjectivePrerequisiteUncheckedUpdateWithoutPrerequisiteInput>
  }

  export type ObjectivePrerequisiteUpdateManyWithWhereWithoutPrerequisiteInput = {
    where: ObjectivePrerequisiteScalarWhereInput
    data: XOR<ObjectivePrerequisiteUpdateManyMutationInput, ObjectivePrerequisiteUncheckedUpdateManyWithoutPrerequisiteInput>
  }

  export type PerformanceMetricUpsertWithWhereUniqueWithoutLearningObjectiveInput = {
    where: PerformanceMetricWhereUniqueInput
    update: XOR<PerformanceMetricUpdateWithoutLearningObjectiveInput, PerformanceMetricUncheckedUpdateWithoutLearningObjectiveInput>
    create: XOR<PerformanceMetricCreateWithoutLearningObjectiveInput, PerformanceMetricUncheckedCreateWithoutLearningObjectiveInput>
  }

  export type PerformanceMetricUpdateWithWhereUniqueWithoutLearningObjectiveInput = {
    where: PerformanceMetricWhereUniqueInput
    data: XOR<PerformanceMetricUpdateWithoutLearningObjectiveInput, PerformanceMetricUncheckedUpdateWithoutLearningObjectiveInput>
  }

  export type PerformanceMetricUpdateManyWithWhereWithoutLearningObjectiveInput = {
    where: PerformanceMetricScalarWhereInput
    data: XOR<PerformanceMetricUpdateManyMutationInput, PerformanceMetricUncheckedUpdateManyWithoutLearningObjectiveInput>
  }

  export type PerformanceMetricScalarWhereInput = {
    AND?: PerformanceMetricScalarWhereInput | PerformanceMetricScalarWhereInput[]
    OR?: PerformanceMetricScalarWhereInput[]
    NOT?: PerformanceMetricScalarWhereInput | PerformanceMetricScalarWhereInput[]
    id?: StringFilter<"PerformanceMetric"> | string
    userId?: StringFilter<"PerformanceMetric"> | string
    learningObjectiveId?: StringFilter<"PerformanceMetric"> | string
    date?: DateTimeFilter<"PerformanceMetric"> | Date | string
    retentionScore?: FloatFilter<"PerformanceMetric"> | number
    studyTimeMs?: IntFilter<"PerformanceMetric"> | number
    reviewCount?: IntFilter<"PerformanceMetric"> | number
    correctReviews?: IntFilter<"PerformanceMetric"> | number
    incorrectReviews?: IntFilter<"PerformanceMetric"> | number
    createdAt?: DateTimeFilter<"PerformanceMetric"> | Date | string
  }

  export type PriorityFeedbackUpsertWithWhereUniqueWithoutLearningObjectiveInput = {
    where: PriorityFeedbackWhereUniqueInput
    update: XOR<PriorityFeedbackUpdateWithoutLearningObjectiveInput, PriorityFeedbackUncheckedUpdateWithoutLearningObjectiveInput>
    create: XOR<PriorityFeedbackCreateWithoutLearningObjectiveInput, PriorityFeedbackUncheckedCreateWithoutLearningObjectiveInput>
  }

  export type PriorityFeedbackUpdateWithWhereUniqueWithoutLearningObjectiveInput = {
    where: PriorityFeedbackWhereUniqueInput
    data: XOR<PriorityFeedbackUpdateWithoutLearningObjectiveInput, PriorityFeedbackUncheckedUpdateWithoutLearningObjectiveInput>
  }

  export type PriorityFeedbackUpdateManyWithWhereWithoutLearningObjectiveInput = {
    where: PriorityFeedbackScalarWhereInput
    data: XOR<PriorityFeedbackUpdateManyMutationInput, PriorityFeedbackUncheckedUpdateManyWithoutLearningObjectiveInput>
  }

  export type PriorityFeedbackScalarWhereInput = {
    AND?: PriorityFeedbackScalarWhereInput | PriorityFeedbackScalarWhereInput[]
    OR?: PriorityFeedbackScalarWhereInput[]
    NOT?: PriorityFeedbackScalarWhereInput | PriorityFeedbackScalarWhereInput[]
    id?: StringFilter<"PriorityFeedback"> | string
    userId?: StringFilter<"PriorityFeedback"> | string
    objectiveId?: StringFilter<"PriorityFeedback"> | string
    suggestedPriority?: FloatFilter<"PriorityFeedback"> | number
    userFeedback?: EnumFeedbackRatingFilter<"PriorityFeedback"> | $Enums.FeedbackRating
    notes?: StringNullableFilter<"PriorityFeedback"> | string | null
    createdAt?: DateTimeFilter<"PriorityFeedback"> | Date | string
  }

  export type StrugglePredictionUpsertWithWhereUniqueWithoutLearningObjectiveInput = {
    where: StrugglePredictionWhereUniqueInput
    update: XOR<StrugglePredictionUpdateWithoutLearningObjectiveInput, StrugglePredictionUncheckedUpdateWithoutLearningObjectiveInput>
    create: XOR<StrugglePredictionCreateWithoutLearningObjectiveInput, StrugglePredictionUncheckedCreateWithoutLearningObjectiveInput>
  }

  export type StrugglePredictionUpdateWithWhereUniqueWithoutLearningObjectiveInput = {
    where: StrugglePredictionWhereUniqueInput
    data: XOR<StrugglePredictionUpdateWithoutLearningObjectiveInput, StrugglePredictionUncheckedUpdateWithoutLearningObjectiveInput>
  }

  export type StrugglePredictionUpdateManyWithWhereWithoutLearningObjectiveInput = {
    where: StrugglePredictionScalarWhereInput
    data: XOR<StrugglePredictionUpdateManyMutationInput, StrugglePredictionUncheckedUpdateManyWithoutLearningObjectiveInput>
  }

  export type StrugglePredictionScalarWhereInput = {
    AND?: StrugglePredictionScalarWhereInput | StrugglePredictionScalarWhereInput[]
    OR?: StrugglePredictionScalarWhereInput[]
    NOT?: StrugglePredictionScalarWhereInput | StrugglePredictionScalarWhereInput[]
    id?: StringFilter<"StrugglePrediction"> | string
    userId?: StringFilter<"StrugglePrediction"> | string
    learningObjectiveId?: StringNullableFilter<"StrugglePrediction"> | string | null
    topicId?: StringNullableFilter<"StrugglePrediction"> | string | null
    predictionDate?: DateTimeFilter<"StrugglePrediction"> | Date | string
    predictedStruggleProbability?: FloatFilter<"StrugglePrediction"> | number
    predictionConfidence?: FloatFilter<"StrugglePrediction"> | number
    predictionStatus?: EnumPredictionStatusFilter<"StrugglePrediction"> | $Enums.PredictionStatus
    actualOutcome?: BoolNullableFilter<"StrugglePrediction"> | boolean | null
    outcomeRecordedAt?: DateTimeNullableFilter<"StrugglePrediction"> | Date | string | null
    featureVector?: JsonFilter<"StrugglePrediction">
  }

  export type StruggleIndicatorUpsertWithWhereUniqueWithoutLearningObjectiveInput = {
    where: StruggleIndicatorWhereUniqueInput
    update: XOR<StruggleIndicatorUpdateWithoutLearningObjectiveInput, StruggleIndicatorUncheckedUpdateWithoutLearningObjectiveInput>
    create: XOR<StruggleIndicatorCreateWithoutLearningObjectiveInput, StruggleIndicatorUncheckedCreateWithoutLearningObjectiveInput>
  }

  export type StruggleIndicatorUpdateWithWhereUniqueWithoutLearningObjectiveInput = {
    where: StruggleIndicatorWhereUniqueInput
    data: XOR<StruggleIndicatorUpdateWithoutLearningObjectiveInput, StruggleIndicatorUncheckedUpdateWithoutLearningObjectiveInput>
  }

  export type StruggleIndicatorUpdateManyWithWhereWithoutLearningObjectiveInput = {
    where: StruggleIndicatorScalarWhereInput
    data: XOR<StruggleIndicatorUpdateManyMutationInput, StruggleIndicatorUncheckedUpdateManyWithoutLearningObjectiveInput>
  }

  export type StruggleIndicatorScalarWhereInput = {
    AND?: StruggleIndicatorScalarWhereInput | StruggleIndicatorScalarWhereInput[]
    OR?: StruggleIndicatorScalarWhereInput[]
    NOT?: StruggleIndicatorScalarWhereInput | StruggleIndicatorScalarWhereInput[]
    id?: StringFilter<"StruggleIndicator"> | string
    userId?: StringFilter<"StruggleIndicator"> | string
    predictionId?: StringNullableFilter<"StruggleIndicator"> | string | null
    learningObjectiveId?: StringFilter<"StruggleIndicator"> | string
    indicatorType?: EnumIndicatorTypeFilter<"StruggleIndicator"> | $Enums.IndicatorType
    severity?: EnumSeverityFilter<"StruggleIndicator"> | $Enums.Severity
    detectedAt?: DateTimeFilter<"StruggleIndicator"> | Date | string
    context?: JsonFilter<"StruggleIndicator">
  }

  export type LearningObjectiveCreateWithoutPrerequisitesInput = {
    id?: string
    objective: string
    complexity?: $Enums.ObjectiveComplexity
    pageStart?: number | null
    pageEnd?: number | null
    isHighYield?: boolean
    boardExamTags?: LearningObjectiveCreateboardExamTagsInput | string[]
    extractedBy?: string
    createdAt?: Date | string
    masteryLevel?: $Enums.MasteryLevel
    totalStudyTimeMs?: number
    lastStudiedAt?: Date | string | null
    weaknessScore?: number
    lecture: LectureCreateNestedOneWithoutLearningObjectivesInput
    cards?: CardCreateNestedManyWithoutObjectiveInput
    dependents?: ObjectivePrerequisiteCreateNestedManyWithoutPrerequisiteInput
    performanceMetrics?: PerformanceMetricCreateNestedManyWithoutLearningObjectiveInput
    priorityFeedback?: PriorityFeedbackCreateNestedManyWithoutLearningObjectiveInput
    strugglePredictions?: StrugglePredictionCreateNestedManyWithoutLearningObjectiveInput
    struggleIndicators?: StruggleIndicatorCreateNestedManyWithoutLearningObjectiveInput
  }

  export type LearningObjectiveUncheckedCreateWithoutPrerequisitesInput = {
    id?: string
    lectureId: string
    objective: string
    complexity?: $Enums.ObjectiveComplexity
    pageStart?: number | null
    pageEnd?: number | null
    isHighYield?: boolean
    boardExamTags?: LearningObjectiveCreateboardExamTagsInput | string[]
    extractedBy?: string
    createdAt?: Date | string
    masteryLevel?: $Enums.MasteryLevel
    totalStudyTimeMs?: number
    lastStudiedAt?: Date | string | null
    weaknessScore?: number
    cards?: CardUncheckedCreateNestedManyWithoutObjectiveInput
    dependents?: ObjectivePrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput
    performanceMetrics?: PerformanceMetricUncheckedCreateNestedManyWithoutLearningObjectiveInput
    priorityFeedback?: PriorityFeedbackUncheckedCreateNestedManyWithoutLearningObjectiveInput
    strugglePredictions?: StrugglePredictionUncheckedCreateNestedManyWithoutLearningObjectiveInput
    struggleIndicators?: StruggleIndicatorUncheckedCreateNestedManyWithoutLearningObjectiveInput
  }

  export type LearningObjectiveCreateOrConnectWithoutPrerequisitesInput = {
    where: LearningObjectiveWhereUniqueInput
    create: XOR<LearningObjectiveCreateWithoutPrerequisitesInput, LearningObjectiveUncheckedCreateWithoutPrerequisitesInput>
  }

  export type LearningObjectiveCreateWithoutDependentsInput = {
    id?: string
    objective: string
    complexity?: $Enums.ObjectiveComplexity
    pageStart?: number | null
    pageEnd?: number | null
    isHighYield?: boolean
    boardExamTags?: LearningObjectiveCreateboardExamTagsInput | string[]
    extractedBy?: string
    createdAt?: Date | string
    masteryLevel?: $Enums.MasteryLevel
    totalStudyTimeMs?: number
    lastStudiedAt?: Date | string | null
    weaknessScore?: number
    lecture: LectureCreateNestedOneWithoutLearningObjectivesInput
    cards?: CardCreateNestedManyWithoutObjectiveInput
    prerequisites?: ObjectivePrerequisiteCreateNestedManyWithoutObjectiveInput
    performanceMetrics?: PerformanceMetricCreateNestedManyWithoutLearningObjectiveInput
    priorityFeedback?: PriorityFeedbackCreateNestedManyWithoutLearningObjectiveInput
    strugglePredictions?: StrugglePredictionCreateNestedManyWithoutLearningObjectiveInput
    struggleIndicators?: StruggleIndicatorCreateNestedManyWithoutLearningObjectiveInput
  }

  export type LearningObjectiveUncheckedCreateWithoutDependentsInput = {
    id?: string
    lectureId: string
    objective: string
    complexity?: $Enums.ObjectiveComplexity
    pageStart?: number | null
    pageEnd?: number | null
    isHighYield?: boolean
    boardExamTags?: LearningObjectiveCreateboardExamTagsInput | string[]
    extractedBy?: string
    createdAt?: Date | string
    masteryLevel?: $Enums.MasteryLevel
    totalStudyTimeMs?: number
    lastStudiedAt?: Date | string | null
    weaknessScore?: number
    cards?: CardUncheckedCreateNestedManyWithoutObjectiveInput
    prerequisites?: ObjectivePrerequisiteUncheckedCreateNestedManyWithoutObjectiveInput
    performanceMetrics?: PerformanceMetricUncheckedCreateNestedManyWithoutLearningObjectiveInput
    priorityFeedback?: PriorityFeedbackUncheckedCreateNestedManyWithoutLearningObjectiveInput
    strugglePredictions?: StrugglePredictionUncheckedCreateNestedManyWithoutLearningObjectiveInput
    struggleIndicators?: StruggleIndicatorUncheckedCreateNestedManyWithoutLearningObjectiveInput
  }

  export type LearningObjectiveCreateOrConnectWithoutDependentsInput = {
    where: LearningObjectiveWhereUniqueInput
    create: XOR<LearningObjectiveCreateWithoutDependentsInput, LearningObjectiveUncheckedCreateWithoutDependentsInput>
  }

  export type LearningObjectiveUpsertWithoutPrerequisitesInput = {
    update: XOR<LearningObjectiveUpdateWithoutPrerequisitesInput, LearningObjectiveUncheckedUpdateWithoutPrerequisitesInput>
    create: XOR<LearningObjectiveCreateWithoutPrerequisitesInput, LearningObjectiveUncheckedCreateWithoutPrerequisitesInput>
    where?: LearningObjectiveWhereInput
  }

  export type LearningObjectiveUpdateToOneWithWhereWithoutPrerequisitesInput = {
    where?: LearningObjectiveWhereInput
    data: XOR<LearningObjectiveUpdateWithoutPrerequisitesInput, LearningObjectiveUncheckedUpdateWithoutPrerequisitesInput>
  }

  export type LearningObjectiveUpdateWithoutPrerequisitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    complexity?: EnumObjectiveComplexityFieldUpdateOperationsInput | $Enums.ObjectiveComplexity
    pageStart?: NullableIntFieldUpdateOperationsInput | number | null
    pageEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isHighYield?: BoolFieldUpdateOperationsInput | boolean
    boardExamTags?: LearningObjectiveUpdateboardExamTagsInput | string[]
    extractedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masteryLevel?: EnumMasteryLevelFieldUpdateOperationsInput | $Enums.MasteryLevel
    totalStudyTimeMs?: IntFieldUpdateOperationsInput | number
    lastStudiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weaknessScore?: FloatFieldUpdateOperationsInput | number
    lecture?: LectureUpdateOneRequiredWithoutLearningObjectivesNestedInput
    cards?: CardUpdateManyWithoutObjectiveNestedInput
    dependents?: ObjectivePrerequisiteUpdateManyWithoutPrerequisiteNestedInput
    performanceMetrics?: PerformanceMetricUpdateManyWithoutLearningObjectiveNestedInput
    priorityFeedback?: PriorityFeedbackUpdateManyWithoutLearningObjectiveNestedInput
    strugglePredictions?: StrugglePredictionUpdateManyWithoutLearningObjectiveNestedInput
    struggleIndicators?: StruggleIndicatorUpdateManyWithoutLearningObjectiveNestedInput
  }

  export type LearningObjectiveUncheckedUpdateWithoutPrerequisitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    complexity?: EnumObjectiveComplexityFieldUpdateOperationsInput | $Enums.ObjectiveComplexity
    pageStart?: NullableIntFieldUpdateOperationsInput | number | null
    pageEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isHighYield?: BoolFieldUpdateOperationsInput | boolean
    boardExamTags?: LearningObjectiveUpdateboardExamTagsInput | string[]
    extractedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masteryLevel?: EnumMasteryLevelFieldUpdateOperationsInput | $Enums.MasteryLevel
    totalStudyTimeMs?: IntFieldUpdateOperationsInput | number
    lastStudiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weaknessScore?: FloatFieldUpdateOperationsInput | number
    cards?: CardUncheckedUpdateManyWithoutObjectiveNestedInput
    dependents?: ObjectivePrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput
    performanceMetrics?: PerformanceMetricUncheckedUpdateManyWithoutLearningObjectiveNestedInput
    priorityFeedback?: PriorityFeedbackUncheckedUpdateManyWithoutLearningObjectiveNestedInput
    strugglePredictions?: StrugglePredictionUncheckedUpdateManyWithoutLearningObjectiveNestedInput
    struggleIndicators?: StruggleIndicatorUncheckedUpdateManyWithoutLearningObjectiveNestedInput
  }

  export type LearningObjectiveUpsertWithoutDependentsInput = {
    update: XOR<LearningObjectiveUpdateWithoutDependentsInput, LearningObjectiveUncheckedUpdateWithoutDependentsInput>
    create: XOR<LearningObjectiveCreateWithoutDependentsInput, LearningObjectiveUncheckedCreateWithoutDependentsInput>
    where?: LearningObjectiveWhereInput
  }

  export type LearningObjectiveUpdateToOneWithWhereWithoutDependentsInput = {
    where?: LearningObjectiveWhereInput
    data: XOR<LearningObjectiveUpdateWithoutDependentsInput, LearningObjectiveUncheckedUpdateWithoutDependentsInput>
  }

  export type LearningObjectiveUpdateWithoutDependentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    complexity?: EnumObjectiveComplexityFieldUpdateOperationsInput | $Enums.ObjectiveComplexity
    pageStart?: NullableIntFieldUpdateOperationsInput | number | null
    pageEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isHighYield?: BoolFieldUpdateOperationsInput | boolean
    boardExamTags?: LearningObjectiveUpdateboardExamTagsInput | string[]
    extractedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masteryLevel?: EnumMasteryLevelFieldUpdateOperationsInput | $Enums.MasteryLevel
    totalStudyTimeMs?: IntFieldUpdateOperationsInput | number
    lastStudiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weaknessScore?: FloatFieldUpdateOperationsInput | number
    lecture?: LectureUpdateOneRequiredWithoutLearningObjectivesNestedInput
    cards?: CardUpdateManyWithoutObjectiveNestedInput
    prerequisites?: ObjectivePrerequisiteUpdateManyWithoutObjectiveNestedInput
    performanceMetrics?: PerformanceMetricUpdateManyWithoutLearningObjectiveNestedInput
    priorityFeedback?: PriorityFeedbackUpdateManyWithoutLearningObjectiveNestedInput
    strugglePredictions?: StrugglePredictionUpdateManyWithoutLearningObjectiveNestedInput
    struggleIndicators?: StruggleIndicatorUpdateManyWithoutLearningObjectiveNestedInput
  }

  export type LearningObjectiveUncheckedUpdateWithoutDependentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    complexity?: EnumObjectiveComplexityFieldUpdateOperationsInput | $Enums.ObjectiveComplexity
    pageStart?: NullableIntFieldUpdateOperationsInput | number | null
    pageEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isHighYield?: BoolFieldUpdateOperationsInput | boolean
    boardExamTags?: LearningObjectiveUpdateboardExamTagsInput | string[]
    extractedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masteryLevel?: EnumMasteryLevelFieldUpdateOperationsInput | $Enums.MasteryLevel
    totalStudyTimeMs?: IntFieldUpdateOperationsInput | number
    lastStudiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weaknessScore?: FloatFieldUpdateOperationsInput | number
    cards?: CardUncheckedUpdateManyWithoutObjectiveNestedInput
    prerequisites?: ObjectivePrerequisiteUncheckedUpdateManyWithoutObjectiveNestedInput
    performanceMetrics?: PerformanceMetricUncheckedUpdateManyWithoutLearningObjectiveNestedInput
    priorityFeedback?: PriorityFeedbackUncheckedUpdateManyWithoutLearningObjectiveNestedInput
    strugglePredictions?: StrugglePredictionUncheckedUpdateManyWithoutLearningObjectiveNestedInput
    struggleIndicators?: StruggleIndicatorUncheckedUpdateManyWithoutLearningObjectiveNestedInput
  }

  export type UserCreateWithoutMissionsInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: CourseCreateNestedManyWithoutUserInput
    lectures?: LectureCreateNestedManyWithoutUserInput
    studySessions?: StudySessionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    exams?: ExamCreateNestedManyWithoutUserInput
    coursePriorities?: CoursePriorityCreateNestedManyWithoutUserInput
    streak?: StreakCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    studyGoals?: StudyGoalCreateNestedManyWithoutUserInput
    missionStreak?: MissionStreakCreateNestedOneWithoutUserInput
    missionReviews?: MissionReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMissionsInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    lectures?: LectureUncheckedCreateNestedManyWithoutUserInput
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamUncheckedCreateNestedManyWithoutUserInput
    coursePriorities?: CoursePriorityUncheckedCreateNestedManyWithoutUserInput
    streak?: StreakUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    studyGoals?: StudyGoalUncheckedCreateNestedManyWithoutUserInput
    missionStreak?: MissionStreakUncheckedCreateNestedOneWithoutUserInput
    missionReviews?: MissionReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMissionsInput, UserUncheckedCreateWithoutMissionsInput>
  }

  export type StudySessionCreateWithoutMissionInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    reviewsCompleted?: number
    newCardsStudied?: number
    sessionNotes?: string | null
    currentObjectiveIndex?: number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutStudySessionsInput
    reviews?: ReviewCreateNestedManyWithoutSessionInput
    validationResponses?: ValidationResponseCreateNestedManyWithoutSessionInput
  }

  export type StudySessionUncheckedCreateWithoutMissionInput = {
    id?: string
    userId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    reviewsCompleted?: number
    newCardsStudied?: number
    sessionNotes?: string | null
    currentObjectiveIndex?: number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
    reviews?: ReviewUncheckedCreateNestedManyWithoutSessionInput
    validationResponses?: ValidationResponseUncheckedCreateNestedManyWithoutSessionInput
  }

  export type StudySessionCreateOrConnectWithoutMissionInput = {
    where: StudySessionWhereUniqueInput
    create: XOR<StudySessionCreateWithoutMissionInput, StudySessionUncheckedCreateWithoutMissionInput>
  }

  export type StudySessionCreateManyMissionInputEnvelope = {
    data: StudySessionCreateManyMissionInput | StudySessionCreateManyMissionInput[]
    skipDuplicates?: boolean
  }

  export type MissionFeedbackCreateWithoutMissionInput = {
    id?: string
    userId: string
    helpfulnessRating: number
    relevanceScore: number
    paceRating: $Enums.PaceRating
    improvementSuggestions?: string | null
    submittedAt?: Date | string
  }

  export type MissionFeedbackUncheckedCreateWithoutMissionInput = {
    id?: string
    userId: string
    helpfulnessRating: number
    relevanceScore: number
    paceRating: $Enums.PaceRating
    improvementSuggestions?: string | null
    submittedAt?: Date | string
  }

  export type MissionFeedbackCreateOrConnectWithoutMissionInput = {
    where: MissionFeedbackWhereUniqueInput
    create: XOR<MissionFeedbackCreateWithoutMissionInput, MissionFeedbackUncheckedCreateWithoutMissionInput>
  }

  export type MissionFeedbackCreateManyMissionInputEnvelope = {
    data: MissionFeedbackCreateManyMissionInput | MissionFeedbackCreateManyMissionInput[]
    skipDuplicates?: boolean
  }

  export type InterventionRecommendationCreateWithoutMissionInput = {
    id?: string
    userId: string
    interventionType: $Enums.InterventionType
    description: string
    reasoning: string
    priority?: number
    status?: $Enums.InterventionStatus
    appliedAt?: Date | string | null
    effectiveness?: number | null
    createdAt?: Date | string
    prediction: StrugglePredictionCreateNestedOneWithoutInterventionsInput
  }

  export type InterventionRecommendationUncheckedCreateWithoutMissionInput = {
    id?: string
    predictionId: string
    userId: string
    interventionType: $Enums.InterventionType
    description: string
    reasoning: string
    priority?: number
    status?: $Enums.InterventionStatus
    appliedAt?: Date | string | null
    effectiveness?: number | null
    createdAt?: Date | string
  }

  export type InterventionRecommendationCreateOrConnectWithoutMissionInput = {
    where: InterventionRecommendationWhereUniqueInput
    create: XOR<InterventionRecommendationCreateWithoutMissionInput, InterventionRecommendationUncheckedCreateWithoutMissionInput>
  }

  export type InterventionRecommendationCreateManyMissionInputEnvelope = {
    data: InterventionRecommendationCreateManyMissionInput | InterventionRecommendationCreateManyMissionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMissionsInput = {
    update: XOR<UserUpdateWithoutMissionsInput, UserUncheckedUpdateWithoutMissionsInput>
    create: XOR<UserCreateWithoutMissionsInput, UserUncheckedCreateWithoutMissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMissionsInput, UserUncheckedUpdateWithoutMissionsInput>
  }

  export type UserUpdateWithoutMissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseUpdateManyWithoutUserNestedInput
    lectures?: LectureUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    exams?: ExamUpdateManyWithoutUserNestedInput
    coursePriorities?: CoursePriorityUpdateManyWithoutUserNestedInput
    streak?: StreakUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    studyGoals?: StudyGoalUpdateManyWithoutUserNestedInput
    missionStreak?: MissionStreakUpdateOneWithoutUserNestedInput
    missionReviews?: MissionReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    lectures?: LectureUncheckedUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUserNestedInput
    coursePriorities?: CoursePriorityUncheckedUpdateManyWithoutUserNestedInput
    streak?: StreakUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    studyGoals?: StudyGoalUncheckedUpdateManyWithoutUserNestedInput
    missionStreak?: MissionStreakUncheckedUpdateOneWithoutUserNestedInput
    missionReviews?: MissionReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StudySessionUpsertWithWhereUniqueWithoutMissionInput = {
    where: StudySessionWhereUniqueInput
    update: XOR<StudySessionUpdateWithoutMissionInput, StudySessionUncheckedUpdateWithoutMissionInput>
    create: XOR<StudySessionCreateWithoutMissionInput, StudySessionUncheckedCreateWithoutMissionInput>
  }

  export type StudySessionUpdateWithWhereUniqueWithoutMissionInput = {
    where: StudySessionWhereUniqueInput
    data: XOR<StudySessionUpdateWithoutMissionInput, StudySessionUncheckedUpdateWithoutMissionInput>
  }

  export type StudySessionUpdateManyWithWhereWithoutMissionInput = {
    where: StudySessionScalarWhereInput
    data: XOR<StudySessionUpdateManyMutationInput, StudySessionUncheckedUpdateManyWithoutMissionInput>
  }

  export type MissionFeedbackUpsertWithWhereUniqueWithoutMissionInput = {
    where: MissionFeedbackWhereUniqueInput
    update: XOR<MissionFeedbackUpdateWithoutMissionInput, MissionFeedbackUncheckedUpdateWithoutMissionInput>
    create: XOR<MissionFeedbackCreateWithoutMissionInput, MissionFeedbackUncheckedCreateWithoutMissionInput>
  }

  export type MissionFeedbackUpdateWithWhereUniqueWithoutMissionInput = {
    where: MissionFeedbackWhereUniqueInput
    data: XOR<MissionFeedbackUpdateWithoutMissionInput, MissionFeedbackUncheckedUpdateWithoutMissionInput>
  }

  export type MissionFeedbackUpdateManyWithWhereWithoutMissionInput = {
    where: MissionFeedbackScalarWhereInput
    data: XOR<MissionFeedbackUpdateManyMutationInput, MissionFeedbackUncheckedUpdateManyWithoutMissionInput>
  }

  export type MissionFeedbackScalarWhereInput = {
    AND?: MissionFeedbackScalarWhereInput | MissionFeedbackScalarWhereInput[]
    OR?: MissionFeedbackScalarWhereInput[]
    NOT?: MissionFeedbackScalarWhereInput | MissionFeedbackScalarWhereInput[]
    id?: StringFilter<"MissionFeedback"> | string
    userId?: StringFilter<"MissionFeedback"> | string
    missionId?: StringFilter<"MissionFeedback"> | string
    helpfulnessRating?: IntFilter<"MissionFeedback"> | number
    relevanceScore?: IntFilter<"MissionFeedback"> | number
    paceRating?: EnumPaceRatingFilter<"MissionFeedback"> | $Enums.PaceRating
    improvementSuggestions?: StringNullableFilter<"MissionFeedback"> | string | null
    submittedAt?: DateTimeFilter<"MissionFeedback"> | Date | string
  }

  export type InterventionRecommendationUpsertWithWhereUniqueWithoutMissionInput = {
    where: InterventionRecommendationWhereUniqueInput
    update: XOR<InterventionRecommendationUpdateWithoutMissionInput, InterventionRecommendationUncheckedUpdateWithoutMissionInput>
    create: XOR<InterventionRecommendationCreateWithoutMissionInput, InterventionRecommendationUncheckedCreateWithoutMissionInput>
  }

  export type InterventionRecommendationUpdateWithWhereUniqueWithoutMissionInput = {
    where: InterventionRecommendationWhereUniqueInput
    data: XOR<InterventionRecommendationUpdateWithoutMissionInput, InterventionRecommendationUncheckedUpdateWithoutMissionInput>
  }

  export type InterventionRecommendationUpdateManyWithWhereWithoutMissionInput = {
    where: InterventionRecommendationScalarWhereInput
    data: XOR<InterventionRecommendationUpdateManyMutationInput, InterventionRecommendationUncheckedUpdateManyWithoutMissionInput>
  }

  export type InterventionRecommendationScalarWhereInput = {
    AND?: InterventionRecommendationScalarWhereInput | InterventionRecommendationScalarWhereInput[]
    OR?: InterventionRecommendationScalarWhereInput[]
    NOT?: InterventionRecommendationScalarWhereInput | InterventionRecommendationScalarWhereInput[]
    id?: StringFilter<"InterventionRecommendation"> | string
    predictionId?: StringFilter<"InterventionRecommendation"> | string
    userId?: StringFilter<"InterventionRecommendation"> | string
    interventionType?: EnumInterventionTypeFilter<"InterventionRecommendation"> | $Enums.InterventionType
    description?: StringFilter<"InterventionRecommendation"> | string
    reasoning?: StringFilter<"InterventionRecommendation"> | string
    priority?: IntFilter<"InterventionRecommendation"> | number
    status?: EnumInterventionStatusFilter<"InterventionRecommendation"> | $Enums.InterventionStatus
    appliedAt?: DateTimeNullableFilter<"InterventionRecommendation"> | Date | string | null
    appliedToMissionId?: StringNullableFilter<"InterventionRecommendation"> | string | null
    effectiveness?: FloatNullableFilter<"InterventionRecommendation"> | number | null
    createdAt?: DateTimeFilter<"InterventionRecommendation"> | Date | string
  }

  export type CourseCreateWithoutCardsInput = {
    id?: string
    name: string
    code?: string | null
    term?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCoursesInput
    lectures?: LectureCreateNestedManyWithoutCourseInput
    exams?: ExamCreateNestedManyWithoutCourseInput
    coursePriorities?: CoursePriorityCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCardsInput = {
    id?: string
    userId: string
    name: string
    code?: string | null
    term?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lectures?: LectureUncheckedCreateNestedManyWithoutCourseInput
    exams?: ExamUncheckedCreateNestedManyWithoutCourseInput
    coursePriorities?: CoursePriorityUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCardsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCardsInput, CourseUncheckedCreateWithoutCardsInput>
  }

  export type LectureCreateWithoutCardsInput = {
    id?: string
    title: string
    fileName: string
    fileUrl: string
    fileSize: number
    processingStatus?: $Enums.ProcessingStatus
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    processingProgress?: number
    totalPages?: number | null
    processedPages?: number
    processingStartedAt?: Date | string | null
    estimatedCompletionAt?: Date | string | null
    weekNumber?: number | null
    topicTags?: LectureCreatetopicTagsInput | string[]
    user: UserCreateNestedOneWithoutLecturesInput
    course: CourseCreateNestedOneWithoutLecturesInput
    contentChunks?: ContentChunkCreateNestedManyWithoutLectureInput
    learningObjectives?: LearningObjectiveCreateNestedManyWithoutLectureInput
  }

  export type LectureUncheckedCreateWithoutCardsInput = {
    id?: string
    userId: string
    courseId: string
    title: string
    fileName: string
    fileUrl: string
    fileSize: number
    processingStatus?: $Enums.ProcessingStatus
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    processingProgress?: number
    totalPages?: number | null
    processedPages?: number
    processingStartedAt?: Date | string | null
    estimatedCompletionAt?: Date | string | null
    weekNumber?: number | null
    topicTags?: LectureCreatetopicTagsInput | string[]
    contentChunks?: ContentChunkUncheckedCreateNestedManyWithoutLectureInput
    learningObjectives?: LearningObjectiveUncheckedCreateNestedManyWithoutLectureInput
  }

  export type LectureCreateOrConnectWithoutCardsInput = {
    where: LectureWhereUniqueInput
    create: XOR<LectureCreateWithoutCardsInput, LectureUncheckedCreateWithoutCardsInput>
  }

  export type LearningObjectiveCreateWithoutCardsInput = {
    id?: string
    objective: string
    complexity?: $Enums.ObjectiveComplexity
    pageStart?: number | null
    pageEnd?: number | null
    isHighYield?: boolean
    boardExamTags?: LearningObjectiveCreateboardExamTagsInput | string[]
    extractedBy?: string
    createdAt?: Date | string
    masteryLevel?: $Enums.MasteryLevel
    totalStudyTimeMs?: number
    lastStudiedAt?: Date | string | null
    weaknessScore?: number
    lecture: LectureCreateNestedOneWithoutLearningObjectivesInput
    prerequisites?: ObjectivePrerequisiteCreateNestedManyWithoutObjectiveInput
    dependents?: ObjectivePrerequisiteCreateNestedManyWithoutPrerequisiteInput
    performanceMetrics?: PerformanceMetricCreateNestedManyWithoutLearningObjectiveInput
    priorityFeedback?: PriorityFeedbackCreateNestedManyWithoutLearningObjectiveInput
    strugglePredictions?: StrugglePredictionCreateNestedManyWithoutLearningObjectiveInput
    struggleIndicators?: StruggleIndicatorCreateNestedManyWithoutLearningObjectiveInput
  }

  export type LearningObjectiveUncheckedCreateWithoutCardsInput = {
    id?: string
    lectureId: string
    objective: string
    complexity?: $Enums.ObjectiveComplexity
    pageStart?: number | null
    pageEnd?: number | null
    isHighYield?: boolean
    boardExamTags?: LearningObjectiveCreateboardExamTagsInput | string[]
    extractedBy?: string
    createdAt?: Date | string
    masteryLevel?: $Enums.MasteryLevel
    totalStudyTimeMs?: number
    lastStudiedAt?: Date | string | null
    weaknessScore?: number
    prerequisites?: ObjectivePrerequisiteUncheckedCreateNestedManyWithoutObjectiveInput
    dependents?: ObjectivePrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput
    performanceMetrics?: PerformanceMetricUncheckedCreateNestedManyWithoutLearningObjectiveInput
    priorityFeedback?: PriorityFeedbackUncheckedCreateNestedManyWithoutLearningObjectiveInput
    strugglePredictions?: StrugglePredictionUncheckedCreateNestedManyWithoutLearningObjectiveInput
    struggleIndicators?: StruggleIndicatorUncheckedCreateNestedManyWithoutLearningObjectiveInput
  }

  export type LearningObjectiveCreateOrConnectWithoutCardsInput = {
    where: LearningObjectiveWhereUniqueInput
    create: XOR<LearningObjectiveCreateWithoutCardsInput, LearningObjectiveUncheckedCreateWithoutCardsInput>
  }

  export type ReviewCreateWithoutCardInput = {
    id?: string
    rating: $Enums.ReviewRating
    timeSpentMs: number
    reviewedAt?: Date | string
    difficultyBefore: number
    stabilityBefore: number
    difficultyAfter: number
    stabilityAfter: number
    user: UserCreateNestedOneWithoutReviewsInput
    session?: StudySessionCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutCardInput = {
    id?: string
    userId: string
    sessionId?: string | null
    rating: $Enums.ReviewRating
    timeSpentMs: number
    reviewedAt?: Date | string
    difficultyBefore: number
    stabilityBefore: number
    difficultyAfter: number
    stabilityAfter: number
  }

  export type ReviewCreateOrConnectWithoutCardInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutCardInput, ReviewUncheckedCreateWithoutCardInput>
  }

  export type ReviewCreateManyCardInputEnvelope = {
    data: ReviewCreateManyCardInput | ReviewCreateManyCardInput[]
    skipDuplicates?: boolean
  }

  export type CourseUpsertWithoutCardsInput = {
    update: XOR<CourseUpdateWithoutCardsInput, CourseUncheckedUpdateWithoutCardsInput>
    create: XOR<CourseCreateWithoutCardsInput, CourseUncheckedCreateWithoutCardsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutCardsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutCardsInput, CourseUncheckedUpdateWithoutCardsInput>
  }

  export type CourseUpdateWithoutCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoursesNestedInput
    lectures?: LectureUpdateManyWithoutCourseNestedInput
    exams?: ExamUpdateManyWithoutCourseNestedInput
    coursePriorities?: CoursePriorityUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LectureUncheckedUpdateManyWithoutCourseNestedInput
    exams?: ExamUncheckedUpdateManyWithoutCourseNestedInput
    coursePriorities?: CoursePriorityUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type LectureUpsertWithoutCardsInput = {
    update: XOR<LectureUpdateWithoutCardsInput, LectureUncheckedUpdateWithoutCardsInput>
    create: XOR<LectureCreateWithoutCardsInput, LectureUncheckedCreateWithoutCardsInput>
    where?: LectureWhereInput
  }

  export type LectureUpdateToOneWithWhereWithoutCardsInput = {
    where?: LectureWhereInput
    data: XOR<LectureUpdateWithoutCardsInput, LectureUncheckedUpdateWithoutCardsInput>
  }

  export type LectureUpdateWithoutCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingProgress?: IntFieldUpdateOperationsInput | number
    totalPages?: NullableIntFieldUpdateOperationsInput | number | null
    processedPages?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weekNumber?: NullableIntFieldUpdateOperationsInput | number | null
    topicTags?: LectureUpdatetopicTagsInput | string[]
    user?: UserUpdateOneRequiredWithoutLecturesNestedInput
    course?: CourseUpdateOneRequiredWithoutLecturesNestedInput
    contentChunks?: ContentChunkUpdateManyWithoutLectureNestedInput
    learningObjectives?: LearningObjectiveUpdateManyWithoutLectureNestedInput
  }

  export type LectureUncheckedUpdateWithoutCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingProgress?: IntFieldUpdateOperationsInput | number
    totalPages?: NullableIntFieldUpdateOperationsInput | number | null
    processedPages?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weekNumber?: NullableIntFieldUpdateOperationsInput | number | null
    topicTags?: LectureUpdatetopicTagsInput | string[]
    contentChunks?: ContentChunkUncheckedUpdateManyWithoutLectureNestedInput
    learningObjectives?: LearningObjectiveUncheckedUpdateManyWithoutLectureNestedInput
  }

  export type LearningObjectiveUpsertWithoutCardsInput = {
    update: XOR<LearningObjectiveUpdateWithoutCardsInput, LearningObjectiveUncheckedUpdateWithoutCardsInput>
    create: XOR<LearningObjectiveCreateWithoutCardsInput, LearningObjectiveUncheckedCreateWithoutCardsInput>
    where?: LearningObjectiveWhereInput
  }

  export type LearningObjectiveUpdateToOneWithWhereWithoutCardsInput = {
    where?: LearningObjectiveWhereInput
    data: XOR<LearningObjectiveUpdateWithoutCardsInput, LearningObjectiveUncheckedUpdateWithoutCardsInput>
  }

  export type LearningObjectiveUpdateWithoutCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    complexity?: EnumObjectiveComplexityFieldUpdateOperationsInput | $Enums.ObjectiveComplexity
    pageStart?: NullableIntFieldUpdateOperationsInput | number | null
    pageEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isHighYield?: BoolFieldUpdateOperationsInput | boolean
    boardExamTags?: LearningObjectiveUpdateboardExamTagsInput | string[]
    extractedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masteryLevel?: EnumMasteryLevelFieldUpdateOperationsInput | $Enums.MasteryLevel
    totalStudyTimeMs?: IntFieldUpdateOperationsInput | number
    lastStudiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weaknessScore?: FloatFieldUpdateOperationsInput | number
    lecture?: LectureUpdateOneRequiredWithoutLearningObjectivesNestedInput
    prerequisites?: ObjectivePrerequisiteUpdateManyWithoutObjectiveNestedInput
    dependents?: ObjectivePrerequisiteUpdateManyWithoutPrerequisiteNestedInput
    performanceMetrics?: PerformanceMetricUpdateManyWithoutLearningObjectiveNestedInput
    priorityFeedback?: PriorityFeedbackUpdateManyWithoutLearningObjectiveNestedInput
    strugglePredictions?: StrugglePredictionUpdateManyWithoutLearningObjectiveNestedInput
    struggleIndicators?: StruggleIndicatorUpdateManyWithoutLearningObjectiveNestedInput
  }

  export type LearningObjectiveUncheckedUpdateWithoutCardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    complexity?: EnumObjectiveComplexityFieldUpdateOperationsInput | $Enums.ObjectiveComplexity
    pageStart?: NullableIntFieldUpdateOperationsInput | number | null
    pageEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isHighYield?: BoolFieldUpdateOperationsInput | boolean
    boardExamTags?: LearningObjectiveUpdateboardExamTagsInput | string[]
    extractedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masteryLevel?: EnumMasteryLevelFieldUpdateOperationsInput | $Enums.MasteryLevel
    totalStudyTimeMs?: IntFieldUpdateOperationsInput | number
    lastStudiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weaknessScore?: FloatFieldUpdateOperationsInput | number
    prerequisites?: ObjectivePrerequisiteUncheckedUpdateManyWithoutObjectiveNestedInput
    dependents?: ObjectivePrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput
    performanceMetrics?: PerformanceMetricUncheckedUpdateManyWithoutLearningObjectiveNestedInput
    priorityFeedback?: PriorityFeedbackUncheckedUpdateManyWithoutLearningObjectiveNestedInput
    strugglePredictions?: StrugglePredictionUncheckedUpdateManyWithoutLearningObjectiveNestedInput
    struggleIndicators?: StruggleIndicatorUncheckedUpdateManyWithoutLearningObjectiveNestedInput
  }

  export type ReviewUpsertWithWhereUniqueWithoutCardInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutCardInput, ReviewUncheckedUpdateWithoutCardInput>
    create: XOR<ReviewCreateWithoutCardInput, ReviewUncheckedCreateWithoutCardInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutCardInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutCardInput, ReviewUncheckedUpdateWithoutCardInput>
  }

  export type ReviewUpdateManyWithWhereWithoutCardInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutCardInput>
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: CourseCreateNestedManyWithoutUserInput
    lectures?: LectureCreateNestedManyWithoutUserInput
    studySessions?: StudySessionCreateNestedManyWithoutUserInput
    missions?: MissionCreateNestedManyWithoutUserInput
    exams?: ExamCreateNestedManyWithoutUserInput
    coursePriorities?: CoursePriorityCreateNestedManyWithoutUserInput
    streak?: StreakCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    studyGoals?: StudyGoalCreateNestedManyWithoutUserInput
    missionStreak?: MissionStreakCreateNestedOneWithoutUserInput
    missionReviews?: MissionReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    lectures?: LectureUncheckedCreateNestedManyWithoutUserInput
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutUserInput
    missions?: MissionUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamUncheckedCreateNestedManyWithoutUserInput
    coursePriorities?: CoursePriorityUncheckedCreateNestedManyWithoutUserInput
    streak?: StreakUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    studyGoals?: StudyGoalUncheckedCreateNestedManyWithoutUserInput
    missionStreak?: MissionStreakUncheckedCreateNestedOneWithoutUserInput
    missionReviews?: MissionReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type CardCreateWithoutReviewsInput = {
    id?: string
    front: string
    back: string
    cardType?: $Enums.CardType
    createdAt?: Date | string
    difficulty?: number
    stability?: number
    retrievability?: number
    lastReviewedAt?: Date | string | null
    nextReviewAt?: Date | string | null
    reviewCount?: number
    lapseCount?: number
    course: CourseCreateNestedOneWithoutCardsInput
    lecture?: LectureCreateNestedOneWithoutCardsInput
    objective?: LearningObjectiveCreateNestedOneWithoutCardsInput
  }

  export type CardUncheckedCreateWithoutReviewsInput = {
    id?: string
    courseId: string
    lectureId?: string | null
    objectiveId?: string | null
    front: string
    back: string
    cardType?: $Enums.CardType
    createdAt?: Date | string
    difficulty?: number
    stability?: number
    retrievability?: number
    lastReviewedAt?: Date | string | null
    nextReviewAt?: Date | string | null
    reviewCount?: number
    lapseCount?: number
  }

  export type CardCreateOrConnectWithoutReviewsInput = {
    where: CardWhereUniqueInput
    create: XOR<CardCreateWithoutReviewsInput, CardUncheckedCreateWithoutReviewsInput>
  }

  export type StudySessionCreateWithoutReviewsInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    reviewsCompleted?: number
    newCardsStudied?: number
    sessionNotes?: string | null
    currentObjectiveIndex?: number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutStudySessionsInput
    mission?: MissionCreateNestedOneWithoutStudySessionsInput
    validationResponses?: ValidationResponseCreateNestedManyWithoutSessionInput
  }

  export type StudySessionUncheckedCreateWithoutReviewsInput = {
    id?: string
    userId: string
    missionId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    reviewsCompleted?: number
    newCardsStudied?: number
    sessionNotes?: string | null
    currentObjectiveIndex?: number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
    validationResponses?: ValidationResponseUncheckedCreateNestedManyWithoutSessionInput
  }

  export type StudySessionCreateOrConnectWithoutReviewsInput = {
    where: StudySessionWhereUniqueInput
    create: XOR<StudySessionCreateWithoutReviewsInput, StudySessionUncheckedCreateWithoutReviewsInput>
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseUpdateManyWithoutUserNestedInput
    lectures?: LectureUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUpdateManyWithoutUserNestedInput
    missions?: MissionUpdateManyWithoutUserNestedInput
    exams?: ExamUpdateManyWithoutUserNestedInput
    coursePriorities?: CoursePriorityUpdateManyWithoutUserNestedInput
    streak?: StreakUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    studyGoals?: StudyGoalUpdateManyWithoutUserNestedInput
    missionStreak?: MissionStreakUpdateOneWithoutUserNestedInput
    missionReviews?: MissionReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    lectures?: LectureUncheckedUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUncheckedUpdateManyWithoutUserNestedInput
    missions?: MissionUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUserNestedInput
    coursePriorities?: CoursePriorityUncheckedUpdateManyWithoutUserNestedInput
    streak?: StreakUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    studyGoals?: StudyGoalUncheckedUpdateManyWithoutUserNestedInput
    missionStreak?: MissionStreakUncheckedUpdateOneWithoutUserNestedInput
    missionReviews?: MissionReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CardUpsertWithoutReviewsInput = {
    update: XOR<CardUpdateWithoutReviewsInput, CardUncheckedUpdateWithoutReviewsInput>
    create: XOR<CardCreateWithoutReviewsInput, CardUncheckedCreateWithoutReviewsInput>
    where?: CardWhereInput
  }

  export type CardUpdateToOneWithWhereWithoutReviewsInput = {
    where?: CardWhereInput
    data: XOR<CardUpdateWithoutReviewsInput, CardUncheckedUpdateWithoutReviewsInput>
  }

  export type CardUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    front?: StringFieldUpdateOperationsInput | string
    back?: StringFieldUpdateOperationsInput | string
    cardType?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficulty?: FloatFieldUpdateOperationsInput | number
    stability?: FloatFieldUpdateOperationsInput | number
    retrievability?: FloatFieldUpdateOperationsInput | number
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    lapseCount?: IntFieldUpdateOperationsInput | number
    course?: CourseUpdateOneRequiredWithoutCardsNestedInput
    lecture?: LectureUpdateOneWithoutCardsNestedInput
    objective?: LearningObjectiveUpdateOneWithoutCardsNestedInput
  }

  export type CardUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    lectureId?: NullableStringFieldUpdateOperationsInput | string | null
    objectiveId?: NullableStringFieldUpdateOperationsInput | string | null
    front?: StringFieldUpdateOperationsInput | string
    back?: StringFieldUpdateOperationsInput | string
    cardType?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficulty?: FloatFieldUpdateOperationsInput | number
    stability?: FloatFieldUpdateOperationsInput | number
    retrievability?: FloatFieldUpdateOperationsInput | number
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    lapseCount?: IntFieldUpdateOperationsInput | number
  }

  export type StudySessionUpsertWithoutReviewsInput = {
    update: XOR<StudySessionUpdateWithoutReviewsInput, StudySessionUncheckedUpdateWithoutReviewsInput>
    create: XOR<StudySessionCreateWithoutReviewsInput, StudySessionUncheckedCreateWithoutReviewsInput>
    where?: StudySessionWhereInput
  }

  export type StudySessionUpdateToOneWithWhereWithoutReviewsInput = {
    where?: StudySessionWhereInput
    data: XOR<StudySessionUpdateWithoutReviewsInput, StudySessionUncheckedUpdateWithoutReviewsInput>
  }

  export type StudySessionUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    reviewsCompleted?: IntFieldUpdateOperationsInput | number
    newCardsStudied?: IntFieldUpdateOperationsInput | number
    sessionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    currentObjectiveIndex?: IntFieldUpdateOperationsInput | number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutStudySessionsNestedInput
    mission?: MissionUpdateOneWithoutStudySessionsNestedInput
    validationResponses?: ValidationResponseUpdateManyWithoutSessionNestedInput
  }

  export type StudySessionUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    missionId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    reviewsCompleted?: IntFieldUpdateOperationsInput | number
    newCardsStudied?: IntFieldUpdateOperationsInput | number
    sessionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    currentObjectiveIndex?: IntFieldUpdateOperationsInput | number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
    validationResponses?: ValidationResponseUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserCreateWithoutStudySessionsInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: CourseCreateNestedManyWithoutUserInput
    lectures?: LectureCreateNestedManyWithoutUserInput
    missions?: MissionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    exams?: ExamCreateNestedManyWithoutUserInput
    coursePriorities?: CoursePriorityCreateNestedManyWithoutUserInput
    streak?: StreakCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    studyGoals?: StudyGoalCreateNestedManyWithoutUserInput
    missionStreak?: MissionStreakCreateNestedOneWithoutUserInput
    missionReviews?: MissionReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStudySessionsInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    lectures?: LectureUncheckedCreateNestedManyWithoutUserInput
    missions?: MissionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamUncheckedCreateNestedManyWithoutUserInput
    coursePriorities?: CoursePriorityUncheckedCreateNestedManyWithoutUserInput
    streak?: StreakUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    studyGoals?: StudyGoalUncheckedCreateNestedManyWithoutUserInput
    missionStreak?: MissionStreakUncheckedCreateNestedOneWithoutUserInput
    missionReviews?: MissionReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudySessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudySessionsInput, UserUncheckedCreateWithoutStudySessionsInput>
  }

  export type MissionCreateWithoutStudySessionsInput = {
    id?: string
    date?: Date | string
    status?: $Enums.MissionStatus
    estimatedMinutes: number
    completedAt?: Date | string | null
    actualMinutes?: number | null
    completedObjectivesCount?: number
    objectives: JsonNullValueInput | InputJsonValue
    reviewCardCount?: number
    newContentCount?: number
    successScore?: number | null
    difficultyRating?: number | null
    user: UserCreateNestedOneWithoutMissionsInput
    feedback?: MissionFeedbackCreateNestedManyWithoutMissionInput
    interventions?: InterventionRecommendationCreateNestedManyWithoutMissionInput
  }

  export type MissionUncheckedCreateWithoutStudySessionsInput = {
    id?: string
    userId: string
    date?: Date | string
    status?: $Enums.MissionStatus
    estimatedMinutes: number
    completedAt?: Date | string | null
    actualMinutes?: number | null
    completedObjectivesCount?: number
    objectives: JsonNullValueInput | InputJsonValue
    reviewCardCount?: number
    newContentCount?: number
    successScore?: number | null
    difficultyRating?: number | null
    feedback?: MissionFeedbackUncheckedCreateNestedManyWithoutMissionInput
    interventions?: InterventionRecommendationUncheckedCreateNestedManyWithoutMissionInput
  }

  export type MissionCreateOrConnectWithoutStudySessionsInput = {
    where: MissionWhereUniqueInput
    create: XOR<MissionCreateWithoutStudySessionsInput, MissionUncheckedCreateWithoutStudySessionsInput>
  }

  export type ReviewCreateWithoutSessionInput = {
    id?: string
    rating: $Enums.ReviewRating
    timeSpentMs: number
    reviewedAt?: Date | string
    difficultyBefore: number
    stabilityBefore: number
    difficultyAfter: number
    stabilityAfter: number
    user: UserCreateNestedOneWithoutReviewsInput
    card: CardCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutSessionInput = {
    id?: string
    userId: string
    cardId: string
    rating: $Enums.ReviewRating
    timeSpentMs: number
    reviewedAt?: Date | string
    difficultyBefore: number
    stabilityBefore: number
    difficultyAfter: number
    stabilityAfter: number
  }

  export type ReviewCreateOrConnectWithoutSessionInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutSessionInput, ReviewUncheckedCreateWithoutSessionInput>
  }

  export type ReviewCreateManySessionInputEnvelope = {
    data: ReviewCreateManySessionInput | ReviewCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type ValidationResponseCreateWithoutSessionInput = {
    id?: string
    userAnswer: string
    aiEvaluation: string
    score: number
    confidence?: number | null
    respondedAt?: Date | string
    prompt: ValidationPromptCreateNestedOneWithoutResponsesInput
  }

  export type ValidationResponseUncheckedCreateWithoutSessionInput = {
    id?: string
    promptId: string
    userAnswer: string
    aiEvaluation: string
    score: number
    confidence?: number | null
    respondedAt?: Date | string
  }

  export type ValidationResponseCreateOrConnectWithoutSessionInput = {
    where: ValidationResponseWhereUniqueInput
    create: XOR<ValidationResponseCreateWithoutSessionInput, ValidationResponseUncheckedCreateWithoutSessionInput>
  }

  export type ValidationResponseCreateManySessionInputEnvelope = {
    data: ValidationResponseCreateManySessionInput | ValidationResponseCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStudySessionsInput = {
    update: XOR<UserUpdateWithoutStudySessionsInput, UserUncheckedUpdateWithoutStudySessionsInput>
    create: XOR<UserCreateWithoutStudySessionsInput, UserUncheckedCreateWithoutStudySessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudySessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudySessionsInput, UserUncheckedUpdateWithoutStudySessionsInput>
  }

  export type UserUpdateWithoutStudySessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseUpdateManyWithoutUserNestedInput
    lectures?: LectureUpdateManyWithoutUserNestedInput
    missions?: MissionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    exams?: ExamUpdateManyWithoutUserNestedInput
    coursePriorities?: CoursePriorityUpdateManyWithoutUserNestedInput
    streak?: StreakUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    studyGoals?: StudyGoalUpdateManyWithoutUserNestedInput
    missionStreak?: MissionStreakUpdateOneWithoutUserNestedInput
    missionReviews?: MissionReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudySessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    lectures?: LectureUncheckedUpdateManyWithoutUserNestedInput
    missions?: MissionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUserNestedInput
    coursePriorities?: CoursePriorityUncheckedUpdateManyWithoutUserNestedInput
    streak?: StreakUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    studyGoals?: StudyGoalUncheckedUpdateManyWithoutUserNestedInput
    missionStreak?: MissionStreakUncheckedUpdateOneWithoutUserNestedInput
    missionReviews?: MissionReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MissionUpsertWithoutStudySessionsInput = {
    update: XOR<MissionUpdateWithoutStudySessionsInput, MissionUncheckedUpdateWithoutStudySessionsInput>
    create: XOR<MissionCreateWithoutStudySessionsInput, MissionUncheckedCreateWithoutStudySessionsInput>
    where?: MissionWhereInput
  }

  export type MissionUpdateToOneWithWhereWithoutStudySessionsInput = {
    where?: MissionWhereInput
    data: XOR<MissionUpdateWithoutStudySessionsInput, MissionUncheckedUpdateWithoutStudySessionsInput>
  }

  export type MissionUpdateWithoutStudySessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMissionStatusFieldUpdateOperationsInput | $Enums.MissionStatus
    estimatedMinutes?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    completedObjectivesCount?: IntFieldUpdateOperationsInput | number
    objectives?: JsonNullValueInput | InputJsonValue
    reviewCardCount?: IntFieldUpdateOperationsInput | number
    newContentCount?: IntFieldUpdateOperationsInput | number
    successScore?: NullableFloatFieldUpdateOperationsInput | number | null
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutMissionsNestedInput
    feedback?: MissionFeedbackUpdateManyWithoutMissionNestedInput
    interventions?: InterventionRecommendationUpdateManyWithoutMissionNestedInput
  }

  export type MissionUncheckedUpdateWithoutStudySessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMissionStatusFieldUpdateOperationsInput | $Enums.MissionStatus
    estimatedMinutes?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    completedObjectivesCount?: IntFieldUpdateOperationsInput | number
    objectives?: JsonNullValueInput | InputJsonValue
    reviewCardCount?: IntFieldUpdateOperationsInput | number
    newContentCount?: IntFieldUpdateOperationsInput | number
    successScore?: NullableFloatFieldUpdateOperationsInput | number | null
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: MissionFeedbackUncheckedUpdateManyWithoutMissionNestedInput
    interventions?: InterventionRecommendationUncheckedUpdateManyWithoutMissionNestedInput
  }

  export type ReviewUpsertWithWhereUniqueWithoutSessionInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutSessionInput, ReviewUncheckedUpdateWithoutSessionInput>
    create: XOR<ReviewCreateWithoutSessionInput, ReviewUncheckedCreateWithoutSessionInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutSessionInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutSessionInput, ReviewUncheckedUpdateWithoutSessionInput>
  }

  export type ReviewUpdateManyWithWhereWithoutSessionInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutSessionInput>
  }

  export type ValidationResponseUpsertWithWhereUniqueWithoutSessionInput = {
    where: ValidationResponseWhereUniqueInput
    update: XOR<ValidationResponseUpdateWithoutSessionInput, ValidationResponseUncheckedUpdateWithoutSessionInput>
    create: XOR<ValidationResponseCreateWithoutSessionInput, ValidationResponseUncheckedCreateWithoutSessionInput>
  }

  export type ValidationResponseUpdateWithWhereUniqueWithoutSessionInput = {
    where: ValidationResponseWhereUniqueInput
    data: XOR<ValidationResponseUpdateWithoutSessionInput, ValidationResponseUncheckedUpdateWithoutSessionInput>
  }

  export type ValidationResponseUpdateManyWithWhereWithoutSessionInput = {
    where: ValidationResponseScalarWhereInput
    data: XOR<ValidationResponseUpdateManyMutationInput, ValidationResponseUncheckedUpdateManyWithoutSessionInput>
  }

  export type ValidationResponseScalarWhereInput = {
    AND?: ValidationResponseScalarWhereInput | ValidationResponseScalarWhereInput[]
    OR?: ValidationResponseScalarWhereInput[]
    NOT?: ValidationResponseScalarWhereInput | ValidationResponseScalarWhereInput[]
    id?: StringFilter<"ValidationResponse"> | string
    promptId?: StringFilter<"ValidationResponse"> | string
    sessionId?: StringNullableFilter<"ValidationResponse"> | string | null
    userAnswer?: StringFilter<"ValidationResponse"> | string
    aiEvaluation?: StringFilter<"ValidationResponse"> | string
    score?: FloatFilter<"ValidationResponse"> | number
    confidence?: FloatNullableFilter<"ValidationResponse"> | number | null
    respondedAt?: DateTimeFilter<"ValidationResponse"> | Date | string
  }

  export type ConceptRelationshipCreateWithoutFromConceptInput = {
    id?: string
    relationship: $Enums.RelationshipType
    strength?: number
    createdAt?: Date | string
    toConcept: ConceptCreateNestedOneWithoutRelatedToInput
  }

  export type ConceptRelationshipUncheckedCreateWithoutFromConceptInput = {
    id?: string
    toConceptId: string
    relationship: $Enums.RelationshipType
    strength?: number
    createdAt?: Date | string
  }

  export type ConceptRelationshipCreateOrConnectWithoutFromConceptInput = {
    where: ConceptRelationshipWhereUniqueInput
    create: XOR<ConceptRelationshipCreateWithoutFromConceptInput, ConceptRelationshipUncheckedCreateWithoutFromConceptInput>
  }

  export type ConceptRelationshipCreateManyFromConceptInputEnvelope = {
    data: ConceptRelationshipCreateManyFromConceptInput | ConceptRelationshipCreateManyFromConceptInput[]
    skipDuplicates?: boolean
  }

  export type ConceptRelationshipCreateWithoutToConceptInput = {
    id?: string
    relationship: $Enums.RelationshipType
    strength?: number
    createdAt?: Date | string
    fromConcept: ConceptCreateNestedOneWithoutRelatedFromInput
  }

  export type ConceptRelationshipUncheckedCreateWithoutToConceptInput = {
    id?: string
    fromConceptId: string
    relationship: $Enums.RelationshipType
    strength?: number
    createdAt?: Date | string
  }

  export type ConceptRelationshipCreateOrConnectWithoutToConceptInput = {
    where: ConceptRelationshipWhereUniqueInput
    create: XOR<ConceptRelationshipCreateWithoutToConceptInput, ConceptRelationshipUncheckedCreateWithoutToConceptInput>
  }

  export type ConceptRelationshipCreateManyToConceptInputEnvelope = {
    data: ConceptRelationshipCreateManyToConceptInput | ConceptRelationshipCreateManyToConceptInput[]
    skipDuplicates?: boolean
  }

  export type ConceptRelationshipUpsertWithWhereUniqueWithoutFromConceptInput = {
    where: ConceptRelationshipWhereUniqueInput
    update: XOR<ConceptRelationshipUpdateWithoutFromConceptInput, ConceptRelationshipUncheckedUpdateWithoutFromConceptInput>
    create: XOR<ConceptRelationshipCreateWithoutFromConceptInput, ConceptRelationshipUncheckedCreateWithoutFromConceptInput>
  }

  export type ConceptRelationshipUpdateWithWhereUniqueWithoutFromConceptInput = {
    where: ConceptRelationshipWhereUniqueInput
    data: XOR<ConceptRelationshipUpdateWithoutFromConceptInput, ConceptRelationshipUncheckedUpdateWithoutFromConceptInput>
  }

  export type ConceptRelationshipUpdateManyWithWhereWithoutFromConceptInput = {
    where: ConceptRelationshipScalarWhereInput
    data: XOR<ConceptRelationshipUpdateManyMutationInput, ConceptRelationshipUncheckedUpdateManyWithoutFromConceptInput>
  }

  export type ConceptRelationshipScalarWhereInput = {
    AND?: ConceptRelationshipScalarWhereInput | ConceptRelationshipScalarWhereInput[]
    OR?: ConceptRelationshipScalarWhereInput[]
    NOT?: ConceptRelationshipScalarWhereInput | ConceptRelationshipScalarWhereInput[]
    id?: StringFilter<"ConceptRelationship"> | string
    fromConceptId?: StringFilter<"ConceptRelationship"> | string
    toConceptId?: StringFilter<"ConceptRelationship"> | string
    relationship?: EnumRelationshipTypeFilter<"ConceptRelationship"> | $Enums.RelationshipType
    strength?: FloatFilter<"ConceptRelationship"> | number
    createdAt?: DateTimeFilter<"ConceptRelationship"> | Date | string
  }

  export type ConceptRelationshipUpsertWithWhereUniqueWithoutToConceptInput = {
    where: ConceptRelationshipWhereUniqueInput
    update: XOR<ConceptRelationshipUpdateWithoutToConceptInput, ConceptRelationshipUncheckedUpdateWithoutToConceptInput>
    create: XOR<ConceptRelationshipCreateWithoutToConceptInput, ConceptRelationshipUncheckedCreateWithoutToConceptInput>
  }

  export type ConceptRelationshipUpdateWithWhereUniqueWithoutToConceptInput = {
    where: ConceptRelationshipWhereUniqueInput
    data: XOR<ConceptRelationshipUpdateWithoutToConceptInput, ConceptRelationshipUncheckedUpdateWithoutToConceptInput>
  }

  export type ConceptRelationshipUpdateManyWithWhereWithoutToConceptInput = {
    where: ConceptRelationshipScalarWhereInput
    data: XOR<ConceptRelationshipUpdateManyMutationInput, ConceptRelationshipUncheckedUpdateManyWithoutToConceptInput>
  }

  export type ConceptCreateWithoutRelatedFromInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    relatedTo?: ConceptRelationshipCreateNestedManyWithoutToConceptInput
  }

  export type ConceptUncheckedCreateWithoutRelatedFromInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    relatedTo?: ConceptRelationshipUncheckedCreateNestedManyWithoutToConceptInput
  }

  export type ConceptCreateOrConnectWithoutRelatedFromInput = {
    where: ConceptWhereUniqueInput
    create: XOR<ConceptCreateWithoutRelatedFromInput, ConceptUncheckedCreateWithoutRelatedFromInput>
  }

  export type ConceptCreateWithoutRelatedToInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    relatedFrom?: ConceptRelationshipCreateNestedManyWithoutFromConceptInput
  }

  export type ConceptUncheckedCreateWithoutRelatedToInput = {
    id?: string
    name: string
    description?: string | null
    category?: string | null
    createdAt?: Date | string
    relatedFrom?: ConceptRelationshipUncheckedCreateNestedManyWithoutFromConceptInput
  }

  export type ConceptCreateOrConnectWithoutRelatedToInput = {
    where: ConceptWhereUniqueInput
    create: XOR<ConceptCreateWithoutRelatedToInput, ConceptUncheckedCreateWithoutRelatedToInput>
  }

  export type ConceptUpsertWithoutRelatedFromInput = {
    update: XOR<ConceptUpdateWithoutRelatedFromInput, ConceptUncheckedUpdateWithoutRelatedFromInput>
    create: XOR<ConceptCreateWithoutRelatedFromInput, ConceptUncheckedCreateWithoutRelatedFromInput>
    where?: ConceptWhereInput
  }

  export type ConceptUpdateToOneWithWhereWithoutRelatedFromInput = {
    where?: ConceptWhereInput
    data: XOR<ConceptUpdateWithoutRelatedFromInput, ConceptUncheckedUpdateWithoutRelatedFromInput>
  }

  export type ConceptUpdateWithoutRelatedFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedTo?: ConceptRelationshipUpdateManyWithoutToConceptNestedInput
  }

  export type ConceptUncheckedUpdateWithoutRelatedFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedTo?: ConceptRelationshipUncheckedUpdateManyWithoutToConceptNestedInput
  }

  export type ConceptUpsertWithoutRelatedToInput = {
    update: XOR<ConceptUpdateWithoutRelatedToInput, ConceptUncheckedUpdateWithoutRelatedToInput>
    create: XOR<ConceptCreateWithoutRelatedToInput, ConceptUncheckedCreateWithoutRelatedToInput>
    where?: ConceptWhereInput
  }

  export type ConceptUpdateToOneWithWhereWithoutRelatedToInput = {
    where?: ConceptWhereInput
    data: XOR<ConceptUpdateWithoutRelatedToInput, ConceptUncheckedUpdateWithoutRelatedToInput>
  }

  export type ConceptUpdateWithoutRelatedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedFrom?: ConceptRelationshipUpdateManyWithoutFromConceptNestedInput
  }

  export type ConceptUncheckedUpdateWithoutRelatedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedFrom?: ConceptRelationshipUncheckedUpdateManyWithoutFromConceptNestedInput
  }

  export type ValidationResponseCreateWithoutPromptInput = {
    id?: string
    userAnswer: string
    aiEvaluation: string
    score: number
    confidence?: number | null
    respondedAt?: Date | string
    session?: StudySessionCreateNestedOneWithoutValidationResponsesInput
  }

  export type ValidationResponseUncheckedCreateWithoutPromptInput = {
    id?: string
    sessionId?: string | null
    userAnswer: string
    aiEvaluation: string
    score: number
    confidence?: number | null
    respondedAt?: Date | string
  }

  export type ValidationResponseCreateOrConnectWithoutPromptInput = {
    where: ValidationResponseWhereUniqueInput
    create: XOR<ValidationResponseCreateWithoutPromptInput, ValidationResponseUncheckedCreateWithoutPromptInput>
  }

  export type ValidationResponseCreateManyPromptInputEnvelope = {
    data: ValidationResponseCreateManyPromptInput | ValidationResponseCreateManyPromptInput[]
    skipDuplicates?: boolean
  }

  export type ValidationResponseUpsertWithWhereUniqueWithoutPromptInput = {
    where: ValidationResponseWhereUniqueInput
    update: XOR<ValidationResponseUpdateWithoutPromptInput, ValidationResponseUncheckedUpdateWithoutPromptInput>
    create: XOR<ValidationResponseCreateWithoutPromptInput, ValidationResponseUncheckedCreateWithoutPromptInput>
  }

  export type ValidationResponseUpdateWithWhereUniqueWithoutPromptInput = {
    where: ValidationResponseWhereUniqueInput
    data: XOR<ValidationResponseUpdateWithoutPromptInput, ValidationResponseUncheckedUpdateWithoutPromptInput>
  }

  export type ValidationResponseUpdateManyWithWhereWithoutPromptInput = {
    where: ValidationResponseScalarWhereInput
    data: XOR<ValidationResponseUpdateManyMutationInput, ValidationResponseUncheckedUpdateManyWithoutPromptInput>
  }

  export type ValidationPromptCreateWithoutResponsesInput = {
    id?: string
    promptText: string
    promptType: $Enums.PromptType
    conceptName: string
    expectedCriteria?: ValidationPromptCreateexpectedCriteriaInput | string[]
    createdAt?: Date | string
  }

  export type ValidationPromptUncheckedCreateWithoutResponsesInput = {
    id?: string
    promptText: string
    promptType: $Enums.PromptType
    conceptName: string
    expectedCriteria?: ValidationPromptCreateexpectedCriteriaInput | string[]
    createdAt?: Date | string
  }

  export type ValidationPromptCreateOrConnectWithoutResponsesInput = {
    where: ValidationPromptWhereUniqueInput
    create: XOR<ValidationPromptCreateWithoutResponsesInput, ValidationPromptUncheckedCreateWithoutResponsesInput>
  }

  export type StudySessionCreateWithoutValidationResponsesInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    reviewsCompleted?: number
    newCardsStudied?: number
    sessionNotes?: string | null
    currentObjectiveIndex?: number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutStudySessionsInput
    mission?: MissionCreateNestedOneWithoutStudySessionsInput
    reviews?: ReviewCreateNestedManyWithoutSessionInput
  }

  export type StudySessionUncheckedCreateWithoutValidationResponsesInput = {
    id?: string
    userId: string
    missionId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    reviewsCompleted?: number
    newCardsStudied?: number
    sessionNotes?: string | null
    currentObjectiveIndex?: number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
    reviews?: ReviewUncheckedCreateNestedManyWithoutSessionInput
  }

  export type StudySessionCreateOrConnectWithoutValidationResponsesInput = {
    where: StudySessionWhereUniqueInput
    create: XOR<StudySessionCreateWithoutValidationResponsesInput, StudySessionUncheckedCreateWithoutValidationResponsesInput>
  }

  export type ValidationPromptUpsertWithoutResponsesInput = {
    update: XOR<ValidationPromptUpdateWithoutResponsesInput, ValidationPromptUncheckedUpdateWithoutResponsesInput>
    create: XOR<ValidationPromptCreateWithoutResponsesInput, ValidationPromptUncheckedCreateWithoutResponsesInput>
    where?: ValidationPromptWhereInput
  }

  export type ValidationPromptUpdateToOneWithWhereWithoutResponsesInput = {
    where?: ValidationPromptWhereInput
    data: XOR<ValidationPromptUpdateWithoutResponsesInput, ValidationPromptUncheckedUpdateWithoutResponsesInput>
  }

  export type ValidationPromptUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptText?: StringFieldUpdateOperationsInput | string
    promptType?: EnumPromptTypeFieldUpdateOperationsInput | $Enums.PromptType
    conceptName?: StringFieldUpdateOperationsInput | string
    expectedCriteria?: ValidationPromptUpdateexpectedCriteriaInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ValidationPromptUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptText?: StringFieldUpdateOperationsInput | string
    promptType?: EnumPromptTypeFieldUpdateOperationsInput | $Enums.PromptType
    conceptName?: StringFieldUpdateOperationsInput | string
    expectedCriteria?: ValidationPromptUpdateexpectedCriteriaInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudySessionUpsertWithoutValidationResponsesInput = {
    update: XOR<StudySessionUpdateWithoutValidationResponsesInput, StudySessionUncheckedUpdateWithoutValidationResponsesInput>
    create: XOR<StudySessionCreateWithoutValidationResponsesInput, StudySessionUncheckedCreateWithoutValidationResponsesInput>
    where?: StudySessionWhereInput
  }

  export type StudySessionUpdateToOneWithWhereWithoutValidationResponsesInput = {
    where?: StudySessionWhereInput
    data: XOR<StudySessionUpdateWithoutValidationResponsesInput, StudySessionUncheckedUpdateWithoutValidationResponsesInput>
  }

  export type StudySessionUpdateWithoutValidationResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    reviewsCompleted?: IntFieldUpdateOperationsInput | number
    newCardsStudied?: IntFieldUpdateOperationsInput | number
    sessionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    currentObjectiveIndex?: IntFieldUpdateOperationsInput | number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutStudySessionsNestedInput
    mission?: MissionUpdateOneWithoutStudySessionsNestedInput
    reviews?: ReviewUpdateManyWithoutSessionNestedInput
  }

  export type StudySessionUncheckedUpdateWithoutValidationResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    missionId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    reviewsCompleted?: IntFieldUpdateOperationsInput | number
    newCardsStudied?: IntFieldUpdateOperationsInput | number
    sessionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    currentObjectiveIndex?: IntFieldUpdateOperationsInput | number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
    reviews?: ReviewUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type InsightPatternCreateWithoutPatternInput = {
    id?: string
    insight: BehavioralInsightCreateNestedOneWithoutPatternsInput
  }

  export type InsightPatternUncheckedCreateWithoutPatternInput = {
    id?: string
    insightId: string
  }

  export type InsightPatternCreateOrConnectWithoutPatternInput = {
    where: InsightPatternWhereUniqueInput
    create: XOR<InsightPatternCreateWithoutPatternInput, InsightPatternUncheckedCreateWithoutPatternInput>
  }

  export type InsightPatternCreateManyPatternInputEnvelope = {
    data: InsightPatternCreateManyPatternInput | InsightPatternCreateManyPatternInput[]
    skipDuplicates?: boolean
  }

  export type InsightPatternUpsertWithWhereUniqueWithoutPatternInput = {
    where: InsightPatternWhereUniqueInput
    update: XOR<InsightPatternUpdateWithoutPatternInput, InsightPatternUncheckedUpdateWithoutPatternInput>
    create: XOR<InsightPatternCreateWithoutPatternInput, InsightPatternUncheckedCreateWithoutPatternInput>
  }

  export type InsightPatternUpdateWithWhereUniqueWithoutPatternInput = {
    where: InsightPatternWhereUniqueInput
    data: XOR<InsightPatternUpdateWithoutPatternInput, InsightPatternUncheckedUpdateWithoutPatternInput>
  }

  export type InsightPatternUpdateManyWithWhereWithoutPatternInput = {
    where: InsightPatternScalarWhereInput
    data: XOR<InsightPatternUpdateManyMutationInput, InsightPatternUncheckedUpdateManyWithoutPatternInput>
  }

  export type InsightPatternScalarWhereInput = {
    AND?: InsightPatternScalarWhereInput | InsightPatternScalarWhereInput[]
    OR?: InsightPatternScalarWhereInput[]
    NOT?: InsightPatternScalarWhereInput | InsightPatternScalarWhereInput[]
    id?: StringFilter<"InsightPattern"> | string
    insightId?: StringFilter<"InsightPattern"> | string
    patternId?: StringFilter<"InsightPattern"> | string
  }

  export type InsightPatternCreateWithoutInsightInput = {
    id?: string
    pattern: BehavioralPatternCreateNestedOneWithoutInsightsInput
  }

  export type InsightPatternUncheckedCreateWithoutInsightInput = {
    id?: string
    patternId: string
  }

  export type InsightPatternCreateOrConnectWithoutInsightInput = {
    where: InsightPatternWhereUniqueInput
    create: XOR<InsightPatternCreateWithoutInsightInput, InsightPatternUncheckedCreateWithoutInsightInput>
  }

  export type InsightPatternCreateManyInsightInputEnvelope = {
    data: InsightPatternCreateManyInsightInput | InsightPatternCreateManyInsightInput[]
    skipDuplicates?: boolean
  }

  export type InsightPatternUpsertWithWhereUniqueWithoutInsightInput = {
    where: InsightPatternWhereUniqueInput
    update: XOR<InsightPatternUpdateWithoutInsightInput, InsightPatternUncheckedUpdateWithoutInsightInput>
    create: XOR<InsightPatternCreateWithoutInsightInput, InsightPatternUncheckedCreateWithoutInsightInput>
  }

  export type InsightPatternUpdateWithWhereUniqueWithoutInsightInput = {
    where: InsightPatternWhereUniqueInput
    data: XOR<InsightPatternUpdateWithoutInsightInput, InsightPatternUncheckedUpdateWithoutInsightInput>
  }

  export type InsightPatternUpdateManyWithWhereWithoutInsightInput = {
    where: InsightPatternScalarWhereInput
    data: XOR<InsightPatternUpdateManyMutationInput, InsightPatternUncheckedUpdateManyWithoutInsightInput>
  }

  export type BehavioralInsightCreateWithoutPatternsInput = {
    id?: string
    userId: string
    insightType: $Enums.InsightType
    title: string
    description: string
    actionableRecommendation: string
    confidence: number
    createdAt?: Date | string
    acknowledgedAt?: Date | string | null
    applied?: boolean
  }

  export type BehavioralInsightUncheckedCreateWithoutPatternsInput = {
    id?: string
    userId: string
    insightType: $Enums.InsightType
    title: string
    description: string
    actionableRecommendation: string
    confidence: number
    createdAt?: Date | string
    acknowledgedAt?: Date | string | null
    applied?: boolean
  }

  export type BehavioralInsightCreateOrConnectWithoutPatternsInput = {
    where: BehavioralInsightWhereUniqueInput
    create: XOR<BehavioralInsightCreateWithoutPatternsInput, BehavioralInsightUncheckedCreateWithoutPatternsInput>
  }

  export type BehavioralPatternCreateWithoutInsightsInput = {
    id?: string
    userId: string
    patternType: $Enums.BehavioralPatternType
    patternName: string
    confidence: number
    evidence: JsonNullValueInput | InputJsonValue
    detectedAt?: Date | string
    lastSeenAt?: Date | string
    occurrenceCount?: number
  }

  export type BehavioralPatternUncheckedCreateWithoutInsightsInput = {
    id?: string
    userId: string
    patternType: $Enums.BehavioralPatternType
    patternName: string
    confidence: number
    evidence: JsonNullValueInput | InputJsonValue
    detectedAt?: Date | string
    lastSeenAt?: Date | string
    occurrenceCount?: number
  }

  export type BehavioralPatternCreateOrConnectWithoutInsightsInput = {
    where: BehavioralPatternWhereUniqueInput
    create: XOR<BehavioralPatternCreateWithoutInsightsInput, BehavioralPatternUncheckedCreateWithoutInsightsInput>
  }

  export type BehavioralInsightUpsertWithoutPatternsInput = {
    update: XOR<BehavioralInsightUpdateWithoutPatternsInput, BehavioralInsightUncheckedUpdateWithoutPatternsInput>
    create: XOR<BehavioralInsightCreateWithoutPatternsInput, BehavioralInsightUncheckedCreateWithoutPatternsInput>
    where?: BehavioralInsightWhereInput
  }

  export type BehavioralInsightUpdateToOneWithWhereWithoutPatternsInput = {
    where?: BehavioralInsightWhereInput
    data: XOR<BehavioralInsightUpdateWithoutPatternsInput, BehavioralInsightUncheckedUpdateWithoutPatternsInput>
  }

  export type BehavioralInsightUpdateWithoutPatternsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    insightType?: EnumInsightTypeFieldUpdateOperationsInput | $Enums.InsightType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionableRecommendation?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BehavioralInsightUncheckedUpdateWithoutPatternsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    insightType?: EnumInsightTypeFieldUpdateOperationsInput | $Enums.InsightType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    actionableRecommendation?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applied?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BehavioralPatternUpsertWithoutInsightsInput = {
    update: XOR<BehavioralPatternUpdateWithoutInsightsInput, BehavioralPatternUncheckedUpdateWithoutInsightsInput>
    create: XOR<BehavioralPatternCreateWithoutInsightsInput, BehavioralPatternUncheckedCreateWithoutInsightsInput>
    where?: BehavioralPatternWhereInput
  }

  export type BehavioralPatternUpdateToOneWithWhereWithoutInsightsInput = {
    where?: BehavioralPatternWhereInput
    data: XOR<BehavioralPatternUpdateWithoutInsightsInput, BehavioralPatternUncheckedUpdateWithoutInsightsInput>
  }

  export type BehavioralPatternUpdateWithoutInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    patternType?: EnumBehavioralPatternTypeFieldUpdateOperationsInput | $Enums.BehavioralPatternType
    patternName?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: JsonNullValueInput | InputJsonValue
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    occurrenceCount?: IntFieldUpdateOperationsInput | number
  }

  export type BehavioralPatternUncheckedUpdateWithoutInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    patternType?: EnumBehavioralPatternTypeFieldUpdateOperationsInput | $Enums.BehavioralPatternType
    patternName?: StringFieldUpdateOperationsInput | string
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: JsonNullValueInput | InputJsonValue
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    occurrenceCount?: IntFieldUpdateOperationsInput | number
  }

  export type LearningObjectiveCreateWithoutStrugglePredictionsInput = {
    id?: string
    objective: string
    complexity?: $Enums.ObjectiveComplexity
    pageStart?: number | null
    pageEnd?: number | null
    isHighYield?: boolean
    boardExamTags?: LearningObjectiveCreateboardExamTagsInput | string[]
    extractedBy?: string
    createdAt?: Date | string
    masteryLevel?: $Enums.MasteryLevel
    totalStudyTimeMs?: number
    lastStudiedAt?: Date | string | null
    weaknessScore?: number
    lecture: LectureCreateNestedOneWithoutLearningObjectivesInput
    cards?: CardCreateNestedManyWithoutObjectiveInput
    prerequisites?: ObjectivePrerequisiteCreateNestedManyWithoutObjectiveInput
    dependents?: ObjectivePrerequisiteCreateNestedManyWithoutPrerequisiteInput
    performanceMetrics?: PerformanceMetricCreateNestedManyWithoutLearningObjectiveInput
    priorityFeedback?: PriorityFeedbackCreateNestedManyWithoutLearningObjectiveInput
    struggleIndicators?: StruggleIndicatorCreateNestedManyWithoutLearningObjectiveInput
  }

  export type LearningObjectiveUncheckedCreateWithoutStrugglePredictionsInput = {
    id?: string
    lectureId: string
    objective: string
    complexity?: $Enums.ObjectiveComplexity
    pageStart?: number | null
    pageEnd?: number | null
    isHighYield?: boolean
    boardExamTags?: LearningObjectiveCreateboardExamTagsInput | string[]
    extractedBy?: string
    createdAt?: Date | string
    masteryLevel?: $Enums.MasteryLevel
    totalStudyTimeMs?: number
    lastStudiedAt?: Date | string | null
    weaknessScore?: number
    cards?: CardUncheckedCreateNestedManyWithoutObjectiveInput
    prerequisites?: ObjectivePrerequisiteUncheckedCreateNestedManyWithoutObjectiveInput
    dependents?: ObjectivePrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput
    performanceMetrics?: PerformanceMetricUncheckedCreateNestedManyWithoutLearningObjectiveInput
    priorityFeedback?: PriorityFeedbackUncheckedCreateNestedManyWithoutLearningObjectiveInput
    struggleIndicators?: StruggleIndicatorUncheckedCreateNestedManyWithoutLearningObjectiveInput
  }

  export type LearningObjectiveCreateOrConnectWithoutStrugglePredictionsInput = {
    where: LearningObjectiveWhereUniqueInput
    create: XOR<LearningObjectiveCreateWithoutStrugglePredictionsInput, LearningObjectiveUncheckedCreateWithoutStrugglePredictionsInput>
  }

  export type StruggleIndicatorCreateWithoutPredictionInput = {
    id?: string
    userId: string
    indicatorType: $Enums.IndicatorType
    severity?: $Enums.Severity
    detectedAt?: Date | string
    context: JsonNullValueInput | InputJsonValue
    learningObjective: LearningObjectiveCreateNestedOneWithoutStruggleIndicatorsInput
  }

  export type StruggleIndicatorUncheckedCreateWithoutPredictionInput = {
    id?: string
    userId: string
    learningObjectiveId: string
    indicatorType: $Enums.IndicatorType
    severity?: $Enums.Severity
    detectedAt?: Date | string
    context: JsonNullValueInput | InputJsonValue
  }

  export type StruggleIndicatorCreateOrConnectWithoutPredictionInput = {
    where: StruggleIndicatorWhereUniqueInput
    create: XOR<StruggleIndicatorCreateWithoutPredictionInput, StruggleIndicatorUncheckedCreateWithoutPredictionInput>
  }

  export type StruggleIndicatorCreateManyPredictionInputEnvelope = {
    data: StruggleIndicatorCreateManyPredictionInput | StruggleIndicatorCreateManyPredictionInput[]
    skipDuplicates?: boolean
  }

  export type InterventionRecommendationCreateWithoutPredictionInput = {
    id?: string
    userId: string
    interventionType: $Enums.InterventionType
    description: string
    reasoning: string
    priority?: number
    status?: $Enums.InterventionStatus
    appliedAt?: Date | string | null
    effectiveness?: number | null
    createdAt?: Date | string
    mission?: MissionCreateNestedOneWithoutInterventionsInput
  }

  export type InterventionRecommendationUncheckedCreateWithoutPredictionInput = {
    id?: string
    userId: string
    interventionType: $Enums.InterventionType
    description: string
    reasoning: string
    priority?: number
    status?: $Enums.InterventionStatus
    appliedAt?: Date | string | null
    appliedToMissionId?: string | null
    effectiveness?: number | null
    createdAt?: Date | string
  }

  export type InterventionRecommendationCreateOrConnectWithoutPredictionInput = {
    where: InterventionRecommendationWhereUniqueInput
    create: XOR<InterventionRecommendationCreateWithoutPredictionInput, InterventionRecommendationUncheckedCreateWithoutPredictionInput>
  }

  export type InterventionRecommendationCreateManyPredictionInputEnvelope = {
    data: InterventionRecommendationCreateManyPredictionInput | InterventionRecommendationCreateManyPredictionInput[]
    skipDuplicates?: boolean
  }

  export type PredictionFeedbackCreateWithoutPredictionInput = {
    id?: string
    userId: string
    feedbackType: $Enums.FeedbackType
    actualStruggle: boolean
    helpfulness?: number | null
    comments?: string | null
    submittedAt?: Date | string
  }

  export type PredictionFeedbackUncheckedCreateWithoutPredictionInput = {
    id?: string
    userId: string
    feedbackType: $Enums.FeedbackType
    actualStruggle: boolean
    helpfulness?: number | null
    comments?: string | null
    submittedAt?: Date | string
  }

  export type PredictionFeedbackCreateOrConnectWithoutPredictionInput = {
    where: PredictionFeedbackWhereUniqueInput
    create: XOR<PredictionFeedbackCreateWithoutPredictionInput, PredictionFeedbackUncheckedCreateWithoutPredictionInput>
  }

  export type PredictionFeedbackCreateManyPredictionInputEnvelope = {
    data: PredictionFeedbackCreateManyPredictionInput | PredictionFeedbackCreateManyPredictionInput[]
    skipDuplicates?: boolean
  }

  export type LearningObjectiveUpsertWithoutStrugglePredictionsInput = {
    update: XOR<LearningObjectiveUpdateWithoutStrugglePredictionsInput, LearningObjectiveUncheckedUpdateWithoutStrugglePredictionsInput>
    create: XOR<LearningObjectiveCreateWithoutStrugglePredictionsInput, LearningObjectiveUncheckedCreateWithoutStrugglePredictionsInput>
    where?: LearningObjectiveWhereInput
  }

  export type LearningObjectiveUpdateToOneWithWhereWithoutStrugglePredictionsInput = {
    where?: LearningObjectiveWhereInput
    data: XOR<LearningObjectiveUpdateWithoutStrugglePredictionsInput, LearningObjectiveUncheckedUpdateWithoutStrugglePredictionsInput>
  }

  export type LearningObjectiveUpdateWithoutStrugglePredictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    complexity?: EnumObjectiveComplexityFieldUpdateOperationsInput | $Enums.ObjectiveComplexity
    pageStart?: NullableIntFieldUpdateOperationsInput | number | null
    pageEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isHighYield?: BoolFieldUpdateOperationsInput | boolean
    boardExamTags?: LearningObjectiveUpdateboardExamTagsInput | string[]
    extractedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masteryLevel?: EnumMasteryLevelFieldUpdateOperationsInput | $Enums.MasteryLevel
    totalStudyTimeMs?: IntFieldUpdateOperationsInput | number
    lastStudiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weaknessScore?: FloatFieldUpdateOperationsInput | number
    lecture?: LectureUpdateOneRequiredWithoutLearningObjectivesNestedInput
    cards?: CardUpdateManyWithoutObjectiveNestedInput
    prerequisites?: ObjectivePrerequisiteUpdateManyWithoutObjectiveNestedInput
    dependents?: ObjectivePrerequisiteUpdateManyWithoutPrerequisiteNestedInput
    performanceMetrics?: PerformanceMetricUpdateManyWithoutLearningObjectiveNestedInput
    priorityFeedback?: PriorityFeedbackUpdateManyWithoutLearningObjectiveNestedInput
    struggleIndicators?: StruggleIndicatorUpdateManyWithoutLearningObjectiveNestedInput
  }

  export type LearningObjectiveUncheckedUpdateWithoutStrugglePredictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    complexity?: EnumObjectiveComplexityFieldUpdateOperationsInput | $Enums.ObjectiveComplexity
    pageStart?: NullableIntFieldUpdateOperationsInput | number | null
    pageEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isHighYield?: BoolFieldUpdateOperationsInput | boolean
    boardExamTags?: LearningObjectiveUpdateboardExamTagsInput | string[]
    extractedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masteryLevel?: EnumMasteryLevelFieldUpdateOperationsInput | $Enums.MasteryLevel
    totalStudyTimeMs?: IntFieldUpdateOperationsInput | number
    lastStudiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weaknessScore?: FloatFieldUpdateOperationsInput | number
    cards?: CardUncheckedUpdateManyWithoutObjectiveNestedInput
    prerequisites?: ObjectivePrerequisiteUncheckedUpdateManyWithoutObjectiveNestedInput
    dependents?: ObjectivePrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput
    performanceMetrics?: PerformanceMetricUncheckedUpdateManyWithoutLearningObjectiveNestedInput
    priorityFeedback?: PriorityFeedbackUncheckedUpdateManyWithoutLearningObjectiveNestedInput
    struggleIndicators?: StruggleIndicatorUncheckedUpdateManyWithoutLearningObjectiveNestedInput
  }

  export type StruggleIndicatorUpsertWithWhereUniqueWithoutPredictionInput = {
    where: StruggleIndicatorWhereUniqueInput
    update: XOR<StruggleIndicatorUpdateWithoutPredictionInput, StruggleIndicatorUncheckedUpdateWithoutPredictionInput>
    create: XOR<StruggleIndicatorCreateWithoutPredictionInput, StruggleIndicatorUncheckedCreateWithoutPredictionInput>
  }

  export type StruggleIndicatorUpdateWithWhereUniqueWithoutPredictionInput = {
    where: StruggleIndicatorWhereUniqueInput
    data: XOR<StruggleIndicatorUpdateWithoutPredictionInput, StruggleIndicatorUncheckedUpdateWithoutPredictionInput>
  }

  export type StruggleIndicatorUpdateManyWithWhereWithoutPredictionInput = {
    where: StruggleIndicatorScalarWhereInput
    data: XOR<StruggleIndicatorUpdateManyMutationInput, StruggleIndicatorUncheckedUpdateManyWithoutPredictionInput>
  }

  export type InterventionRecommendationUpsertWithWhereUniqueWithoutPredictionInput = {
    where: InterventionRecommendationWhereUniqueInput
    update: XOR<InterventionRecommendationUpdateWithoutPredictionInput, InterventionRecommendationUncheckedUpdateWithoutPredictionInput>
    create: XOR<InterventionRecommendationCreateWithoutPredictionInput, InterventionRecommendationUncheckedCreateWithoutPredictionInput>
  }

  export type InterventionRecommendationUpdateWithWhereUniqueWithoutPredictionInput = {
    where: InterventionRecommendationWhereUniqueInput
    data: XOR<InterventionRecommendationUpdateWithoutPredictionInput, InterventionRecommendationUncheckedUpdateWithoutPredictionInput>
  }

  export type InterventionRecommendationUpdateManyWithWhereWithoutPredictionInput = {
    where: InterventionRecommendationScalarWhereInput
    data: XOR<InterventionRecommendationUpdateManyMutationInput, InterventionRecommendationUncheckedUpdateManyWithoutPredictionInput>
  }

  export type PredictionFeedbackUpsertWithWhereUniqueWithoutPredictionInput = {
    where: PredictionFeedbackWhereUniqueInput
    update: XOR<PredictionFeedbackUpdateWithoutPredictionInput, PredictionFeedbackUncheckedUpdateWithoutPredictionInput>
    create: XOR<PredictionFeedbackCreateWithoutPredictionInput, PredictionFeedbackUncheckedCreateWithoutPredictionInput>
  }

  export type PredictionFeedbackUpdateWithWhereUniqueWithoutPredictionInput = {
    where: PredictionFeedbackWhereUniqueInput
    data: XOR<PredictionFeedbackUpdateWithoutPredictionInput, PredictionFeedbackUncheckedUpdateWithoutPredictionInput>
  }

  export type PredictionFeedbackUpdateManyWithWhereWithoutPredictionInput = {
    where: PredictionFeedbackScalarWhereInput
    data: XOR<PredictionFeedbackUpdateManyMutationInput, PredictionFeedbackUncheckedUpdateManyWithoutPredictionInput>
  }

  export type PredictionFeedbackScalarWhereInput = {
    AND?: PredictionFeedbackScalarWhereInput | PredictionFeedbackScalarWhereInput[]
    OR?: PredictionFeedbackScalarWhereInput[]
    NOT?: PredictionFeedbackScalarWhereInput | PredictionFeedbackScalarWhereInput[]
    id?: StringFilter<"PredictionFeedback"> | string
    predictionId?: StringFilter<"PredictionFeedback"> | string
    userId?: StringFilter<"PredictionFeedback"> | string
    feedbackType?: EnumFeedbackTypeFilter<"PredictionFeedback"> | $Enums.FeedbackType
    actualStruggle?: BoolFilter<"PredictionFeedback"> | boolean
    helpfulness?: IntNullableFilter<"PredictionFeedback"> | number | null
    comments?: StringNullableFilter<"PredictionFeedback"> | string | null
    submittedAt?: DateTimeFilter<"PredictionFeedback"> | Date | string
  }

  export type StrugglePredictionCreateWithoutIndicatorsInput = {
    id?: string
    userId: string
    topicId?: string | null
    predictionDate?: Date | string
    predictedStruggleProbability: number
    predictionConfidence: number
    predictionStatus?: $Enums.PredictionStatus
    actualOutcome?: boolean | null
    outcomeRecordedAt?: Date | string | null
    featureVector: JsonNullValueInput | InputJsonValue
    learningObjective?: LearningObjectiveCreateNestedOneWithoutStrugglePredictionsInput
    interventions?: InterventionRecommendationCreateNestedManyWithoutPredictionInput
    feedbacks?: PredictionFeedbackCreateNestedManyWithoutPredictionInput
  }

  export type StrugglePredictionUncheckedCreateWithoutIndicatorsInput = {
    id?: string
    userId: string
    learningObjectiveId?: string | null
    topicId?: string | null
    predictionDate?: Date | string
    predictedStruggleProbability: number
    predictionConfidence: number
    predictionStatus?: $Enums.PredictionStatus
    actualOutcome?: boolean | null
    outcomeRecordedAt?: Date | string | null
    featureVector: JsonNullValueInput | InputJsonValue
    interventions?: InterventionRecommendationUncheckedCreateNestedManyWithoutPredictionInput
    feedbacks?: PredictionFeedbackUncheckedCreateNestedManyWithoutPredictionInput
  }

  export type StrugglePredictionCreateOrConnectWithoutIndicatorsInput = {
    where: StrugglePredictionWhereUniqueInput
    create: XOR<StrugglePredictionCreateWithoutIndicatorsInput, StrugglePredictionUncheckedCreateWithoutIndicatorsInput>
  }

  export type LearningObjectiveCreateWithoutStruggleIndicatorsInput = {
    id?: string
    objective: string
    complexity?: $Enums.ObjectiveComplexity
    pageStart?: number | null
    pageEnd?: number | null
    isHighYield?: boolean
    boardExamTags?: LearningObjectiveCreateboardExamTagsInput | string[]
    extractedBy?: string
    createdAt?: Date | string
    masteryLevel?: $Enums.MasteryLevel
    totalStudyTimeMs?: number
    lastStudiedAt?: Date | string | null
    weaknessScore?: number
    lecture: LectureCreateNestedOneWithoutLearningObjectivesInput
    cards?: CardCreateNestedManyWithoutObjectiveInput
    prerequisites?: ObjectivePrerequisiteCreateNestedManyWithoutObjectiveInput
    dependents?: ObjectivePrerequisiteCreateNestedManyWithoutPrerequisiteInput
    performanceMetrics?: PerformanceMetricCreateNestedManyWithoutLearningObjectiveInput
    priorityFeedback?: PriorityFeedbackCreateNestedManyWithoutLearningObjectiveInput
    strugglePredictions?: StrugglePredictionCreateNestedManyWithoutLearningObjectiveInput
  }

  export type LearningObjectiveUncheckedCreateWithoutStruggleIndicatorsInput = {
    id?: string
    lectureId: string
    objective: string
    complexity?: $Enums.ObjectiveComplexity
    pageStart?: number | null
    pageEnd?: number | null
    isHighYield?: boolean
    boardExamTags?: LearningObjectiveCreateboardExamTagsInput | string[]
    extractedBy?: string
    createdAt?: Date | string
    masteryLevel?: $Enums.MasteryLevel
    totalStudyTimeMs?: number
    lastStudiedAt?: Date | string | null
    weaknessScore?: number
    cards?: CardUncheckedCreateNestedManyWithoutObjectiveInput
    prerequisites?: ObjectivePrerequisiteUncheckedCreateNestedManyWithoutObjectiveInput
    dependents?: ObjectivePrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput
    performanceMetrics?: PerformanceMetricUncheckedCreateNestedManyWithoutLearningObjectiveInput
    priorityFeedback?: PriorityFeedbackUncheckedCreateNestedManyWithoutLearningObjectiveInput
    strugglePredictions?: StrugglePredictionUncheckedCreateNestedManyWithoutLearningObjectiveInput
  }

  export type LearningObjectiveCreateOrConnectWithoutStruggleIndicatorsInput = {
    where: LearningObjectiveWhereUniqueInput
    create: XOR<LearningObjectiveCreateWithoutStruggleIndicatorsInput, LearningObjectiveUncheckedCreateWithoutStruggleIndicatorsInput>
  }

  export type StrugglePredictionUpsertWithoutIndicatorsInput = {
    update: XOR<StrugglePredictionUpdateWithoutIndicatorsInput, StrugglePredictionUncheckedUpdateWithoutIndicatorsInput>
    create: XOR<StrugglePredictionCreateWithoutIndicatorsInput, StrugglePredictionUncheckedCreateWithoutIndicatorsInput>
    where?: StrugglePredictionWhereInput
  }

  export type StrugglePredictionUpdateToOneWithWhereWithoutIndicatorsInput = {
    where?: StrugglePredictionWhereInput
    data: XOR<StrugglePredictionUpdateWithoutIndicatorsInput, StrugglePredictionUncheckedUpdateWithoutIndicatorsInput>
  }

  export type StrugglePredictionUpdateWithoutIndicatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    predictionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    predictedStruggleProbability?: FloatFieldUpdateOperationsInput | number
    predictionConfidence?: FloatFieldUpdateOperationsInput | number
    predictionStatus?: EnumPredictionStatusFieldUpdateOperationsInput | $Enums.PredictionStatus
    actualOutcome?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outcomeRecordedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featureVector?: JsonNullValueInput | InputJsonValue
    learningObjective?: LearningObjectiveUpdateOneWithoutStrugglePredictionsNestedInput
    interventions?: InterventionRecommendationUpdateManyWithoutPredictionNestedInput
    feedbacks?: PredictionFeedbackUpdateManyWithoutPredictionNestedInput
  }

  export type StrugglePredictionUncheckedUpdateWithoutIndicatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    learningObjectiveId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    predictionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    predictedStruggleProbability?: FloatFieldUpdateOperationsInput | number
    predictionConfidence?: FloatFieldUpdateOperationsInput | number
    predictionStatus?: EnumPredictionStatusFieldUpdateOperationsInput | $Enums.PredictionStatus
    actualOutcome?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outcomeRecordedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featureVector?: JsonNullValueInput | InputJsonValue
    interventions?: InterventionRecommendationUncheckedUpdateManyWithoutPredictionNestedInput
    feedbacks?: PredictionFeedbackUncheckedUpdateManyWithoutPredictionNestedInput
  }

  export type LearningObjectiveUpsertWithoutStruggleIndicatorsInput = {
    update: XOR<LearningObjectiveUpdateWithoutStruggleIndicatorsInput, LearningObjectiveUncheckedUpdateWithoutStruggleIndicatorsInput>
    create: XOR<LearningObjectiveCreateWithoutStruggleIndicatorsInput, LearningObjectiveUncheckedCreateWithoutStruggleIndicatorsInput>
    where?: LearningObjectiveWhereInput
  }

  export type LearningObjectiveUpdateToOneWithWhereWithoutStruggleIndicatorsInput = {
    where?: LearningObjectiveWhereInput
    data: XOR<LearningObjectiveUpdateWithoutStruggleIndicatorsInput, LearningObjectiveUncheckedUpdateWithoutStruggleIndicatorsInput>
  }

  export type LearningObjectiveUpdateWithoutStruggleIndicatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    complexity?: EnumObjectiveComplexityFieldUpdateOperationsInput | $Enums.ObjectiveComplexity
    pageStart?: NullableIntFieldUpdateOperationsInput | number | null
    pageEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isHighYield?: BoolFieldUpdateOperationsInput | boolean
    boardExamTags?: LearningObjectiveUpdateboardExamTagsInput | string[]
    extractedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masteryLevel?: EnumMasteryLevelFieldUpdateOperationsInput | $Enums.MasteryLevel
    totalStudyTimeMs?: IntFieldUpdateOperationsInput | number
    lastStudiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weaknessScore?: FloatFieldUpdateOperationsInput | number
    lecture?: LectureUpdateOneRequiredWithoutLearningObjectivesNestedInput
    cards?: CardUpdateManyWithoutObjectiveNestedInput
    prerequisites?: ObjectivePrerequisiteUpdateManyWithoutObjectiveNestedInput
    dependents?: ObjectivePrerequisiteUpdateManyWithoutPrerequisiteNestedInput
    performanceMetrics?: PerformanceMetricUpdateManyWithoutLearningObjectiveNestedInput
    priorityFeedback?: PriorityFeedbackUpdateManyWithoutLearningObjectiveNestedInput
    strugglePredictions?: StrugglePredictionUpdateManyWithoutLearningObjectiveNestedInput
  }

  export type LearningObjectiveUncheckedUpdateWithoutStruggleIndicatorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    complexity?: EnumObjectiveComplexityFieldUpdateOperationsInput | $Enums.ObjectiveComplexity
    pageStart?: NullableIntFieldUpdateOperationsInput | number | null
    pageEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isHighYield?: BoolFieldUpdateOperationsInput | boolean
    boardExamTags?: LearningObjectiveUpdateboardExamTagsInput | string[]
    extractedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masteryLevel?: EnumMasteryLevelFieldUpdateOperationsInput | $Enums.MasteryLevel
    totalStudyTimeMs?: IntFieldUpdateOperationsInput | number
    lastStudiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weaknessScore?: FloatFieldUpdateOperationsInput | number
    cards?: CardUncheckedUpdateManyWithoutObjectiveNestedInput
    prerequisites?: ObjectivePrerequisiteUncheckedUpdateManyWithoutObjectiveNestedInput
    dependents?: ObjectivePrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput
    performanceMetrics?: PerformanceMetricUncheckedUpdateManyWithoutLearningObjectiveNestedInput
    priorityFeedback?: PriorityFeedbackUncheckedUpdateManyWithoutLearningObjectiveNestedInput
    strugglePredictions?: StrugglePredictionUncheckedUpdateManyWithoutLearningObjectiveNestedInput
  }

  export type StrugglePredictionCreateWithoutInterventionsInput = {
    id?: string
    userId: string
    topicId?: string | null
    predictionDate?: Date | string
    predictedStruggleProbability: number
    predictionConfidence: number
    predictionStatus?: $Enums.PredictionStatus
    actualOutcome?: boolean | null
    outcomeRecordedAt?: Date | string | null
    featureVector: JsonNullValueInput | InputJsonValue
    learningObjective?: LearningObjectiveCreateNestedOneWithoutStrugglePredictionsInput
    indicators?: StruggleIndicatorCreateNestedManyWithoutPredictionInput
    feedbacks?: PredictionFeedbackCreateNestedManyWithoutPredictionInput
  }

  export type StrugglePredictionUncheckedCreateWithoutInterventionsInput = {
    id?: string
    userId: string
    learningObjectiveId?: string | null
    topicId?: string | null
    predictionDate?: Date | string
    predictedStruggleProbability: number
    predictionConfidence: number
    predictionStatus?: $Enums.PredictionStatus
    actualOutcome?: boolean | null
    outcomeRecordedAt?: Date | string | null
    featureVector: JsonNullValueInput | InputJsonValue
    indicators?: StruggleIndicatorUncheckedCreateNestedManyWithoutPredictionInput
    feedbacks?: PredictionFeedbackUncheckedCreateNestedManyWithoutPredictionInput
  }

  export type StrugglePredictionCreateOrConnectWithoutInterventionsInput = {
    where: StrugglePredictionWhereUniqueInput
    create: XOR<StrugglePredictionCreateWithoutInterventionsInput, StrugglePredictionUncheckedCreateWithoutInterventionsInput>
  }

  export type MissionCreateWithoutInterventionsInput = {
    id?: string
    date?: Date | string
    status?: $Enums.MissionStatus
    estimatedMinutes: number
    completedAt?: Date | string | null
    actualMinutes?: number | null
    completedObjectivesCount?: number
    objectives: JsonNullValueInput | InputJsonValue
    reviewCardCount?: number
    newContentCount?: number
    successScore?: number | null
    difficultyRating?: number | null
    user: UserCreateNestedOneWithoutMissionsInput
    studySessions?: StudySessionCreateNestedManyWithoutMissionInput
    feedback?: MissionFeedbackCreateNestedManyWithoutMissionInput
  }

  export type MissionUncheckedCreateWithoutInterventionsInput = {
    id?: string
    userId: string
    date?: Date | string
    status?: $Enums.MissionStatus
    estimatedMinutes: number
    completedAt?: Date | string | null
    actualMinutes?: number | null
    completedObjectivesCount?: number
    objectives: JsonNullValueInput | InputJsonValue
    reviewCardCount?: number
    newContentCount?: number
    successScore?: number | null
    difficultyRating?: number | null
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutMissionInput
    feedback?: MissionFeedbackUncheckedCreateNestedManyWithoutMissionInput
  }

  export type MissionCreateOrConnectWithoutInterventionsInput = {
    where: MissionWhereUniqueInput
    create: XOR<MissionCreateWithoutInterventionsInput, MissionUncheckedCreateWithoutInterventionsInput>
  }

  export type StrugglePredictionUpsertWithoutInterventionsInput = {
    update: XOR<StrugglePredictionUpdateWithoutInterventionsInput, StrugglePredictionUncheckedUpdateWithoutInterventionsInput>
    create: XOR<StrugglePredictionCreateWithoutInterventionsInput, StrugglePredictionUncheckedCreateWithoutInterventionsInput>
    where?: StrugglePredictionWhereInput
  }

  export type StrugglePredictionUpdateToOneWithWhereWithoutInterventionsInput = {
    where?: StrugglePredictionWhereInput
    data: XOR<StrugglePredictionUpdateWithoutInterventionsInput, StrugglePredictionUncheckedUpdateWithoutInterventionsInput>
  }

  export type StrugglePredictionUpdateWithoutInterventionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    predictionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    predictedStruggleProbability?: FloatFieldUpdateOperationsInput | number
    predictionConfidence?: FloatFieldUpdateOperationsInput | number
    predictionStatus?: EnumPredictionStatusFieldUpdateOperationsInput | $Enums.PredictionStatus
    actualOutcome?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outcomeRecordedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featureVector?: JsonNullValueInput | InputJsonValue
    learningObjective?: LearningObjectiveUpdateOneWithoutStrugglePredictionsNestedInput
    indicators?: StruggleIndicatorUpdateManyWithoutPredictionNestedInput
    feedbacks?: PredictionFeedbackUpdateManyWithoutPredictionNestedInput
  }

  export type StrugglePredictionUncheckedUpdateWithoutInterventionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    learningObjectiveId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    predictionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    predictedStruggleProbability?: FloatFieldUpdateOperationsInput | number
    predictionConfidence?: FloatFieldUpdateOperationsInput | number
    predictionStatus?: EnumPredictionStatusFieldUpdateOperationsInput | $Enums.PredictionStatus
    actualOutcome?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outcomeRecordedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featureVector?: JsonNullValueInput | InputJsonValue
    indicators?: StruggleIndicatorUncheckedUpdateManyWithoutPredictionNestedInput
    feedbacks?: PredictionFeedbackUncheckedUpdateManyWithoutPredictionNestedInput
  }

  export type MissionUpsertWithoutInterventionsInput = {
    update: XOR<MissionUpdateWithoutInterventionsInput, MissionUncheckedUpdateWithoutInterventionsInput>
    create: XOR<MissionCreateWithoutInterventionsInput, MissionUncheckedCreateWithoutInterventionsInput>
    where?: MissionWhereInput
  }

  export type MissionUpdateToOneWithWhereWithoutInterventionsInput = {
    where?: MissionWhereInput
    data: XOR<MissionUpdateWithoutInterventionsInput, MissionUncheckedUpdateWithoutInterventionsInput>
  }

  export type MissionUpdateWithoutInterventionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMissionStatusFieldUpdateOperationsInput | $Enums.MissionStatus
    estimatedMinutes?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    completedObjectivesCount?: IntFieldUpdateOperationsInput | number
    objectives?: JsonNullValueInput | InputJsonValue
    reviewCardCount?: IntFieldUpdateOperationsInput | number
    newContentCount?: IntFieldUpdateOperationsInput | number
    successScore?: NullableFloatFieldUpdateOperationsInput | number | null
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutMissionsNestedInput
    studySessions?: StudySessionUpdateManyWithoutMissionNestedInput
    feedback?: MissionFeedbackUpdateManyWithoutMissionNestedInput
  }

  export type MissionUncheckedUpdateWithoutInterventionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMissionStatusFieldUpdateOperationsInput | $Enums.MissionStatus
    estimatedMinutes?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    completedObjectivesCount?: IntFieldUpdateOperationsInput | number
    objectives?: JsonNullValueInput | InputJsonValue
    reviewCardCount?: IntFieldUpdateOperationsInput | number
    newContentCount?: IntFieldUpdateOperationsInput | number
    successScore?: NullableFloatFieldUpdateOperationsInput | number | null
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    studySessions?: StudySessionUncheckedUpdateManyWithoutMissionNestedInput
    feedback?: MissionFeedbackUncheckedUpdateManyWithoutMissionNestedInput
  }

  export type StrugglePredictionCreateWithoutFeedbacksInput = {
    id?: string
    userId: string
    topicId?: string | null
    predictionDate?: Date | string
    predictedStruggleProbability: number
    predictionConfidence: number
    predictionStatus?: $Enums.PredictionStatus
    actualOutcome?: boolean | null
    outcomeRecordedAt?: Date | string | null
    featureVector: JsonNullValueInput | InputJsonValue
    learningObjective?: LearningObjectiveCreateNestedOneWithoutStrugglePredictionsInput
    indicators?: StruggleIndicatorCreateNestedManyWithoutPredictionInput
    interventions?: InterventionRecommendationCreateNestedManyWithoutPredictionInput
  }

  export type StrugglePredictionUncheckedCreateWithoutFeedbacksInput = {
    id?: string
    userId: string
    learningObjectiveId?: string | null
    topicId?: string | null
    predictionDate?: Date | string
    predictedStruggleProbability: number
    predictionConfidence: number
    predictionStatus?: $Enums.PredictionStatus
    actualOutcome?: boolean | null
    outcomeRecordedAt?: Date | string | null
    featureVector: JsonNullValueInput | InputJsonValue
    indicators?: StruggleIndicatorUncheckedCreateNestedManyWithoutPredictionInput
    interventions?: InterventionRecommendationUncheckedCreateNestedManyWithoutPredictionInput
  }

  export type StrugglePredictionCreateOrConnectWithoutFeedbacksInput = {
    where: StrugglePredictionWhereUniqueInput
    create: XOR<StrugglePredictionCreateWithoutFeedbacksInput, StrugglePredictionUncheckedCreateWithoutFeedbacksInput>
  }

  export type StrugglePredictionUpsertWithoutFeedbacksInput = {
    update: XOR<StrugglePredictionUpdateWithoutFeedbacksInput, StrugglePredictionUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<StrugglePredictionCreateWithoutFeedbacksInput, StrugglePredictionUncheckedCreateWithoutFeedbacksInput>
    where?: StrugglePredictionWhereInput
  }

  export type StrugglePredictionUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: StrugglePredictionWhereInput
    data: XOR<StrugglePredictionUpdateWithoutFeedbacksInput, StrugglePredictionUncheckedUpdateWithoutFeedbacksInput>
  }

  export type StrugglePredictionUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    predictionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    predictedStruggleProbability?: FloatFieldUpdateOperationsInput | number
    predictionConfidence?: FloatFieldUpdateOperationsInput | number
    predictionStatus?: EnumPredictionStatusFieldUpdateOperationsInput | $Enums.PredictionStatus
    actualOutcome?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outcomeRecordedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featureVector?: JsonNullValueInput | InputJsonValue
    learningObjective?: LearningObjectiveUpdateOneWithoutStrugglePredictionsNestedInput
    indicators?: StruggleIndicatorUpdateManyWithoutPredictionNestedInput
    interventions?: InterventionRecommendationUpdateManyWithoutPredictionNestedInput
  }

  export type StrugglePredictionUncheckedUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    learningObjectiveId?: NullableStringFieldUpdateOperationsInput | string | null
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    predictionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    predictedStruggleProbability?: FloatFieldUpdateOperationsInput | number
    predictionConfidence?: FloatFieldUpdateOperationsInput | number
    predictionStatus?: EnumPredictionStatusFieldUpdateOperationsInput | $Enums.PredictionStatus
    actualOutcome?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outcomeRecordedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featureVector?: JsonNullValueInput | InputJsonValue
    indicators?: StruggleIndicatorUncheckedUpdateManyWithoutPredictionNestedInput
    interventions?: InterventionRecommendationUncheckedUpdateManyWithoutPredictionNestedInput
  }

  export type LearningObjectiveCreateWithoutPerformanceMetricsInput = {
    id?: string
    objective: string
    complexity?: $Enums.ObjectiveComplexity
    pageStart?: number | null
    pageEnd?: number | null
    isHighYield?: boolean
    boardExamTags?: LearningObjectiveCreateboardExamTagsInput | string[]
    extractedBy?: string
    createdAt?: Date | string
    masteryLevel?: $Enums.MasteryLevel
    totalStudyTimeMs?: number
    lastStudiedAt?: Date | string | null
    weaknessScore?: number
    lecture: LectureCreateNestedOneWithoutLearningObjectivesInput
    cards?: CardCreateNestedManyWithoutObjectiveInput
    prerequisites?: ObjectivePrerequisiteCreateNestedManyWithoutObjectiveInput
    dependents?: ObjectivePrerequisiteCreateNestedManyWithoutPrerequisiteInput
    priorityFeedback?: PriorityFeedbackCreateNestedManyWithoutLearningObjectiveInput
    strugglePredictions?: StrugglePredictionCreateNestedManyWithoutLearningObjectiveInput
    struggleIndicators?: StruggleIndicatorCreateNestedManyWithoutLearningObjectiveInput
  }

  export type LearningObjectiveUncheckedCreateWithoutPerformanceMetricsInput = {
    id?: string
    lectureId: string
    objective: string
    complexity?: $Enums.ObjectiveComplexity
    pageStart?: number | null
    pageEnd?: number | null
    isHighYield?: boolean
    boardExamTags?: LearningObjectiveCreateboardExamTagsInput | string[]
    extractedBy?: string
    createdAt?: Date | string
    masteryLevel?: $Enums.MasteryLevel
    totalStudyTimeMs?: number
    lastStudiedAt?: Date | string | null
    weaknessScore?: number
    cards?: CardUncheckedCreateNestedManyWithoutObjectiveInput
    prerequisites?: ObjectivePrerequisiteUncheckedCreateNestedManyWithoutObjectiveInput
    dependents?: ObjectivePrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput
    priorityFeedback?: PriorityFeedbackUncheckedCreateNestedManyWithoutLearningObjectiveInput
    strugglePredictions?: StrugglePredictionUncheckedCreateNestedManyWithoutLearningObjectiveInput
    struggleIndicators?: StruggleIndicatorUncheckedCreateNestedManyWithoutLearningObjectiveInput
  }

  export type LearningObjectiveCreateOrConnectWithoutPerformanceMetricsInput = {
    where: LearningObjectiveWhereUniqueInput
    create: XOR<LearningObjectiveCreateWithoutPerformanceMetricsInput, LearningObjectiveUncheckedCreateWithoutPerformanceMetricsInput>
  }

  export type LearningObjectiveUpsertWithoutPerformanceMetricsInput = {
    update: XOR<LearningObjectiveUpdateWithoutPerformanceMetricsInput, LearningObjectiveUncheckedUpdateWithoutPerformanceMetricsInput>
    create: XOR<LearningObjectiveCreateWithoutPerformanceMetricsInput, LearningObjectiveUncheckedCreateWithoutPerformanceMetricsInput>
    where?: LearningObjectiveWhereInput
  }

  export type LearningObjectiveUpdateToOneWithWhereWithoutPerformanceMetricsInput = {
    where?: LearningObjectiveWhereInput
    data: XOR<LearningObjectiveUpdateWithoutPerformanceMetricsInput, LearningObjectiveUncheckedUpdateWithoutPerformanceMetricsInput>
  }

  export type LearningObjectiveUpdateWithoutPerformanceMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    complexity?: EnumObjectiveComplexityFieldUpdateOperationsInput | $Enums.ObjectiveComplexity
    pageStart?: NullableIntFieldUpdateOperationsInput | number | null
    pageEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isHighYield?: BoolFieldUpdateOperationsInput | boolean
    boardExamTags?: LearningObjectiveUpdateboardExamTagsInput | string[]
    extractedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masteryLevel?: EnumMasteryLevelFieldUpdateOperationsInput | $Enums.MasteryLevel
    totalStudyTimeMs?: IntFieldUpdateOperationsInput | number
    lastStudiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weaknessScore?: FloatFieldUpdateOperationsInput | number
    lecture?: LectureUpdateOneRequiredWithoutLearningObjectivesNestedInput
    cards?: CardUpdateManyWithoutObjectiveNestedInput
    prerequisites?: ObjectivePrerequisiteUpdateManyWithoutObjectiveNestedInput
    dependents?: ObjectivePrerequisiteUpdateManyWithoutPrerequisiteNestedInput
    priorityFeedback?: PriorityFeedbackUpdateManyWithoutLearningObjectiveNestedInput
    strugglePredictions?: StrugglePredictionUpdateManyWithoutLearningObjectiveNestedInput
    struggleIndicators?: StruggleIndicatorUpdateManyWithoutLearningObjectiveNestedInput
  }

  export type LearningObjectiveUncheckedUpdateWithoutPerformanceMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    complexity?: EnumObjectiveComplexityFieldUpdateOperationsInput | $Enums.ObjectiveComplexity
    pageStart?: NullableIntFieldUpdateOperationsInput | number | null
    pageEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isHighYield?: BoolFieldUpdateOperationsInput | boolean
    boardExamTags?: LearningObjectiveUpdateboardExamTagsInput | string[]
    extractedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masteryLevel?: EnumMasteryLevelFieldUpdateOperationsInput | $Enums.MasteryLevel
    totalStudyTimeMs?: IntFieldUpdateOperationsInput | number
    lastStudiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weaknessScore?: FloatFieldUpdateOperationsInput | number
    cards?: CardUncheckedUpdateManyWithoutObjectiveNestedInput
    prerequisites?: ObjectivePrerequisiteUncheckedUpdateManyWithoutObjectiveNestedInput
    dependents?: ObjectivePrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput
    priorityFeedback?: PriorityFeedbackUncheckedUpdateManyWithoutLearningObjectiveNestedInput
    strugglePredictions?: StrugglePredictionUncheckedUpdateManyWithoutLearningObjectiveNestedInput
    struggleIndicators?: StruggleIndicatorUncheckedUpdateManyWithoutLearningObjectiveNestedInput
  }

  export type UserCreateWithoutExamsInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: CourseCreateNestedManyWithoutUserInput
    lectures?: LectureCreateNestedManyWithoutUserInput
    studySessions?: StudySessionCreateNestedManyWithoutUserInput
    missions?: MissionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    coursePriorities?: CoursePriorityCreateNestedManyWithoutUserInput
    streak?: StreakCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    studyGoals?: StudyGoalCreateNestedManyWithoutUserInput
    missionStreak?: MissionStreakCreateNestedOneWithoutUserInput
    missionReviews?: MissionReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExamsInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    lectures?: LectureUncheckedCreateNestedManyWithoutUserInput
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutUserInput
    missions?: MissionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    coursePriorities?: CoursePriorityUncheckedCreateNestedManyWithoutUserInput
    streak?: StreakUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    studyGoals?: StudyGoalUncheckedCreateNestedManyWithoutUserInput
    missionStreak?: MissionStreakUncheckedCreateNestedOneWithoutUserInput
    missionReviews?: MissionReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExamsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExamsInput, UserUncheckedCreateWithoutExamsInput>
  }

  export type CourseCreateWithoutExamsInput = {
    id?: string
    name: string
    code?: string | null
    term?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCoursesInput
    lectures?: LectureCreateNestedManyWithoutCourseInput
    cards?: CardCreateNestedManyWithoutCourseInput
    coursePriorities?: CoursePriorityCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutExamsInput = {
    id?: string
    userId: string
    name: string
    code?: string | null
    term?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lectures?: LectureUncheckedCreateNestedManyWithoutCourseInput
    cards?: CardUncheckedCreateNestedManyWithoutCourseInput
    coursePriorities?: CoursePriorityUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutExamsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutExamsInput, CourseUncheckedCreateWithoutExamsInput>
  }

  export type UserUpsertWithoutExamsInput = {
    update: XOR<UserUpdateWithoutExamsInput, UserUncheckedUpdateWithoutExamsInput>
    create: XOR<UserCreateWithoutExamsInput, UserUncheckedCreateWithoutExamsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExamsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExamsInput, UserUncheckedUpdateWithoutExamsInput>
  }

  export type UserUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseUpdateManyWithoutUserNestedInput
    lectures?: LectureUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUpdateManyWithoutUserNestedInput
    missions?: MissionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    coursePriorities?: CoursePriorityUpdateManyWithoutUserNestedInput
    streak?: StreakUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    studyGoals?: StudyGoalUpdateManyWithoutUserNestedInput
    missionStreak?: MissionStreakUpdateOneWithoutUserNestedInput
    missionReviews?: MissionReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    lectures?: LectureUncheckedUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUncheckedUpdateManyWithoutUserNestedInput
    missions?: MissionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    coursePriorities?: CoursePriorityUncheckedUpdateManyWithoutUserNestedInput
    streak?: StreakUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    studyGoals?: StudyGoalUncheckedUpdateManyWithoutUserNestedInput
    missionStreak?: MissionStreakUncheckedUpdateOneWithoutUserNestedInput
    missionReviews?: MissionReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutExamsInput = {
    update: XOR<CourseUpdateWithoutExamsInput, CourseUncheckedUpdateWithoutExamsInput>
    create: XOR<CourseCreateWithoutExamsInput, CourseUncheckedCreateWithoutExamsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutExamsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutExamsInput, CourseUncheckedUpdateWithoutExamsInput>
  }

  export type CourseUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoursesNestedInput
    lectures?: LectureUpdateManyWithoutCourseNestedInput
    cards?: CardUpdateManyWithoutCourseNestedInput
    coursePriorities?: CoursePriorityUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LectureUncheckedUpdateManyWithoutCourseNestedInput
    cards?: CardUncheckedUpdateManyWithoutCourseNestedInput
    coursePriorities?: CoursePriorityUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type UserCreateWithoutCoursePrioritiesInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: CourseCreateNestedManyWithoutUserInput
    lectures?: LectureCreateNestedManyWithoutUserInput
    studySessions?: StudySessionCreateNestedManyWithoutUserInput
    missions?: MissionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    exams?: ExamCreateNestedManyWithoutUserInput
    streak?: StreakCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    studyGoals?: StudyGoalCreateNestedManyWithoutUserInput
    missionStreak?: MissionStreakCreateNestedOneWithoutUserInput
    missionReviews?: MissionReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCoursePrioritiesInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    lectures?: LectureUncheckedCreateNestedManyWithoutUserInput
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutUserInput
    missions?: MissionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamUncheckedCreateNestedManyWithoutUserInput
    streak?: StreakUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    studyGoals?: StudyGoalUncheckedCreateNestedManyWithoutUserInput
    missionStreak?: MissionStreakUncheckedCreateNestedOneWithoutUserInput
    missionReviews?: MissionReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCoursePrioritiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCoursePrioritiesInput, UserUncheckedCreateWithoutCoursePrioritiesInput>
  }

  export type CourseCreateWithoutCoursePrioritiesInput = {
    id?: string
    name: string
    code?: string | null
    term?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCoursesInput
    lectures?: LectureCreateNestedManyWithoutCourseInput
    cards?: CardCreateNestedManyWithoutCourseInput
    exams?: ExamCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCoursePrioritiesInput = {
    id?: string
    userId: string
    name: string
    code?: string | null
    term?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lectures?: LectureUncheckedCreateNestedManyWithoutCourseInput
    cards?: CardUncheckedCreateNestedManyWithoutCourseInput
    exams?: ExamUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCoursePrioritiesInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCoursePrioritiesInput, CourseUncheckedCreateWithoutCoursePrioritiesInput>
  }

  export type UserUpsertWithoutCoursePrioritiesInput = {
    update: XOR<UserUpdateWithoutCoursePrioritiesInput, UserUncheckedUpdateWithoutCoursePrioritiesInput>
    create: XOR<UserCreateWithoutCoursePrioritiesInput, UserUncheckedCreateWithoutCoursePrioritiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCoursePrioritiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCoursePrioritiesInput, UserUncheckedUpdateWithoutCoursePrioritiesInput>
  }

  export type UserUpdateWithoutCoursePrioritiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseUpdateManyWithoutUserNestedInput
    lectures?: LectureUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUpdateManyWithoutUserNestedInput
    missions?: MissionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    exams?: ExamUpdateManyWithoutUserNestedInput
    streak?: StreakUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    studyGoals?: StudyGoalUpdateManyWithoutUserNestedInput
    missionStreak?: MissionStreakUpdateOneWithoutUserNestedInput
    missionReviews?: MissionReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCoursePrioritiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    lectures?: LectureUncheckedUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUncheckedUpdateManyWithoutUserNestedInput
    missions?: MissionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUserNestedInput
    streak?: StreakUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    studyGoals?: StudyGoalUncheckedUpdateManyWithoutUserNestedInput
    missionStreak?: MissionStreakUncheckedUpdateOneWithoutUserNestedInput
    missionReviews?: MissionReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutCoursePrioritiesInput = {
    update: XOR<CourseUpdateWithoutCoursePrioritiesInput, CourseUncheckedUpdateWithoutCoursePrioritiesInput>
    create: XOR<CourseCreateWithoutCoursePrioritiesInput, CourseUncheckedCreateWithoutCoursePrioritiesInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutCoursePrioritiesInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutCoursePrioritiesInput, CourseUncheckedUpdateWithoutCoursePrioritiesInput>
  }

  export type CourseUpdateWithoutCoursePrioritiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoursesNestedInput
    lectures?: LectureUpdateManyWithoutCourseNestedInput
    cards?: CardUpdateManyWithoutCourseNestedInput
    exams?: ExamUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCoursePrioritiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LectureUncheckedUpdateManyWithoutCourseNestedInput
    cards?: CardUncheckedUpdateManyWithoutCourseNestedInput
    exams?: ExamUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type LearningObjectiveCreateWithoutPriorityFeedbackInput = {
    id?: string
    objective: string
    complexity?: $Enums.ObjectiveComplexity
    pageStart?: number | null
    pageEnd?: number | null
    isHighYield?: boolean
    boardExamTags?: LearningObjectiveCreateboardExamTagsInput | string[]
    extractedBy?: string
    createdAt?: Date | string
    masteryLevel?: $Enums.MasteryLevel
    totalStudyTimeMs?: number
    lastStudiedAt?: Date | string | null
    weaknessScore?: number
    lecture: LectureCreateNestedOneWithoutLearningObjectivesInput
    cards?: CardCreateNestedManyWithoutObjectiveInput
    prerequisites?: ObjectivePrerequisiteCreateNestedManyWithoutObjectiveInput
    dependents?: ObjectivePrerequisiteCreateNestedManyWithoutPrerequisiteInput
    performanceMetrics?: PerformanceMetricCreateNestedManyWithoutLearningObjectiveInput
    strugglePredictions?: StrugglePredictionCreateNestedManyWithoutLearningObjectiveInput
    struggleIndicators?: StruggleIndicatorCreateNestedManyWithoutLearningObjectiveInput
  }

  export type LearningObjectiveUncheckedCreateWithoutPriorityFeedbackInput = {
    id?: string
    lectureId: string
    objective: string
    complexity?: $Enums.ObjectiveComplexity
    pageStart?: number | null
    pageEnd?: number | null
    isHighYield?: boolean
    boardExamTags?: LearningObjectiveCreateboardExamTagsInput | string[]
    extractedBy?: string
    createdAt?: Date | string
    masteryLevel?: $Enums.MasteryLevel
    totalStudyTimeMs?: number
    lastStudiedAt?: Date | string | null
    weaknessScore?: number
    cards?: CardUncheckedCreateNestedManyWithoutObjectiveInput
    prerequisites?: ObjectivePrerequisiteUncheckedCreateNestedManyWithoutObjectiveInput
    dependents?: ObjectivePrerequisiteUncheckedCreateNestedManyWithoutPrerequisiteInput
    performanceMetrics?: PerformanceMetricUncheckedCreateNestedManyWithoutLearningObjectiveInput
    strugglePredictions?: StrugglePredictionUncheckedCreateNestedManyWithoutLearningObjectiveInput
    struggleIndicators?: StruggleIndicatorUncheckedCreateNestedManyWithoutLearningObjectiveInput
  }

  export type LearningObjectiveCreateOrConnectWithoutPriorityFeedbackInput = {
    where: LearningObjectiveWhereUniqueInput
    create: XOR<LearningObjectiveCreateWithoutPriorityFeedbackInput, LearningObjectiveUncheckedCreateWithoutPriorityFeedbackInput>
  }

  export type LearningObjectiveUpsertWithoutPriorityFeedbackInput = {
    update: XOR<LearningObjectiveUpdateWithoutPriorityFeedbackInput, LearningObjectiveUncheckedUpdateWithoutPriorityFeedbackInput>
    create: XOR<LearningObjectiveCreateWithoutPriorityFeedbackInput, LearningObjectiveUncheckedCreateWithoutPriorityFeedbackInput>
    where?: LearningObjectiveWhereInput
  }

  export type LearningObjectiveUpdateToOneWithWhereWithoutPriorityFeedbackInput = {
    where?: LearningObjectiveWhereInput
    data: XOR<LearningObjectiveUpdateWithoutPriorityFeedbackInput, LearningObjectiveUncheckedUpdateWithoutPriorityFeedbackInput>
  }

  export type LearningObjectiveUpdateWithoutPriorityFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    complexity?: EnumObjectiveComplexityFieldUpdateOperationsInput | $Enums.ObjectiveComplexity
    pageStart?: NullableIntFieldUpdateOperationsInput | number | null
    pageEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isHighYield?: BoolFieldUpdateOperationsInput | boolean
    boardExamTags?: LearningObjectiveUpdateboardExamTagsInput | string[]
    extractedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masteryLevel?: EnumMasteryLevelFieldUpdateOperationsInput | $Enums.MasteryLevel
    totalStudyTimeMs?: IntFieldUpdateOperationsInput | number
    lastStudiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weaknessScore?: FloatFieldUpdateOperationsInput | number
    lecture?: LectureUpdateOneRequiredWithoutLearningObjectivesNestedInput
    cards?: CardUpdateManyWithoutObjectiveNestedInput
    prerequisites?: ObjectivePrerequisiteUpdateManyWithoutObjectiveNestedInput
    dependents?: ObjectivePrerequisiteUpdateManyWithoutPrerequisiteNestedInput
    performanceMetrics?: PerformanceMetricUpdateManyWithoutLearningObjectiveNestedInput
    strugglePredictions?: StrugglePredictionUpdateManyWithoutLearningObjectiveNestedInput
    struggleIndicators?: StruggleIndicatorUpdateManyWithoutLearningObjectiveNestedInput
  }

  export type LearningObjectiveUncheckedUpdateWithoutPriorityFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    complexity?: EnumObjectiveComplexityFieldUpdateOperationsInput | $Enums.ObjectiveComplexity
    pageStart?: NullableIntFieldUpdateOperationsInput | number | null
    pageEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isHighYield?: BoolFieldUpdateOperationsInput | boolean
    boardExamTags?: LearningObjectiveUpdateboardExamTagsInput | string[]
    extractedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masteryLevel?: EnumMasteryLevelFieldUpdateOperationsInput | $Enums.MasteryLevel
    totalStudyTimeMs?: IntFieldUpdateOperationsInput | number
    lastStudiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weaknessScore?: FloatFieldUpdateOperationsInput | number
    cards?: CardUncheckedUpdateManyWithoutObjectiveNestedInput
    prerequisites?: ObjectivePrerequisiteUncheckedUpdateManyWithoutObjectiveNestedInput
    dependents?: ObjectivePrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput
    performanceMetrics?: PerformanceMetricUncheckedUpdateManyWithoutLearningObjectiveNestedInput
    strugglePredictions?: StrugglePredictionUncheckedUpdateManyWithoutLearningObjectiveNestedInput
    struggleIndicators?: StruggleIndicatorUncheckedUpdateManyWithoutLearningObjectiveNestedInput
  }

  export type UserCreateWithoutStreakInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: CourseCreateNestedManyWithoutUserInput
    lectures?: LectureCreateNestedManyWithoutUserInput
    studySessions?: StudySessionCreateNestedManyWithoutUserInput
    missions?: MissionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    exams?: ExamCreateNestedManyWithoutUserInput
    coursePriorities?: CoursePriorityCreateNestedManyWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    studyGoals?: StudyGoalCreateNestedManyWithoutUserInput
    missionStreak?: MissionStreakCreateNestedOneWithoutUserInput
    missionReviews?: MissionReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStreakInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    lectures?: LectureUncheckedCreateNestedManyWithoutUserInput
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutUserInput
    missions?: MissionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamUncheckedCreateNestedManyWithoutUserInput
    coursePriorities?: CoursePriorityUncheckedCreateNestedManyWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    studyGoals?: StudyGoalUncheckedCreateNestedManyWithoutUserInput
    missionStreak?: MissionStreakUncheckedCreateNestedOneWithoutUserInput
    missionReviews?: MissionReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStreakInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStreakInput, UserUncheckedCreateWithoutStreakInput>
  }

  export type UserUpsertWithoutStreakInput = {
    update: XOR<UserUpdateWithoutStreakInput, UserUncheckedUpdateWithoutStreakInput>
    create: XOR<UserCreateWithoutStreakInput, UserUncheckedCreateWithoutStreakInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStreakInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStreakInput, UserUncheckedUpdateWithoutStreakInput>
  }

  export type UserUpdateWithoutStreakInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseUpdateManyWithoutUserNestedInput
    lectures?: LectureUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUpdateManyWithoutUserNestedInput
    missions?: MissionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    exams?: ExamUpdateManyWithoutUserNestedInput
    coursePriorities?: CoursePriorityUpdateManyWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    studyGoals?: StudyGoalUpdateManyWithoutUserNestedInput
    missionStreak?: MissionStreakUpdateOneWithoutUserNestedInput
    missionReviews?: MissionReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStreakInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    lectures?: LectureUncheckedUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUncheckedUpdateManyWithoutUserNestedInput
    missions?: MissionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUserNestedInput
    coursePriorities?: CoursePriorityUncheckedUpdateManyWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    studyGoals?: StudyGoalUncheckedUpdateManyWithoutUserNestedInput
    missionStreak?: MissionStreakUncheckedUpdateOneWithoutUserNestedInput
    missionReviews?: MissionReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAchievementsInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: CourseCreateNestedManyWithoutUserInput
    lectures?: LectureCreateNestedManyWithoutUserInput
    studySessions?: StudySessionCreateNestedManyWithoutUserInput
    missions?: MissionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    exams?: ExamCreateNestedManyWithoutUserInput
    coursePriorities?: CoursePriorityCreateNestedManyWithoutUserInput
    streak?: StreakCreateNestedOneWithoutUserInput
    studyGoals?: StudyGoalCreateNestedManyWithoutUserInput
    missionStreak?: MissionStreakCreateNestedOneWithoutUserInput
    missionReviews?: MissionReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAchievementsInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    lectures?: LectureUncheckedCreateNestedManyWithoutUserInput
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutUserInput
    missions?: MissionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamUncheckedCreateNestedManyWithoutUserInput
    coursePriorities?: CoursePriorityUncheckedCreateNestedManyWithoutUserInput
    streak?: StreakUncheckedCreateNestedOneWithoutUserInput
    studyGoals?: StudyGoalUncheckedCreateNestedManyWithoutUserInput
    missionStreak?: MissionStreakUncheckedCreateNestedOneWithoutUserInput
    missionReviews?: MissionReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAchievementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
  }

  export type UserUpsertWithoutAchievementsInput = {
    update: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseUpdateManyWithoutUserNestedInput
    lectures?: LectureUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUpdateManyWithoutUserNestedInput
    missions?: MissionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    exams?: ExamUpdateManyWithoutUserNestedInput
    coursePriorities?: CoursePriorityUpdateManyWithoutUserNestedInput
    streak?: StreakUpdateOneWithoutUserNestedInput
    studyGoals?: StudyGoalUpdateManyWithoutUserNestedInput
    missionStreak?: MissionStreakUpdateOneWithoutUserNestedInput
    missionReviews?: MissionReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    lectures?: LectureUncheckedUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUncheckedUpdateManyWithoutUserNestedInput
    missions?: MissionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUserNestedInput
    coursePriorities?: CoursePriorityUncheckedUpdateManyWithoutUserNestedInput
    streak?: StreakUncheckedUpdateOneWithoutUserNestedInput
    studyGoals?: StudyGoalUncheckedUpdateManyWithoutUserNestedInput
    missionStreak?: MissionStreakUncheckedUpdateOneWithoutUserNestedInput
    missionReviews?: MissionReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutStudyGoalsInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: CourseCreateNestedManyWithoutUserInput
    lectures?: LectureCreateNestedManyWithoutUserInput
    studySessions?: StudySessionCreateNestedManyWithoutUserInput
    missions?: MissionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    exams?: ExamCreateNestedManyWithoutUserInput
    coursePriorities?: CoursePriorityCreateNestedManyWithoutUserInput
    streak?: StreakCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    missionStreak?: MissionStreakCreateNestedOneWithoutUserInput
    missionReviews?: MissionReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStudyGoalsInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    lectures?: LectureUncheckedCreateNestedManyWithoutUserInput
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutUserInput
    missions?: MissionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamUncheckedCreateNestedManyWithoutUserInput
    coursePriorities?: CoursePriorityUncheckedCreateNestedManyWithoutUserInput
    streak?: StreakUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    missionStreak?: MissionStreakUncheckedCreateNestedOneWithoutUserInput
    missionReviews?: MissionReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStudyGoalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudyGoalsInput, UserUncheckedCreateWithoutStudyGoalsInput>
  }

  export type UserUpsertWithoutStudyGoalsInput = {
    update: XOR<UserUpdateWithoutStudyGoalsInput, UserUncheckedUpdateWithoutStudyGoalsInput>
    create: XOR<UserCreateWithoutStudyGoalsInput, UserUncheckedCreateWithoutStudyGoalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudyGoalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudyGoalsInput, UserUncheckedUpdateWithoutStudyGoalsInput>
  }

  export type UserUpdateWithoutStudyGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseUpdateManyWithoutUserNestedInput
    lectures?: LectureUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUpdateManyWithoutUserNestedInput
    missions?: MissionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    exams?: ExamUpdateManyWithoutUserNestedInput
    coursePriorities?: CoursePriorityUpdateManyWithoutUserNestedInput
    streak?: StreakUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    missionStreak?: MissionStreakUpdateOneWithoutUserNestedInput
    missionReviews?: MissionReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStudyGoalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    lectures?: LectureUncheckedUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUncheckedUpdateManyWithoutUserNestedInput
    missions?: MissionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUserNestedInput
    coursePriorities?: CoursePriorityUncheckedUpdateManyWithoutUserNestedInput
    streak?: StreakUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    missionStreak?: MissionStreakUncheckedUpdateOneWithoutUserNestedInput
    missionReviews?: MissionReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MissionCreateWithoutFeedbackInput = {
    id?: string
    date?: Date | string
    status?: $Enums.MissionStatus
    estimatedMinutes: number
    completedAt?: Date | string | null
    actualMinutes?: number | null
    completedObjectivesCount?: number
    objectives: JsonNullValueInput | InputJsonValue
    reviewCardCount?: number
    newContentCount?: number
    successScore?: number | null
    difficultyRating?: number | null
    user: UserCreateNestedOneWithoutMissionsInput
    studySessions?: StudySessionCreateNestedManyWithoutMissionInput
    interventions?: InterventionRecommendationCreateNestedManyWithoutMissionInput
  }

  export type MissionUncheckedCreateWithoutFeedbackInput = {
    id?: string
    userId: string
    date?: Date | string
    status?: $Enums.MissionStatus
    estimatedMinutes: number
    completedAt?: Date | string | null
    actualMinutes?: number | null
    completedObjectivesCount?: number
    objectives: JsonNullValueInput | InputJsonValue
    reviewCardCount?: number
    newContentCount?: number
    successScore?: number | null
    difficultyRating?: number | null
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutMissionInput
    interventions?: InterventionRecommendationUncheckedCreateNestedManyWithoutMissionInput
  }

  export type MissionCreateOrConnectWithoutFeedbackInput = {
    where: MissionWhereUniqueInput
    create: XOR<MissionCreateWithoutFeedbackInput, MissionUncheckedCreateWithoutFeedbackInput>
  }

  export type MissionUpsertWithoutFeedbackInput = {
    update: XOR<MissionUpdateWithoutFeedbackInput, MissionUncheckedUpdateWithoutFeedbackInput>
    create: XOR<MissionCreateWithoutFeedbackInput, MissionUncheckedCreateWithoutFeedbackInput>
    where?: MissionWhereInput
  }

  export type MissionUpdateToOneWithWhereWithoutFeedbackInput = {
    where?: MissionWhereInput
    data: XOR<MissionUpdateWithoutFeedbackInput, MissionUncheckedUpdateWithoutFeedbackInput>
  }

  export type MissionUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMissionStatusFieldUpdateOperationsInput | $Enums.MissionStatus
    estimatedMinutes?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    completedObjectivesCount?: IntFieldUpdateOperationsInput | number
    objectives?: JsonNullValueInput | InputJsonValue
    reviewCardCount?: IntFieldUpdateOperationsInput | number
    newContentCount?: IntFieldUpdateOperationsInput | number
    successScore?: NullableFloatFieldUpdateOperationsInput | number | null
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneRequiredWithoutMissionsNestedInput
    studySessions?: StudySessionUpdateManyWithoutMissionNestedInput
    interventions?: InterventionRecommendationUpdateManyWithoutMissionNestedInput
  }

  export type MissionUncheckedUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMissionStatusFieldUpdateOperationsInput | $Enums.MissionStatus
    estimatedMinutes?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    completedObjectivesCount?: IntFieldUpdateOperationsInput | number
    objectives?: JsonNullValueInput | InputJsonValue
    reviewCardCount?: IntFieldUpdateOperationsInput | number
    newContentCount?: IntFieldUpdateOperationsInput | number
    successScore?: NullableFloatFieldUpdateOperationsInput | number | null
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    studySessions?: StudySessionUncheckedUpdateManyWithoutMissionNestedInput
    interventions?: InterventionRecommendationUncheckedUpdateManyWithoutMissionNestedInput
  }

  export type UserCreateWithoutMissionStreakInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: CourseCreateNestedManyWithoutUserInput
    lectures?: LectureCreateNestedManyWithoutUserInput
    studySessions?: StudySessionCreateNestedManyWithoutUserInput
    missions?: MissionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    exams?: ExamCreateNestedManyWithoutUserInput
    coursePriorities?: CoursePriorityCreateNestedManyWithoutUserInput
    streak?: StreakCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    studyGoals?: StudyGoalCreateNestedManyWithoutUserInput
    missionReviews?: MissionReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMissionStreakInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    lectures?: LectureUncheckedCreateNestedManyWithoutUserInput
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutUserInput
    missions?: MissionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamUncheckedCreateNestedManyWithoutUserInput
    coursePriorities?: CoursePriorityUncheckedCreateNestedManyWithoutUserInput
    streak?: StreakUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    studyGoals?: StudyGoalUncheckedCreateNestedManyWithoutUserInput
    missionReviews?: MissionReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMissionStreakInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMissionStreakInput, UserUncheckedCreateWithoutMissionStreakInput>
  }

  export type UserUpsertWithoutMissionStreakInput = {
    update: XOR<UserUpdateWithoutMissionStreakInput, UserUncheckedUpdateWithoutMissionStreakInput>
    create: XOR<UserCreateWithoutMissionStreakInput, UserUncheckedCreateWithoutMissionStreakInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMissionStreakInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMissionStreakInput, UserUncheckedUpdateWithoutMissionStreakInput>
  }

  export type UserUpdateWithoutMissionStreakInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseUpdateManyWithoutUserNestedInput
    lectures?: LectureUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUpdateManyWithoutUserNestedInput
    missions?: MissionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    exams?: ExamUpdateManyWithoutUserNestedInput
    coursePriorities?: CoursePriorityUpdateManyWithoutUserNestedInput
    streak?: StreakUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    studyGoals?: StudyGoalUpdateManyWithoutUserNestedInput
    missionReviews?: MissionReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMissionStreakInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    lectures?: LectureUncheckedUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUncheckedUpdateManyWithoutUserNestedInput
    missions?: MissionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUserNestedInput
    coursePriorities?: CoursePriorityUncheckedUpdateManyWithoutUserNestedInput
    streak?: StreakUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    studyGoals?: StudyGoalUncheckedUpdateManyWithoutUserNestedInput
    missionReviews?: MissionReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMissionReviewsInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: CourseCreateNestedManyWithoutUserInput
    lectures?: LectureCreateNestedManyWithoutUserInput
    studySessions?: StudySessionCreateNestedManyWithoutUserInput
    missions?: MissionCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    exams?: ExamCreateNestedManyWithoutUserInput
    coursePriorities?: CoursePriorityCreateNestedManyWithoutUserInput
    streak?: StreakCreateNestedOneWithoutUserInput
    achievements?: AchievementCreateNestedManyWithoutUserInput
    studyGoals?: StudyGoalCreateNestedManyWithoutUserInput
    missionStreak?: MissionStreakCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMissionReviewsInput = {
    id?: string
    email?: string | null
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    defaultMissionMinutes?: number
    missionDifficulty?: string
    preferredStudyTime?: string | null
    autoGenerateMissions?: boolean
    performanceTrackingEnabled?: boolean
    includeInAnalytics?: boolean
    lastMissionAdaptation?: Date | string | null
    behavioralAnalysisEnabled?: boolean
    learningStyleProfilingEnabled?: boolean
    shareAnonymizedPatterns?: boolean
    courses?: CourseUncheckedCreateNestedManyWithoutUserInput
    lectures?: LectureUncheckedCreateNestedManyWithoutUserInput
    studySessions?: StudySessionUncheckedCreateNestedManyWithoutUserInput
    missions?: MissionUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    exams?: ExamUncheckedCreateNestedManyWithoutUserInput
    coursePriorities?: CoursePriorityUncheckedCreateNestedManyWithoutUserInput
    streak?: StreakUncheckedCreateNestedOneWithoutUserInput
    achievements?: AchievementUncheckedCreateNestedManyWithoutUserInput
    studyGoals?: StudyGoalUncheckedCreateNestedManyWithoutUserInput
    missionStreak?: MissionStreakUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMissionReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMissionReviewsInput, UserUncheckedCreateWithoutMissionReviewsInput>
  }

  export type UserUpsertWithoutMissionReviewsInput = {
    update: XOR<UserUpdateWithoutMissionReviewsInput, UserUncheckedUpdateWithoutMissionReviewsInput>
    create: XOR<UserCreateWithoutMissionReviewsInput, UserUncheckedCreateWithoutMissionReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMissionReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMissionReviewsInput, UserUncheckedUpdateWithoutMissionReviewsInput>
  }

  export type UserUpdateWithoutMissionReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseUpdateManyWithoutUserNestedInput
    lectures?: LectureUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUpdateManyWithoutUserNestedInput
    missions?: MissionUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    exams?: ExamUpdateManyWithoutUserNestedInput
    coursePriorities?: CoursePriorityUpdateManyWithoutUserNestedInput
    streak?: StreakUpdateOneWithoutUserNestedInput
    achievements?: AchievementUpdateManyWithoutUserNestedInput
    studyGoals?: StudyGoalUpdateManyWithoutUserNestedInput
    missionStreak?: MissionStreakUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMissionReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    defaultMissionMinutes?: IntFieldUpdateOperationsInput | number
    missionDifficulty?: StringFieldUpdateOperationsInput | string
    preferredStudyTime?: NullableStringFieldUpdateOperationsInput | string | null
    autoGenerateMissions?: BoolFieldUpdateOperationsInput | boolean
    performanceTrackingEnabled?: BoolFieldUpdateOperationsInput | boolean
    includeInAnalytics?: BoolFieldUpdateOperationsInput | boolean
    lastMissionAdaptation?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    behavioralAnalysisEnabled?: BoolFieldUpdateOperationsInput | boolean
    learningStyleProfilingEnabled?: BoolFieldUpdateOperationsInput | boolean
    shareAnonymizedPatterns?: BoolFieldUpdateOperationsInput | boolean
    courses?: CourseUncheckedUpdateManyWithoutUserNestedInput
    lectures?: LectureUncheckedUpdateManyWithoutUserNestedInput
    studySessions?: StudySessionUncheckedUpdateManyWithoutUserNestedInput
    missions?: MissionUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    exams?: ExamUncheckedUpdateManyWithoutUserNestedInput
    coursePriorities?: CoursePriorityUncheckedUpdateManyWithoutUserNestedInput
    streak?: StreakUncheckedUpdateOneWithoutUserNestedInput
    achievements?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    studyGoals?: StudyGoalUncheckedUpdateManyWithoutUserNestedInput
    missionStreak?: MissionStreakUncheckedUpdateOneWithoutUserNestedInput
  }

  export type CourseCreateManyUserInput = {
    id?: string
    name: string
    code?: string | null
    term?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LectureCreateManyUserInput = {
    id?: string
    courseId: string
    title: string
    fileName: string
    fileUrl: string
    fileSize: number
    processingStatus?: $Enums.ProcessingStatus
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    processingProgress?: number
    totalPages?: number | null
    processedPages?: number
    processingStartedAt?: Date | string | null
    estimatedCompletionAt?: Date | string | null
    weekNumber?: number | null
    topicTags?: LectureCreatetopicTagsInput | string[]
  }

  export type StudySessionCreateManyUserInput = {
    id?: string
    missionId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    reviewsCompleted?: number
    newCardsStudied?: number
    sessionNotes?: string | null
    currentObjectiveIndex?: number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MissionCreateManyUserInput = {
    id?: string
    date?: Date | string
    status?: $Enums.MissionStatus
    estimatedMinutes: number
    completedAt?: Date | string | null
    actualMinutes?: number | null
    completedObjectivesCount?: number
    objectives: JsonNullValueInput | InputJsonValue
    reviewCardCount?: number
    newContentCount?: number
    successScore?: number | null
    difficultyRating?: number | null
  }

  export type ReviewCreateManyUserInput = {
    id?: string
    cardId: string
    sessionId?: string | null
    rating: $Enums.ReviewRating
    timeSpentMs: number
    reviewedAt?: Date | string
    difficultyBefore: number
    stabilityBefore: number
    difficultyAfter: number
    stabilityAfter: number
  }

  export type ExamCreateManyUserInput = {
    id?: string
    name: string
    date: Date | string
    courseId: string
    coverageTopics?: ExamCreatecoverageTopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoursePriorityCreateManyUserInput = {
    id?: string
    courseId: string
    priorityLevel?: $Enums.PriorityLevel
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AchievementCreateManyUserInput = {
    id?: string
    type: $Enums.AchievementType
    name: string
    description: string
    tier?: $Enums.AchievementTier
    earnedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StudyGoalCreateManyUserInput = {
    id?: string
    goalType: $Enums.GoalType
    targetValue: number
    currentProgress?: number
    period: $Enums.GoalPeriod
    startDate: Date | string
    endDate: Date | string
    isCompleted?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MissionReviewCreateManyUserInput = {
    id?: string
    period: $Enums.ReviewPeriod
    startDate: Date | string
    endDate: Date | string
    summary: JsonNullValueInput | InputJsonValue
    highlights: JsonNullValueInput | InputJsonValue
    insights: JsonNullValueInput | InputJsonValue
    recommendations: JsonNullValueInput | InputJsonValue
    generatedAt?: Date | string
  }

  export type CourseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LectureUpdateManyWithoutCourseNestedInput
    cards?: CardUpdateManyWithoutCourseNestedInput
    exams?: ExamUpdateManyWithoutCourseNestedInput
    coursePriorities?: CoursePriorityUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LectureUncheckedUpdateManyWithoutCourseNestedInput
    cards?: CardUncheckedUpdateManyWithoutCourseNestedInput
    exams?: ExamUncheckedUpdateManyWithoutCourseNestedInput
    coursePriorities?: CoursePriorityUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    term?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LectureUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingProgress?: IntFieldUpdateOperationsInput | number
    totalPages?: NullableIntFieldUpdateOperationsInput | number | null
    processedPages?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weekNumber?: NullableIntFieldUpdateOperationsInput | number | null
    topicTags?: LectureUpdatetopicTagsInput | string[]
    course?: CourseUpdateOneRequiredWithoutLecturesNestedInput
    contentChunks?: ContentChunkUpdateManyWithoutLectureNestedInput
    learningObjectives?: LearningObjectiveUpdateManyWithoutLectureNestedInput
    cards?: CardUpdateManyWithoutLectureNestedInput
  }

  export type LectureUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingProgress?: IntFieldUpdateOperationsInput | number
    totalPages?: NullableIntFieldUpdateOperationsInput | number | null
    processedPages?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weekNumber?: NullableIntFieldUpdateOperationsInput | number | null
    topicTags?: LectureUpdatetopicTagsInput | string[]
    contentChunks?: ContentChunkUncheckedUpdateManyWithoutLectureNestedInput
    learningObjectives?: LearningObjectiveUncheckedUpdateManyWithoutLectureNestedInput
    cards?: CardUncheckedUpdateManyWithoutLectureNestedInput
  }

  export type LectureUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingProgress?: IntFieldUpdateOperationsInput | number
    totalPages?: NullableIntFieldUpdateOperationsInput | number | null
    processedPages?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weekNumber?: NullableIntFieldUpdateOperationsInput | number | null
    topicTags?: LectureUpdatetopicTagsInput | string[]
  }

  export type StudySessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    reviewsCompleted?: IntFieldUpdateOperationsInput | number
    newCardsStudied?: IntFieldUpdateOperationsInput | number
    sessionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    currentObjectiveIndex?: IntFieldUpdateOperationsInput | number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
    mission?: MissionUpdateOneWithoutStudySessionsNestedInput
    reviews?: ReviewUpdateManyWithoutSessionNestedInput
    validationResponses?: ValidationResponseUpdateManyWithoutSessionNestedInput
  }

  export type StudySessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    missionId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    reviewsCompleted?: IntFieldUpdateOperationsInput | number
    newCardsStudied?: IntFieldUpdateOperationsInput | number
    sessionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    currentObjectiveIndex?: IntFieldUpdateOperationsInput | number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
    reviews?: ReviewUncheckedUpdateManyWithoutSessionNestedInput
    validationResponses?: ValidationResponseUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type StudySessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    missionId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    reviewsCompleted?: IntFieldUpdateOperationsInput | number
    newCardsStudied?: IntFieldUpdateOperationsInput | number
    sessionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    currentObjectiveIndex?: IntFieldUpdateOperationsInput | number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MissionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMissionStatusFieldUpdateOperationsInput | $Enums.MissionStatus
    estimatedMinutes?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    completedObjectivesCount?: IntFieldUpdateOperationsInput | number
    objectives?: JsonNullValueInput | InputJsonValue
    reviewCardCount?: IntFieldUpdateOperationsInput | number
    newContentCount?: IntFieldUpdateOperationsInput | number
    successScore?: NullableFloatFieldUpdateOperationsInput | number | null
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    studySessions?: StudySessionUpdateManyWithoutMissionNestedInput
    feedback?: MissionFeedbackUpdateManyWithoutMissionNestedInput
    interventions?: InterventionRecommendationUpdateManyWithoutMissionNestedInput
  }

  export type MissionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMissionStatusFieldUpdateOperationsInput | $Enums.MissionStatus
    estimatedMinutes?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    completedObjectivesCount?: IntFieldUpdateOperationsInput | number
    objectives?: JsonNullValueInput | InputJsonValue
    reviewCardCount?: IntFieldUpdateOperationsInput | number
    newContentCount?: IntFieldUpdateOperationsInput | number
    successScore?: NullableFloatFieldUpdateOperationsInput | number | null
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
    studySessions?: StudySessionUncheckedUpdateManyWithoutMissionNestedInput
    feedback?: MissionFeedbackUncheckedUpdateManyWithoutMissionNestedInput
    interventions?: InterventionRecommendationUncheckedUpdateManyWithoutMissionNestedInput
  }

  export type MissionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumMissionStatusFieldUpdateOperationsInput | $Enums.MissionStatus
    estimatedMinutes?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    completedObjectivesCount?: IntFieldUpdateOperationsInput | number
    objectives?: JsonNullValueInput | InputJsonValue
    reviewCardCount?: IntFieldUpdateOperationsInput | number
    newContentCount?: IntFieldUpdateOperationsInput | number
    successScore?: NullableFloatFieldUpdateOperationsInput | number | null
    difficultyRating?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: EnumReviewRatingFieldUpdateOperationsInput | $Enums.ReviewRating
    timeSpentMs?: IntFieldUpdateOperationsInput | number
    reviewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficultyBefore?: FloatFieldUpdateOperationsInput | number
    stabilityBefore?: FloatFieldUpdateOperationsInput | number
    difficultyAfter?: FloatFieldUpdateOperationsInput | number
    stabilityAfter?: FloatFieldUpdateOperationsInput | number
    card?: CardUpdateOneRequiredWithoutReviewsNestedInput
    session?: StudySessionUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: EnumReviewRatingFieldUpdateOperationsInput | $Enums.ReviewRating
    timeSpentMs?: IntFieldUpdateOperationsInput | number
    reviewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficultyBefore?: FloatFieldUpdateOperationsInput | number
    stabilityBefore?: FloatFieldUpdateOperationsInput | number
    difficultyAfter?: FloatFieldUpdateOperationsInput | number
    stabilityAfter?: FloatFieldUpdateOperationsInput | number
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: EnumReviewRatingFieldUpdateOperationsInput | $Enums.ReviewRating
    timeSpentMs?: IntFieldUpdateOperationsInput | number
    reviewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficultyBefore?: FloatFieldUpdateOperationsInput | number
    stabilityBefore?: FloatFieldUpdateOperationsInput | number
    difficultyAfter?: FloatFieldUpdateOperationsInput | number
    stabilityAfter?: FloatFieldUpdateOperationsInput | number
  }

  export type ExamUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    coverageTopics?: ExamUpdatecoverageTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutExamsNestedInput
  }

  export type ExamUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: StringFieldUpdateOperationsInput | string
    coverageTopics?: ExamUpdatecoverageTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    courseId?: StringFieldUpdateOperationsInput | string
    coverageTopics?: ExamUpdatecoverageTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoursePriorityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    priorityLevel?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    course?: CourseUpdateOneRequiredWithoutCoursePrioritiesNestedInput
  }

  export type CoursePriorityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    priorityLevel?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoursePriorityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    priorityLevel?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAchievementTypeFieldUpdateOperationsInput | $Enums.AchievementType
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tier?: EnumAchievementTierFieldUpdateOperationsInput | $Enums.AchievementTier
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AchievementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAchievementTypeFieldUpdateOperationsInput | $Enums.AchievementType
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tier?: EnumAchievementTierFieldUpdateOperationsInput | $Enums.AchievementTier
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AchievementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAchievementTypeFieldUpdateOperationsInput | $Enums.AchievementType
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tier?: EnumAchievementTierFieldUpdateOperationsInput | $Enums.AchievementTier
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type StudyGoalUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalType?: EnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType
    targetValue?: IntFieldUpdateOperationsInput | number
    currentProgress?: IntFieldUpdateOperationsInput | number
    period?: EnumGoalPeriodFieldUpdateOperationsInput | $Enums.GoalPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyGoalUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalType?: EnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType
    targetValue?: IntFieldUpdateOperationsInput | number
    currentProgress?: IntFieldUpdateOperationsInput | number
    period?: EnumGoalPeriodFieldUpdateOperationsInput | $Enums.GoalPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyGoalUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    goalType?: EnumGoalTypeFieldUpdateOperationsInput | $Enums.GoalType
    targetValue?: IntFieldUpdateOperationsInput | number
    currentProgress?: IntFieldUpdateOperationsInput | number
    period?: EnumGoalPeriodFieldUpdateOperationsInput | $Enums.GoalPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: EnumReviewPeriodFieldUpdateOperationsInput | $Enums.ReviewPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: JsonNullValueInput | InputJsonValue
    highlights?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: EnumReviewPeriodFieldUpdateOperationsInput | $Enums.ReviewPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: JsonNullValueInput | InputJsonValue
    highlights?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: EnumReviewPeriodFieldUpdateOperationsInput | $Enums.ReviewPeriod
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    summary?: JsonNullValueInput | InputJsonValue
    highlights?: JsonNullValueInput | InputJsonValue
    insights?: JsonNullValueInput | InputJsonValue
    recommendations?: JsonNullValueInput | InputJsonValue
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LectureCreateManyCourseInput = {
    id?: string
    userId: string
    title: string
    fileName: string
    fileUrl: string
    fileSize: number
    processingStatus?: $Enums.ProcessingStatus
    uploadedAt?: Date | string
    processedAt?: Date | string | null
    processingProgress?: number
    totalPages?: number | null
    processedPages?: number
    processingStartedAt?: Date | string | null
    estimatedCompletionAt?: Date | string | null
    weekNumber?: number | null
    topicTags?: LectureCreatetopicTagsInput | string[]
  }

  export type CardCreateManyCourseInput = {
    id?: string
    lectureId?: string | null
    objectiveId?: string | null
    front: string
    back: string
    cardType?: $Enums.CardType
    createdAt?: Date | string
    difficulty?: number
    stability?: number
    retrievability?: number
    lastReviewedAt?: Date | string | null
    nextReviewAt?: Date | string | null
    reviewCount?: number
    lapseCount?: number
  }

  export type ExamCreateManyCourseInput = {
    id?: string
    userId: string
    name: string
    date: Date | string
    coverageTopics?: ExamCreatecoverageTopicsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoursePriorityCreateManyCourseInput = {
    id?: string
    userId: string
    priorityLevel?: $Enums.PriorityLevel
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LectureUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingProgress?: IntFieldUpdateOperationsInput | number
    totalPages?: NullableIntFieldUpdateOperationsInput | number | null
    processedPages?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weekNumber?: NullableIntFieldUpdateOperationsInput | number | null
    topicTags?: LectureUpdatetopicTagsInput | string[]
    user?: UserUpdateOneRequiredWithoutLecturesNestedInput
    contentChunks?: ContentChunkUpdateManyWithoutLectureNestedInput
    learningObjectives?: LearningObjectiveUpdateManyWithoutLectureNestedInput
    cards?: CardUpdateManyWithoutLectureNestedInput
  }

  export type LectureUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingProgress?: IntFieldUpdateOperationsInput | number
    totalPages?: NullableIntFieldUpdateOperationsInput | number | null
    processedPages?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weekNumber?: NullableIntFieldUpdateOperationsInput | number | null
    topicTags?: LectureUpdatetopicTagsInput | string[]
    contentChunks?: ContentChunkUncheckedUpdateManyWithoutLectureNestedInput
    learningObjectives?: LearningObjectiveUncheckedUpdateManyWithoutLectureNestedInput
    cards?: CardUncheckedUpdateManyWithoutLectureNestedInput
  }

  export type LectureUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    processingStatus?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processingProgress?: IntFieldUpdateOperationsInput | number
    totalPages?: NullableIntFieldUpdateOperationsInput | number | null
    processedPages?: IntFieldUpdateOperationsInput | number
    processingStartedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedCompletionAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weekNumber?: NullableIntFieldUpdateOperationsInput | number | null
    topicTags?: LectureUpdatetopicTagsInput | string[]
  }

  export type CardUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    front?: StringFieldUpdateOperationsInput | string
    back?: StringFieldUpdateOperationsInput | string
    cardType?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficulty?: FloatFieldUpdateOperationsInput | number
    stability?: FloatFieldUpdateOperationsInput | number
    retrievability?: FloatFieldUpdateOperationsInput | number
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    lapseCount?: IntFieldUpdateOperationsInput | number
    lecture?: LectureUpdateOneWithoutCardsNestedInput
    objective?: LearningObjectiveUpdateOneWithoutCardsNestedInput
    reviews?: ReviewUpdateManyWithoutCardNestedInput
  }

  export type CardUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: NullableStringFieldUpdateOperationsInput | string | null
    objectiveId?: NullableStringFieldUpdateOperationsInput | string | null
    front?: StringFieldUpdateOperationsInput | string
    back?: StringFieldUpdateOperationsInput | string
    cardType?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficulty?: FloatFieldUpdateOperationsInput | number
    stability?: FloatFieldUpdateOperationsInput | number
    retrievability?: FloatFieldUpdateOperationsInput | number
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    lapseCount?: IntFieldUpdateOperationsInput | number
    reviews?: ReviewUncheckedUpdateManyWithoutCardNestedInput
  }

  export type CardUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: NullableStringFieldUpdateOperationsInput | string | null
    objectiveId?: NullableStringFieldUpdateOperationsInput | string | null
    front?: StringFieldUpdateOperationsInput | string
    back?: StringFieldUpdateOperationsInput | string
    cardType?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficulty?: FloatFieldUpdateOperationsInput | number
    stability?: FloatFieldUpdateOperationsInput | number
    retrievability?: FloatFieldUpdateOperationsInput | number
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    lapseCount?: IntFieldUpdateOperationsInput | number
  }

  export type ExamUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    coverageTopics?: ExamUpdatecoverageTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExamsNestedInput
  }

  export type ExamUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    coverageTopics?: ExamUpdatecoverageTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    coverageTopics?: ExamUpdatecoverageTopicsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoursePriorityUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    priorityLevel?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoursePrioritiesNestedInput
  }

  export type CoursePriorityUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    priorityLevel?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoursePriorityUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    priorityLevel?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentChunkCreateManyLectureInput = {
    id?: string
    content: string
    chunkIndex: number
    pageNumber?: number | null
    createdAt?: Date | string
  }

  export type LearningObjectiveCreateManyLectureInput = {
    id?: string
    objective: string
    complexity?: $Enums.ObjectiveComplexity
    pageStart?: number | null
    pageEnd?: number | null
    isHighYield?: boolean
    boardExamTags?: LearningObjectiveCreateboardExamTagsInput | string[]
    extractedBy?: string
    createdAt?: Date | string
    masteryLevel?: $Enums.MasteryLevel
    totalStudyTimeMs?: number
    lastStudiedAt?: Date | string | null
    weaknessScore?: number
  }

  export type CardCreateManyLectureInput = {
    id?: string
    courseId: string
    objectiveId?: string | null
    front: string
    back: string
    cardType?: $Enums.CardType
    createdAt?: Date | string
    difficulty?: number
    stability?: number
    retrievability?: number
    lastReviewedAt?: Date | string | null
    nextReviewAt?: Date | string | null
    reviewCount?: number
    lapseCount?: number
  }

  export type ContentChunkUpdateWithoutLectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentChunkUncheckedUpdateWithoutLectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentChunkUncheckedUpdateManyWithoutLectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    chunkIndex?: IntFieldUpdateOperationsInput | number
    pageNumber?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearningObjectiveUpdateWithoutLectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    complexity?: EnumObjectiveComplexityFieldUpdateOperationsInput | $Enums.ObjectiveComplexity
    pageStart?: NullableIntFieldUpdateOperationsInput | number | null
    pageEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isHighYield?: BoolFieldUpdateOperationsInput | boolean
    boardExamTags?: LearningObjectiveUpdateboardExamTagsInput | string[]
    extractedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masteryLevel?: EnumMasteryLevelFieldUpdateOperationsInput | $Enums.MasteryLevel
    totalStudyTimeMs?: IntFieldUpdateOperationsInput | number
    lastStudiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weaknessScore?: FloatFieldUpdateOperationsInput | number
    cards?: CardUpdateManyWithoutObjectiveNestedInput
    prerequisites?: ObjectivePrerequisiteUpdateManyWithoutObjectiveNestedInput
    dependents?: ObjectivePrerequisiteUpdateManyWithoutPrerequisiteNestedInput
    performanceMetrics?: PerformanceMetricUpdateManyWithoutLearningObjectiveNestedInput
    priorityFeedback?: PriorityFeedbackUpdateManyWithoutLearningObjectiveNestedInput
    strugglePredictions?: StrugglePredictionUpdateManyWithoutLearningObjectiveNestedInput
    struggleIndicators?: StruggleIndicatorUpdateManyWithoutLearningObjectiveNestedInput
  }

  export type LearningObjectiveUncheckedUpdateWithoutLectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    complexity?: EnumObjectiveComplexityFieldUpdateOperationsInput | $Enums.ObjectiveComplexity
    pageStart?: NullableIntFieldUpdateOperationsInput | number | null
    pageEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isHighYield?: BoolFieldUpdateOperationsInput | boolean
    boardExamTags?: LearningObjectiveUpdateboardExamTagsInput | string[]
    extractedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masteryLevel?: EnumMasteryLevelFieldUpdateOperationsInput | $Enums.MasteryLevel
    totalStudyTimeMs?: IntFieldUpdateOperationsInput | number
    lastStudiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weaknessScore?: FloatFieldUpdateOperationsInput | number
    cards?: CardUncheckedUpdateManyWithoutObjectiveNestedInput
    prerequisites?: ObjectivePrerequisiteUncheckedUpdateManyWithoutObjectiveNestedInput
    dependents?: ObjectivePrerequisiteUncheckedUpdateManyWithoutPrerequisiteNestedInput
    performanceMetrics?: PerformanceMetricUncheckedUpdateManyWithoutLearningObjectiveNestedInput
    priorityFeedback?: PriorityFeedbackUncheckedUpdateManyWithoutLearningObjectiveNestedInput
    strugglePredictions?: StrugglePredictionUncheckedUpdateManyWithoutLearningObjectiveNestedInput
    struggleIndicators?: StruggleIndicatorUncheckedUpdateManyWithoutLearningObjectiveNestedInput
  }

  export type LearningObjectiveUncheckedUpdateManyWithoutLectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    complexity?: EnumObjectiveComplexityFieldUpdateOperationsInput | $Enums.ObjectiveComplexity
    pageStart?: NullableIntFieldUpdateOperationsInput | number | null
    pageEnd?: NullableIntFieldUpdateOperationsInput | number | null
    isHighYield?: BoolFieldUpdateOperationsInput | boolean
    boardExamTags?: LearningObjectiveUpdateboardExamTagsInput | string[]
    extractedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    masteryLevel?: EnumMasteryLevelFieldUpdateOperationsInput | $Enums.MasteryLevel
    totalStudyTimeMs?: IntFieldUpdateOperationsInput | number
    lastStudiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    weaknessScore?: FloatFieldUpdateOperationsInput | number
  }

  export type CardUpdateWithoutLectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    front?: StringFieldUpdateOperationsInput | string
    back?: StringFieldUpdateOperationsInput | string
    cardType?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficulty?: FloatFieldUpdateOperationsInput | number
    stability?: FloatFieldUpdateOperationsInput | number
    retrievability?: FloatFieldUpdateOperationsInput | number
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    lapseCount?: IntFieldUpdateOperationsInput | number
    course?: CourseUpdateOneRequiredWithoutCardsNestedInput
    objective?: LearningObjectiveUpdateOneWithoutCardsNestedInput
    reviews?: ReviewUpdateManyWithoutCardNestedInput
  }

  export type CardUncheckedUpdateWithoutLectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    objectiveId?: NullableStringFieldUpdateOperationsInput | string | null
    front?: StringFieldUpdateOperationsInput | string
    back?: StringFieldUpdateOperationsInput | string
    cardType?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficulty?: FloatFieldUpdateOperationsInput | number
    stability?: FloatFieldUpdateOperationsInput | number
    retrievability?: FloatFieldUpdateOperationsInput | number
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    lapseCount?: IntFieldUpdateOperationsInput | number
    reviews?: ReviewUncheckedUpdateManyWithoutCardNestedInput
  }

  export type CardUncheckedUpdateManyWithoutLectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    objectiveId?: NullableStringFieldUpdateOperationsInput | string | null
    front?: StringFieldUpdateOperationsInput | string
    back?: StringFieldUpdateOperationsInput | string
    cardType?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficulty?: FloatFieldUpdateOperationsInput | number
    stability?: FloatFieldUpdateOperationsInput | number
    retrievability?: FloatFieldUpdateOperationsInput | number
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    lapseCount?: IntFieldUpdateOperationsInput | number
  }

  export type CardCreateManyObjectiveInput = {
    id?: string
    courseId: string
    lectureId?: string | null
    front: string
    back: string
    cardType?: $Enums.CardType
    createdAt?: Date | string
    difficulty?: number
    stability?: number
    retrievability?: number
    lastReviewedAt?: Date | string | null
    nextReviewAt?: Date | string | null
    reviewCount?: number
    lapseCount?: number
  }

  export type ObjectivePrerequisiteCreateManyObjectiveInput = {
    id?: string
    prerequisiteId: string
    strength?: number
  }

  export type ObjectivePrerequisiteCreateManyPrerequisiteInput = {
    id?: string
    objectiveId: string
    strength?: number
  }

  export type PerformanceMetricCreateManyLearningObjectiveInput = {
    id?: string
    userId: string
    date?: Date | string
    retentionScore: number
    studyTimeMs: number
    reviewCount: number
    correctReviews: number
    incorrectReviews: number
    createdAt?: Date | string
  }

  export type PriorityFeedbackCreateManyLearningObjectiveInput = {
    id?: string
    userId: string
    suggestedPriority: number
    userFeedback: $Enums.FeedbackRating
    notes?: string | null
    createdAt?: Date | string
  }

  export type StrugglePredictionCreateManyLearningObjectiveInput = {
    id?: string
    userId: string
    topicId?: string | null
    predictionDate?: Date | string
    predictedStruggleProbability: number
    predictionConfidence: number
    predictionStatus?: $Enums.PredictionStatus
    actualOutcome?: boolean | null
    outcomeRecordedAt?: Date | string | null
    featureVector: JsonNullValueInput | InputJsonValue
  }

  export type StruggleIndicatorCreateManyLearningObjectiveInput = {
    id?: string
    userId: string
    predictionId?: string | null
    indicatorType: $Enums.IndicatorType
    severity?: $Enums.Severity
    detectedAt?: Date | string
    context: JsonNullValueInput | InputJsonValue
  }

  export type CardUpdateWithoutObjectiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    front?: StringFieldUpdateOperationsInput | string
    back?: StringFieldUpdateOperationsInput | string
    cardType?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficulty?: FloatFieldUpdateOperationsInput | number
    stability?: FloatFieldUpdateOperationsInput | number
    retrievability?: FloatFieldUpdateOperationsInput | number
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    lapseCount?: IntFieldUpdateOperationsInput | number
    course?: CourseUpdateOneRequiredWithoutCardsNestedInput
    lecture?: LectureUpdateOneWithoutCardsNestedInput
    reviews?: ReviewUpdateManyWithoutCardNestedInput
  }

  export type CardUncheckedUpdateWithoutObjectiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    lectureId?: NullableStringFieldUpdateOperationsInput | string | null
    front?: StringFieldUpdateOperationsInput | string
    back?: StringFieldUpdateOperationsInput | string
    cardType?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficulty?: FloatFieldUpdateOperationsInput | number
    stability?: FloatFieldUpdateOperationsInput | number
    retrievability?: FloatFieldUpdateOperationsInput | number
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    lapseCount?: IntFieldUpdateOperationsInput | number
    reviews?: ReviewUncheckedUpdateManyWithoutCardNestedInput
  }

  export type CardUncheckedUpdateManyWithoutObjectiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    lectureId?: NullableStringFieldUpdateOperationsInput | string | null
    front?: StringFieldUpdateOperationsInput | string
    back?: StringFieldUpdateOperationsInput | string
    cardType?: EnumCardTypeFieldUpdateOperationsInput | $Enums.CardType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficulty?: FloatFieldUpdateOperationsInput | number
    stability?: FloatFieldUpdateOperationsInput | number
    retrievability?: FloatFieldUpdateOperationsInput | number
    lastReviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextReviewAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    lapseCount?: IntFieldUpdateOperationsInput | number
  }

  export type ObjectivePrerequisiteUpdateWithoutObjectiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
    prerequisite?: LearningObjectiveUpdateOneRequiredWithoutDependentsNestedInput
  }

  export type ObjectivePrerequisiteUncheckedUpdateWithoutObjectiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    prerequisiteId?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
  }

  export type ObjectivePrerequisiteUncheckedUpdateManyWithoutObjectiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    prerequisiteId?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
  }

  export type ObjectivePrerequisiteUpdateWithoutPrerequisiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
    objective?: LearningObjectiveUpdateOneRequiredWithoutPrerequisitesNestedInput
  }

  export type ObjectivePrerequisiteUncheckedUpdateWithoutPrerequisiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    objectiveId?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
  }

  export type ObjectivePrerequisiteUncheckedUpdateManyWithoutPrerequisiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    objectiveId?: StringFieldUpdateOperationsInput | string
    strength?: FloatFieldUpdateOperationsInput | number
  }

  export type PerformanceMetricUpdateWithoutLearningObjectiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionScore?: FloatFieldUpdateOperationsInput | number
    studyTimeMs?: IntFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    correctReviews?: IntFieldUpdateOperationsInput | number
    incorrectReviews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceMetricUncheckedUpdateWithoutLearningObjectiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionScore?: FloatFieldUpdateOperationsInput | number
    studyTimeMs?: IntFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    correctReviews?: IntFieldUpdateOperationsInput | number
    incorrectReviews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceMetricUncheckedUpdateManyWithoutLearningObjectiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    retentionScore?: FloatFieldUpdateOperationsInput | number
    studyTimeMs?: IntFieldUpdateOperationsInput | number
    reviewCount?: IntFieldUpdateOperationsInput | number
    correctReviews?: IntFieldUpdateOperationsInput | number
    incorrectReviews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriorityFeedbackUpdateWithoutLearningObjectiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    suggestedPriority?: FloatFieldUpdateOperationsInput | number
    userFeedback?: EnumFeedbackRatingFieldUpdateOperationsInput | $Enums.FeedbackRating
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriorityFeedbackUncheckedUpdateWithoutLearningObjectiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    suggestedPriority?: FloatFieldUpdateOperationsInput | number
    userFeedback?: EnumFeedbackRatingFieldUpdateOperationsInput | $Enums.FeedbackRating
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriorityFeedbackUncheckedUpdateManyWithoutLearningObjectiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    suggestedPriority?: FloatFieldUpdateOperationsInput | number
    userFeedback?: EnumFeedbackRatingFieldUpdateOperationsInput | $Enums.FeedbackRating
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StrugglePredictionUpdateWithoutLearningObjectiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    predictionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    predictedStruggleProbability?: FloatFieldUpdateOperationsInput | number
    predictionConfidence?: FloatFieldUpdateOperationsInput | number
    predictionStatus?: EnumPredictionStatusFieldUpdateOperationsInput | $Enums.PredictionStatus
    actualOutcome?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outcomeRecordedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featureVector?: JsonNullValueInput | InputJsonValue
    indicators?: StruggleIndicatorUpdateManyWithoutPredictionNestedInput
    interventions?: InterventionRecommendationUpdateManyWithoutPredictionNestedInput
    feedbacks?: PredictionFeedbackUpdateManyWithoutPredictionNestedInput
  }

  export type StrugglePredictionUncheckedUpdateWithoutLearningObjectiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    predictionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    predictedStruggleProbability?: FloatFieldUpdateOperationsInput | number
    predictionConfidence?: FloatFieldUpdateOperationsInput | number
    predictionStatus?: EnumPredictionStatusFieldUpdateOperationsInput | $Enums.PredictionStatus
    actualOutcome?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outcomeRecordedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featureVector?: JsonNullValueInput | InputJsonValue
    indicators?: StruggleIndicatorUncheckedUpdateManyWithoutPredictionNestedInput
    interventions?: InterventionRecommendationUncheckedUpdateManyWithoutPredictionNestedInput
    feedbacks?: PredictionFeedbackUncheckedUpdateManyWithoutPredictionNestedInput
  }

  export type StrugglePredictionUncheckedUpdateManyWithoutLearningObjectiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    topicId?: NullableStringFieldUpdateOperationsInput | string | null
    predictionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    predictedStruggleProbability?: FloatFieldUpdateOperationsInput | number
    predictionConfidence?: FloatFieldUpdateOperationsInput | number
    predictionStatus?: EnumPredictionStatusFieldUpdateOperationsInput | $Enums.PredictionStatus
    actualOutcome?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outcomeRecordedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    featureVector?: JsonNullValueInput | InputJsonValue
  }

  export type StruggleIndicatorUpdateWithoutLearningObjectiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    indicatorType?: EnumIndicatorTypeFieldUpdateOperationsInput | $Enums.IndicatorType
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: JsonNullValueInput | InputJsonValue
    prediction?: StrugglePredictionUpdateOneWithoutIndicatorsNestedInput
  }

  export type StruggleIndicatorUncheckedUpdateWithoutLearningObjectiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    predictionId?: NullableStringFieldUpdateOperationsInput | string | null
    indicatorType?: EnumIndicatorTypeFieldUpdateOperationsInput | $Enums.IndicatorType
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: JsonNullValueInput | InputJsonValue
  }

  export type StruggleIndicatorUncheckedUpdateManyWithoutLearningObjectiveInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    predictionId?: NullableStringFieldUpdateOperationsInput | string | null
    indicatorType?: EnumIndicatorTypeFieldUpdateOperationsInput | $Enums.IndicatorType
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: JsonNullValueInput | InputJsonValue
  }

  export type StudySessionCreateManyMissionInput = {
    id?: string
    userId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    reviewsCompleted?: number
    newCardsStudied?: number
    sessionNotes?: string | null
    currentObjectiveIndex?: number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MissionFeedbackCreateManyMissionInput = {
    id?: string
    userId: string
    helpfulnessRating: number
    relevanceScore: number
    paceRating: $Enums.PaceRating
    improvementSuggestions?: string | null
    submittedAt?: Date | string
  }

  export type InterventionRecommendationCreateManyMissionInput = {
    id?: string
    predictionId: string
    userId: string
    interventionType: $Enums.InterventionType
    description: string
    reasoning: string
    priority?: number
    status?: $Enums.InterventionStatus
    appliedAt?: Date | string | null
    effectiveness?: number | null
    createdAt?: Date | string
  }

  export type StudySessionUpdateWithoutMissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    reviewsCompleted?: IntFieldUpdateOperationsInput | number
    newCardsStudied?: IntFieldUpdateOperationsInput | number
    sessionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    currentObjectiveIndex?: IntFieldUpdateOperationsInput | number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutStudySessionsNestedInput
    reviews?: ReviewUpdateManyWithoutSessionNestedInput
    validationResponses?: ValidationResponseUpdateManyWithoutSessionNestedInput
  }

  export type StudySessionUncheckedUpdateWithoutMissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    reviewsCompleted?: IntFieldUpdateOperationsInput | number
    newCardsStudied?: IntFieldUpdateOperationsInput | number
    sessionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    currentObjectiveIndex?: IntFieldUpdateOperationsInput | number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
    reviews?: ReviewUncheckedUpdateManyWithoutSessionNestedInput
    validationResponses?: ValidationResponseUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type StudySessionUncheckedUpdateManyWithoutMissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    reviewsCompleted?: IntFieldUpdateOperationsInput | number
    newCardsStudied?: IntFieldUpdateOperationsInput | number
    sessionNotes?: NullableStringFieldUpdateOperationsInput | string | null
    currentObjectiveIndex?: IntFieldUpdateOperationsInput | number
    missionObjectives?: NullableJsonNullValueInput | InputJsonValue
    objectiveCompletions?: NullableJsonNullValueInput | InputJsonValue
  }

  export type MissionFeedbackUpdateWithoutMissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    helpfulnessRating?: IntFieldUpdateOperationsInput | number
    relevanceScore?: IntFieldUpdateOperationsInput | number
    paceRating?: EnumPaceRatingFieldUpdateOperationsInput | $Enums.PaceRating
    improvementSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionFeedbackUncheckedUpdateWithoutMissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    helpfulnessRating?: IntFieldUpdateOperationsInput | number
    relevanceScore?: IntFieldUpdateOperationsInput | number
    paceRating?: EnumPaceRatingFieldUpdateOperationsInput | $Enums.PaceRating
    improvementSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MissionFeedbackUncheckedUpdateManyWithoutMissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    helpfulnessRating?: IntFieldUpdateOperationsInput | number
    relevanceScore?: IntFieldUpdateOperationsInput | number
    paceRating?: EnumPaceRatingFieldUpdateOperationsInput | $Enums.PaceRating
    improvementSuggestions?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionRecommendationUpdateWithoutMissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    interventionType?: EnumInterventionTypeFieldUpdateOperationsInput | $Enums.InterventionType
    description?: StringFieldUpdateOperationsInput | string
    reasoning?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prediction?: StrugglePredictionUpdateOneRequiredWithoutInterventionsNestedInput
  }

  export type InterventionRecommendationUncheckedUpdateWithoutMissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    predictionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    interventionType?: EnumInterventionTypeFieldUpdateOperationsInput | $Enums.InterventionType
    description?: StringFieldUpdateOperationsInput | string
    reasoning?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionRecommendationUncheckedUpdateManyWithoutMissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    predictionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    interventionType?: EnumInterventionTypeFieldUpdateOperationsInput | $Enums.InterventionType
    description?: StringFieldUpdateOperationsInput | string
    reasoning?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyCardInput = {
    id?: string
    userId: string
    sessionId?: string | null
    rating: $Enums.ReviewRating
    timeSpentMs: number
    reviewedAt?: Date | string
    difficultyBefore: number
    stabilityBefore: number
    difficultyAfter: number
    stabilityAfter: number
  }

  export type ReviewUpdateWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: EnumReviewRatingFieldUpdateOperationsInput | $Enums.ReviewRating
    timeSpentMs?: IntFieldUpdateOperationsInput | number
    reviewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficultyBefore?: FloatFieldUpdateOperationsInput | number
    stabilityBefore?: FloatFieldUpdateOperationsInput | number
    difficultyAfter?: FloatFieldUpdateOperationsInput | number
    stabilityAfter?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    session?: StudySessionUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: EnumReviewRatingFieldUpdateOperationsInput | $Enums.ReviewRating
    timeSpentMs?: IntFieldUpdateOperationsInput | number
    reviewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficultyBefore?: FloatFieldUpdateOperationsInput | number
    stabilityBefore?: FloatFieldUpdateOperationsInput | number
    difficultyAfter?: FloatFieldUpdateOperationsInput | number
    stabilityAfter?: FloatFieldUpdateOperationsInput | number
  }

  export type ReviewUncheckedUpdateManyWithoutCardInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: EnumReviewRatingFieldUpdateOperationsInput | $Enums.ReviewRating
    timeSpentMs?: IntFieldUpdateOperationsInput | number
    reviewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficultyBefore?: FloatFieldUpdateOperationsInput | number
    stabilityBefore?: FloatFieldUpdateOperationsInput | number
    difficultyAfter?: FloatFieldUpdateOperationsInput | number
    stabilityAfter?: FloatFieldUpdateOperationsInput | number
  }

  export type ReviewCreateManySessionInput = {
    id?: string
    userId: string
    cardId: string
    rating: $Enums.ReviewRating
    timeSpentMs: number
    reviewedAt?: Date | string
    difficultyBefore: number
    stabilityBefore: number
    difficultyAfter: number
    stabilityAfter: number
  }

  export type ValidationResponseCreateManySessionInput = {
    id?: string
    promptId: string
    userAnswer: string
    aiEvaluation: string
    score: number
    confidence?: number | null
    respondedAt?: Date | string
  }

  export type ReviewUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: EnumReviewRatingFieldUpdateOperationsInput | $Enums.ReviewRating
    timeSpentMs?: IntFieldUpdateOperationsInput | number
    reviewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficultyBefore?: FloatFieldUpdateOperationsInput | number
    stabilityBefore?: FloatFieldUpdateOperationsInput | number
    difficultyAfter?: FloatFieldUpdateOperationsInput | number
    stabilityAfter?: FloatFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    card?: CardUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    rating?: EnumReviewRatingFieldUpdateOperationsInput | $Enums.ReviewRating
    timeSpentMs?: IntFieldUpdateOperationsInput | number
    reviewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficultyBefore?: FloatFieldUpdateOperationsInput | number
    stabilityBefore?: FloatFieldUpdateOperationsInput | number
    difficultyAfter?: FloatFieldUpdateOperationsInput | number
    stabilityAfter?: FloatFieldUpdateOperationsInput | number
  }

  export type ReviewUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cardId?: StringFieldUpdateOperationsInput | string
    rating?: EnumReviewRatingFieldUpdateOperationsInput | $Enums.ReviewRating
    timeSpentMs?: IntFieldUpdateOperationsInput | number
    reviewedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    difficultyBefore?: FloatFieldUpdateOperationsInput | number
    stabilityBefore?: FloatFieldUpdateOperationsInput | number
    difficultyAfter?: FloatFieldUpdateOperationsInput | number
    stabilityAfter?: FloatFieldUpdateOperationsInput | number
  }

  export type ValidationResponseUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userAnswer?: StringFieldUpdateOperationsInput | string
    aiEvaluation?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prompt?: ValidationPromptUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type ValidationResponseUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    userAnswer?: StringFieldUpdateOperationsInput | string
    aiEvaluation?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ValidationResponseUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    promptId?: StringFieldUpdateOperationsInput | string
    userAnswer?: StringFieldUpdateOperationsInput | string
    aiEvaluation?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptRelationshipCreateManyFromConceptInput = {
    id?: string
    toConceptId: string
    relationship: $Enums.RelationshipType
    strength?: number
    createdAt?: Date | string
  }

  export type ConceptRelationshipCreateManyToConceptInput = {
    id?: string
    fromConceptId: string
    relationship: $Enums.RelationshipType
    strength?: number
    createdAt?: Date | string
  }

  export type ConceptRelationshipUpdateWithoutFromConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    strength?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toConcept?: ConceptUpdateOneRequiredWithoutRelatedToNestedInput
  }

  export type ConceptRelationshipUncheckedUpdateWithoutFromConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    toConceptId?: StringFieldUpdateOperationsInput | string
    relationship?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    strength?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptRelationshipUncheckedUpdateManyWithoutFromConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    toConceptId?: StringFieldUpdateOperationsInput | string
    relationship?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    strength?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptRelationshipUpdateWithoutToConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationship?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    strength?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromConcept?: ConceptUpdateOneRequiredWithoutRelatedFromNestedInput
  }

  export type ConceptRelationshipUncheckedUpdateWithoutToConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromConceptId?: StringFieldUpdateOperationsInput | string
    relationship?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    strength?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConceptRelationshipUncheckedUpdateManyWithoutToConceptInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromConceptId?: StringFieldUpdateOperationsInput | string
    relationship?: EnumRelationshipTypeFieldUpdateOperationsInput | $Enums.RelationshipType
    strength?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ValidationResponseCreateManyPromptInput = {
    id?: string
    sessionId?: string | null
    userAnswer: string
    aiEvaluation: string
    score: number
    confidence?: number | null
    respondedAt?: Date | string
  }

  export type ValidationResponseUpdateWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    userAnswer?: StringFieldUpdateOperationsInput | string
    aiEvaluation?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: StudySessionUpdateOneWithoutValidationResponsesNestedInput
  }

  export type ValidationResponseUncheckedUpdateWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userAnswer?: StringFieldUpdateOperationsInput | string
    aiEvaluation?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ValidationResponseUncheckedUpdateManyWithoutPromptInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    userAnswer?: StringFieldUpdateOperationsInput | string
    aiEvaluation?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightPatternCreateManyPatternInput = {
    id?: string
    insightId: string
  }

  export type InsightPatternUpdateWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    insight?: BehavioralInsightUpdateOneRequiredWithoutPatternsNestedInput
  }

  export type InsightPatternUncheckedUpdateWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
  }

  export type InsightPatternUncheckedUpdateManyWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
  }

  export type InsightPatternCreateManyInsightInput = {
    id?: string
    patternId: string
  }

  export type InsightPatternUpdateWithoutInsightInput = {
    id?: StringFieldUpdateOperationsInput | string
    pattern?: BehavioralPatternUpdateOneRequiredWithoutInsightsNestedInput
  }

  export type InsightPatternUncheckedUpdateWithoutInsightInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
  }

  export type InsightPatternUncheckedUpdateManyWithoutInsightInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
  }

  export type StruggleIndicatorCreateManyPredictionInput = {
    id?: string
    userId: string
    learningObjectiveId: string
    indicatorType: $Enums.IndicatorType
    severity?: $Enums.Severity
    detectedAt?: Date | string
    context: JsonNullValueInput | InputJsonValue
  }

  export type InterventionRecommendationCreateManyPredictionInput = {
    id?: string
    userId: string
    interventionType: $Enums.InterventionType
    description: string
    reasoning: string
    priority?: number
    status?: $Enums.InterventionStatus
    appliedAt?: Date | string | null
    appliedToMissionId?: string | null
    effectiveness?: number | null
    createdAt?: Date | string
  }

  export type PredictionFeedbackCreateManyPredictionInput = {
    id?: string
    userId: string
    feedbackType: $Enums.FeedbackType
    actualStruggle: boolean
    helpfulness?: number | null
    comments?: string | null
    submittedAt?: Date | string
  }

  export type StruggleIndicatorUpdateWithoutPredictionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    indicatorType?: EnumIndicatorTypeFieldUpdateOperationsInput | $Enums.IndicatorType
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: JsonNullValueInput | InputJsonValue
    learningObjective?: LearningObjectiveUpdateOneRequiredWithoutStruggleIndicatorsNestedInput
  }

  export type StruggleIndicatorUncheckedUpdateWithoutPredictionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    learningObjectiveId?: StringFieldUpdateOperationsInput | string
    indicatorType?: EnumIndicatorTypeFieldUpdateOperationsInput | $Enums.IndicatorType
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: JsonNullValueInput | InputJsonValue
  }

  export type StruggleIndicatorUncheckedUpdateManyWithoutPredictionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    learningObjectiveId?: StringFieldUpdateOperationsInput | string
    indicatorType?: EnumIndicatorTypeFieldUpdateOperationsInput | $Enums.IndicatorType
    severity?: EnumSeverityFieldUpdateOperationsInput | $Enums.Severity
    detectedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    context?: JsonNullValueInput | InputJsonValue
  }

  export type InterventionRecommendationUpdateWithoutPredictionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    interventionType?: EnumInterventionTypeFieldUpdateOperationsInput | $Enums.InterventionType
    description?: StringFieldUpdateOperationsInput | string
    reasoning?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    effectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mission?: MissionUpdateOneWithoutInterventionsNestedInput
  }

  export type InterventionRecommendationUncheckedUpdateWithoutPredictionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    interventionType?: EnumInterventionTypeFieldUpdateOperationsInput | $Enums.InterventionType
    description?: StringFieldUpdateOperationsInput | string
    reasoning?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedToMissionId?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterventionRecommendationUncheckedUpdateManyWithoutPredictionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    interventionType?: EnumInterventionTypeFieldUpdateOperationsInput | $Enums.InterventionType
    description?: StringFieldUpdateOperationsInput | string
    reasoning?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    status?: EnumInterventionStatusFieldUpdateOperationsInput | $Enums.InterventionStatus
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedToMissionId?: NullableStringFieldUpdateOperationsInput | string | null
    effectiveness?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionFeedbackUpdateWithoutPredictionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feedbackType?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    actualStruggle?: BoolFieldUpdateOperationsInput | boolean
    helpfulness?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionFeedbackUncheckedUpdateWithoutPredictionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feedbackType?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    actualStruggle?: BoolFieldUpdateOperationsInput | boolean
    helpfulness?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionFeedbackUncheckedUpdateManyWithoutPredictionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    feedbackType?: EnumFeedbackTypeFieldUpdateOperationsInput | $Enums.FeedbackType
    actualStruggle?: BoolFieldUpdateOperationsInput | boolean
    helpfulness?: NullableIntFieldUpdateOperationsInput | number | null
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseCountOutputTypeDefaultArgs instead
     */
    export type CourseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LectureCountOutputTypeDefaultArgs instead
     */
    export type LectureCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LectureCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LearningObjectiveCountOutputTypeDefaultArgs instead
     */
    export type LearningObjectiveCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LearningObjectiveCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MissionCountOutputTypeDefaultArgs instead
     */
    export type MissionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MissionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CardCountOutputTypeDefaultArgs instead
     */
    export type CardCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CardCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudySessionCountOutputTypeDefaultArgs instead
     */
    export type StudySessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudySessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConceptCountOutputTypeDefaultArgs instead
     */
    export type ConceptCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConceptCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ValidationPromptCountOutputTypeDefaultArgs instead
     */
    export type ValidationPromptCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ValidationPromptCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BehavioralPatternCountOutputTypeDefaultArgs instead
     */
    export type BehavioralPatternCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BehavioralPatternCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BehavioralInsightCountOutputTypeDefaultArgs instead
     */
    export type BehavioralInsightCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BehavioralInsightCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StrugglePredictionCountOutputTypeDefaultArgs instead
     */
    export type StrugglePredictionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StrugglePredictionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseDefaultArgs instead
     */
    export type CourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LectureDefaultArgs instead
     */
    export type LectureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LectureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContentChunkDefaultArgs instead
     */
    export type ContentChunkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContentChunkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LearningObjectiveDefaultArgs instead
     */
    export type LearningObjectiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LearningObjectiveDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObjectivePrerequisiteDefaultArgs instead
     */
    export type ObjectivePrerequisiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObjectivePrerequisiteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MissionDefaultArgs instead
     */
    export type MissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CardDefaultArgs instead
     */
    export type CardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReviewDefaultArgs instead
     */
    export type ReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudySessionDefaultArgs instead
     */
    export type StudySessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudySessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConceptDefaultArgs instead
     */
    export type ConceptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConceptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConceptRelationshipDefaultArgs instead
     */
    export type ConceptRelationshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConceptRelationshipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ValidationPromptDefaultArgs instead
     */
    export type ValidationPromptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ValidationPromptDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ValidationResponseDefaultArgs instead
     */
    export type ValidationResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ValidationResponseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComprehensionMetricDefaultArgs instead
     */
    export type ComprehensionMetricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComprehensionMetricDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BehavioralEventDefaultArgs instead
     */
    export type BehavioralEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BehavioralEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BehavioralPatternDefaultArgs instead
     */
    export type BehavioralPatternArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BehavioralPatternDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BehavioralInsightDefaultArgs instead
     */
    export type BehavioralInsightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BehavioralInsightDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InsightPatternDefaultArgs instead
     */
    export type InsightPatternArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InsightPatternDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserLearningProfileDefaultArgs instead
     */
    export type UserLearningProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserLearningProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LearningPatternDefaultArgs instead
     */
    export type LearningPatternArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LearningPatternDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PerformancePredictionDefaultArgs instead
     */
    export type PerformancePredictionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PerformancePredictionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StrugglePredictionDefaultArgs instead
     */
    export type StrugglePredictionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StrugglePredictionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StruggleIndicatorDefaultArgs instead
     */
    export type StruggleIndicatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StruggleIndicatorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InterventionRecommendationDefaultArgs instead
     */
    export type InterventionRecommendationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InterventionRecommendationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PredictionFeedbackDefaultArgs instead
     */
    export type PredictionFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PredictionFeedbackDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PerformanceMetricDefaultArgs instead
     */
    export type PerformanceMetricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PerformanceMetricDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamDefaultArgs instead
     */
    export type ExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CoursePriorityDefaultArgs instead
     */
    export type CoursePriorityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CoursePriorityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PriorityFeedbackDefaultArgs instead
     */
    export type PriorityFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PriorityFeedbackDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StreakDefaultArgs instead
     */
    export type StreakArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StreakDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AchievementDefaultArgs instead
     */
    export type AchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AchievementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudyGoalDefaultArgs instead
     */
    export type StudyGoalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudyGoalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MissionAnalyticsDefaultArgs instead
     */
    export type MissionAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MissionAnalyticsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MissionFeedbackDefaultArgs instead
     */
    export type MissionFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MissionFeedbackDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MissionStreakDefaultArgs instead
     */
    export type MissionStreakArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MissionStreakDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MissionReviewDefaultArgs instead
     */
    export type MissionReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MissionReviewDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}