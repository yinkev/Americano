/**
 * AUTO-GENERATED FROM PYDANTIC V2 MODELS - DO NOT EDIT MANUALLY
 *
 * This file is automatically generated from Python Pydantic V2 models.
 * Any manual changes will be overwritten on next generation.
 *
 * Source modules:
 *   - src.validation.models
 *   - src.challenge.models
 *   - src.adaptive.models
 *   - src.analytics.models
 *   - app.models.predictions
 *   - app.models.feedback
 *   - app.models.interventions
 *   - app.models.analytics
 *
 * Generated: 2025-10-27 11:15:09 UTC
 * Generator: Custom Pydantic V2 â†’ TypeScript converter
 *
 * To regenerate:
 *   cd apps/api && python scripts/generate_types.py
 *   or
 *   cd apps/web && npm run generate-types
 */

export type ChiefComplaint = string;
/**
 * Clinical decision questions at key stages (stage, prompt, options, correctAnswer, reasoning)
 */
export type Questions = {
  [k: string]: unknown;
}[];

/**
 * Structured clinical case presentation.
 */
export interface CaseStructure {
  chief_complaint: ChiefComplaint;
  demographics: Demographics;
  history: History;
  physical_exam: PhysicalExam;
  labs: Labs;
  questions: Questions;
  [k: string]: unknown;
}
/**
 * Age, sex, occupation, relevant social info
 */
export interface Demographics {
  [k: string]: unknown;
}
/**
 * HPI, PMH, medications, allergies, social history, family history
 */
export interface History {
  [k: string]: unknown;
}
/**
 * Vitals, general appearance, cardiovascular, respiratory, other systems
 */
export interface PhysicalExam {
  [k: string]: unknown;
}
/**
 * Available initial labs, imaging results, and options for additional workup
 */
export interface Labs {
  [k: string]: unknown;
}

export type ObjectiveId = string;
/**
 * Text content of the learning objective
 */
export type ObjectiveText = string;
/**
 * Type of vulnerability: overconfidence | partial_understanding | recent_mistakes
 */
export type VulnerabilityType = string;

/**
 * Request model for generating challenge questions.
 */
export interface ChallengeGenerationRequest {
  objective_id: ObjectiveId;
  objective_text: ObjectiveText;
  vulnerability_type: VulnerabilityType;
  [k: string]: unknown;
}

export type UserId = string;
/**
 * List of performance records for analysis
 */
export type PerformanceData = {
  [k: string]: unknown;
}[];
/**
 * Max concepts to return
 */
export type Limit = number;

/**
 * Request model for identifying vulnerable concepts.
 */
export interface ChallengeIdentificationRequest {
  user_id: UserId;
  performance_data: PerformanceData;
  limit?: Limit;
  [k: string]: unknown;
}

export type ScenarioId = string;
/**
 * Free text explanation of clinical reasoning
 */
export type UserReasoning = string;
/**
 * Time spent on scenario in seconds
 */
export type TimeSpent = number;
/**
 * Summary of the case for evaluation context
 */
export type CaseSummary = string;

/**
 * Request model for evaluating clinical reasoning on a scenario.
 */
export interface ClinicalEvaluationRequest {
  scenario_id: ScenarioId;
  user_choices: UserChoices;
  user_reasoning: UserReasoning;
  time_spent: TimeSpent;
  case_summary: CaseSummary;
  [k: string]: unknown;
}
/**
 * JSON of user selections at each decision point
 */
export interface UserChoices {
  [k: string]: unknown;
}

export type OverallScore = number;
/**
 * History/exam collection score
 */
export type DataGathering = number;
/**
 * Diagnostic reasoning score
 */
export type Diagnosis = number;
/**
 * Treatment planning score
 */
export type Management = number;
/**
 * Systematic thinking score
 */
export type ClinicalReasoning = number;
/**
 * 2-3 bullet points on what the student did well
 *
 * @minItems 2
 * @maxItems 3
 */
export type Strengths = [string, string] | [string, string, string];
/**
 * 2-3 bullet points on errors or missed opportunities
 *
 * @minItems 2
 * @maxItems 3
 */
export type Weaknesses = [string, string] | [string, string, string];
/**
 * Critical findings the student overlooked (empty if none)
 */
export type MissedFindings = string[];
/**
 * Cognitive biases detected (anchoring, premature closure, etc.)
 */
export type CognitiveBiases = string[];
/**
 * Brief description of the ideal diagnostic/management approach
 */
export type OptimalPathway = string;
/**
 * Key learning points with resource suggestions
 *
 * @minItems 2
 * @maxItems 4
 */
export type TeachingPoints = [string, string] | [string, string, string] | [string, string, string, string];

/**
 * Structured clinical reasoning evaluation response from ChatMock via instructor.
 *
 * This model is used as the response_model for instructor, ensuring
 * the LLM returns data in exactly this format with validation.
 */
export interface ClinicalEvaluationResult {
  overall_score: OverallScore;
  competency_scores: CompetencyScores;
  strengths: Strengths;
  weaknesses: Weaknesses;
  missed_findings: MissedFindings;
  cognitive_biases: CognitiveBiases;
  optimal_pathway: OptimalPathway;
  teaching_points: TeachingPoints;
  [k: string]: unknown;
}
/**
 * Breakdown by clinical competency domain
 */
export interface CompetencyScores {
  data_gathering: DataGathering;
  diagnosis: Diagnosis;
  management: Management;
  clinical_reasoning: ClinicalReasoning;
  [k: string]: unknown;
}

export type DataGathering = number;
/**
 * Diagnostic reasoning score
 */
export type Diagnosis = number;
/**
 * Treatment planning score
 */
export type Management = number;
/**
 * Systematic thinking score
 */
export type ClinicalReasoning = number;

/**
 * Competency-based scores for clinical reasoning evaluation.
 */
export interface CompetencyScores {
  data_gathering: DataGathering;
  diagnosis: Diagnosis;
  management: Management;
  clinical_reasoning: ClinicalReasoning;
  [k: string]: unknown;
}

export type Error = string;
/**
 * Detailed error message
 */
export type Message = string;
/**
 * Error timestamp (ISO format)
 */
export type Timestamp = string;

/**
 * Standardized error response format.
 */
export interface ErrorResponse {
  error: Error;
  message: Message;
  details?: Details;
  timestamp?: Timestamp;
  [k: string]: unknown;
}
/**
 * Additional error context
 */
export interface Details {
  [k: string]: unknown;
}

export type PromptId = string;
/**
 * User's explanation (multi-paragraph allowed)
 */
export type UserAnswer = string;
/**
 * User's self-assessed confidence (1-5 scale)
 */
export type ConfidenceLevel = number;
/**
 * The learning objective being tested
 */
export type ObjectiveText = string;

/**
 * Request model for evaluating user comprehension.
 */
export interface EvaluationRequest {
  prompt_id: PromptId;
  user_answer: UserAnswer;
  confidence_level: ConfidenceLevel;
  objective_text: ObjectiveText;
  [k: string]: unknown;
}

export type OverallScore = number;
/**
 * Medical terminology usage score (20% weight)
 */
export type TerminologyScore = number;
/**
 * Concept connections score (30% weight)
 */
export type RelationshipsScore = number;
/**
 * Clinical application score (30% weight)
 */
export type ApplicationScore = number;
/**
 * Patient-friendly clarity score (20% weight)
 */
export type ClarityScore = number;
/**
 * 2-3 bullet points on what was explained well
 *
 * @minItems 2
 * @maxItems 3
 */
export type Strengths = [string, string] | [string, string, string];
/**
 * 2-3 bullet points on what's missing or incorrect
 *
 * @minItems 2
 * @maxItems 3
 */
export type Gaps = [string, string] | [string, string, string];
/**
 * Confidence - Score (calculated post-LLM evaluation)
 */
export type CalibrationDelta = number;
/**
 * User-friendly calibration insight (calculated post-LLM evaluation)
 */
export type CalibrationNote = string;

/**
 * Structured evaluation response from ChatMock via instructor.
 *
 * This model is used as the response_model for instructor, ensuring
 * the LLM returns data in exactly this format with validation.
 */
export interface EvaluationResult {
  overall_score: OverallScore;
  terminology_score: TerminologyScore;
  relationships_score: RelationshipsScore;
  application_score: ApplicationScore;
  clarity_score: ClarityScore;
  strengths: Strengths;
  gaps: Gaps;
  calibration_delta?: CalibrationDelta;
  calibration_note?: CalibrationNote;
  [k: string]: unknown;
}

export type Status = "healthy" | "unhealthy";
/**
 * Service name
 */
export type Service = string;
/**
 * API version
 */
export type Version = string;

/**
 * Health check endpoint response.
 */
export interface HealthCheckResponse {
  status: Status;
  service?: Service;
  version?: Version;
  [k: string]: unknown;
}

export type ObjectiveId = string;
/**
 * Text content of the learning objective
 */
export type ObjectiveText = string;

/**
 * Request model for generating comprehension prompts.
 */
export interface PromptGenerationRequest {
  objective_id: ObjectiveId;
  objective_text: ObjectiveText;
  [k: string]: unknown;
}

export type PromptText = string;
/**
 * Type of prompt template used
 */
export type PromptType = "Direct Question" | "Clinical Scenario" | "Teaching Simulation";
/**
 * Key concepts the user should cover in their explanation
 */
export type ExpectedCriteria = string[];

/**
 * Response model for generated comprehension prompts.
 */
export interface PromptGenerationResponse {
  prompt_text: PromptText;
  prompt_type: PromptType;
  expected_criteria: ExpectedCriteria;
  [k: string]: unknown;
}

export type ObjectiveId = string;
/**
 * Text content of the learning objective
 */
export type ObjectiveText = string;
/**
 * Board exam topics (USMLE/COMLEX tags)
 */
export type BoardExamTags = string[];
/**
 * Difficulty level for case scenario
 */
export type Difficulty = "BASIC" | "INTERMEDIATE" | "ADVANCED";

/**
 * Request model for generating clinical case scenarios.
 */
export interface ScenarioGenerationRequest {
  objective_id: ObjectiveId;
  objective_text: ObjectiveText;
  board_exam_tags: BoardExamTags;
  difficulty?: Difficulty;
  [k: string]: unknown;
}

export type ScenarioId = string;
/**
 * Source learning objective ID
 */
export type ObjectiveId = string;
/**
 * Type of clinical reasoning tested
 */
export type ScenarioType = "DIAGNOSIS" | "MANAGEMENT" | "DIFFERENTIAL" | "COMPLICATIONS";
/**
 * Difficulty level (BASIC/INTERMEDIATE/ADVANCED)
 */
export type Difficulty = string;
/**
 * Patient's chief complaint
 */
export type ChiefComplaint = string;
/**
 * Clinical decision questions at key stages (stage, prompt, options, correctAnswer, reasoning)
 */
export type Questions = {
  [k: string]: unknown;
}[];
/**
 * Primary board exam topic tested
 */
export type BoardExamTopic = string;

/**
 * Response model for generated clinical case scenarios.
 */
export interface ScenarioGenerationResponse {
  scenario_id: ScenarioId;
  objective_id: ObjectiveId;
  scenario_type: ScenarioType;
  difficulty: Difficulty;
  case_text: CaseStructure;
  board_exam_topic: BoardExamTopic;
  [k: string]: unknown;
}
/**
 * Structured clinical case presentation
 */
export interface CaseStructure {
  chief_complaint: ChiefComplaint;
  demographics: Demographics;
  history: History;
  physical_exam: PhysicalExam;
  labs: Labs;
  questions: Questions;
  [k: string]: unknown;
}
/**
 * Age, sex, occupation, relevant social info
 */
export interface Demographics {
  [k: string]: unknown;
}
/**
 * HPI, PMH, medications, allergies, social history, family history
 */
export interface History {
  [k: string]: unknown;
}
/**
 * Vitals, general appearance, cardiovascular, respiratory, other systems
 */
export interface PhysicalExam {
  [k: string]: unknown;
}
/**
 * Available initial labs, imaging results, and options for additional workup
 */
export interface Labs {
  [k: string]: unknown;
}

export type Field = string;
/**
 * Validation error message
 */
export type Message = string;
/**
 * Invalid value that was provided
 */
export type Value = string;

/**
 * Validation error detail for request/response errors.
 */
export interface ValidationErrorDetail {
  field: Field;
  message: Message;
  value?: Value;
  [k: string]: unknown;
}

export type Id = string;
export type UserId = string;
export type ObjectiveId = string;
export type PromptId = string;
export type IsCorrect = boolean;
export type Score = number;
export type ConfidenceLevel = number | null;
export type RespondedAt = string;
export type ConceptName = string | null;
export type CourseName = string | null;
export type TopicTags = string[];
export type BoardExamTags = string[];

/**
 * Represents a controlled failure attempt (from ValidationResponse).
 *
 * This is a simplified view used for pattern detection.
 * In production, this would map to actual ValidationResponse records.
 */
export interface ControlledFailureRecord {
  id: Id;
  user_id: UserId;
  objective_id: ObjectiveId;
  prompt_id: PromptId;
  is_correct: IsCorrect;
  score: Score;
  confidence_level?: ConfidenceLevel;
  responded_at: RespondedAt;
  concept_name?: ConceptName;
  course_name?: CourseName;
  topic_tags?: TopicTags;
  board_exam_tags?: BoardExamTags;
  [k: string]: unknown;
}

export type Id = string | null;
export type UserId = string;
/**
 * Type: 'category', 'systematic_error', 'topic'
 */
export type PatternType = string;
/**
 * Human-readable pattern description
 */
export type PatternDescription = string;
/**
 * Objective IDs with this pattern
 */
export type AffectedObjectives = string[];
/**
 * Number of failures showing this pattern
 */
export type Frequency = number;
/**
 * Recommended remediation actions
 */
export type Remediation = string;
export type DetectedAt = string;

/**
 * Represents a detected failure pattern for a user.
 *
 * Attributes:
 *     id: Unique identifier (generated by database)
 *     user_id: User who has this pattern
 *     pattern_type: Type of pattern (category, systematic_error, etc.)
 *     pattern_description: Human-readable description
 *     affected_objectives: List of objective IDs showing this pattern
 *     frequency: How many times this pattern appeared
 *     remediation: Recommended resources or actions
 *     detected_at: When pattern was first detected
 */
export interface FailurePattern {
  id?: Id;
  user_id: UserId;
  pattern_type: PatternType;
  pattern_description: PatternDescription;
  affected_objectives?: AffectedObjectives;
  frequency: Frequency;
  remediation: Remediation;
  detected_at?: DetectedAt;
  [k: string]: unknown;
}

export type ActualStruggle = boolean;
/**
 * Feedback type enum matching Prisma schema
 */
export type FeedbackType = "HELPFUL" | "NOT_HELPFUL" | "INACCURATE" | "INTERVENTION_GOOD" | "INTERVENTION_BAD";
/**
 * Optional feedback comments
 */
export type Comments = string | null;

/**
 * Request body for POST /predictions/{id}/feedback
 *
 * Records user feedback on prediction accuracy.
 */
export interface FeedbackRequest {
  actual_struggle: ActualStruggle;
  feedback_type: FeedbackType;
  comments?: Comments;
  [k: string]: unknown;
}

export type FeedbackRecorded = boolean;
export type PredictionId = string;
export type FeedbackId = string;
/**
 * Updated model accuracy if calculated
 */
export type ModelAccuracyUpdate = number | null;
export type Message = string;
export type SubmittedAt = string;

/**
 * Response for feedback submission.
 */
export interface FeedbackResponse {
  feedback_recorded: FeedbackRecorded;
  prediction_id: PredictionId;
  feedback_id: FeedbackId;
  model_accuracy_update?: ModelAccuracyUpdate;
  message?: Message;
  submitted_at?: SubmittedAt;
  [k: string]: unknown;
}

export type MisconceptionExplained = string;
/**
 * Clarification of the correct concept with clinical context (3-4 sentences)
 */
export type CorrectConcept = string;
/**
 * Real-world clinical scenario or patient example demonstrating the concept (2-3 sentences)
 */
export type ClinicalContext = string;
/**
 * Memorable mnemonic, visual analogy, or patient story to aid retention (1-2 sentences)
 */
export type MemoryAnchor = string;
/**
 * Type of memory anchor created
 */
export type MemoryAnchorType = "mnemonic" | "visual_analogy" | "patient_story" | "clinical_pearl";

/**
 * Structured corrective feedback from ChatMock via instructor.
 *
 * This model enforces the rubric:
 * 1. Explain misconception
 * 2. Clarify correct concept
 * 3. Provide clinical context
 * 4. Create memorable anchor
 *
 * Used as response_model for instructor to ensure structured output.
 */
export interface StructuredFeedback {
  misconception_explained: MisconceptionExplained;
  correct_concept: CorrectConcept;
  clinical_context: ClinicalContext;
  memory_anchor: MemoryAnchor;
  memory_anchor_type: MemoryAnchorType;
  [k: string]: unknown;
}

export type UserId = string;
/**
 * Minimum frequency to consider a pattern
 */
export type MinFrequency = number;

/**
 * Request to detect failure patterns for a user.
 */
export interface PatternDetectionRequest {
  user_id: UserId;
  min_frequency?: MinFrequency;
  [k: string]: unknown;
}

export type Id = string | null;
export type UserId = string;
/**
 * Type: 'category', 'systematic_error', 'topic'
 */
export type PatternType = string;
/**
 * Human-readable pattern description
 */
export type PatternDescription = string;
/**
 * Objective IDs with this pattern
 */
export type AffectedObjectives = string[];
/**
 * Number of failures showing this pattern
 */
export type Frequency = number;
/**
 * Recommended remediation actions
 */
export type Remediation = string;
export type DetectedAt = string;
export type Patterns = FailurePattern[];
export type TotalPatterns = number;
export type DetectionTimestamp = string;

/**
 * Response containing detected failure patterns.
 */
export interface PatternDetectionResponse {
  patterns: Patterns;
  total_patterns: TotalPatterns;
  detection_timestamp?: DetectionTimestamp;
  [k: string]: unknown;
}
/**
 * Represents a detected failure pattern for a user.
 *
 * Attributes:
 *     id: Unique identifier (generated by database)
 *     user_id: User who has this pattern
 *     pattern_type: Type of pattern (category, systematic_error, etc.)
 *     pattern_description: Human-readable description
 *     affected_objectives: List of objective IDs showing this pattern
 *     frequency: How many times this pattern appeared
 *     remediation: Recommended resources or actions
 *     detected_at: When pattern was first detected
 */
export interface FailurePattern {
  id?: Id;
  user_id: UserId;
  pattern_type: PatternType;
  pattern_description: PatternDescription;
  affected_objectives?: AffectedObjectives;
  frequency: Frequency;
  remediation: Remediation;
  detected_at?: DetectedAt;
  [k: string]: unknown;
}

export type FailureId = string;
/**
 * Timestamp when failure occurred
 */
export type FailedAt = string;

/**
 * Request model for scheduling retries after a failure.
 *
 * Attributes:
 *     failure_id: ID of the failure record (challenge attempt)
 *     failed_at: When the failure occurred (defaults to now)
 */
export interface RetryScheduleRequest {
  failure_id: FailureId;
  failed_at?: FailedAt;
  [k: string]: unknown;
}

export type FailureId = string;
/**
 * Array of 5 retry dates: [+1d, +3d, +7d, +14d, +30d] from failure
 *
 * @minItems 5
 * @maxItems 5
 */
export type RetryDates = [string, string, string, string, string];
/**
 * Days between failure and each retry
 */
export type RetryIntervalsDays = number[];
/**
 * Explanation of the spaced repetition schedule
 */
export type Reasoning = string;
/**
 * How retry questions will vary to prevent memorization
 */
export type VariationStrategy = string;

/**
 * Response model with calculated retry dates.
 *
 * Returns the spaced repetition schedule: [+1, +3, +7, +14, +30 days].
 * Includes reasoning for transparency.
 */
export interface RetryScheduleResponse {
  failure_id: FailureId;
  retry_dates: RetryDates;
  retry_intervals_days?: RetryIntervalsDays;
  reasoning: Reasoning;
  variation_strategy: VariationStrategy;
  [k: string]: unknown;
}

export type QuestionsAsked = number;
/**
 * Baseline questions without adaptive (default 15)
 */
export type BaselineQuestions = number;
/**
 * Percentage of time saved vs baseline
 */
export type TimeSavedPercent = number;
/**
 * Overall efficiency score (0-100)
 */
export type EfficiencyScore = number;

/**
 * Assessment efficiency metrics.
 */
export interface EfficiencyMetrics {
  questions_asked: QuestionsAsked;
  baseline_questions?: BaselineQuestions;
  time_saved_percent: TimeSavedPercent;
  efficiency_score: EfficiencyScore;
  [k: string]: unknown;
}

export type QuestionId = string;
export type Correct = boolean;
/**
 * Item difficulty (beta, IRT scale -3 to +3)
 */
export type Difficulty = number;
/**
 * Item discrimination (alpha)
 */
export type Discrimination = number;
/**
 * Response history
 */
export type Responses = ResponseRecord[];
/**
 * Initial theta estimate
 */
export type InitialTheta = number;
/**
 * Maximum Newton-Raphson iterations
 */
export type MaxIterations = number;
/**
 * Convergence tolerance
 */
export type Tolerance = number;

/**
 * Input for IRT theta estimation.
 */
export interface IRTCalculationInput {
  responses: Responses;
  initial_theta?: InitialTheta;
  max_iterations?: MaxIterations;
  tolerance?: Tolerance;
  [k: string]: unknown;
}
/**
 * Individual response record for IRT calculation.
 */
export interface ResponseRecord {
  question_id: QuestionId;
  correct: Correct;
  difficulty: Difficulty;
  discrimination?: Discrimination;
  [k: string]: unknown;
}

export type QuestionId = string;
export type Correct = boolean;
/**
 * Item difficulty (beta, IRT scale -3 to +3)
 */
export type Difficulty = number;
/**
 * Item discrimination (alpha)
 */
export type Discrimination = number;

/**
 * Individual response record for IRT calculation.
 */
export interface ResponseRecord {
  question_id: QuestionId;
  correct: Correct;
  difficulty: Difficulty;
  discrimination?: Discrimination;
  [k: string]: unknown;
}

export type Theta = number;
/**
 * Standard error of theta estimate
 */
export type StandardError = number;
/**
 * 95% confidence interval width
 */
export type ConfidenceInterval = number;
/**
 * Number of IRT iterations performed
 */
export type Iterations = number;
/**
 * Whether IRT algorithm converged
 */
export type Converged = boolean;

/**
 * IRT algorithm metrics (knowledge estimate and convergence).
 */
export interface IRTMetrics {
  theta: Theta;
  standard_error: StandardError;
  confidence_interval: ConfidenceInterval;
  iterations: Iterations;
  converged: Converged;
  [k: string]: unknown;
}

export type SessionId = string;
/**
 * Learning objective being assessed
 */
export type ObjectiveId = string;
/**
 * ID of last question answered (if any)
 */
export type QuestionId = string | null;
/**
 * User's answer to last question
 */
export type UserAnswer = string | null;
/**
 * Current difficulty level (0-100)
 */
export type CurrentDifficulty = number;

/**
 * Request for next adaptive question.
 *
 * Includes session context and optionally the last response for difficulty adjustment.
 */
export interface NextQuestionRequest {
  session_id: SessionId;
  objective_id: ObjectiveId;
  question_id?: QuestionId;
  user_answer?: UserAnswer;
  current_difficulty?: CurrentDifficulty;
  [k: string]: unknown;
}

export type QuestionId = string;
/**
 * The actual question content
 */
export type QuestionText = string;
/**
 * Question difficulty (0-100)
 */
export type Difficulty = number;
/**
 * Item discrimination parameter (IRT)
 */
export type Discrimination = number;
/**
 * Whether this is a follow-up question
 */
export type IsFollowUp = boolean;
/**
 * Parent question ID if follow-up
 */
export type ParentQuestionId = string | null;
/**
 * Knowledge estimate (ability parameter)
 */
export type Theta = number;
/**
 * Standard error of theta estimate
 */
export type StandardError = number;
/**
 * 95% confidence interval width
 */
export type ConfidenceInterval = number;
/**
 * Number of IRT iterations performed
 */
export type Iterations = number;
/**
 * Whether IRT algorithm converged
 */
export type Converged = boolean;
/**
 * Number of questions asked so far
 */
export type QuestionsAsked = number;
/**
 * Baseline questions without adaptive (default 15)
 */
export type BaselineQuestions = number;
/**
 * Percentage of time saved vs baseline
 */
export type TimeSavedPercent = number;
/**
 * Overall efficiency score (0-100)
 */
export type EfficiencyScore = number;
/**
 * Recommendation to end assessment (early stop)
 */
export type ShouldEnd = boolean;
/**
 * Reason for difficulty adjustment
 */
export type AdjustmentReason = string | null;

/**
 * Response with next adaptive question.
 *
 * Includes the question, IRT metrics, efficiency metrics, and early stop flag.
 */
export interface NextQuestionResponse {
  question: QuestionData;
  irt_metrics: IRTMetrics;
  efficiency_metrics: EfficiencyMetrics;
  should_end: ShouldEnd;
  adjustment_reason?: AdjustmentReason;
  [k: string]: unknown;
}
/**
 * Next question to present
 */
export interface QuestionData {
  question_id: QuestionId;
  question_text: QuestionText;
  difficulty: Difficulty;
  discrimination: Discrimination;
  is_follow_up?: IsFollowUp;
  parent_question_id?: ParentQuestionId;
  [k: string]: unknown;
}
/**
 * IRT algorithm metrics
 */
export interface IRTMetrics {
  theta: Theta;
  standard_error: StandardError;
  confidence_interval: ConfidenceInterval;
  iterations: Iterations;
  converged: Converged;
  [k: string]: unknown;
}
/**
 * Assessment efficiency
 */
export interface EfficiencyMetrics {
  questions_asked: QuestionsAsked;
  baseline_questions?: BaselineQuestions;
  time_saved_percent: TimeSavedPercent;
  efficiency_score: EfficiencyScore;
  [k: string]: unknown;
}

export type QuestionId = string;
/**
 * The actual question content
 */
export type QuestionText = string;
/**
 * Question difficulty (0-100)
 */
export type Difficulty = number;
/**
 * Item discrimination parameter (IRT)
 */
export type Discrimination = number;
/**
 * Whether this is a follow-up question
 */
export type IsFollowUp = boolean;
/**
 * Parent question ID if follow-up
 */
export type ParentQuestionId = string | null;

/**
 * Generated or selected question data.
 */
export interface QuestionData {
  question_id: QuestionId;
  question_text: QuestionText;
  difficulty: Difficulty;
  discrimination: Discrimination;
  is_follow_up?: IsFollowUp;
  parent_question_id?: ParentQuestionId;
  [k: string]: unknown;
}

export type SessionId = string;
/**
 * Learning objective ID
 */
export type ObjectiveId = string;
/**
 * Knowledge estimate (ability parameter)
 */
export type Theta = number;
/**
 * Standard error of theta estimate
 */
export type StandardError = number;
/**
 * 95% confidence interval width
 */
export type ConfidenceInterval = number;
/**
 * Number of IRT iterations performed
 */
export type Iterations = number;
/**
 * Whether IRT algorithm converged
 */
export type Converged = boolean;
/**
 * Number of questions asked so far
 */
export type QuestionsAsked = number;
/**
 * Baseline questions without adaptive (default 15)
 */
export type BaselineQuestions = number;
/**
 * Percentage of time saved vs baseline
 */
export type TimeSavedPercent = number;
/**
 * Overall efficiency score (0-100)
 */
export type EfficiencyScore = number;
/**
 * Theta estimates over iterations
 */
export type ConvergenceHistory = number[];

/**
 * Session-level IRT and efficiency metrics.
 *
 * Provides overall assessment metrics for a session.
 */
export interface SessionMetricsResponse {
  session_id: SessionId;
  objective_id: ObjectiveId;
  irt_metrics: IRTMetrics;
  efficiency_metrics: EfficiencyMetrics;
  convergence_history: ConvergenceHistory;
  baseline_comparison: BaselineComparison;
  [k: string]: unknown;
}
/**
 * Final IRT metrics
 */
export interface IRTMetrics {
  theta: Theta;
  standard_error: StandardError;
  confidence_interval: ConfidenceInterval;
  iterations: Iterations;
  converged: Converged;
  [k: string]: unknown;
}
/**
 * Efficiency metrics
 */
export interface EfficiencyMetrics {
  questions_asked: QuestionsAsked;
  baseline_questions?: BaselineQuestions;
  time_saved_percent: TimeSavedPercent;
  efficiency_score: EfficiencyScore;
  [k: string]: unknown;
}
/**
 * Comparison to non-adaptive baseline
 */
export interface BaselineComparison {
  [k: string]: unknown;
}

export type Category = "strength" | "weakness" | "pattern" | "recommendation";
/**
 * What the AI observed in the data
 */
export type Observation = string;
/**
 * Recommended action for the learner
 */
export type Action = string;
/**
 * AI confidence in this insight
 */
export type Confidence = number;

/**
 * Structured AI-generated insight from ChatMock (GPT-5) via instructor.
 *
 * Format: category-observation-action
 */
export interface AIInsight {
  category: Category;
  observation: Observation;
  action: Action;
  confidence: Confidence;
  [k: string]: unknown;
}

export type UserId = string;
export type DateRange = ("7d" | "30d" | "90d" | "1y" | "all") | null;

/**
 * Base request model for analytics endpoints.
 */
export interface AnalyticsRequest {
  user_id: UserId;
  date_range?: DateRange;
  [k: string]: unknown;
}

export type ObjectiveId = string;
export type ObjectiveName = string;
/**
 * Difference between confidence and performance (positive = overconfident)
 */
export type CalibrationDelta = number;
export type Category = "overconfident" | "underconfident" | "dangerous_gap";
export type Description = string;

/**
 * Confidence calibration mismatch.
 */
export interface CalibrationIssue {
  objective_id: ObjectiveId;
  objective_name: ObjectiveName;
  calibration_delta: CalibrationDelta;
  category: Category;
  description: Description;
  [k: string]: unknown;
}

export type UserId = string;
export type DateRange = ("7d" | "30d" | "90d" | "1y" | "all") | null;

/**
 * Request for memorization vs understanding comparison.
 */
export interface ComparisonRequest {
  user_id: UserId;
  date_range?: DateRange;
  [k: string]: unknown;
}

export type UserId = string;
/**
 * Time series: [{date, score}]
 */
export type MemorizationTrend = {
  [k: string]: unknown;
}[];
/**
 * Time series: [{date, score}]
 */
export type UnderstandingTrend = {
  [k: string]: unknown;
}[];
export type ObjectiveId = string;
export type ObjectiveName = string;
/**
 * Flashcard avg score
 */
export type MemorizationScore = number;
/**
 * Validation avg score
 */
export type UnderstandingScore = number;
/**
 * memorization - understanding (positive = illusion of knowledge)
 */
export type Gap = number;
/**
 * high: gap > 30, medium: gap > 20, low: gap <= 20
 */
export type Severity = "high" | "medium" | "low";
/**
 * Objectives with memorization-understanding gap
 */
export type Gaps = MemorizationVsUnderstandingGap[];
/**
 * Pearson correlation between memorization and understanding
 */
export type CorrelationCoefficient = number;
export type GeneratedAt = string;

/**
 * Understanding vs memorization comparison.
 *
 * Compares:
 * - Memorization proxy: Flashcard review performance (spaced repetition scores)
 * - Understanding measure: Validation assessment scores (comprehension, reasoning)
 *
 * Identifies "Illusion of Knowledge" where flashcard performance is high but understanding is low.
 */
export interface ComparisonResponse {
  user_id: UserId;
  memorization_trend: MemorizationTrend;
  understanding_trend: UnderstandingTrend;
  gaps: Gaps;
  correlation_coefficient: CorrelationCoefficient;
  generated_at?: GeneratedAt;
  [k: string]: unknown;
}
/**
 * Objective showing gap between memorization and understanding.
 */
export interface MemorizationVsUnderstandingGap {
  objective_id: ObjectiveId;
  objective_name: ObjectiveName;
  memorization_score: MemorizationScore;
  understanding_score: UnderstandingScore;
  gap: Gap;
  severity: Severity;
  [k: string]: unknown;
}

export type ObjectiveId = string;
export type ObjectiveName = string;
/**
 * Flashcard avg score
 */
export type MemorizationScore = number;
/**
 * Validation avg score
 */
export type UnderstandingScore = number;
/**
 * memorization - understanding (positive = illusion of knowledge)
 */
export type Gap = number;
/**
 * high: gap > 30, medium: gap > 20, low: gap <= 20
 */
export type Severity = "high" | "medium" | "low";

/**
 * Objective showing gap between memorization and understanding.
 */
export interface MemorizationVsUnderstandingGap {
  objective_id: ObjectiveId;
  objective_name: ObjectiveName;
  memorization_score: MemorizationScore;
  understanding_score: UnderstandingScore;
  gap: Gap;
  severity: Severity;
  [k: string]: unknown;
}

export type UserPercentile = number;
export type UserScore = number;
export type PeerAverage = number;
export type PeerStdDev = number;
/**
 * Dimension name: terminology, relationships, application, clarity
 */
export type Dimension = string;
export type UserScore1 = number;
export type PeerAverage1 = number;
/**
 * User's percentile rank for this dimension (scipy percentileofscore)
 */
export type Percentile = number;
/**
 * Per-dimension breakdown: terminology, relationships, application, clarity
 */
export type DimensionComparisons = DimensionComparison[];
/**
 * Dimensions where user_score > peer_average
 */
export type StrengthsVsPeers = string[];
/**
 * Dimensions where user_score < peer_avg - 0.5*std_dev
 */
export type GapsVsPeers = string[];
/**
 * Number of users in peer group
 */
export type PeerGroupSize = number;
export type GeneratedAt = string;

/**
 * Comparison analytics result comparing user performance with peer group.
 *
 * Uses scipy.stats.percentileofscore for percentile calculations.
 * Minimum 50 users required for valid peer comparison.
 */
export interface ComparisonResult {
  user_percentile: UserPercentile;
  user_score: UserScore;
  peer_average: PeerAverage;
  peer_std_dev: PeerStdDev;
  dimension_comparisons: DimensionComparisons;
  strengths_vs_peers: StrengthsVsPeers;
  gaps_vs_peers: GapsVsPeers;
  peer_group_size: PeerGroupSize;
  generated_at?: GeneratedAt;
  [k: string]: unknown;
}
/**
 * Per-dimension comparison between user and peers.
 *
 * Dimensions: terminology, relationships, application, clarity
 */
export interface DimensionComparison {
  dimension: Dimension;
  user_score: UserScore1;
  peer_average: PeerAverage1;
  percentile: Percentile;
  [k: string]: unknown;
}

export type Dimension = string;
export type UserScore = number;
export type PeerAverage = number;
/**
 * User's percentile rank for this dimension (scipy percentileofscore)
 */
export type Percentile = number;

/**
 * Per-dimension comparison between user and peers.
 *
 * Dimensions: terminology, relationships, application, clarity
 */
export interface DimensionComparison {
  dimension: Dimension;
  user_score: UserScore;
  peer_average: PeerAverage;
  percentile: Percentile;
  [k: string]: unknown;
}

export type UserId = string;
export type ObjectiveId = string;
export type ObjectiveName = string;
export type Score = number;
export type PercentileRank = number;
export type Strengths = ObjectiveStrength[];
export type ObjectiveId1 = string;
export type ObjectiveName1 = string;
export type Score1 = number;
export type PercentileRank1 = number;
export type Weaknesses = ObjectiveWeakness[];
export type ObjectiveId2 = string;
export type ObjectiveName2 = string;
/**
 * Difference between confidence and performance (positive = overconfident)
 */
export type CalibrationDelta = number;
export type Category = "overconfident" | "underconfident" | "dangerous_gap";
export type Description = string;
export type CalibrationIssues = CalibrationIssue[];
/**
 * 3-5 AI-generated insights from ChatMock
 *
 * @minItems 3
 * @maxItems 5
 */
export type AiInsights =
  | [AIInsight, AIInsight, AIInsight]
  | [AIInsight, AIInsight, AIInsight, AIInsight]
  | [AIInsight, AIInsight, AIInsight, AIInsight, AIInsight];
export type Category1 = "strength" | "weakness" | "pattern" | "recommendation";
/**
 * What the AI observed in the data
 */
export type Observation = string;
/**
 * Recommended action for the learner
 */
export type Action = string;
/**
 * AI confidence in this insight
 */
export type Confidence = number;
/**
 * @minItems 2
 * @maxItems 2
 */
export type AnalysisDateRange = [unknown, unknown];
export type GeneratedAt = string;

/**
 * Comprehensive analysis of user's comprehension patterns.
 */
export interface ComprehensionPattern {
  user_id: UserId;
  strengths: Strengths;
  weaknesses: Weaknesses;
  calibration_issues: CalibrationIssues;
  ai_insights: AiInsights;
  analysis_date_range: AnalysisDateRange;
  generated_at?: GeneratedAt;
  [k: string]: unknown;
}
/**
 * Top performing objective (top 10% percentile).
 */
export interface ObjectiveStrength {
  objective_id: ObjectiveId;
  objective_name: ObjectiveName;
  score: Score;
  percentile_rank: PercentileRank;
  [k: string]: unknown;
}
/**
 * Underperforming objective (bottom 10% percentile).
 */
export interface ObjectiveWeakness {
  objective_id: ObjectiveId1;
  objective_name: ObjectiveName1;
  score: Score1;
  percentile_rank: PercentileRank1;
  [k: string]: unknown;
}
/**
 * Confidence calibration mismatch.
 */
export interface CalibrationIssue {
  objective_id: ObjectiveId2;
  objective_name: ObjectiveName2;
  calibration_delta: CalibrationDelta;
  category: Category;
  description: Description;
  [k: string]: unknown;
}
/**
 * Structured AI-generated insight from ChatMock (GPT-5) via instructor.
 *
 * Format: category-observation-action
 */
export interface AIInsight {
  category: Category1;
  observation: Observation;
  action: Action;
  confidence: Confidence;
  [k: string]: unknown;
}

export type ObjectiveId = string;
export type ObjectiveName = string;
export type Score = number;
export type PercentileRank = number;

/**
 * Top performing objective (top 10% percentile).
 */
export interface ObjectiveStrength {
  objective_id: ObjectiveId;
  objective_name: ObjectiveName;
  score: Score;
  percentile_rank: PercentileRank;
  [k: string]: unknown;
}

export type ObjectiveId = string;
export type ObjectiveName = string;
export type Score = number;
export type PercentileRank = number;

/**
 * Underperforming objective (bottom 10% percentile).
 */
export interface ObjectiveWeakness {
  objective_id: ObjectiveId;
  objective_name: ObjectiveName;
  score: Score;
  percentile_rank: PercentileRank;
  [k: string]: unknown;
}

export type UserId = string;
/**
 * NxN correlation matrix where N = number of objectives
 */
export type Matrix = number[][];
/**
 * Ordered list of objective IDs corresponding to matrix indices
 */
export type ObjectiveIds = string[];
export type ObjectiveNames = string[];
/**
 * High positive correlation (>0.5) with many others
 */
export type FoundationalObjectives = {
  [k: string]: unknown;
}[];
/**
 * Low score + negative correlation pattern
 */
export type BottleneckObjectives = {
  [k: string]: unknown;
}[];
/**
 * Ordered list of objective IDs prioritizing foundational objectives
 */
export type RecommendedStudySequence = string[];
export type GeneratedAt = string;

/**
 * Pearson correlation coefficient matrix for all objectives.
 *
 * Matrix format: [[objective_pairs], [correlation_values]]
 */
export interface CorrelationMatrix {
  user_id: UserId;
  matrix: Matrix;
  objective_ids: ObjectiveIds;
  objective_names: ObjectiveNames;
  foundational_objectives: FoundationalObjectives;
  bottleneck_objectives: BottleneckObjectives;
  recommended_study_sequence: RecommendedStudySequence;
  generated_at?: GeneratedAt;
  [k: string]: unknown;
}

export type UserId = string;

/**
 * Request for cross-objective correlations.
 */
export interface CorrelationsRequest {
  user_id: UserId;
  [k: string]: unknown;
}

export type UserId = string;
export type PriorityObjectiveId = string;
export type PriorityObjectiveName = string;
export type InsightCategory = "dangerous_gap" | "bottleneck" | "weakness" | "optimization";
export type Title = string;
export type Description = string;
/**
 * 2-4 specific action items
 *
 * @minItems 2
 * @maxItems 4
 */
export type ActionItems = [string, string] | [string, string, string] | [string, string, string, string];
export type EstimatedTimeMinutes = number;
export type GeneratedAt = string;

/**
 * Single daily recommendation (highest priority).
 *
 * Priority scoring:
 * 1. Dangerous gaps (overconfidence + low score)
 * 2. Bottleneck objectives (blocking others)
 * 3. Weaknesses (bottom 10%)
 * 4. Optimization opportunities
 */
export interface DailyInsight {
  user_id: UserId;
  priority_objective_id: PriorityObjectiveId;
  priority_objective_name: PriorityObjectiveName;
  insight_category: InsightCategory;
  title: Title;
  description: Description;
  action_items: ActionItems;
  estimated_time_minutes: EstimatedTimeMinutes;
  generated_at?: GeneratedAt;
  [k: string]: unknown;
}

export type CurrentScore = number;
/**
 * Trend direction
 */
export type Trend = "up" | "down" | "stable";
/**
 * Last 7 data points for mini chart
 */
export type Sparkline = number[];
/**
 * % change from previous period
 */
export type ChangePercentage = number | null;

/**
 * Summary of a single validation metric for dashboard display.
 */
export interface DashboardMetricSummary {
  current_score: CurrentScore;
  trend: Trend;
  sparkline: Sparkline;
  change_percentage?: ChangePercentage;
  [k: string]: unknown;
}

export type UserId = string;
export type DateRange = ("7d" | "30d" | "90d" | "1y" | "all") | null;
/**
 * Filter by course
 */
export type CourseId = string | null;
/**
 * Filter by topic tag
 */
export type Topic = string | null;

/**
 * Request for dashboard overview.
 */
export interface DashboardRequest {
  user_id: UserId;
  date_range?: DateRange;
  course_id?: CourseId;
  topic?: Topic;
  [k: string]: unknown;
}

export type UserId = string;
/**
 * Current average score
 */
export type CurrentScore = number;
/**
 * Trend direction
 */
export type Trend = "up" | "down" | "stable";
/**
 * Last 7 data points for mini chart
 */
export type Sparkline = number[];
/**
 * % change from previous period
 */
export type ChangePercentage = number | null;
/**
 * Number of objectives at mastery level (>=80%)
 */
export type Count = number;
/**
 * Total number of objectives
 */
export type Total = number;
/**
 * Mastery percentage
 */
export type Percentage = number;
export type GeneratedAt = string;

/**
 * Dashboard overview with 6 metric summaries.
 *
 * Aggregates data from:
 * - Story 4.1: Comprehension (validation prompts)
 * - Story 4.2: Clinical reasoning (scenario performance)
 * - Story 4.3: Controlled failure (challenge learning effectiveness)
 * - Story 4.4: Calibration accuracy (confidence vs performance)
 * - Story 4.5: Adaptive efficiency (IRT difficulty matching)
 * - Mastery verification (objectives at >=80%)
 */
export interface DashboardResponse {
  user_id: UserId;
  comprehension: DashboardMetricSummary;
  reasoning: DashboardMetricSummary;
  failure: DashboardMetricSummary;
  calibration: DashboardMetricSummary;
  adaptive: DashboardMetricSummary;
  mastery: MasterySummary;
  generated_at?: GeneratedAt;
  [k: string]: unknown;
}
/**
 * Summary of a single validation metric for dashboard display.
 */
export interface DashboardMetricSummary {
  current_score: CurrentScore;
  trend: Trend;
  sparkline: Sparkline;
  change_percentage?: ChangePercentage;
  [k: string]: unknown;
}
/**
 * Mastery status summary for dashboard.
 */
export interface MasterySummary {
  count: Count;
  total: Total;
  percentage: Percentage;
  [k: string]: unknown;
}

export type Count = number;
/**
 * Total number of objectives
 */
export type Total = number;
/**
 * Mastery percentage
 */
export type Percentage = number;

/**
 * Mastery status summary for dashboard.
 */
export interface MasterySummary {
  count: Count;
  total: Total;
  percentage: Percentage;
  [k: string]: unknown;
}

export type OverallScore = number;
/**
 * Total learning sessions completed
 */
export type TotalSessions = number;
/**
 * Total validation questions answered
 */
export type TotalQuestions = number;
export type Date = string;
export type Score = number;
/**
 * Last 7 days of overall scores
 */
export type RecentTrends = TrendPoint[];
/**
 * Overall confidence calibration assessment
 */
export type CalibrationStatus = "well-calibrated" | "overconfident" | "underconfident";
/**
 * Top 3 areas of strength (objective names)
 *
 * @minItems 0
 * @maxItems 3
 */
export type TopStrengths = [] | [string] | [string, string] | [string, string, string];
/**
 * Top 3 areas needing improvement (objective names)
 *
 * @minItems 0
 * @maxItems 3
 */
export type ImprovementAreas = [] | [string] | [string, string] | [string, string, string];
export type GeneratedAt = string;

/**
 * Comprehensive dashboard summary aggregating all Epic 4 validation metrics.
 *
 * Provides high-level overview with:
 * - Overall understanding score (weighted average)
 * - Total sessions and questions completed
 * - Mastery level breakdown (beginner, proficient, expert)
 * - Recent performance trends (last 7 days)
 * - Calibration status assessment
 * - Top strengths and improvement areas
 */
export interface DashboardSummary {
  overall_score: OverallScore;
  total_sessions: TotalSessions;
  total_questions: TotalQuestions;
  mastery_breakdown: MasteryBreakdown;
  recent_trends: RecentTrends;
  calibration_status: CalibrationStatus;
  top_strengths: TopStrengths;
  improvement_areas: ImprovementAreas;
  generated_at?: GeneratedAt;
  [k: string]: unknown;
}
/**
 * Count by level: {'beginner': N, 'proficient': N, 'expert': N}
 */
export interface MasteryBreakdown {
  [k: string]: number;
}
/**
 * Single data point in trend time series.
 */
export interface TrendPoint {
  date: Date;
  score: Score;
  [k: string]: unknown;
}

export type Date = string;
export type Score = number;

/**
 * Single data point in trend time series.
 */
export interface TrendPoint {
  date: Date;
  score: Score;
  [k: string]: unknown;
}

export type Probability = number;
/**
 * 95% confidence interval for prediction
 *
 * @minItems 2
 * @maxItems 2
 */
export type ConfidenceInterval = [unknown, unknown];
/**
 * AI-generated recommendation based on prediction
 */
export type Recommendation = string;

/**
 * Prediction of exam success probability using logistic regression.
 *
 * Features: comprehension (30%), reasoning (35%), mastery (20%), calibration (15%)
 */
export interface ExamSuccessPrediction {
  probability: Probability;
  confidence_interval: ConfidenceInterval;
  contributing_factors: ContributingFactors;
  recommendation: Recommendation;
  [k: string]: unknown;
}
/**
 * Feature contributions: {comprehension, reasoning, mastery, calibration}
 */
export interface ContributingFactors {
  [k: string]: number;
}

export type ObjectiveId = string;
export type ObjectiveName = string;
/**
 * Probability of retaining knowledge (0-1 scale)
 */
export type RetentionProbability = number;
export type DaysSinceReview = number;
/**
 * Knowledge strength based on mastery and review frequency
 */
export type StrengthScore = number;
/**
 * Categorized forgetting risk
 */
export type RiskLevel = "low" | "moderate" | "high" | "critical";
export type RecommendedReviewDate = string;

/**
 * Forgetting risk calculation using Ebbinghaus forgetting curve: R = e^(-t/S).
 *
 * Where:
 * - R = retention probability
 * - t = days since last review
 * - S = strength (based on mastery level and review history)
 */
export interface ForgettingRiskPrediction {
  objective_id: ObjectiveId;
  objective_name: ObjectiveName;
  retention_probability: RetentionProbability;
  days_since_review: DaysSinceReview;
  strength_score: StrengthScore;
  risk_level: RiskLevel;
  recommended_review_date: RecommendedReviewDate;
  [k: string]: unknown;
}

export type ObjectiveId = string;
export type ObjectiveName = string;
/**
 * Weekly improvement rate
 */
export type Slope = number;
export type Intercept = number;
export type RSquared = number;
export type PredictedDaysToMastery = number | null;

/**
 * Linear regression prediction of growth.
 */
export interface GrowthTrajectory {
  objective_id: ObjectiveId;
  objective_name: ObjectiveName;
  slope: Slope;
  intercept: Intercept;
  r_squared: RSquared;
  predicted_days_to_mastery?: PredictedDaysToMastery;
  [k: string]: unknown;
}

export type Period = "week" | "month";
/**
 * Percentage point improvement per period
 */
export type Rate = number;
export type Trend = "accelerating" | "stable" | "decelerating";

/**
 * Calculated improvement rates.
 */
export interface ImprovementRate {
  period: Period;
  rate: Rate;
  trend: Trend;
  [k: string]: unknown;
}

export type PatternDetected =
  | "overconfidence"
  | "weak_reasoning"
  | "poor_retention"
  | "bottleneck_detected"
  | "regression_detected";
export type InterventionType =
  | "more_failure_challenges"
  | "clinical_scenarios"
  | "spaced_repetition"
  | "foundational_review"
  | "immediate_review";
export type Description = string;
export type Priority = "high" | "medium" | "low";
export type EstimatedTimeHours = number;

/**
 * Personalized intervention based on detected patterns.
 */
export interface InterventionSuggestion {
  pattern_detected: PatternDetected;
  intervention_type: InterventionType;
  description: Description;
  priority: Priority;
  estimated_time_hours: EstimatedTimeHours;
  [k: string]: unknown;
}

export type UserId = string;
/**
 * Time series data: [{timestamp, score, confidence, ...}]
 */
export type Metrics = {
  [k: string]: number;
}[];
export type ObjectiveId = string;
export type ObjectiveName = string;
export type MilestoneType = "mastery_verified" | "major_improvement" | "streak_achieved";
export type DateAchieved = string;
export type Description = string;
export type ScoreBefore = number | null;
export type ScoreAfter = number | null;
export type Milestones = Milestone[];
export type ObjectiveId1 = string;
export type ObjectiveName1 = string;
export type ScoreBefore1 = number;
export type ScoreAfter1 = number;
/**
 * Percentage point decline
 */
export type DeclineAmount = number;
export type DateDetected = string;
export type PossibleCauses = string[];
export type Regressions = Regression[];
export type ObjectiveId2 = string;
export type ObjectiveName2 = string;
/**
 * Weekly improvement rate
 */
export type Slope = number;
export type Intercept = number;
export type RSquared = number;
export type PredictedDaysToMastery = number | null;
export type GrowthTrajectory = GrowthTrajectory1[];
export type Period = "week" | "month";
/**
 * Percentage point improvement per period
 */
export type Rate = number;
export type Trend = "accelerating" | "stable" | "decelerating";
/**
 * @minItems 2
 * @maxItems 2
 */
export type DateRange = [unknown, unknown];
export type GeneratedAt = string;

/**
 * Historical progress tracking over time.
 */
export interface LongitudinalMetric {
  user_id: UserId;
  metrics: Metrics;
  milestones: Milestones;
  regressions: Regressions;
  growth_trajectory: GrowthTrajectory;
  improvement_rates: ImprovementRates;
  date_range: DateRange;
  generated_at?: GeneratedAt;
  [k: string]: unknown;
}
/**
 * Significant achievement in learning journey.
 */
export interface Milestone {
  objective_id: ObjectiveId;
  objective_name: ObjectiveName;
  milestone_type: MilestoneType;
  date_achieved: DateAchieved;
  description: Description;
  score_before?: ScoreBefore;
  score_after?: ScoreAfter;
  [k: string]: unknown;
}
/**
 * Performance decline in previously mastered topic.
 */
export interface Regression {
  objective_id: ObjectiveId1;
  objective_name: ObjectiveName1;
  score_before: ScoreBefore1;
  score_after: ScoreAfter1;
  decline_amount: DeclineAmount;
  date_detected: DateDetected;
  possible_causes: PossibleCauses;
  [k: string]: unknown;
}
/**
 * Linear regression prediction of growth.
 */
export interface GrowthTrajectory1 {
  objective_id: ObjectiveId2;
  objective_name: ObjectiveName2;
  slope: Slope;
  intercept: Intercept;
  r_squared: RSquared;
  predicted_days_to_mastery?: PredictedDaysToMastery;
  [k: string]: unknown;
}
/**
 * Rates by period: {week: ImprovementRate, month: ImprovementRate}
 */
export interface ImprovementRates {
  [k: string]: ImprovementRate;
}
/**
 * Calculated improvement rates.
 */
export interface ImprovementRate {
  period: Period;
  rate: Rate;
  trend: Trend;
  [k: string]: unknown;
}

export type ObjectiveId = string;
export type ObjectiveName = string;
export type MilestoneType = "mastery_verified" | "major_improvement" | "streak_achieved";
export type DateAchieved = string;
export type Description = string;
export type ScoreBefore = number | null;
export type ScoreAfter = number | null;

/**
 * Significant achievement in learning journey.
 */
export interface Milestone {
  objective_id: ObjectiveId;
  objective_name: ObjectiveName;
  milestone_type: MilestoneType;
  date_achieved: DateAchieved;
  description: Description;
  score_before?: ScoreBefore;
  score_after?: ScoreAfter;
  [k: string]: unknown;
}

export type ObjectiveId = string;
export type ObjectiveName = string;
export type ScoreBefore = number;
export type ScoreAfter = number;
/**
 * Percentage point decline
 */
export type DeclineAmount = number;
export type DateDetected = string;
export type PossibleCauses = string[];

/**
 * Performance decline in previously mastered topic.
 */
export interface Regression {
  objective_id: ObjectiveId;
  objective_name: ObjectiveName;
  score_before: ScoreBefore;
  score_after: ScoreAfter;
  decline_amount: DeclineAmount;
  date_detected: DateDetected;
  possible_causes: PossibleCauses;
  [k: string]: unknown;
}

export type UserId = string;
export type DateRange = ("7d" | "30d" | "90d" | "1y" | "all") | null;
export type Dimensions = ("comprehension" | "reasoning" | "calibration" | "mastery")[];

/**
 * Request for historical progress tracking.
 */
export interface LongitudinalRequest {
  user_id: UserId;
  date_range?: DateRange;
  dimensions?: Dimensions;
  [k: string]: unknown;
}

export type ObjectiveId = string;
export type ObjectiveName = string;
export type CurrentScore = number;
/**
 * Predicted date to reach 80% threshold (None if already mastered or insufficient data)
 */
export type PredictedMasteryDate = string | null;
/**
 * Estimated days until mastery
 */
export type DaysToMastery = number | null;
/**
 * Average weekly improvement in percentage points
 */
export type WeeklyImprovementRate = number;
/**
 * Prediction confidence based on data points and consistency
 */
export type Confidence = "high" | "moderate" | "low";

/**
 * Predicted date to reach 80% mastery using linear regression extrapolation.
 */
export interface MasteryDatePrediction {
  objective_id: ObjectiveId;
  objective_name: ObjectiveName;
  current_score: CurrentScore;
  predicted_mastery_date?: PredictedMasteryDate;
  days_to_mastery?: DaysToMastery;
  weekly_improvement_rate: WeeklyImprovementRate;
  confidence: Confidence;
  [k: string]: unknown;
}

export type MetricName = string;
export type MeanAbsoluteError = number;
/**
 * RÂ² score
 */
export type RSquared = number;
export type SampleSize = number;
export type LastUpdated = string;

/**
 * Model performance metrics for prediction accuracy tracking.
 */
export interface ModelAccuracy {
  metric_name: MetricName;
  mean_absolute_error: MeanAbsoluteError;
  r_squared: RSquared;
  sample_size: SampleSize;
  last_updated: LastUpdated;
  [k: string]: unknown;
}

export type UserId = string;
export type DateRange = ("7d" | "30d" | "90d" | "1y" | "all") | null;

/**
 * Request for comprehension patterns analysis.
 */
export interface PatternsRequest {
  user_id: UserId;
  date_range?: DateRange;
  [k: string]: unknown;
}

export type UserId = string;
/**
 * Specific objective ID or None for overall comparison
 */
export type ObjectiveId = string | null;
export type Mean = number;
export type Median = number;
export type StdDev = number;
/**
 * First quartile (p25)
 */
export type Q1 = number;
/**
 * Second quartile (p50, median)
 */
export type Q2 = number;
/**
 * Third quartile (p75)
 */
export type Q3 = number;
/**
 * Interquartile range (q3 - q1)
 */
export type Iqr = number;
/**
 * Lower whisker: q1 - 1.5*iqr
 */
export type WhiskerLow = number;
/**
 * Upper whisker: q3 + 1.5*iqr
 */
export type WhiskerHigh = number;
/**
 * Minimum 50 users for validity
 */
export type SampleSize = number;
/**
 * Timestamp of last calculation
 */
export type LastCalculated = string;
export type UserPercentile = number;
export type ObjectiveId1 = string;
export type ObjectiveName = string;
export type UserScore = number;
export type UserPercentile1 = number;
export type Category = "top_quartile" | "above_average" | "below_average" | "bottom_quartile";
/**
 * Objectives where user is in top 25%
 */
export type RelativeStrengths = RelativePerformance[];
/**
 * Objectives where user is in bottom 25%
 */
export type RelativeWeaknesses = RelativePerformance[];
export type GeneratedAt = string;

/**
 * Peer comparison data (anonymized, minimum 50 users).
 */
export interface PeerBenchmark {
  user_id: UserId;
  objective_id?: ObjectiveId;
  peer_distribution: PeerDistribution;
  user_percentile: UserPercentile;
  relative_strengths: RelativeStrengths;
  relative_weaknesses: RelativeWeaknesses;
  generated_at?: GeneratedAt;
  [k: string]: unknown;
}
/**
 * Statistical distribution of peer performance for box plot visualization.
 *
 * Includes quartiles, IQR, and whiskers for outlier detection.
 */
export interface PeerDistribution {
  mean: Mean;
  median: Median;
  std_dev: StdDev;
  quartiles: Quartiles;
  q1: Q1;
  q2: Q2;
  q3: Q3;
  iqr: Iqr;
  whisker_low: WhiskerLow;
  whisker_high: WhiskerHigh;
  sample_size: SampleSize;
  last_calculated?: LastCalculated;
  [k: string]: unknown;
}
/**
 * {p25, p50, p75} percentile values
 */
export interface Quartiles {
  [k: string]: number;
}
/**
 * User's position relative to peers.
 */
export interface RelativePerformance {
  objective_id: ObjectiveId1;
  objective_name: ObjectiveName;
  user_score: UserScore;
  user_percentile: UserPercentile1;
  category: Category;
  [k: string]: unknown;
}

export type Mean = number;
export type Median = number;
export type StdDev = number;
/**
 * First quartile (p25)
 */
export type Q1 = number;
/**
 * Second quartile (p50, median)
 */
export type Q2 = number;
/**
 * Third quartile (p75)
 */
export type Q3 = number;
/**
 * Interquartile range (q3 - q1)
 */
export type Iqr = number;
/**
 * Lower whisker: q1 - 1.5*iqr
 */
export type WhiskerLow = number;
/**
 * Upper whisker: q3 + 1.5*iqr
 */
export type WhiskerHigh = number;
/**
 * Minimum 50 users for validity
 */
export type SampleSize = number;
/**
 * Timestamp of last calculation
 */
export type LastCalculated = string;

/**
 * Statistical distribution of peer performance for box plot visualization.
 *
 * Includes quartiles, IQR, and whiskers for outlier detection.
 */
export interface PeerDistribution {
  mean: Mean;
  median: Median;
  std_dev: StdDev;
  quartiles: Quartiles;
  q1: Q1;
  q2: Q2;
  q3: Q3;
  iqr: Iqr;
  whisker_low: WhiskerLow;
  whisker_high: WhiskerHigh;
  sample_size: SampleSize;
  last_calculated?: LastCalculated;
  [k: string]: unknown;
}
/**
 * {p25, p50, p75} percentile values
 */
export interface Quartiles {
  [k: string]: number;
}

export type ObjectiveId = string;
export type ObjectiveName = string;
export type UserScore = number;
export type UserPercentile = number;
export type Category = "top_quartile" | "above_average" | "below_average" | "bottom_quartile";

/**
 * User's position relative to peers.
 */
export interface RelativePerformance {
  objective_id: ObjectiveId;
  objective_name: ObjectiveName;
  user_score: UserScore;
  user_percentile: UserPercentile;
  category: Category;
  [k: string]: unknown;
}

export type UserId = string;
export type ObjectiveId = string | null;

/**
 * Request for peer comparison.
 */
export interface PeerBenchmarkRequest {
  user_id: UserId;
  objective_id?: ObjectiveId;
  [k: string]: unknown;
}

export type UserId = string;
export type DateRange = ("7d" | "30d" | "90d" | "1y" | "all") | null;
/**
 * Specific exam to predict for
 */
export type ExamType = string | null;

/**
 * Request for predictive analytics.
 */
export interface PredictionsRequest {
  user_id: UserId;
  date_range?: DateRange;
  exam_type?: ExamType;
  [k: string]: unknown;
}

export type UserId = string;
export type UserId1 = string;
export type PriorityObjectiveId = string;
export type PriorityObjectiveName = string;
export type InsightCategory = "dangerous_gap" | "bottleneck" | "weakness" | "optimization";
export type Title = string;
export type Description = string;
/**
 * 2-4 specific action items
 *
 * @minItems 2
 * @maxItems 4
 */
export type ActionItems = [string, string] | [string, string, string] | [string, string, string, string];
export type EstimatedTimeMinutes = number;
export type GeneratedAt = string;
/**
 * Exactly 3 top objectives for the week
 *
 * @minItems 3
 * @maxItems 3
 */
export type WeeklyTop3 = [WeeklyTopObjective, WeeklyTopObjective, WeeklyTopObjective];
export type ObjectiveId = string;
export type ObjectiveName = string;
/**
 * ChatMock-generated rationale for prioritizing this objective
 */
export type Rationale = string;
export type EstimatedHours = number;
export type PatternDetected =
  | "overconfidence"
  | "weak_reasoning"
  | "poor_retention"
  | "bottleneck_detected"
  | "regression_detected";
export type InterventionType =
  | "more_failure_challenges"
  | "clinical_scenarios"
  | "spaced_repetition"
  | "foundational_review"
  | "immediate_review";
export type Description1 = string;
export type Priority = "high" | "medium" | "low";
export type EstimatedTimeHours = number;
export type Interventions = InterventionSuggestion[];
export type ObjectiveId1 = string;
export type ObjectiveName1 = string;
export type CurrentScore = number;
/**
 * Estimated study hours to reach 80% threshold
 */
export type HoursToMastery = number;
export type WeeksToMastery = number;
export type TimeEstimates = TimeToMasteryEstimate[];
export type ExamSuccessProbability = number;
export type GeneratedAt1 = string;

/**
 * Comprehensive personalized recommendations.
 *
 * Uses ChatMock (GPT-5) via instructor for AI-generated text.
 */
export interface RecommendationData {
  user_id: UserId;
  daily_insight: DailyInsight;
  weekly_top3: WeeklyTop3;
  interventions: Interventions;
  time_estimates: TimeEstimates;
  exam_success_probability: ExamSuccessProbability;
  generated_at?: GeneratedAt1;
  [k: string]: unknown;
}
/**
 * Single daily recommendation (highest priority).
 *
 * Priority scoring:
 * 1. Dangerous gaps (overconfidence + low score)
 * 2. Bottleneck objectives (blocking others)
 * 3. Weaknesses (bottom 10%)
 * 4. Optimization opportunities
 */
export interface DailyInsight {
  user_id: UserId1;
  priority_objective_id: PriorityObjectiveId;
  priority_objective_name: PriorityObjectiveName;
  insight_category: InsightCategory;
  title: Title;
  description: Description;
  action_items: ActionItems;
  estimated_time_minutes: EstimatedTimeMinutes;
  generated_at?: GeneratedAt;
  [k: string]: unknown;
}
/**
 * One of top 3 objectives to focus on this week.
 */
export interface WeeklyTopObjective {
  objective_id: ObjectiveId;
  objective_name: ObjectiveName;
  rationale: Rationale;
  estimated_hours: EstimatedHours;
  [k: string]: unknown;
}
/**
 * Personalized intervention based on detected patterns.
 */
export interface InterventionSuggestion {
  pattern_detected: PatternDetected;
  intervention_type: InterventionType;
  description: Description1;
  priority: Priority;
  estimated_time_hours: EstimatedTimeHours;
  [k: string]: unknown;
}
/**
 * Estimated time required to reach mastery for each objective.
 */
export interface TimeToMasteryEstimate {
  objective_id: ObjectiveId1;
  objective_name: ObjectiveName1;
  current_score: CurrentScore;
  hours_to_mastery: HoursToMastery;
  weeks_to_mastery: WeeksToMastery;
  [k: string]: unknown;
}

export type ObjectiveId = string;
export type ObjectiveName = string;
export type CurrentScore = number;
/**
 * Estimated study hours to reach 80% threshold
 */
export type HoursToMastery = number;
export type WeeksToMastery = number;

/**
 * Estimated time required to reach mastery for each objective.
 */
export interface TimeToMasteryEstimate {
  objective_id: ObjectiveId;
  objective_name: ObjectiveName;
  current_score: CurrentScore;
  hours_to_mastery: HoursToMastery;
  weeks_to_mastery: WeeksToMastery;
  [k: string]: unknown;
}

export type ObjectiveId = string;
export type ObjectiveName = string;
/**
 * ChatMock-generated rationale for prioritizing this objective
 */
export type Rationale = string;
export type EstimatedHours = number;

/**
 * One of top 3 objectives to focus on this week.
 */
export interface WeeklyTopObjective {
  objective_id: ObjectiveId;
  objective_name: ObjectiveName;
  rationale: Rationale;
  estimated_hours: EstimatedHours;
  [k: string]: unknown;
}

export type UserId = string;

/**
 * Request for AI recommendations.
 */
export interface RecommendationsRequest {
  user_id: UserId;
  [k: string]: unknown;
}

export type ObjectiveId = string;
export type ObjectiveName = string;
export type UserPercentile = number;
export type PeerAvg = number;
/**
 * user_percentile - avg_percentile (positive value)
 */
export type Advantage = number;

/**
 * Objective where user performs better than average.
 */
export interface RelativeStrength {
  objective_id: ObjectiveId;
  objective_name: ObjectiveName;
  user_percentile: UserPercentile;
  peer_avg: PeerAvg;
  advantage: Advantage;
  [k: string]: unknown;
}

export type ObjectiveId = string;
export type ObjectiveName = string;
export type UserPercentile = number;
export type PeerAvg = number;
/**
 * avg_percentile - user_percentile (positive value)
 */
export type Disadvantage = number;

/**
 * Objective where user performs below average.
 */
export interface RelativeWeakness {
  objective_id: ObjectiveId;
  objective_name: ObjectiveName;
  user_percentile: UserPercentile;
  peer_avg: PeerAvg;
  disadvantage: Disadvantage;
  [k: string]: unknown;
}

export type UserId = string;
/**
 * Predicted probability of passing exam (0-1 scale)
 */
export type Probability = number;
/**
 * 95% confidence interval for prediction
 *
 * @minItems 2
 * @maxItems 2
 */
export type ConfidenceInterval = [unknown, unknown];
/**
 * AI-generated recommendation based on prediction
 */
export type Recommendation = string;
export type ObjectiveId = string;
export type ObjectiveName = string;
/**
 * Probability of retaining knowledge (0-1 scale)
 */
export type RetentionProbability = number;
export type DaysSinceReview = number;
/**
 * Knowledge strength based on mastery and review frequency
 */
export type StrengthScore = number;
/**
 * Categorized forgetting risk
 */
export type RiskLevel = "low" | "moderate" | "high" | "critical";
export type RecommendedReviewDate = string;
export type ForgettingRisks = ForgettingRiskPrediction[];
export type ObjectiveId1 = string;
export type ObjectiveName1 = string;
export type CurrentScore = number;
/**
 * Predicted date to reach 80% threshold (None if already mastered or insufficient data)
 */
export type PredictedMasteryDate = string | null;
/**
 * Estimated days until mastery
 */
export type DaysToMastery = number | null;
/**
 * Average weekly improvement in percentage points
 */
export type WeeklyImprovementRate = number;
/**
 * Prediction confidence based on data points and consistency
 */
export type Confidence = "high" | "moderate" | "low";
export type MasteryDates = MasteryDatePrediction[];
export type MetricName = string;
export type MeanAbsoluteError = number;
/**
 * RÂ² score
 */
export type RSquared = number;
export type SampleSize = number;
export type LastUpdated = string;
export type GeneratedAt = string;

/**
 * Comprehensive prediction data for all analytics.
 */
export interface UnderstandingPrediction {
  user_id: UserId;
  exam_success: ExamSuccessPrediction;
  forgetting_risks: ForgettingRisks;
  mastery_dates: MasteryDates;
  model_accuracy: ModelAccuracy;
  generated_at?: GeneratedAt;
  [k: string]: unknown;
}
/**
 * Prediction of exam success probability using logistic regression.
 *
 * Features: comprehension (30%), reasoning (35%), mastery (20%), calibration (15%)
 */
export interface ExamSuccessPrediction {
  probability: Probability;
  confidence_interval: ConfidenceInterval;
  contributing_factors: ContributingFactors;
  recommendation: Recommendation;
  [k: string]: unknown;
}
/**
 * Feature contributions: {comprehension, reasoning, mastery, calibration}
 */
export interface ContributingFactors {
  [k: string]: number;
}
/**
 * Forgetting risk calculation using Ebbinghaus forgetting curve: R = e^(-t/S).
 *
 * Where:
 * - R = retention probability
 * - t = days since last review
 * - S = strength (based on mastery level and review history)
 */
export interface ForgettingRiskPrediction {
  objective_id: ObjectiveId;
  objective_name: ObjectiveName;
  retention_probability: RetentionProbability;
  days_since_review: DaysSinceReview;
  strength_score: StrengthScore;
  risk_level: RiskLevel;
  recommended_review_date: RecommendedReviewDate;
  [k: string]: unknown;
}
/**
 * Predicted date to reach 80% mastery using linear regression extrapolation.
 */
export interface MasteryDatePrediction {
  objective_id: ObjectiveId1;
  objective_name: ObjectiveName1;
  current_score: CurrentScore;
  predicted_mastery_date?: PredictedMasteryDate;
  days_to_mastery?: DaysToMastery;
  weekly_improvement_rate: WeeklyImprovementRate;
  confidence: Confidence;
  [k: string]: unknown;
}
/**
 * Accuracy metrics for each prediction model
 */
export interface ModelAccuracy {
  [k: string]: ModelAccuracy1;
}
/**
 * Model performance metrics for prediction accuracy tracking.
 */
export interface ModelAccuracy1 {
  metric_name: MetricName;
  mean_absolute_error: MeanAbsoluteError;
  r_squared: RSquared;
  sample_size: SampleSize;
  last_updated: LastUpdated;
  [k: string]: unknown;
}

export type Id = string;
/**
 * Alert type for user notifications
 */
export type AlertType = "PROACTIVE_WARNING" | "PREREQUISITE_ALERT" | "REAL_TIME_ALERT" | "INTERVENTION_SUGGESTION";
export type Title = string;
export type Message = string;
/**
 * Indicator severity enum matching Prisma schema
 */
export type Severity = "LOW" | "MEDIUM" | "HIGH";
export type Priority = number;
export type PredictionId = string | null;
export type InterventionId = string | null;
export type CreatedAt = string;

/**
 * Alert notification for user.
 */
export interface AlertResponse {
  id: Id;
  type: AlertType;
  title: Title;
  message: Message;
  severity: Severity;
  priority: Priority;
  prediction_id?: PredictionId;
  intervention_id?: InterventionId;
  created_at: CreatedAt;
  [k: string]: unknown;
}

export type AlertType = "PROACTIVE_WARNING" | "PREREQUISITE_ALERT" | "REAL_TIME_ALERT" | "INTERVENTION_SUGGESTION";

export type Severity = "LOW" | "MEDIUM" | "HIGH";

export type Id = string;
export type UserId = string;
export type LearningObjectiveId = string | null;
export type TopicId = string | null;
export type PredictionDate = string;
export type PredictedStruggleProbability = number;
export type PredictionConfidence = number;
/**
 * Prediction status enum matching Prisma schema
 */
export type PredictionStatus = "PENDING" | "CONFIRMED" | "FALSE_POSITIVE" | "MISSED";
/**
 * LOW, MEDIUM, or HIGH
 */
export type RiskLevel = string;
/**
 * Human-readable explanation
 */
export type Reasoning = string;
export type ObjectiveName = string | null;
export type CourseName = string | null;
export type Indicators = {
  [k: string]: unknown;
}[];

/**
 * Detailed prediction information for a single objective.
 */
export interface PredictionDetail {
  id: Id;
  user_id: UserId;
  learning_objective_id?: LearningObjectiveId;
  topic_id?: TopicId;
  prediction_date: PredictionDate;
  predicted_struggle_probability: PredictedStruggleProbability;
  prediction_confidence: PredictionConfidence;
  prediction_status: PredictionStatus;
  feature_vector: FeatureVector;
  risk_level: RiskLevel;
  reasoning: Reasoning;
  objective_name?: ObjectiveName;
  course_name?: CourseName;
  indicators?: Indicators;
  [k: string]: unknown;
}
/**
 * Features used for prediction
 */
export interface FeatureVector {
  [k: string]: unknown;
}

export type PredictionStatus = "PENDING" | "CONFIRMED" | "FALSE_POSITIVE" | "MISSED";

export type UserId = string;
/**
 * Days ahead to predict (1-30)
 */
export type DaysAhead = number;

/**
 * Request body for POST /predictions/generate
 *
 * Triggers prediction analysis for a user.
 */
export interface PredictionRequest {
  user_id: UserId;
  days_ahead?: DaysAhead;
  [k: string]: unknown;
}

export type Id = string;
export type UserId = string;
export type LearningObjectiveId = string | null;
export type TopicId = string | null;
export type PredictionDate = string;
export type PredictedStruggleProbability = number;
export type PredictionConfidence = number;
/**
 * Prediction status enum matching Prisma schema
 */
export type PredictionStatus = "PENDING" | "CONFIRMED" | "FALSE_POSITIVE" | "MISSED";
/**
 * LOW, MEDIUM, or HIGH
 */
export type RiskLevel = string;
/**
 * Human-readable explanation
 */
export type Reasoning = string;
export type ObjectiveName = string | null;
export type CourseName = string | null;
export type Indicators = {
  [k: string]: unknown;
}[];
export type Predictions = PredictionDetail[];
export type Alerts = AlertResponse[] | null;
export type Id1 = string;
/**
 * Alert type for user notifications
 */
export type AlertType = "PROACTIVE_WARNING" | "PREREQUISITE_ALERT" | "REAL_TIME_ALERT" | "INTERVENTION_SUGGESTION";
export type Title = string;
export type Message = string;
/**
 * Indicator severity enum matching Prisma schema
 */
export type Severity = "LOW" | "MEDIUM" | "HIGH";
export type Priority = number;
export type PredictionId = string | null;
export type InterventionId = string | null;
export type CreatedAt = string;
export type TotalCount = number;
export type HighRiskCount = number;
export type MediumRiskCount = number;
export type LowRiskCount = number;
export type GeneratedAt = string;

/**
 * Response for POST /predictions/generate and GET /predictions
 */
export interface PredictionResponse {
  predictions: Predictions;
  alerts?: Alerts;
  total_count: TotalCount;
  high_risk_count: HighRiskCount;
  medium_risk_count: MediumRiskCount;
  low_risk_count: LowRiskCount;
  generated_at?: GeneratedAt;
  [k: string]: unknown;
}
/**
 * Detailed prediction information for a single objective.
 */
export interface PredictionDetail {
  id: Id;
  user_id: UserId;
  learning_objective_id?: LearningObjectiveId;
  topic_id?: TopicId;
  prediction_date: PredictionDate;
  predicted_struggle_probability: PredictedStruggleProbability;
  prediction_confidence: PredictionConfidence;
  prediction_status: PredictionStatus;
  feature_vector: FeatureVector;
  risk_level: RiskLevel;
  reasoning: Reasoning;
  objective_name?: ObjectiveName;
  course_name?: CourseName;
  indicators?: Indicators;
  [k: string]: unknown;
}
/**
 * Features used for prediction
 */
export interface FeatureVector {
  [k: string]: unknown;
}
/**
 * Alert notification for user.
 */
export interface AlertResponse {
  id: Id1;
  type: AlertType;
  title: Title;
  message: Message;
  severity: Severity;
  priority: Priority;
  prediction_id?: PredictionId;
  intervention_id?: InterventionId;
  created_at: CreatedAt;
  [k: string]: unknown;
}

export type FeedbackType = "HELPFUL" | "NOT_HELPFUL" | "INACCURATE" | "INTERVENTION_GOOD" | "INTERVENTION_BAD";

export type MissionId = string | null;

/**
 * Request to apply an intervention to a mission.
 */
export interface InterventionApplyRequest {
  mission_id?: MissionId;
  [k: string]: unknown;
}

export type Success = boolean;
export type InterventionId = string;
export type MissionId = string;
export type Message = string;
export type AppliedAt = string;

/**
 * Response after applying an intervention.
 */
export interface InterventionApplyResponse {
  success: Success;
  intervention_id: InterventionId;
  mission_id: MissionId;
  message: Message;
  applied_at?: AppliedAt;
  [k: string]: unknown;
}

export type Id = string;
export type PredictionId = string;
export type UserId = string;
/**
 * Intervention type enum matching Prisma schema
 */
export type InterventionType =
  | "PREREQUISITE_REVIEW"
  | "DIFFICULTY_PROGRESSION"
  | "CONTENT_FORMAT_ADAPT"
  | "COGNITIVE_LOAD_REDUCE"
  | "SPACED_REPETITION_BOOST"
  | "BREAK_SCHEDULE_ADJUST";
export type Description = string;
export type Reasoning = string;
export type Priority = number;
/**
 * Intervention status enum matching Prisma schema
 */
export type InterventionStatus = "PENDING" | "APPLIED" | "COMPLETED" | "DISMISSED";
export type AppliedAt = string | null;
export type AppliedToMissionId = string | null;
export type Effectiveness = number | null;
export type CreatedAt = string;

/**
 * Intervention recommendation response.
 */
export interface InterventionResponse {
  id: Id;
  prediction_id: PredictionId;
  user_id: UserId;
  intervention_type: InterventionType;
  description: Description;
  reasoning: Reasoning;
  priority: Priority;
  status: InterventionStatus;
  applied_at?: AppliedAt;
  applied_to_mission_id?: AppliedToMissionId;
  effectiveness?: Effectiveness;
  created_at: CreatedAt;
  [k: string]: unknown;
}

export type InterventionStatus = "PENDING" | "APPLIED" | "COMPLETED" | "DISMISSED";

export type InterventionType =
  | "PREREQUISITE_REVIEW"
  | "DIFFICULTY_PROGRESSION"
  | "CONTENT_FORMAT_ADAPT"
  | "COGNITIVE_LOAD_REDUCE"
  | "SPACED_REPETITION_BOOST"
  | "BREAK_SCHEDULE_ADJUST";

export type Accuracy = number;
/**
 * Precision score
 */
export type Precision = number;
/**
 * Recall score
 */
export type Recall = number;
/**
 * F1 score
 */
export type F1Score = number;
/**
 * AUC-ROC score
 */
export type AucRoc = number | null;
/**
 * rule_based or logistic_regression
 */
export type ModelType = string;
export type ModelVersion = string;
export type LastUpdated = string;
/**
 * Number of training examples
 */
export type DataPoints = number;
export type FeatureImportance = {
  [k: string]: number;
} | null;
/**
 * Accuracy over time
 */
export type AccuracyTrend =
  | {
      [k: string]: unknown;
    }[]
  | null;

/**
 * Response for GET /analytics/model-performance
 *
 * Returns comprehensive model metrics and performance data.
 */
export interface ModelPerformanceResponse {
  accuracy: Accuracy;
  precision: Precision;
  recall: Recall;
  f1_score: F1Score;
  auc_roc?: AucRoc;
  calibration: Calibration;
  model_type: ModelType;
  model_version: ModelVersion;
  last_updated: LastUpdated;
  data_points: DataPoints;
  feature_importance?: FeatureImportance;
  accuracy_trend?: AccuracyTrend;
  [k: string]: unknown;
}
/**
 * Calibration curve data
 */
export interface Calibration {
  [k: string]: number[];
}

export type BaselineRate = number;
/**
 * Current struggle rate (0-1)
 */
export type CurrentRate = number;
/**
 * Percentage reduction (can be negative)
 */
export type ReductionPercentage = number;
export type Date = string;
export type StruggleRate = number;
export type StrugglesCount = number;
export type TopicsStudied = number;
/**
 * Struggle rate over time
 */
export type Timeline = TimelinePoint[];
/**
 * Effectiveness by intervention type
 */
export type InterventionEffectiveness = {
  [k: string]: unknown;
}[];
/**
 * Time period: week, month, or all
 */
export type Period = string;
export type BaselinePeriodStart = string | null;
export type BaselinePeriodEnd = string | null;
export type CurrentPeriodStart = string;
export type CurrentPeriodEnd = string;
export type TotalPredictions = number;
export type TotalInterventionsApplied = number;
export type UserFeedbackCount = number;

/**
 * Response for GET /analytics/struggle-reduction
 *
 * Returns struggle reduction metrics and success data.
 */
export interface StruggleReductionResponse {
  baseline_rate: BaselineRate;
  current_rate: CurrentRate;
  reduction_percentage: ReductionPercentage;
  timeline: Timeline;
  intervention_effectiveness: InterventionEffectiveness;
  period: Period;
  baseline_period_start?: BaselinePeriodStart;
  baseline_period_end?: BaselinePeriodEnd;
  current_period_start: CurrentPeriodStart;
  current_period_end: CurrentPeriodEnd;
  total_predictions: TotalPredictions;
  total_interventions_applied: TotalInterventionsApplied;
  user_feedback_count: UserFeedbackCount;
  [k: string]: unknown;
}
/**
 * Timeline data point for struggle reduction metrics.
 */
export interface TimelinePoint {
  date: Date;
  struggle_rate: StruggleRate;
  struggles_count: StrugglesCount;
  topics_studied: TopicsStudied;
  [k: string]: unknown;
}

export type Date = string;
export type StruggleRate = number;
export type StrugglesCount = number;
export type TopicsStudied = number;

/**
 * Timeline data point for struggle reduction metrics.
 */
export interface TimelinePoint {
  date: Date;
  struggle_rate: StruggleRate;
  struggles_count: StrugglesCount;
  topics_studied: TopicsStudied;
  [k: string]: unknown;
}