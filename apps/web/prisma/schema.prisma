generator client {
  provider        = "prisma-client-js"
  output          = "../src/generated/prisma"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [pgvector(map: "vector")]
}

model User {
  id                         String           @id @default(cuid())
  email                      String?          @unique
  name                       String?
  createdAt                  DateTime         @default(now())
  updatedAt                  DateTime         @updatedAt
  autoGenerateMissions       Boolean          @default(true)
  defaultMissionMinutes      Int              @default(50)
  missionDifficulty          String           @default("AUTO")
  preferredStudyTime         String?
  includeInAnalytics         Boolean          @default(true)
  performanceTrackingEnabled Boolean          @default(true)
  lastMissionAdaptation      DateTime?
  achievements               Achievement[]
  coursePriorities           CoursePriority[]
  courses                    Course[]
  exams                      Exam[]
  lectures                   Lecture[]
  missionReviews             MissionReview[]
  missionStreak              MissionStreak?
  missions                   Mission[]
  reviews                    Review[]
  streak                     Streak?
  studyGoals                 StudyGoal[]
  studySessions              StudySession[]

  @@map("users")
}

model Course {
  id               String           @id @default(cuid())
  userId           String
  name             String
  code             String?
  term             String?
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  color            String?
  cards            Card[]
  coursePriorities CoursePriority[]
  user             User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  exams            Exam[]
  lectures         Lecture[]

  @@index([userId])
  @@map("courses")
}

model Lecture {
  id                    String              @id @default(cuid())
  userId                String
  courseId              String
  title                 String
  fileName              String
  fileUrl               String
  fileSize              Int
  processingStatus      ProcessingStatus    @default(PENDING)
  uploadedAt            DateTime            @default(now())
  processedAt           DateTime?
  weekNumber            Int?
  topicTags             String[]
  estimatedCompletionAt DateTime?
  processedPages        Int                 @default(0)
  processingProgress    Int                 @default(0)
  processingStartedAt   DateTime?
  totalPages            Int?
  embeddingProgress     Float               @default(0)
  cards                 Card[]
  contentChunks         ContentChunk[]
  learningObjectives    LearningObjective[]
  course                Course              @relation(fields: [courseId], references: [id], onDelete: Cascade)
  user                  User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([courseId])
  @@index([processingStatus])
  @@map("lectures")
}

model ContentChunk {
  id                                                                                   String                    @id @default(cuid())
  lectureId                                                                            String
  content                                                                              String
  embedding                                                                            Unsupported("vector")?
  chunkIndex                                                                           Int
  pageNumber                                                                           Int?
  createdAt                                                                            DateTime                  @default(now())
  conflicts_conflicts_sourceAChunkIdTocontent_chunks                                   conflicts[]               @relation("conflicts_sourceAChunkIdTocontent_chunks")
  conflicts_conflicts_sourceBChunkIdTocontent_chunks                                   conflicts[]               @relation("conflicts_sourceBChunkIdTocontent_chunks")
  lecture                                                                              Lecture                   @relation(fields: [lectureId], references: [id], onDelete: Cascade)
  content_recommendations_content_recommendations_recommendedContentIdTocontent_chunks content_recommendations[] @relation("content_recommendations_recommendedContentIdTocontent_chunks")
  content_recommendations_content_recommendations_sourceContentIdTocontent_chunks      content_recommendations[] @relation("content_recommendations_sourceContentIdTocontent_chunks")

  @@index([lectureId])
  @@map("content_chunks")
}

model LearningObjective {
  id                 String                  @id @default(cuid())
  lectureId          String
  objective          String
  isHighYield        Boolean                 @default(false)
  extractedBy        String                  @default("gpt-5")
  createdAt          DateTime                @default(now())
  complexity         ObjectiveComplexity     @default(INTERMEDIATE)
  boardExamTags      String[]
  pageStart          Int?
  pageEnd            Int?
  lastStudiedAt      DateTime?
  masteryLevel       MasteryLevel            @default(NOT_STARTED)
  totalStudyTimeMs   Int                     @default(0)
  weaknessScore      Float                   @default(0.5)
  cards              Card[]
  lecture            Lecture                 @relation(fields: [lectureId], references: [id], onDelete: Cascade)
  prerequisites      ObjectivePrerequisite[] @relation("Objective")
  dependents         ObjectivePrerequisite[] @relation("Prerequisite")
  performanceMetrics PerformanceMetric[]
  priorityFeedback   PriorityFeedback[]

  @@index([lectureId])
  @@index([isHighYield])
  @@index([complexity])
  @@index([masteryLevel])
  @@index([weaknessScore])
  @@map("learning_objectives")
}

model ObjectivePrerequisite {
  id             String            @id @default(cuid())
  objectiveId    String
  prerequisiteId String
  strength       Float             @default(1.0)
  objective      LearningObjective @relation("Objective", fields: [objectiveId], references: [id], onDelete: Cascade)
  prerequisite   LearningObjective @relation("Prerequisite", fields: [prerequisiteId], references: [id], onDelete: Cascade)

  @@unique([objectiveId, prerequisiteId])
  @@index([objectiveId])
  @@index([prerequisiteId])
  @@map("objective_prerequisites")
}

model Mission {
  id                       String            @id @default(cuid())
  userId                   String
  date                     DateTime          @default(now())
  status                   MissionStatus     @default(PENDING)
  estimatedMinutes         Int
  completedAt              DateTime?
  reviewCardCount          Int               @default(0)
  newContentCount          Int               @default(0)
  actualMinutes            Int?
  completedObjectivesCount Int               @default(0)
  objectives               Json
  difficultyRating         Int?
  successScore             Float?
  feedback                 MissionFeedback[]
  user                     User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  studySessions            StudySession[]

  @@index([userId])
  @@index([date])
  @@index([status])
  @@map("missions")
}

model Card {
  id             String             @id @default(cuid())
  courseId       String
  lectureId      String?
  objectiveId    String?
  front          String
  back           String
  cardType       CardType           @default(BASIC)
  createdAt      DateTime           @default(now())
  difficulty     Float              @default(0)
  stability      Float              @default(0)
  retrievability Float              @default(0)
  lastReviewedAt DateTime?
  nextReviewAt   DateTime?
  reviewCount    Int                @default(0)
  lapseCount     Int                @default(0)
  course         Course             @relation(fields: [courseId], references: [id], onDelete: Cascade)
  lecture        Lecture?           @relation(fields: [lectureId], references: [id])
  objective      LearningObjective? @relation(fields: [objectiveId], references: [id])
  reviews        Review[]

  @@index([courseId])
  @@index([nextReviewAt])
  @@map("cards")
}

model Review {
  id               String        @id @default(cuid())
  userId           String
  cardId           String
  sessionId        String?
  rating           ReviewRating
  timeSpentMs      Int
  reviewedAt       DateTime      @default(now())
  difficultyBefore Float
  stabilityBefore  Float
  difficultyAfter  Float
  stabilityAfter   Float
  card             Card          @relation(fields: [cardId], references: [id], onDelete: Cascade)
  session          StudySession? @relation(fields: [sessionId], references: [id])
  user             User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([cardId])
  @@index([reviewedAt])
  @@map("reviews")
}

model StudySession {
  id                    String               @id @default(cuid())
  userId                String
  missionId             String?
  startedAt             DateTime             @default(now())
  completedAt           DateTime?
  durationMs            Int?
  reviewsCompleted      Int                  @default(0)
  newCardsStudied       Int                  @default(0)
  sessionNotes          String?
  currentObjectiveIndex Int                  @default(0)
  missionObjectives     Json?
  objectiveCompletions  Json?
  reviews               Review[]
  mission               Mission?             @relation(fields: [missionId], references: [id])
  user                  User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  validationResponses   ValidationResponse[]

  @@index([userId])
  @@index([startedAt])
  @@map("study_sessions")
}

model Concept {
  id          String                 @id @default(cuid())
  name        String                 @unique
  description String?
  category    String?
  embedding   Unsupported("vector")?
  createdAt   DateTime               @default(now())
  relatedFrom ConceptRelationship[]  @relation("ConceptFrom")
  relatedTo   ConceptRelationship[]  @relation("ConceptTo")
  conflicts   conflicts[]

  @@index([category])
  @@map("concepts")
}

model ConceptRelationship {
  id            String           @id @default(cuid())
  fromConceptId String
  toConceptId   String
  relationship  RelationshipType
  strength      Float            @default(1.0)
  createdAt     DateTime         @default(now())
  createdBy     String?
  isUserDefined Boolean          @default(false)
  userNote      String?
  fromConcept   Concept          @relation("ConceptFrom", fields: [fromConceptId], references: [id], onDelete: Cascade)
  toConcept     Concept          @relation("ConceptTo", fields: [toConceptId], references: [id], onDelete: Cascade)

  @@unique([fromConceptId, toConceptId, relationship])
  @@index([fromConceptId])
  @@index([toConceptId])
  @@index([isUserDefined])
  @@map("concept_relationships")
}

model ValidationPrompt {
  id               String               @id @default(cuid())
  promptText       String
  promptType       PromptType
  conceptName      String
  expectedCriteria String[]
  createdAt        DateTime             @default(now())
  responses        ValidationResponse[]

  @@map("validation_prompts")
}

model ValidationResponse {
  id               String           @id @default(cuid())
  promptId         String
  sessionId        String?
  userAnswer       String
  aiEvaluation     String
  score            Float
  confidence       Float?
  respondedAt      DateTime         @default(now())
  userId           String
  confidenceLevel  Int?
  calibrationDelta Float?
  detailedFeedback Json?
  skipped          Boolean          @default(false)
  prompt           ValidationPrompt @relation(fields: [promptId], references: [id], onDelete: Cascade)
  session          StudySession?    @relation(fields: [sessionId], references: [id])

  @@index([promptId])
  @@index([respondedAt])
  @@index([sessionId])
  @@index([userId])
  @@index([userId, respondedAt])
  @@map("validation_responses")
}

model ComprehensionMetric {
  id          String   @id @default(cuid())
  conceptName String
  date        DateTime @default(now())
  avgScore    Float
  sampleSize  Int
  trend       String?

  @@unique([conceptName, date])
  @@index([conceptName])
  @@map("comprehension_metrics")
}

model BehavioralEvent {
  id        String    @id @default(cuid())
  userId    String
  eventType EventType
  eventData Json
  timestamp DateTime  @default(now())

  @@index([userId])
  @@index([eventType])
  @@index([timestamp])
  @@map("behavioral_events")
}

model LearningPattern {
  id          String      @id @default(cuid())
  userId      String
  patternType PatternType
  patternData Json
  confidence  Float
  detectedAt  DateTime    @default(now())
  lastSeenAt  DateTime    @default(now())

  @@index([userId])
  @@index([patternType])
  @@map("learning_patterns")
}

model PerformancePrediction {
  id             String   @id @default(cuid())
  userId         String
  predictedFor   DateTime
  predictionType String
  prediction     Json
  confidence     Float
  createdAt      DateTime @default(now())

  @@index([userId])
  @@index([predictedFor])
  @@map("performance_predictions")
}

model PerformanceMetric {
  id                  String            @id @default(cuid())
  userId              String
  learningObjectiveId String
  date                DateTime          @default(now())
  retentionScore      Float
  studyTimeMs         Int
  reviewCount         Int
  correctReviews      Int
  incorrectReviews    Int
  createdAt           DateTime          @default(now())
  learningObjective   LearningObjective @relation(fields: [learningObjectiveId], references: [id], onDelete: Cascade)

  @@unique([userId, learningObjectiveId, date])
  @@index([userId, date])
  @@index([learningObjectiveId])
  @@map("performance_metrics")
}

model Exam {
  id             String   @id @default(cuid())
  userId         String
  name           String
  date           DateTime
  courseId       String
  coverageTopics String[]
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  course         Course   @relation(fields: [courseId], references: [id], onDelete: Cascade)
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, date])
  @@index([courseId])
  @@map("exams")
}

model CoursePriority {
  id            String        @id @default(cuid())
  userId        String
  courseId      String
  priorityLevel PriorityLevel @default(MEDIUM)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  course        Course        @relation(fields: [courseId], references: [id], onDelete: Cascade)
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, courseId])
  @@map("course_priorities")
}

model PriorityFeedback {
  id                String            @id @default(cuid())
  userId            String
  objectiveId       String
  suggestedPriority Float
  userFeedback      FeedbackRating
  notes             String?
  createdAt         DateTime          @default(now())
  learningObjective LearningObjective @relation(fields: [objectiveId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([objectiveId])
  @@map("priority_feedback")
}

model Streak {
  id               String    @id @default(cuid())
  userId           String    @unique
  currentStreak    Int       @default(0)
  longestStreak    Int       @default(0)
  lastStudyDate    DateTime?
  freezesRemaining Int       @default(2)
  freezeUsedDates  String[]
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  user             User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("streaks")
}

model Achievement {
  id          String          @id @default(cuid())
  userId      String
  type        AchievementType
  name        String
  description String
  tier        AchievementTier @default(BRONZE)
  earnedAt    DateTime        @default(now())
  metadata    Json?
  user        User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([type])
  @@map("achievements")
}

model StudyGoal {
  id              String     @id @default(cuid())
  userId          String
  goalType        GoalType
  targetValue     Int
  currentProgress Int        @default(0)
  period          GoalPeriod
  startDate       DateTime
  endDate         DateTime
  isCompleted     Boolean    @default(false)
  completedAt     DateTime?
  createdAt       DateTime   @default(now())
  user            User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([period, startDate])
  @@map("study_goals")
}

model MissionAnalytics {
  id                  String          @id @default(cuid())
  userId              String
  date                DateTime        @default(now())
  period              AnalyticsPeriod
  missionsGenerated   Int
  missionsCompleted   Int
  missionsSkipped     Int
  avgCompletionRate   Float
  avgTimeAccuracy     Float
  avgDifficultyRating Float
  avgSuccessScore     Float
  createdAt           DateTime        @default(now())

  @@unique([userId, date, period])
  @@index([userId, date])
  @@map("mission_analytics")
}

model MissionFeedback {
  id                     String     @id @default(cuid())
  userId                 String
  missionId              String
  helpfulnessRating      Int
  relevanceScore         Int
  paceRating             PaceRating
  improvementSuggestions String?
  submittedAt            DateTime   @default(now())
  mission                Mission    @relation(fields: [missionId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([missionId])
  @@map("mission_feedback")
}

model MissionStreak {
  id                String    @id @default(cuid())
  userId            String    @unique
  currentStreak     Int       @default(0)
  longestStreak     Int       @default(0)
  lastCompletedDate DateTime?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("mission_streaks")
}

model MissionReview {
  id              String       @id @default(cuid())
  userId          String
  period          ReviewPeriod
  startDate       DateTime
  endDate         DateTime
  summary         Json
  highlights      Json
  insights        Json
  recommendations Json
  generatedAt     DateTime     @default(now())
  user            User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, period, startDate])
  @@index([userId, generatedAt])
  @@map("mission_reviews")
}

model conflict_flags {
  id             String     @id
  conflictId     String?
  userId         String
  sourceAChunkId String
  sourceBChunkId String
  description    String
  userNotes      String?
  flaggedAt      DateTime   @default(now())
  status         String     @default("PENDING")
  conflicts      conflicts? @relation(fields: [conflictId], references: [id])

  @@index([flaggedAt])
  @@index([status])
  @@index([userId])
}

model conflict_history {
  id         String          @id
  conflictId String
  changeType ChangeType
  oldStatus  ConflictStatus?
  newStatus  ConflictStatus?
  changedBy  String
  changedAt  DateTime        @default(now())
  notes      String?
  conflicts  conflicts       @relation(fields: [conflictId], references: [id], onDelete: Cascade)

  @@index([changedAt])
  @@index([conflictId])
}

model conflict_resolutions {
  id                String    @id
  conflictId        String
  resolvedBy        String
  resolution        String
  preferredSourceId String?
  evidence          String?
  resolvedAt        DateTime  @default(now())
  notes             String?
  conflicts         conflicts @relation(fields: [conflictId], references: [id], onDelete: Cascade)

  @@index([conflictId])
  @@index([resolvedAt])
}

model conflicts {
  id                                                      String                 @id
  conceptId                                               String?
  sourceAChunkId                                          String
  sourceBChunkId                                          String
  conflictType                                            ConflictType
  severity                                                ConflictSeverity
  description                                             String
  status                                                  ConflictStatus         @default(ACTIVE)
  createdAt                                               DateTime               @default(now())
  resolvedAt                                              DateTime?
  conflict_flags                                          conflict_flags[]
  conflict_history                                        conflict_history[]
  conflict_resolutions                                    conflict_resolutions[]
  concepts                                                Concept?               @relation(fields: [conceptId], references: [id])
  content_chunks_conflicts_sourceAChunkIdTocontent_chunks ContentChunk           @relation("conflicts_sourceAChunkIdTocontent_chunks", fields: [sourceAChunkId], references: [id], onDelete: Cascade)
  content_chunks_conflicts_sourceBChunkIdTocontent_chunks ContentChunk           @relation("conflicts_sourceBChunkIdTocontent_chunks", fields: [sourceBChunkId], references: [id], onDelete: Cascade)

  @@index([conceptId, status])
  @@index([createdAt])
  @@index([severity])
  @@index([status])
}

model content_recommendations {
  id                                                                          String                    @id
  userId                                                                      String
  recommendedContentId                                                        String
  sourceContentId                                                             String?
  score                                                                       Float
  reasoning                                                                   String
  status                                                                      RecommendationStatus      @default(PENDING)
  contextType                                                                 String
  contextId                                                                   String
  sourceType                                                                  ContentSourceType
  createdAt                                                                   DateTime                  @default(now())
  viewedAt                                                                    DateTime?
  dismissedAt                                                                 DateTime?
  content_chunks_content_recommendations_recommendedContentIdTocontent_chunks ContentChunk              @relation("content_recommendations_recommendedContentIdTocontent_chunks", fields: [recommendedContentId], references: [id], onDelete: Cascade)
  content_chunks_content_recommendations_sourceContentIdTocontent_chunks      ContentChunk?             @relation("content_recommendations_sourceContentIdTocontent_chunks", fields: [sourceContentId], references: [id])
  recommendation_feedback                                                     recommendation_feedback[]

  @@index([contextType, contextId])
  @@index([createdAt])
  @@index([status])
  @@index([userId, contextType, contextId])
  @@index([userId])
}

model recommendation_analytics {
  id                   String   @id
  userId               String
  date                 DateTime @default(now())
  totalRecommendations Int
  viewedCount          Int
  clickedCount         Int
  dismissedCount       Int
  avgRating            Float?
  avgEngagementTimeMs  Int?
  topSourceTypes       Json

  @@unique([userId, date])
  @@index([date])
  @@index([userId])
}

model recommendation_feedback {
  id                      String                  @id
  recommendationId        String
  userId                  String
  rating                  Int
  feedbackText            String?
  helpful                 Boolean?
  createdAt               DateTime                @default(now())
  content_recommendations content_recommendations @relation(fields: [recommendationId], references: [id], onDelete: Cascade)

  @@index([createdAt])
  @@index([recommendationId])
  @@index([userId])
}

model search_clicks {
  id             String         @id
  searchQueryId  String
  userId         String
  resultId       String
  resultType     String
  position       Int
  similarity     Float?
  timestamp      DateTime       @default(now())
  search_queries search_queries @relation(fields: [searchQueryId], references: [id], onDelete: Cascade)

  @@index([resultId, resultType])
  @@index([searchQueryId])
  @@index([userId, timestamp])
}

model search_queries {
  id             String          @id
  userId         String
  query          String
  filters        Json?
  resultCount    Int             @default(0)
  topResultId    String?
  responseTimeMs Int?
  timestamp      DateTime        @default(now())
  isAnonymized   Boolean         @default(false)
  anonymizedAt   DateTime?
  search_clicks  search_clicks[]

  @@index([isAnonymized])
  @@index([timestamp])
  @@index([userId, timestamp])
}

model sources {
  id                      String                    @id
  name                    String                    @unique
  type                    SourceType
  credibilityScore        Int
  medicalSpecialty        String?
  lastUpdated             DateTime?
  metadata                Json?
  createdAt               DateTime                  @default(now())
  user_source_preferences user_source_preferences[]

  @@index([credibilityScore])
  @@index([type])
}

model user_source_preferences {
  id         String     @id
  userId     String
  sourceId   String
  trustLevel TrustLevel
  priority   Int
  notes      String?
  createdAt  DateTime   @default(now())
  updatedAt  DateTime
  sources    sources    @relation(fields: [sourceId], references: [id], onDelete: Cascade)

  @@unique([userId, sourceId])
  @@index([priority])
  @@index([userId])
}

enum ProcessingStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  EMBEDDING
  EMBEDDING_FAILED
}

enum ObjectiveComplexity {
  BASIC
  INTERMEDIATE
  ADVANCED
}

enum MasteryLevel {
  NOT_STARTED
  BEGINNER
  INTERMEDIATE
  ADVANCED
  MASTERED
}

enum MissionStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  SKIPPED
}

enum CardType {
  BASIC
  CLOZE
  CLINICAL_REASONING
}

enum ReviewRating {
  AGAIN
  HARD
  GOOD
  EASY
}

enum RelationshipType {
  PREREQUISITE
  RELATED
  INTEGRATED
  CLINICAL
}

enum PromptType {
  EXPLAIN_TO_PATIENT
  CLINICAL_REASONING
  CONTROLLED_FAILURE
}

enum EventType {
  MISSION_STARTED
  MISSION_COMPLETED
  CARD_REVIEWED
  VALIDATION_COMPLETED
  SESSION_STARTED
  SESSION_ENDED
  LECTURE_UPLOADED
  SEARCH_PERFORMED
  GRAPH_VIEWED
  RECOMMENDATION_VIEWED
  RECOMMENDATION_CLICKED
  RECOMMENDATION_DISMISSED
  RECOMMENDATION_RATED
}

enum PatternType {
  OPTIMAL_STUDY_TIME
  STRUGGLE_TOPIC
  CONTENT_PREFERENCE
  SESSION_LENGTH
  DAY_OF_WEEK_PATTERN
}

enum PriorityLevel {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum FeedbackRating {
  TOO_HIGH
  JUST_RIGHT
  TOO_LOW
}

enum AchievementType {
  STREAK_MILESTONE
  OBJECTIVES_COMPLETED
  CARDS_MASTERED
  PERFECT_SESSION
  EARLY_BIRD
  NIGHT_OWL
}

enum AchievementTier {
  BRONZE
  SILVER
  GOLD
  PLATINUM
}

enum GoalType {
  TIME_BASED
  OBJECTIVE_BASED
  REVIEW_BASED
}

enum GoalPeriod {
  DAILY
  WEEKLY
  MONTHLY
}

enum AnalyticsPeriod {
  DAILY
  WEEKLY
  MONTHLY
}

enum PaceRating {
  TOO_SLOW
  JUST_RIGHT
  TOO_FAST
}

enum ReviewPeriod {
  WEEK
  MONTH
}

enum ChangeType {
  DETECTED
  RESOLVED
  REOPENED
  DISMISSED
  EVIDENCE_UPDATED
  SOURCE_UPDATED
}

enum ConflictSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum ConflictStatus {
  ACTIVE
  RESOLVED
  DISMISSED
  UNDER_REVIEW
}

enum ConflictType {
  DOSAGE
  CONTRAINDICATION
  MECHANISM
  TREATMENT
  DIAGNOSIS
  PROGNOSIS
  OTHER
}

enum ContentSourceType {
  LECTURE
  FIRST_AID
  EXTERNAL_ARTICLE
  CONCEPT_NOTE
  USER_NOTE
}

enum RecommendationStatus {
  PENDING
  VIEWED
  DISMISSED
  RATED
}

enum SourceType {
  FIRST_AID
  LECTURE
  TEXTBOOK
  JOURNAL
  GUIDELINE
  USER_NOTES
}

enum TrustLevel {
  HIGH
  MEDIUM
  LOW
  BLOCKED
}

// ============================================
// Story 5.5: Adaptive Personalization Engine
// ============================================

model PersonalizationPreferences {
  id                      String                @id @default(cuid())
  userId                  String                @unique
  personalizationLevel    PersonalizationLevel  @default(MEDIUM)
  autoAdaptEnabled        Boolean               @default(true)

  // Feature-level toggles
  missionPersonalizationEnabled     Boolean @default(true)
  contentPersonalizationEnabled     Boolean @default(true)
  assessmentPersonalizationEnabled  Boolean @default(true)
  sessionPersonalizationEnabled     Boolean @default(true)

  // Disabled features (for granular control)
  disabledFeatures        String[]              // Array of feature names to disable

  // Metadata
  createdAt               DateTime              @default(now())
  updatedAt               DateTime              @updatedAt
  lastResetAt             DateTime?             // Last time user reset preferences

  // Relations
  configs                 PersonalizationConfig[]
  experiments             PersonalizationExperiment[]

  @@index([userId])
  @@map("personalization_preferences")
}

enum PersonalizationLevel {
  NONE      // No personalization
  LOW       // Conservative personalization (confidence >= 0.85)
  MEDIUM    // Balanced personalization (confidence >= 0.7)
  HIGH      // Aggressive personalization (confidence >= 0.6)
}

model PersonalizationConfig {
  id                      String   @id @default(cuid())
  userId                  String
  preferencesId           String

  // Configuration context
  context                 PersonalizationContext  // mission, content, assessment, session
  strategyVariant         String                  // Pattern-heavy, Prediction-heavy, Balanced, Conservative

  // Personalization parameters (JSON for flexibility)
  missionPersonalization  Json?    // { timing, duration, objectives, difficulty }
  contentPersonalization  Json?    // { contentTypes, learningStyle, topicSelection }
  assessmentPersonalization Json?  // { frequency, difficulty, questionTypes }
  sessionPersonalization  Json?    // { breakTiming, contentSequence, intensityModulation }

  // Effectiveness tracking
  effectivenessScore      Float?   // 0-100 composite effectiveness
  confidenceScore         Float    @default(0.7) // 0.0-1.0 configuration confidence

  // Multi-Armed Bandit tracking
  timesSelected           Int      @default(0)
  totalReward             Float    @default(0.0)
  avgReward               Float    @default(0.0)

  // Metadata
  isActive                Boolean  @default(true)
  activatedAt             DateTime @default(now())
  deactivatedAt           DateTime?
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  // Relations
  preferences             PersonalizationPreferences @relation(fields: [preferencesId], references: [id], onDelete: Cascade)
  effectivenessMetrics    PersonalizationEffectiveness[]

  @@index([userId])
  @@index([context])
  @@index([strategyVariant])
  @@index([isActive])
  @@map("personalization_configs")
}

enum PersonalizationContext {
  MISSION      // Daily mission generation
  CONTENT      // Content recommendations
  ASSESSMENT   // Assessment strategy
  SESSION      // Study session orchestration
}

model PersonalizationEffectiveness {
  id                    String   @id @default(cuid())
  configId              String
  userId                String

  // Time period for metrics
  startDate             DateTime
  endDate               DateTime

  // Improvement metrics (vs baseline)
  retentionImprovement  Float?   // Percentage improvement in retention
  performanceImprovement Float?  // Percentage improvement in performance
  completionRateChange  Float?   // Percentage change in completion rate
  engagementChange      Float?   // Percentage change in engagement

  // Statistical validation
  sampleSize            Int      // Number of data points
  correlation           Float?   // Pearson correlation coefficient
  pValue                Float?   // Statistical significance (p < 0.05)
  confidenceInterval    Json?    // {lower, upper} 95% CI

  // Calculated scores
  compositeScore        Float    // 0-100 weighted composite
  isStatisticallySignificant Boolean @default(false)

  // Metadata
  calculatedAt          DateTime @default(now())

  // Relations
  config                PersonalizationConfig @relation(fields: [configId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([configId])
  @@index([startDate, endDate])
  @@map("personalization_effectiveness")
}

model PersonalizationExperiment {
  id                    String             @id @default(cuid())
  userId                String
  preferencesId         String

  // Experiment configuration
  experimentName        String
  experimentType        ExperimentType     @default(AB_TEST)
  context               PersonalizationContext

  // Experiment variants
  variants              Json               // Array of {variantId, name, config, weight}
  assignedVariant       String?            // Which variant this user is assigned to

  // Status and timing
  status                ExperimentStatus   @default(ACTIVE)
  startDate             DateTime           @default(now())
  endDate               DateTime
  minParticipants       Int                @default(20)
  minDuration           Int                @default(14) // Days

  // Results tracking
  currentParticipants   Int                @default(0)
  variantMetrics        Json?              // {variantId: {metric1, metric2, ...}}
  winningVariant        String?            // Variant with best performance
  statisticalSignificance Float?           // p-value for results

  // Metadata
  createdAt             DateTime           @default(now())
  completedAt           DateTime?

  // Relations
  preferences           PersonalizationPreferences @relation(fields: [preferencesId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([context])
  @@index([startDate, endDate])
  @@map("personalization_experiments")
}

enum ExperimentType {
  AB_TEST              // Two variant comparison
  MULTIVARIATE         // Multiple variant comparison
  MULTI_ARMED_BANDIT   // Epsilon-greedy optimization
}

enum ExperimentStatus {
  DRAFT       // Being configured
  ACTIVE      // Currently running
  COMPLETED   // Finished successfully
  CANCELLED   // Stopped early
}

model PersonalizationOutcome {
  id                    String   @id @default(cuid())
  userId                String
  configId              String?

  // Outcome tracking
  outcomeType           OutcomeType
  context               PersonalizationContext
  timestamp             DateTime @default(now())

  // Performance metrics
  retentionScore        Float?   // 0.0-1.0
  performanceScore      Float?   // 0.0-1.0
  completionRate        Float?   // 0.0-1.0
  engagementScore       Float?   // 0.0-1.0

  // Session metadata
  sessionDuration       Int?     // Minutes
  contentType           String?
  difficultyLevel       String?

  // Attribution
  personalizationApplied Boolean @default(false)
  strategyVariant       String?

  @@index([userId])
  @@index([outcomeType])
  @@index([timestamp])
  @@index([configId])
  @@map("personalization_outcomes")
}

enum OutcomeType {
  MISSION_COMPLETED     // Mission completion outcome
  SESSION_COMPLETED     // Study session outcome
  ASSESSMENT_COMPLETED  // Assessment outcome
  CONTENT_ENGAGED       // Content engagement outcome
}

// ============================================
// Story 5.6: Learning Science Education
// ============================================

model LearningArticle {
  id          String   @id @default(cuid())
  slug        String   @unique  // URL-friendly identifier (e.g., "spaced-repetition")
  title       String
  category    ArticleCategory

  // Article content
  summary     String   // Brief summary (1-2 sentences)
  content     String   @db.Text  // Full article content (Markdown)

  // Personalization metadata
  personalizedSections Json?  // Sections that can be personalized with user data
  // Example: { "your-data": { "type": "forgetting-curve", "position": 2 } }

  // External resources
  externalLinks Json?  // Array of {title, url, description}

  // Metadata
  readingTimeMinutes Int  @default(5)
  difficulty        String @default("BEGINNER")  // BEGINNER, INTERMEDIATE, ADVANCED
  tags              String[]  // For filtering and search

  // Tracking
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  publishedAt DateTime @default(now())

  // Relations
  articleReads ArticleRead[]

  @@index([category])
  @@index([slug])
  @@map("learning_articles")
}

enum ArticleCategory {
  SPACED_REPETITION     // Ebbinghaus forgetting curve & spacing
  ACTIVE_RECALL         // Retrieval practice benefits
  LEARNING_STYLES       // VARK with research nuance
  COGNITIVE_LOAD        // Intrinsic vs extrinsic load
  CIRCADIAN_RHYTHMS     // Optimal timing & chronotypes
}

model ArticleRead {
  id         String   @id @default(cuid())
  userId     String
  articleId  String

  // Engagement tracking
  readAt     DateTime @default(now())
  readDurationSeconds Int?  // How long user spent reading
  completedRead Boolean @default(false)  // Did they read to the end?

  // Feedback (optional)
  helpful    Boolean?  // Was article helpful?
  rating     Int?      // 1-5 stars
  feedback   String?   // Free-text feedback

  // Relations
  article    LearningArticle @relation(fields: [articleId], references: [id], onDelete: Cascade)

  @@unique([userId, articleId])  // One read record per user per article
  @@index([userId])
  @@index([articleId])
  @@index([readAt])
  @@map("article_reads")
}
